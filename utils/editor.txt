// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\core\components\CommandPalette.vue
//

<template>
  <div v-if="isVisible" class="palette-overlay" @click="hide">
    <div class="palette-container" @click.stop>
      <div class="search-wrapper">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            ref="searchInput"
            v-model="searchQuery"
            type="text"
            placeholder="Type a command"
            class="search-input"
            @keydown.down.prevent="navigate(1)"
            @keydown.up.prevent="navigate(-1)"
            @keydown.enter.prevent="executeSelected"
        />
      </div>
      <ul class="results-list">
        <li
            v-for="(command, index) in filteredCommands"
            :key="command.id"
            :class="{ 'selected': index === selectedIndex }"
            @click="executeCommand(command.id)"
            @mouseenter="selectedIndex = index"
        >
          <i v-if="command.icon" :class="[command.icon, 'command-icon']"></i>
          <span>{{ command.label }}</span>
        </li>
        <li v-if="filteredCommands.length === 0" class="no-results">
          No matching commands
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, nextTick, onMounted, onUnmounted } from 'vue';
import { commandService } from '@/core/services/CommandService';
import type { Command } from '@/core/types';

const isVisible = ref(false);
const searchQuery = ref('');
const allCommands = ref<Command[]>([]);
const selectedIndex = ref(0);
const searchInput = ref<HTMLInputElement | null>(null);

const filteredCommands = computed(() => {
  if (!searchQuery.value) {
    return allCommands.value;
  }
  const query = searchQuery.value.toLowerCase();
  return allCommands.value.filter(cmd =>
      cmd.label.toLowerCase().includes(query)
  );
});

const show = () => {
  allCommands.value = Array.from(commandService.commands.values());
  isVisible.value = true;
  nextTick(() => {
    searchInput.value?.focus();
  });
};

const hide = () => {
  isVisible.value = false;
  searchQuery.value = '';
  selectedIndex.value = 0;
};

const navigate = (direction: 1 | -1) => {
  const newIndex = selectedIndex.value + direction;
  if (newIndex >= 0 && newIndex < filteredCommands.value.length) {
    selectedIndex.value = newIndex;
  }
};

const executeSelected = () => {
  const command = filteredCommands.value[selectedIndex.value];
  if (command) {
    executeCommand(command.id);
  }
};

const executeCommand = (commandId: string) => {
  commandService.execute(commandId);
  hide();
};

const handleGlobalKey = (e: KeyboardEvent) => {
  if(e.ctrlKey && e.shiftKey && e.key === 'P') {
    e.preventDefault();
    show();
  }
  if(e.key === 'Escape' && isVisible.value) {
    hide();
  }
}

onMounted(() => window.addEventListener('keydown', handleGlobalKey));
onUnmounted(() => window.removeEventListener('keydown', handleGlobalKey));

defineExpose({ show, hide });
</script>

<style scoped>
.palette-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  display: flex;
  justify-content: center;
  padding-top: 15vh;
}
.palette-container {
  width: 100%;
  max-width: 600px;
  background-color: white;
  border-radius: 0.75rem;
  box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: min-content;
  max-height: 70vh;
}
.search-wrapper {
  position: relative;
  border-bottom: 1px solid #e5e7eb;
  padding: 0.75rem;
}
.search-icon {
  position: absolute;
  left: 1.5rem;
  top: 50%;
  transform: translateY(-50%);
  color: #9ca3af;
}
.search-input {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem 1rem 0.75rem 2.5rem;
  border: none;
  outline: none;
  background: transparent;
}
.results-list {
  overflow-y: auto;
  padding: 0.5rem;
}
.results-list li {
  padding: 0.75rem 1rem;
  border-radius: 0.375rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}
.results-list li.selected {
  background-color: #3B82F6;
  color: white;
}
.no-results {
  color: #9ca3af;
  text-align: center;
  padding: 2rem;
  cursor: default;
}
</style>

// =
// 文件: ..\src\core\components\ContextMenu.vue
//

<!-- 文件: src/core/components/ContextMenu.vue -->
<!-- 描述: 一个通用的、由命令驱动的右键菜单。 -->
<template>
  <div
      v-if="visible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
      @contextmenu.prevent
  >
    <ul class="menu-list">
      <li v-for="item in items" :key="item.id">
        <div v-if="item.isDivider" class="menu-divider"></div>
        <a
            v-else
            href="#"
            class="menu-item"
            :class="{ 'disabled': !canExecute(item.commandId, item.commandContext) }"
            @click.prevent="executeCommand(item)"
        >
          <i v-if="item.icon" :class="[item.icon, 'menu-icon']"></i>
          <span>{{ item.label }}</span>
        </a>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { commandService } from '@/core/services/CommandService';
import type { ContextMenuItem, CommandContext } from '@/core/types';

const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const items = ref<ContextMenuItem[]>([]);

const show = (event: MouseEvent, menuItems: ContextMenuItem[]) => {
  items.value = menuItems;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  items.value = [];
};

const canExecute = (commandId: string, context?: CommandContext) => {
  const command = commandService.get(commandId);
  if (!command) return false;
  if (command.canExecute) {
    return command.canExecute(context);
  }
  return true;
};

const executeCommand = (item: ContextMenuItem) => {
  if (canExecute(item.commandId, item.commandContext)) {
    commandService.execute(item.commandId, item.commandContext);
    hide();
  }
};

const handleClickOutside = (event: MouseEvent) => hide();

onMounted(() => window.addEventListener('click', handleClickOutside));
onBeforeUnmount(() => window.removeEventListener('click', handleClickOutside));

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
.menu-list { list-style: none; }
.menu-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  color: #374151;
  cursor: pointer;
  user-select: none;
  text-decoration: none;
}
.menu-item:not(.disabled):hover { background-color: #f3f4f6; }
.menu-item.disabled { color: #9ca3af; cursor: not-allowed; }
.menu-icon { width: 1rem; text-align: center; }
.menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\core\components\MainPane.vue
//

<template>
  <div class="main-pane-container" ref="containerRef">
    <template v-for="(pane, index) in panes" :key="pane.id">
      <PaneInstance
          :pane="pane"
          :is-active="pane.id === paneStore.activePaneId"
          class="pane-instance"
      />
      <div
          v-if="index < panes.length - 1"
          class="pane-resizer"
          @mousedown.prevent="startResize($event, index)"
      ></div>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { configService } from '@/core/services/ConfigService';
import PaneInstance from './PaneInstance.vue';

const paneStore = usePaneStore();
const panes = computed(() => paneStore.panes);
const containerRef = ref<HTMLElement | null>(null);

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;
  const minWidth = configService.get('pane.minWidth', 200);

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    if (newLeftWidth < minWidth) newLeftWidth = minWidth;
    if (totalWidth - newLeftWidth < minWidth) newLeftWidth = totalWidth - minWidth;

    leftPane.style.flexBasis = `${newLeftWidth}px`;
    rightPane.style.flexBasis = `${totalWidth - newLeftWidth}px`;
    leftPane.style.flexGrow = '0';
    rightPane.style.flexGrow = '0';
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
};
</script>

<style scoped>
.main-pane-container {
  flex-grow: 1; display: flex; overflow: hidden; background-color: #F3F4F6;
}
.pane-instance { flex: 1 1 0px; min-width: 0; }
.pane-resizer {
  width: 5px; background-color: transparent; cursor: col-resize;
  flex-shrink: 0; z-index: 5; position: relative; transition: background-color 0.2s ease;
}
.pane-resizer:hover { background-color: #3B82F6; }
.pane-resizer::before {
  content: ''; position: absolute; left: 2px; top: 0; width: 1px;
  height: 100%; background-color: #E5E7EB;
}
.pane-resizer:hover::before { background-color: transparent; }
</style>

// =
// 文件: ..\src\core\components\PaneInstance.vue
//

<!-- 文件: src/core/components/PaneInstance.vue -->
<!-- 描述: 单个窗格的UI实现，包含标签栏和动态渲染的内容区域。 -->
<template>
  <div class="pane-instance-container" @click="paneStore.setActivePane(pane.id)">
    <TabBar :tabs="pane.tabs" :active-tab-id="pane.activeTabId" :pane-id="pane.id" />
    <div class="content-area">
      <template v-if="activeItem">
        <component :is="resolvedView" :key="activeItem.id" :item="activeItem" />
      </template>
      <div v-else class="welcome-screen">
        <p>No file is open</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch, type PropType } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { useTabStore } from '@/core/stores/tabStore';
import { viewRegistry } from '@/core/services/ViewRegistry';
import type { Pane, CoreItem } from '@/core/types';
import TabBar from './TabBar.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<Pane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  },
});

const paneStore = usePaneStore();
const tabStore = useTabStore();

const activeItem = ref<CoreItem | null>(null);

const resolvedView = computed(() => {
  if (activeItem.value?.viewType) {
    return viewRegistry.resolve(activeItem.value.viewType);
  }
  return null;
});

watch(
    () => props.pane.activeTabId,
    async (newTabId) => {
      if (newTabId) {
        // 通过 tabStore 间接访问 itemProvider
        // @ts-ignore - _itemProvider 是私有的，但这里我们需要它
        const provider = tabStore._itemProvider;
        if (provider) {
          activeItem.value = await provider.getItem(newTabId);
        }
      } else {
        activeItem.value = null;
      }
    },
    { immediate: true }
);
</script>

<style scoped>
.pane-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  border-left: 1px solid #E5E7EB;
}
.pane-instance-container:first-child {
  border-left: none;
}
.content-area {
  flex-grow: 1;
  overflow: auto;
}
.welcome-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #9CA3AF;
  user-select: none;
}
</style>

// =
// 文件: ..\src\core\components\TabBar.vue
//

<template>
  <div class="tab-bar-container">
    <div
        v-for="tab in tabs"
        :key="tab.id"
        class="tab-item"
        :class="{ 'active': tab.id === activeTabId, 'inactive-pane-tab': !isActivePane }"
        @click.stop="tabStore.openTab(tab.id, paneId)"
    >
      <i :class="[tab.icon, 'tab-icon']"></i>
      <span class="tab-title">{{ tab.title }}</span>
      <div class="close-icon-wrapper">
        <i
            v-if="!tab.isDirty"
            class="fa-solid fa-times close-icon"
            @click.stop="tabStore.closeTab(tab.id, paneId)"
        ></i>
        <div v-else class="dirty-indicator" @click.stop="tabStore.closeTab(tab.id, paneId)"></div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from 'vue';
import { useTabStore } from '@/core/stores/tabStore';
import type { Tab } from '@/core/types';

defineProps({
  tabs: { type: Array as PropType<Tab[]>, required: true },
  activeTabId: { type: String as PropType<string | null>, required: true },
  paneId: { type: String, required: true },
  isActivePane: { type: Boolean, required: true },
});

const tabStore = useTabStore();
</script>

<style scoped>
.tab-bar-container {
  display: flex; flex-shrink: 0; background-color: #F3F4F6;
  border-bottom: 1px solid #E5E7EB; padding-top: 0.5rem; padding-left: 0.5rem;
  overflow-x: auto;
}
.tab-item {
  display: flex; align-items: center; padding: 0.6rem 0.5rem 0.6rem 1rem;
  font-size: 0.875rem; color: #6B7280; cursor: pointer;
  border: 1px solid transparent; border-bottom: none;
  border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem;
  background-color: #E5E7EB; white-space: nowrap; transition: background-color 0.2s, color 0.2s;
}
.tab-item:not(:first-child) { margin-left: -1px; }
.tab-item:hover { background-color: #FFFFFF; }
.tab-item.active {
  background-color: #FFFFFF; color: #1F2937;
  border-color: #E5E7EB; z-index: 2; margin-bottom: -1px;
  padding-bottom: calc(0.6rem + 1px);
}
.inactive-pane-tab { background-color: #F3F4F6; color: #9CA3AF; }
.inactive-pane-tab:hover { background-color: #E5E7EB; }
.inactive-pane-tab.active { background-color: #F9FAFB; color: #6B7280; }
.tab-icon { margin-right: 0.5rem; }
.active .tab-icon { color: #3B82F6; }
.inactive-pane-tab.active .tab-icon { color: inherit; }
.tab-title { max-width: 150px; overflow: hidden; text-overflow: ellipsis; }

.close-icon-wrapper {
  margin-left: 0.75rem;
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 99px;
  flex-shrink: 0;
}
.close-icon {
  font-size: 0.8rem;
  opacity: 0.5;
  transition: all 0.2s;
  padding: 0.25rem;
}
.tab-item:hover .close-icon { opacity: 1; }
.close-icon:hover { background-color: #E5E7EB; border-radius: 99px; }

.dirty-indicator {
  width: 0.5rem;
  height: 0.5rem;
  background-color: #6B7280;
  border-radius: 99px;
  transition: all 0.2s;
}
.tab-item:hover .dirty-indicator {
  background-color: transparent;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%236B7280'%3E%3Cpath d='M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z'/%3E%3C/svg%3E");
  background-size: 100% 100%;
  width: 1rem;
  height: 1rem;
}
</style>

// =
// 文件: ..\src\core\components\WelcomeScreen.vue
//

<!-- 文件: src/core/components/WelcomeScreen.vue -->
<!-- 描述: 空窗格的欢迎界面，提供更友好的用户体验。 -->
<template>
  <div class="welcome-screen">
    <i class="fa-solid fa-feather-pointed welcome-icon"></i>
    <h1 class="welcome-title">Editor Core</h1>
    <p class="welcome-subtitle">Select a file from the sidebar to begin.</p>
  </div>
</template>

<style scoped>
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
  background-color: #FFFFFF;
}
.welcome-icon {
  font-size: 4rem; /* 64px */
  color: #E5E7EB; /* gray-200 */
}
.welcome-title {
  font-size: 1.5rem; /* 24px */
  font-weight: 500;
  color: #4B5563; /* gray-600 */
  margin-top: 1.5rem;
}
.welcome-subtitle {
  color: #9CA3AF; /* gray-400 */
  margin-top: 0.5rem;
}
</style>

// =
// 文件: ..\src\core\components\layout\CoreLayout.vue
//


<template>
  <div class="core-layout-container" :class="{'sidebar-hidden': !isSidebarVisible}">
    <div class="activity-bar-area">
      <slot name="activity-bar"></slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-area" :style="{ width: `${sidebarWidth}px` }">
      <slot name="sidebar">
        <!-- Default sidebar content if app doesn't provide one -->
        <SidebarPanel />
      </slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-resizer" @mousedown.prevent="startResize"></div>

    <div class="main-content-area">
      <MainPane />
    </div>

    <!-- Status bar is now part of the main content area for better layout control -->
    <div class="status-bar-area">
      <slot name="status-bar"></slot>
    </div>

    <div class="global-components-area">
      <slot name="global">
        <NotificationCenter />
        <CommandPalette ref="commandPaletteRef" />
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { useLayoutStore } from '@/core/stores/layoutStore';
import { useTabStore } from '@/core/stores/tabStore';
import { keybindingService } from '@/core/services/KeybindingService';
import { workspaceService } from '@/core/services/WorkspaceService';
import { commandService } from '@/core/services/CommandService';
import type { ItemProvider } from '@/core/types/providers';

import MainPane from '../MainPane.vue';
import SidebarPanel from './SidebarPanel.vue';
import NotificationCenter from './NotificationCenter.vue';
import CommandPalette from '../CommandPalette.vue';
import { storeToRefs } from 'pinia';

const props = defineProps<{
  itemProvider: ItemProvider;
}>();

const paneStore = usePaneStore();
const layoutStore = useLayoutStore();
const tabStore = useTabStore();
const { isSidebarVisible, sidebarWidth } = storeToRefs(layoutStore);
const commandPaletteRef = ref<InstanceType<typeof CommandPalette> | null>(null);

// --- Core Initialization ---
onMounted(async () => {
  // 1. Inject dependencies
  tabStore.setItemProvider(props.itemProvider);

  // 2. Register core commands
  commandService.register({
    id: 'core.commandPalette.toggle',
    label: 'Toggle Command Palette',
    execute: () => commandPaletteRef.value?.toggle(), // CommandPalette需要一个toggle方法
  });
  keybindingService.register({ key: 'ctrl+shift+p', commandId: 'core.commandPalette.toggle'});

  // 3. Initialize services
  keybindingService.initialize();

  // 4. Hydrate workspace state from localStorage
  await workspaceService.hydrate();

  // 5. If no state was hydrated, initialize default state
  paneStore.initializePanes();

  // 6. Watch for state changes to persist them
  watch(
      [paneStore.$state, layoutStore.$state],
      () => {
        workspaceService.persist();
      },
      { deep: true }
  );
});

onUnmounted(() => {
  keybindingService.destroy();
});

// --- Sidebar Resizing Logic ---
const startResize = (event: MouseEvent) => {
  const startWidth = sidebarWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    layoutStore.setSidebarWidth(startWidth + dx);
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = 'default';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
};
</script>

<style scoped>
.core-layout-container {
  display: flex; height: 100%; width: 100%; overflow: hidden; background-color: #FFFFFF;
}
.activity-bar-area, .sidebar-area { flex-shrink: 0; height: 100%; }
.activity-bar-area { z-index: 20; border-right: 1px solid #E5E7EB; }
.sidebar-area { z-index: 10; border-right: 1px solid #E5E7EB; }
.sidebar-resizer {
  width: 5px; background-color: transparent; cursor: col-resize; flex-shrink: 0;
  position: relative; z-index: 15;
}
.sidebar-resizer:hover { background-color: #3B82F6; }
.main-content-area {
  flex-grow: 1; display: flex; flex-direction: column; min-width: 0;
  position: relative;
}
.status-bar-area {
  flex-shrink: 0;
  height: 28px; /* Example height */
  border-top: 1px solid #E5E7EB;
}
.global-components-area {
  position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 9999; pointer-events: none;
}
</style>

// =
// 文件: ..\src\core\components\layout\NotificationCenter.vue
//

<template>
  <div class="notification-center">
    <transition-group name="notification-fade" tag="div">
      <div
          v-for="notification in notifications"
          :key="notification.id"
          :class="['notification-toast', `notification-${notification.type}`]"
          @click="notificationStore.remove(notification.id)"
      >
        <span class="message">{{ notification.message }}</span>
      </div>
    </transition-group>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useNotificationStore } from '@/core/stores/notificationStore';

const notificationStore = useNotificationStore();
const notifications = computed(() => notificationStore.notifications);
</script>

<style scoped>
.notification-center {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  pointer-events: all; /* Re-enable pointer events for toasts */
}
.notification-toast {
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  cursor: pointer;
  color: white;
  font-weight: 500;
  transition: all 0.3s ease;
}
.notification-info { background-color: #3B82F6; }
.notification-success { background-color: #16A34A; }
.notification-warning { background-color: #F59E0B; }
.notification-error { background-color: #DC2626; }

.notification-fade-enter-active,
.notification-fade-leave-active {
  transition: opacity 0.5s, transform 0.5s;
}
.notification-fade-enter-from,
.notification-fade-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>

// =
// 文件: ..\src\core\components\layout\SidebarPanel.vue
//


<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <!-- The title can be passed down via a slot or a prop -->
      <slot name="header">
        <h3 class="title">Sidebar</h3>
      </slot>
    </div>
    <div class="content">
      <slot>
        <!-- Default content if no content is provided by the app -->
        <div class="p-4 text-sm text-gray-500">
          This is the default sidebar content.
        </div>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}
.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F0F0F0;
  flex-shrink: 0;
}
.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}
.content {
  flex-grow: 1;
  position: relative;
  overflow: auto;
}
</style>

// =
// 文件: ..\src\core\services\CommandService.ts
//

// 文件: src/core/services/CommandService.ts
// 描述: 命令服务，负责注册、管理和执行所有命令。

import type { Command, CommandContext } from '@/core/types';

class CommandService {
    private commands: Map<string, Command> = new Map();

    /**
     * 注册一个命令。
     * 应用层在启动时调用此方法，将所有业务操作封装成命令并注入内核。
     * @param command - 要注册的命令对象。
     */
    public register(command: Command): void {
        if (this.commands.has(command.id)) {
            console.warn(`[CommandService] Command ID "${command.id}" is already registered. Overwriting.`);
        }
        this.commands.set(command.id, command);
    }

    /**
     * 执行一个命令。
     * @param commandId - 要执行的命令的ID。
     * @param context - 执行命令时传递的上下文。
     */
    public execute(commandId: string, context?: CommandContext): void {
        const command = this.commands.get(commandId);
        if (!command) {
            console.error(`[CommandService] Command "${commandId}" not found.`);
            return;
        }

        if (command.canExecute && !command.canExecute(context)) {
            console.warn(`[CommandService] Execution of command "${commandId}" was prevented by its 'canExecute' condition.`);
            return;
        }

        command.execute(context);
    }

    /**
     * 获取一个命令的定义。
     * @param commandId - 命令的ID。
     * @returns 返回命令对象，如果不存在则返回undefined。
     */
    public get(commandId: string): Command | undefined {
        return this.commands.get(commandId);
    }
}

// 导出一个单例，确保整个应用共享同一个命令中心。
export const commandService = new CommandService();

// =
// 文件: ..\src\core\services\ConfigService.ts
//

// 文件: src/core/services/ConfigService.ts
// 描述: 全局配置服务，允许应用层覆盖内核的默认行为。

class ConfigService {
    private config: Map<string, any> = new Map();

    /**
     * 设置一个配置项。
     * 应用层在初始化时调用此方法来注入自定义配置。
     * @param key - 配置项的键 (e.g., 'pane.minWidth')。
     * @param value - 配置项的值。
     */
    public set(key: string, value: any): void {
        this.config.set(key, value);
    }

    /**
     * 获取一个配置项。
     * 如果配置未被设置，则返回提供的默认值。
     * @param key - 配置项的键。
     * @param defaultValue - 当找不到键时返回的默认值。
     * @returns 配置项的值或默认值。
     */
    public get<T>(key: string, defaultValue: T): T {
        if (this.config.has(key)) {
            return this.config.get(key) as T;
        }
        return defaultValue;
    }
}

// 导出一个单例，确保整个应用共享同一个配置服务。
export const configService = new ConfigService();

// =
// 文件: ..\src\core\services\ContextMenuService.ts
//

// 文件: src/core/services/ContextMenuService.ts

import type { ContextMenuItem, CommandContext } from '@/core/types';

type ContextMenuProvider = (context: CommandContext) => ContextMenuItem[];

class ContextMenuService {
    private providers: Map<string, ContextMenuProvider[]> = new Map();

    /**
     * 注册一个上下文菜单提供者。
     * @param contextType - 上下文类型，如 'pane.background', 'tab.item'。
     * @param provider - 一个返回菜单项数组的函数。
     */
    public registerProvider(contextType: string, provider: ContextMenuProvider): void {
        if (!this.providers.has(contextType)) {
            this.providers.set(contextType, []);
        }
        this.providers.get(contextType)!.push(provider);
    }

    /**
     * 根据上下文类型和具体信息获取所有菜单项。
     * @param contextType - 上下文类型。
     * @param context - 具体的上下文数据，如 { paneId: '...' }。
     * @returns 一个合并后的菜单项数组。
     */
    public getItems(contextType: string, context: CommandContext): ContextMenuItem[] {
        const providers = this.providers.get(contextType) || [];
        // 将所有提供者返回的菜单项数组扁平化成一个数组
        return providers.flatMap(provider => provider(context));
    }
}

export const contextMenuService = new ContextMenuService();

// =
// 文件: ..\src\core\services\EventBusService.ts
//

// 文件: src/core/services/EventBusService.ts
// 描述: 一个轻量级的全局事件总线，用于实现模块间的解耦通信。

type EventHandler = (payload?: any) => void;

class EventBusService {
    private events: Map<string, EventHandler[]> = new Map();

    /**
     * 订阅一个事件。
     * @param eventName - 事件名称 (e.g., 'core:tab.opened')。
     * @param handler - 事件处理函数。
     */
    public on(eventName: string, handler: EventHandler): void {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }
        this.events.get(eventName)!.push(handler);
    }

    /**
     * 取消订阅一个事件。
     * @param eventName - 事件名称。
     * @param handler - 要移除的事件处理函数。
     */
    public off(eventName: string, handler: EventHandler): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }

    /**
     * 触发一个事件，通知所有订阅者。
     * @param eventName - 事件名称。
     * @param payload - （可选）随事件传递的数据。
     */
    public emit(eventName: string, payload?: any): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            // 创建副本以防在处理过程中有订阅/取消订阅操作
            [...handlers].forEach(handler => handler(payload));
        }
    }
}

// 导出一个单例，确保整个应用共享同一个事件总线。
export const eventBus = new EventBusService();

// =
// 文件: ..\src\core\services\KeybindingService.ts
//

import { commandService } from './CommandService';

interface Keybinding {
    key: string;
    commandId: string;
    when?: () => boolean;
}

class KeybindingService {
    private keybindings: Map<string, Keybinding> = new Map();

    public initialize(): void {
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
    }

    public destroy(): void {
        window.removeEventListener('keydown', this.handleKeyDown.bind(this));
    }

    /**
     * 注册一个快捷键。
     * @param keybinding - 快捷键定义对象。
     */
    public register(keybinding: Keybinding): void {
        const key = this.normalizeKey(keybinding.key);
        this.keybindings.set(key, keybinding);
    }

    private handleKeyDown(event: KeyboardEvent): void {
        const key = this.eventToKey(event);
        const binding = this.keybindings.get(key);

        if (binding) {
            if (!binding.when || binding.when()) {
                event.preventDefault();
                event.stopPropagation();
                commandService.execute(binding.commandId);
            }
        }
    }

    private normalizeKey(key: string): string {
        return key.toLowerCase().split('+').sort().join('+');
    }

    private eventToKey(event: KeyboardEvent): string {
        const parts: string[] = [];
        if (event.ctrlKey) parts.push('ctrl');
        if (event.shiftKey) parts.push('shift');
        if (event.altKey) parts.push('alt');
        if (event.metaKey) parts.push('meta'); // Cmd on Mac

        const key = event.key.toLowerCase();
        if (!['control', 'shift', 'alt', 'meta'].includes(key)) {
            parts.push(key);
        }

        return parts.sort().join('+');
    }
}

export const keybindingService = new KeybindingService();

// =
// 文件: ..\src\core\services\ViewRegistry.ts
//

// 文件: src/core/services/ViewRegistry.ts
// 描述: 视图注册表服务，负责管理 "viewType" 字符串到 Vue 组件的映射。

import type { Component } from 'vue';

class ViewRegistry {
    private views: Map<string, Component> = new Map();

    /**
     * 注册一个视图类型及其对应的Vue组件。
     * 应用层在启动时调用此方法，告诉内核如何渲染特定类型的内容。
     * @param viewType - 视图的唯一标识符字符串 (e.g., 'novel-chapter-editor')。
     * @param component - 要渲染的Vue组件。
     */
    public register(viewType: string, component: Component): void {
        if (this.views.has(viewType)) {
            console.warn(`[ViewRegistry] View type "${viewType}" is already registered. Overwriting.`);
        }
        this.views.set(viewType, component);
    }

    /**
     * 根据视图类型解析并返回对应的Vue组件。
     * PaneInstance组件会调用此方法来动态渲染内容。
     * @param viewType - 视图的唯一标识符字符串。
     * @returns 如果找到，则返回Vue组件；否则返回null。
     */
    public resolve(viewType: string): Component | null {
        if (!this.views.has(viewType)) {
            console.error(`[ViewRegistry] No view component registered for type "${viewType}".`);
            return null;
        }
        return this.views.get(viewType) || null;
    }
}

// 导出一个单例，确保整个应用共享同一个视图注册表。
export const viewRegistry = new ViewRegistry();

// =
// 文件: ..\src\core\services\WorkspaceService.ts
//


import { toRaw } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { useLayoutStore } from '@/core/stores/layoutStore';

const WORKSPACE_STORAGE_KEY = 'editorCoreWorkspaceState';

class WorkspaceService {
    private paneStore = usePaneStore();
    private layoutStore = useLayoutStore();

    constructor() {
        this.persist = this.debounce(this.persist.bind(this), 1000);
    }

    /**
     * 将当前工作区状态保存到localStorage。
     */
    public persist(): void {
        const state = {
            panes: {
                panes: toRaw(this.paneStore.panes).map(p => ({
                    id: p.id,
                    activeTabId: p.activeTabId,
                    tabs: p.tabs.map(t => ({ id: t.id })) // 只保存tab的ID
                })),
                activePaneId: this.paneStore.activePaneId,
            },
            layout: {
                isSidebarVisible: this.layoutStore.isSidebarVisible,
                sidebarWidth: this.layoutStore.sidebarWidth,
            },
        };
        localStorage.setItem(WORKSPACE_STORAGE_KEY, JSON.stringify(state));
        console.log('[WorkspaceService] State persisted.');
    }

    /**
     * 从localStorage恢复工作区状态。
     * 应用启动时调用。
     */
    public async hydrate(): Promise<void> {
        const savedStateJSON = localStorage.getItem(WORKSPACE_STORAGE_KEY);
        if (!savedStateJSON) {
            console.log('[WorkspaceService] No saved state found.');
            return;
        }

        try {
            const savedState = JSON.parse(savedStateJSON);

            // 恢复布局状态
            if (savedState.layout) {
                this.layoutStore.hydrate(savedState.layout);
            }

            // 恢复窗格和标签页状态
            if (savedState.panes && savedState.panes.panes.length > 0) {
                // 直接恢复窗格结构
                this.paneStore.panes = []; // 清空默认窗格
                this.paneStore.activePaneId = savedState.panes.activePaneId;

                for (const savedPane of savedState.panes.panes) {
                    const newPane = { id: savedPane.id, activeTabId: savedPane.activeTabId, tabs: [] };
                    this.paneStore.panes.push(newPane);
                    // 异步恢复每个标签页
                    for (const savedTab of savedPane.tabs) {
                        // 这里我们不直接创建Tab对象，而是调用openTab
                        // openTab会从ItemProvider获取最新的title和icon
                        await useTabStore().openTab(savedTab.id, newPane.id);
                    }
                    // 确保恢复后的activeTabId是正确的
                    newPane.activeTabId = savedPane.activeTabId;
                }

                console.log('[WorkspaceService] State hydrated.');
            }
        } catch (error) {
            console.error('[WorkspaceService] Failed to hydrate state:', error);
            localStorage.removeItem(WORKSPACE_STORAGE_KEY);
        }
    }

    /**
     * 简单的debounce函数，防止过于频繁地写入localStorage。
     * @param func - 要节流的函数。
     * @param delay - 延迟时间（毫秒）。
     */
    private debounce<T extends (...args: any[]) => any>(func: T, delay: number): (...args: Parameters<T>) => void {
        let timeoutId: number | undefined;
        return (...args: Parameters<T>) => {
            clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => func(...args), delay);
        };
    }
}

export const workspaceService = new WorkspaceService();

// =
// 文件: ..\src\core\stores\layoutStore.ts
//


import { defineStore } from 'pinia';
import { ref } from 'vue';
import { configService } from '@/core/services/ConfigService';

export const useLayoutStore = defineStore('core-layout', () => {
    // --- State ---
    const isSidebarVisible = ref(true);
    const sidebarWidth = ref(configService.get('layout.sidebar.defaultWidth', 320));

    // --- Actions ---

    /**
     * 切换侧边栏的可见性。
     */
    function toggleSidebar() {
        isSidebarVisible.value = !isSidebarVisible.value;
    }

    /**
     * 设置侧边栏的宽度。
     * @param width - 新的宽度值。
     */
    function setSidebarWidth(width: number) {
        const min = configService.get('layout.sidebar.minWidth', 240);
        const max = configService.get('layout.sidebar.maxWidth', 600);
        sidebarWidth.value = Math.max(min, Math.min(width, max));
    }

    /**
     * (用于工作区恢复) 设置整个布局的状态。
     * @param state - 包含布局状态的对象。
     */
    function hydrate(state: { isSidebarVisible?: boolean; sidebarWidth?: number; }) {
        if (typeof state.isSidebarVisible === 'boolean') {
            isSidebarVisible.value = state.isSidebarVisible;
        }
        if (typeof state.sidebarWidth === 'number') {
            setSidebarWidth(state.sidebarWidth);
        }
    }

    return {
        isSidebarVisible,
        sidebarWidth,
        toggleSidebar,
        setSidebarWidth,
        hydrate,
    };
});

// =
// 文件: ..\src\core\stores\notificationStore.ts
//

// 文件: src/core/stores/notificationStore.ts
// 描述: 管理全局通知（Toast）的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';

export type NotificationType = 'info' | 'success' | 'warning' | 'error';

export interface Notification {
    id: number;
    message: string;
    type: NotificationType;
    duration?: number; // 显示时长（毫秒），可选
}

let nextId = 0;

export const useNotificationStore = defineStore('core-notification', () => {
    const notifications = ref<Notification[]>([]);

    /**
     * 添加一条新通知。
     * @param message - 通知内容。
     * @param type - 通知类型。
     * @param duration - （可选）显示时长，默认3000ms。
     */
    function add(message: string, type: NotificationType = 'info', duration: number = 3000) {
        const id = nextId++;
        notifications.value.push({ id, message, type, duration });

        if (duration > 0) {
            setTimeout(() => {
                remove(id);
            }, duration);
        }
    }

    /**
     * 移除一条通知。
     * @param id - 要移除的通知的ID。
     */
    function remove(id: number) {
        const index = notifications.value.findIndex(n => n.id === id);
        if (index !== -1) {
            notifications.value.splice(index, 1);
        }
    }

    return {
        notifications,
        add,
        remove,
    };
});

// =
// 文件: ..\src\core\stores\paneStore.ts
//

// 文件: src/core/stores/paneStore.ts
// 描述: 管理编辑器所有窗格（Pane）的布局和状态。(增强版)

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Pane } from '@/core/types';
import { eventBus } from '@/core/services/EventBusService';
import { useNotificationStore } from './notificationStore';

export const usePaneStore = defineStore('core-pane', () => {
    // --- State ---
    const panes = ref<Pane[]>([]);
    const activePaneId = ref<string | null>(null);

    // --- Getters ---
    const activePane = computed(() => {
        if (!activePaneId.value) return null;
        return panes.value.find(p => p.id === activePaneId.value) || null;
    });

    // --- Actions ---

    /**
     * 初始化窗格，确保至少有一个窗格存在。
     * 应用启动时必须调用此方法。
     */
    function initializePanes() {
        if (panes.value.length === 0) {
            const initialPaneId = `pane-${Date.now()}`;
            panes.value.push({ id: initialPaneId, tabs: [], activeTabId: null });
            activePaneId.value = initialPaneId;
            eventBus.emit('core:pane.initialized', { initialPaneId });
        }
    }

    /**
     * 设置激活的窗格。
     * @param paneId - 要激活的窗格ID。
     */
    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId) && activePaneId.value !== paneId) {
            activePaneId.value = paneId;
            eventBus.emit('core:pane.activated', { paneId });
        }
    }

    /**
     * 在指定窗格旁边分割出一个新窗格。
     * @param sourcePaneId - 作为分割源的窗格ID。
     * @returns 新创建的窗格ID。
     */
    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) {
            const notificationStore = useNotificationStore();
            notificationStore.add(`Cannot split: pane with ID "${sourcePaneId}" not found.`, 'error');
            return '';
        }

        const newPaneId = `pane-${Date.now()}`;
        const newPane: Pane = { id: newPaneId, tabs: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        eventBus.emit('core:pane.splitted', { sourcePaneId, newPaneId });
        return newPaneId;
    }

    /**
     * 关闭一个窗格。
     * @param paneId - 要关闭的窗格ID。
     */
    function closePane(paneId: string) {
        if (panes.value.length <= 1) {
            const notificationStore = useNotificationStore();
            notificationStore.add('Cannot close the last pane.', 'warning');
            return;
        }

        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        const closedPane = panes.value[paneIndex];
        panes.value.splice(paneIndex, 1);

        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            const newActivePaneId = panes.value[newActiveIndex]?.id || null;
            activePaneId.value = newActivePaneId;
            eventBus.emit('core:pane.activated', { paneId: newActivePaneId });
        }

        eventBus.emit('core:pane.closed', { closedPaneId: paneId, tabs: closedPane.tabs });
    }

    return {
        panes,
        activePaneId,
        activePane,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\core\stores\tabStore.ts
//


import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useNotificationStore } from './notificationStore';
import type { ItemProvider } from '@/core/types/providers';
import type { Tab, CoreItem } from '@/core/types';
import { eventBus } from '@/core/services/EventBusService';

let _itemProvider: ItemProvider | null = null;

export const useTabStore = defineStore('core-tab', () => {
    const paneStore = usePaneStore();
    const notificationStore = useNotificationStore();

    function setItemProvider(provider: ItemProvider) {
        _itemProvider = provider;
    }

    // getActiveItem, openTab, closeTab 保持不变...
    async function getActiveItem(paneId: string): Promise<CoreItem | null> {
        if (!_itemProvider) {
            console.error('[TabStore] Cannot get active item: ItemProvider not set.');
            return null;
        }
        const pane = paneStore.panes.find(p => p.id === paneId);
        if (pane && pane.activeTabId) {
            return await _itemProvider.getItem(pane.activeTabId);
        }
        return null;
    }

    async function openTab(itemId: string, targetPaneId?: string) {
        if (!_itemProvider) {
            throw new Error('[TabStore] ItemProvider has not been set. Cannot open tab.');
        }

        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) {
            notificationStore.add('No active pane to open the tab in.', 'error');
            return;
        }

        for (const p of paneStore.panes) {
            if (p.tabs.some(t => t.id === itemId)) {
                p.activeTabId = itemId;
                paneStore.setActivePane(p.id);
                eventBus.emit('core:tab.activated', { tabId: itemId, paneId: p.id });
                return;
            }
        }

        const item = await _itemProvider.getItem(itemId);
        if (!item) {
            notificationStore.add(`Failed to open: Item with ID "${itemId}" not found.`, 'error');
            return;
        }

        const pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) {
            notificationStore.add(`Target pane with ID "${paneId}" not found.`, 'error');
            return;
        }

        const newTab: Tab = {
            id: item.id,
            title: item.title,
            icon: item.icon,
            isDirty: false, // 初始为未修改状态
        };

        pane.tabs.push(newTab);
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
        eventBus.emit('core:tab.opened', { tab: newTab, paneId: pane.id });
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPane = paneId
            ? paneStore.panes.find(p => p.id === paneId)
            : paneStore.panes.find(p => p.tabs.some(t => t.id === itemId));

        if (!targetPane) return;

        const tabIndex = targetPane.tabs.findIndex(t => t.id === itemId);
        if (tabIndex === -1) return;

        const closedTab = targetPane.tabs[tabIndex];

        // 如果标签是“脏”的，可以阻止关闭（此逻辑应由应用层通过监听事件实现）
        if (closedTab.isDirty) {
            const confirmed = confirm(`Changes to "${closedTab.title}" will be lost. Are you sure you want to close?`);
            if (!confirmed) return;
        }

        targetPane.tabs.splice(tabIndex, 1);
        eventBus.emit('core:tab.closed', { tab: closedTab, paneId: targetPane.id });

        if (targetPane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, tabIndex - 1);
            const newActiveTabId = targetPane.tabs[newActiveIndex]?.id || null;
            targetPane.activeTabId = newActiveTabId;
            eventBus.emit('core:tab.activated', { tabId: newActiveTabId, paneId: targetPane.id });
        }
    }

    /**
     * (新增) 更新一个标签页的UI状态。
     * @param tabId - 要更新的标签页ID。
     * @param state - 要更新的状态，如 { isDirty: true }。
     */
    function updateTabState(tabId: string, state: Partial<Pick<Tab, 'isDirty' | 'title' | 'icon'>>) {
        for (const pane of paneStore.panes) {
            const tab = pane.tabs.find(t => t.id === tabId);
            if (tab) {
                Object.assign(tab, state);
                eventBus.emit('core:tab.stateChanged', { tabId, newState: state });
                break;
            }
        }
    }

    return {
        setItemProvider,
        getActiveItem,
        openTab,
        closeTab,
        updateTabState,
    };
});

// =
// 文件: ..\src\core\types\index.ts
//


export interface CoreItem {
    id: string;
    title: string;
    icon: string;
    viewType: string;
    metadata?: Record<string, any>;
}

/**
 * 标签页的UI状态表示。
 */
export interface Tab {
    id: string;
    title: string;
    icon: string;
    isDirty?: boolean; // 新增：内容是否“变脏”
}

// Pane 保持不变
export interface Pane {
    id:string;
    tabs: Tab[];
    activeTabId: string | null;
}

// CommandContext, Command, ContextMenuItem 保持不变
export interface CommandContext {
    targetId?: string;
    paneId?: string;
    [key: string]: any;
}

export interface Command {
    id: string;
    label: string;
    icon?: string;
    execute: (context?: CommandContext) => void;
    canExecute?: (context?: CommandContext) => boolean;
}

export interface ContextMenuItem {
    id: string;
    label: string;
    icon?: string;
    commandId: string;
    commandContext?: CommandContext;
    isDivider?: boolean;
}

// =
// 文件: ..\src\core\types\providers.ts
//


import type { CoreItem } from './index';
/**
 * 数据提供者接口 (ItemProvider Interface)。
 * 内核自身不实现它，但它依赖这个接口来获取任何需要展示的数据。
 * 应用层（如小说编辑器）必须提供一个实现了此接口的对象，并将其注入到内核中。
 *
 * 这种设计将内核的数据获取逻辑与具体的数据源（如Pinia Store、本地文件、API）完全解耦。
 */
export interface ItemProvider {
    /**
     * 根据ID异步获取一个项目。
     * @param id - 要获取的项目的唯一ID。
     * @returns 返回一个Promise，解析为CoreItem对象或在找不到时解析为null。
     */
    getItem(id: string): Promise<CoreItem | null>;
}

