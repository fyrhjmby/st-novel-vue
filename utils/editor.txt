// == 扫描摘要 ==
//
// 跳过的目录 (共 2 个):
//   - ..\src\novel\editor\components\ai\chat
//   - ..\src\novel\editor\components\layout
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\editor\api\aiService.ts
//


interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 模拟一个流式AI任务API。
 * 这个函数接收一个提示词，然后通过回调函数逐字地将这个提示词返回，
 * 以模拟一个接收到什么就返回什么的 "echo" 服务器。
 * @param prompt - 发送给AI的最终提示词。
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(prompt: string, callbacks: StreamCallbacks): void {
    const { onChunk, onComplete, onError } = callbacks;
    const words = prompt.split('');
    let wordIndex = 0;
    const willFail = Math.random() < 0.1; // 10%的几率模拟失败

    const intervalId = setInterval(() => {
        // 模拟流式输出
        if (wordIndex < words.length) {
            onChunk(words[wordIndex]);
            wordIndex++;
            // 模拟中途失败
            if (willFail && wordIndex > words.length / 2) {
                clearInterval(intervalId);
                onError('模拟网络错误，请重试。');
                return;
            }
        } else {
            // 流式结束
            clearInterval(intervalId);
            onComplete();
        }
    }, 20); // 调整流式速度
}

// =
// 文件: ..\src\novel\editor\components\ai\AIChatView.vue
//

<template>
  <div class="flex-1 flex overflow-hidden">
    <ConversationList />

    <main v-if="activeConversation" class="flex-1 flex flex-col bg-white">
      <ChatHeader :active-conversation="activeConversation" :current-model="currentModel" />

      <ChatMessageHistory :conversation="activeConversation" :is-receiving="isReceiving" />

      <ChatInputArea />

    </main>

    <div v-else class="flex-1 flex items-center justify-center bg-white text-gray-400">
      请从左侧选择或新建一个对话
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';
import { storeToRefs } from 'pinia';
import ConversationList from './chat/ConversationList.vue';
import ChatMessageHistory from './chat/ChatMessageHistory.vue';
import ChatInputArea from './chat/ChatInputArea.vue';
import ChatHeader from './chat/ChatHeader.vue';

const chatStore = useChatStore();
const { activeConversation, currentModel, isReceiving } = storeToRefs(chatStore);

onMounted(() => {
  chatStore.fetchConversations();
});
</script>

// =
// 文件: ..\src\novel\editor\components\ai\AIDiffPreview.vue
//

// 文件: src/novel/editor/components/ai/AIDiffPreview.vue

<template>
  <div class="diff-preview-container">
    <div class="header">
      <h3 class="title">AI生成预览</h3>
      <div class="actions">
        <button v-if="previewTask && previewTask.status === 'completed'" @click="$emit('apply-changes', previewTask.id)" class="apply-btn">
          <i class="fa-solid fa-check"></i>
          应用修改
        </button>
      </div>
    </div>
    <div class="content-area">
      <div v-if="previewTask">
        <div class="prose-preview">
          <div v-html="previewTask.generatedContent.replace(/\n/g, '<br>')"></div>
          <span v-if="previewTask.status === 'processing'" class="blinking-cursor">▍</span>
        </div>
      </div>
      <div v-else class="empty-state">
        <i class="fa-regular fa-eye text-3xl text-gray-300"></i>
        <p class="mt-2">请从上方任务队列中</p>
        <p>选择一个任务来查看预览。</p>
      </div>

      <!-- Manual Apply Floating Button -->
      <button
          v-if="previewTask && previewTask.status === 'completed'"
          @click="$emit('apply-changes', previewTask.id)"
          class="manual-apply-fab"
          title="应用修改"
      >
        <i class="fa-solid fa-check"></i>
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask } from '@/novel/editor/types';

defineProps({
  previewTask: {
    type: Object as PropType<AITask | null>,
    default: null,
  }
});

defineEmits<{
  (e: 'apply-changes', taskId: string): void;
}>();
</script>

<style scoped>
.diff-preview-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; height: 32px; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.apply-btn { display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background-color: #16A34A; color: white; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 500; transition: background-color 0.2s ease; }
.apply-btn:hover { background-color: #15803D; }
.content-area { flex-grow: 1; background-color: #FFFFFF; border-radius: 0.5rem; border: 1px solid #E5E7EB; padding: 1rem; overflow-y: auto; font-size: 0.875rem; line-height: 1.7; color: #374151; position: relative; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
.prose-preview { white-space: pre-wrap; }
.blinking-cursor { font-weight: 500; font-size: 1em; color: #3B82F6; animation: blink 1s step-end infinite; }
@keyframes blink { from, to { color: transparent; } 50% { color: #3B82F6; } }
.content-area { scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.content-area::-webkit-scrollbar { width: 6px; }
.content-area::-webkit-scrollbar-track { background: transparent; }
.content-area::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
.manual-apply-fab {
  position: absolute;
  bottom: 1rem;
  right: 1rem;
  width: 2.75rem;
  height: 2.75rem;
  background-color: #16A34A;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transition: all 0.2s ease;
  z-index: 10;
}
.manual-apply-fab:hover {
  background-color: #15803D;
  transform: scale(1.05);
}
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskItem.vue
//

// 文件: src/novel/editor/components/ai/AITaskItem.vue

<template>
  <div
      :class="['task-item', `status-${task.status}`, { 'clickable': isClickable(task.status) }]"
      @click="handleTaskClick"
  >
    <div class="task-item-header">
      <p class="task-title" :title="task.title">{{ task.title }}</p>
      <div class="flex items-center gap-2">
            <span class="task-status-text">
              <i :class="getStatusIcon(task.status)" class="status-icon"></i>
              {{ getStatusText(task.status) }}
            </span>
        <button
            v-if="task.status === 'completed'"
            @click.stop="emit('apply-changes', task.id)"
            class="apply-now-btn"
        >
          <i class="fa-solid fa-check fa-xs"></i>
          应用
        </button>
      </div>
    </div>

    <div class="task-item-body">
      <div v-if="task.status === 'processing'" class="progress-bar-container">
        <div class="progress-bar"></div>
      </div>
      <p v-if="task.status === 'failed'" class="error-message">
        {{ task.error }} <a href="#" @click.prevent.stop="emit('retry-task', task.id)" class="retry-link">重试</a>
      </p>
      <p v-if="isClickable(task.status)" class="message">
        点击查看详情
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, AITaskStatus } from '@/novel/editor/types';

const props = defineProps({
  task: {
    type: Object as PropType<AITask>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
  (e: 'retry-task', taskId: string): void;
}>();

const getStatusText = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: '等待中',
    processing: '进行中...',
    completed: '待应用',
    failed: '失败',
    applied: '已应用'
  };
  return map[status];
};

const getStatusIcon = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: 'fa-solid fa-hourglass-half',
    processing: 'fa-solid fa-spinner fa-spin',
    completed: 'fa-solid fa-check-circle',
    failed: 'fa-solid fa-times-circle',
    applied: 'fa-solid fa-check-double'
  };
  return map[status];
}

const isClickable = (status: AITaskStatus): boolean => {
  return ['completed', 'processing', 'applied', 'failed'].includes(status);
};

const handleTaskClick = () => {
  if (isClickable(props.task.status)) {
    emit('select-task', props.task);
  }
};
</script>

<style scoped>
.task-item { padding: 0.75rem; border-radius: 0.5rem; border: 1px solid #E5E7EB; transition: all 0.2s ease; background-color: #FFFFFF;}
.task-item.clickable { cursor: pointer; }
.task-item.clickable:hover { border-color: #D1D5DB; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.task-item.status-processing.clickable { border: 1px solid #93C5FD; background-color: #EFF6FF; }
.task-item.status-processing.clickable:hover { background-color: #DBEAFE; border-color: #60A5FA; }
.task-item.status-completed.clickable { border: 1px solid #BBF7D0; background-color: #F0FDF4; }
.task-item.status-completed.clickable:hover { background-color: #DCFCE7; border-color: #A7F3D0; }
.task-item.status-failed { border: 1px solid #FECACA; background-color: #FEF2F2; }
.task-item.status-applied.clickable { border: 1px solid #E5E7EB; background-color: #F9FAFB; }
.task-item.status-applied.clickable:hover { background-color: #F3F4F6; border-color: #E5E7EB; }
.task-item-header { display: flex; justify-content: space-between; align-items: center; }
.task-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.task-status-text { font-size: 0.75rem; font-weight: 500; display: flex; align-items: center; gap: 0.25rem; flex-shrink: 0; }
.status-icon { width: 1rem; text-align: center; }
.status-pending .task-status-text { color: #6B7280; }
.status-processing .task-status-text { color: #2563EB; }
.status-completed .task-status-text { color: #16A34A; }
.status-failed .task-status-text { color: #DC2626; }
.status-applied .task-status-text { color: #6B7280; }
.task-item-body { margin-top: 0.5rem; }
.progress-bar-container { width: 100%; background-color: #E5E7EB; border-radius: 9999px; height: 0.25rem; overflow: hidden; }
.progress-bar { background-color: #3B82F6; height: 100%; width: 100%; border-radius: 9999px; animation: indeterminate-progress 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
@keyframes indeterminate-progress { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
.error-message, .message { font-size: 0.75rem; margin-top: 0.25rem; }
.error-message { color: #B91C1C; }
.message { color: #6B7280; }
.retry-link { text-decoration: underline; font-weight: 500; }
.apply-now-btn { display: flex; align-items: center; gap: 0.25rem; background: #22C55E; color: white; padding: 2px 8px; border-radius: 99px; font-size: 0.7rem; font-weight: 500; transition: background-color 0.2s; }
.apply-now-btn:hover { background: #16A34A; }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskPanel.vue
//

// 文件: src/novel/editor/components/ai/AITaskPanel.vue

<template>
  <div class="ai-task-panel-container">
    <div class="task-queue-section">
      <AITaskQueue @select-task="handleSelectTask" @apply-changes="handleApplyChanges" />
    </div>
    <div class="diff-preview-section">
      <AIDiffPreview :preview-task="selectedTask" @apply-changes="handleApplyChanges" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import AITaskQueue from './AITaskQueue.vue';
import AIDiffPreview from './AIDiffPreview.vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';

const selectedTaskId = ref<string | null>(null);
const aiTaskStore = useAITaskStore();

const selectedTask = computed((): AITask | null => {
  if (!selectedTaskId.value) return null;
  return aiTaskStore.tasks.find(t => t.id === selectedTaskId.value) ?? null;
});

const handleSelectTask = (task: AITask) => {
  selectedTaskId.value = task.id;
};

const handleApplyChanges = (taskId: string) => {
  aiTaskStore.applyChanges(taskId);

  // If the applied task was the one being previewed, clear the preview.
  if (selectedTaskId.value === taskId) {
    selectedTaskId.value = null;
  }
};
</script>

<style scoped>
.ai-task-panel-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #F9FAFB;
}
.task-queue-section {
  height: 50%;
  min-height: 200px;
  flex-shrink: 0;
}
.diff-preview-section {
  flex-grow: 1;
  height: 50%;
}
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskQueue.vue
//

// 文件: src/novel/editor/components/ai/AITaskQueue.vue

<template>
  <div class="task-queue-container">
    <div class="header">
      <h3 class="title">AI任务队列</h3>
      <span v-if="activeTasksCount > 0" class="badge">{{ activeTasksCount }}个活跃</span>
    </div>
    <div v-if="tasks.length > 0" class="task-list">
      <AITaskItem
          v-for="task in tasks"
          :key="task.id"
          :task="task"
          @select-task="handleTaskClick"
          @apply-changes="handleApplyChanges"
          @retry-task="handleRetry"
      />
    </div>
    <div v-else class="empty-state">
      <i class="fa-regular fa-folder-open text-3xl text-gray-300"></i>
      <p class="mt-2">当前没有AI任务</p>
      <p class="text-xs text-gray-400 mt-1">在编辑器中右键开始</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';
import AITaskItem from './AITaskItem.vue';

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
}>();

const aiTaskStore = useAITaskStore();
const tasks = computed(() => aiTaskStore.tasks);
const activeTasksCount = computed(() => aiTaskStore.activeTasksCount);

const handleTaskClick = (task: AITask) => {
  emit('select-task', task);
};

const handleRetry = (taskId: string) => {
  aiTaskStore.retryTask(taskId);
};

const handleApplyChanges = (taskId: string) => {
  emit('apply-changes', taskId);
}
</script>

<style scoped>
.task-queue-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; border-bottom: 1px solid #E5E7EB; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.badge { font-size: 0.75rem; font-weight: 500; padding: 0.125rem 0.5rem; border-radius: 9999px; color: #1D4ED8; background-color: #DBEAFE; }
.task-list { flex-grow: 1; overflow-y: auto; space-y: 0.5rem; padding-right: 4px; }
.empty-state { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
.task-list { scrollbar-width: thin; scrollbar-color: #D1D5DB #f9fafb; }
.task-list::-webkit-scrollbar { width: 6px; }
.task-list::-webkit-scrollbar-track { background: transparent; }
.task-list::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\EditorContextMenu.vue
//

// 文件: src/novel/editor/components/content/EditorContextMenu.vue

<template>
  <div
      v-if="visible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
  >
    <p class="menu-title">AI生成任务</p>
    <a @click="handleExecute('续写')" href="#" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>续写内容</span>
    </a>
    <a @click="handleExecute('润色')" href="#" class="context-menu-item">
      <i class="fa-solid fa-palette w-4 text-center text-[#3B82F6]"></i>
      <span>润色内容</span>
    </a>
    <div class="context-menu-divider"></div>
    <p class="menu-title">分析任务</p>
    <a @click="handleExecute('分析')" href="#" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>分析内容</span>
    </a>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ x: 0, y: 0 });

const show = (event: MouseEvent, container: HTMLElement | null) => {
  const containerRect = container?.getBoundingClientRect() || { top: 0, left: 0 };
  visible.value = true;
  position.value.x = event.clientX - containerRect.left;
  position.value.y = event.clientY - containerRect.top;
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type']) => {
  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu { position: absolute; z-index: 1000; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 0.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); width: 16rem; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s; text-decoration: none; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\EditorInstance.vue
//

// 文件: src/novel/editor/components/content/EditorInstance.vue

<template>
  <div class="editor-instance-container" :class="{'is-active-pane': isActive}" @click="setActivePane">
    <!-- Level 1: Tabs + Pane Actions -->
    <div class="top-header-bar">
      <div class="tabs-bar">
        <div
            v-for="tab in openTabs"
            :key="tab.id"
            class="tab-item"
            :class="{ 'active': tab.id === pane.activeTabId }"
            @click.stop="editorStore.openTab(tab.id, pane.id)"
        >
          <i :class="[tab.icon, 'tab-icon']"></i>
          <span class="tab-title">{{ tab.title }}</span>
          <i
              class="fa-solid fa-times close-icon"
              @click.stop="editorStore.closeTab(tab.id, pane.id)"
          ></i>
        </div>
      </div>
      <PaneActions :pane-id="pane.id" :is-active="isActive" />
    </div>

    <!-- Level 2: Breadcrumbs (only for document types) -->
    <BreadcrumbsBar v-if="activeTab && activeTab.item.type !== 'system'" :pane-id="pane.id" :is-active="isActive" />

    <!-- Main Content Area -->
    <PaneContentDispatcher
        ref="dispatcherRef"
        v-model="activeTabContent"
        :active-tab="activeTab"
        :is-active-pane="isActive"
        @show-context-menu="showEditorContextMenu"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, ref, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { EditorPane } from '@/novel/editor/stores/modules/paneStore';
import PaneActions from '../layout/PaneActions.vue';
import BreadcrumbsBar from '../layout/BreadcrumbsBar.vue';
import PaneContentDispatcher from './PaneContentDispatcher.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<EditorPane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  }
});

const editorStore = useEditorStore();
const dispatcherRef = ref<InstanceType<typeof PaneContentDispatcher> | null>(null);

const openTabs = computed(() => editorStore.getTabsForPane(props.pane.id));
const activeTab = computed(() => editorStore.getActiveTabForPane(props.pane.id));

const activeTabContent = computed({
  get: () => {
    const item = activeTab.value?.item;
    if (item && 'content' in item && typeof item.content === 'string') {
      return item.content;
    }
    return '';
  },
  set: (newContent: string) => {
    const item = activeTab.value?.item;
    if (activeTab.value && item && 'content' in item && props.isActive) {
      editorStore.updateItemContentById(activeTab.value.id, newContent);
    }
  }
});

const setActivePane = () => {
  editorStore.setActivePane(props.pane.id)
};

const showEditorContextMenu = (event: MouseEvent) => {
  dispatcherRef.value?.showContextMenu(event, dispatcherRef.value.$el);
};
</script>

<style scoped>
.editor-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  min-width: 0;
  transition: box-shadow 0.2s;
  border-left: 1px solid #E5E7EB;
}
.editor-instance-container:first-child {
  border-left: none;
}
.top-header-bar {
  display: flex;
  align-items: center;
  flex-shrink: 0;
  background-color: #F3F4F6;
  border-bottom: 1px solid #E5E7EB;
}
.tabs-bar {
  display: flex;
  flex-grow: 1;
  padding-top: 0.5rem;
  padding-left: 0.5rem;
  overflow-x: auto;
  min-width: 0;
}
.tabs-bar::-webkit-scrollbar {
  display: none;
}
.tabs-bar {
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.tab-item {
  display: flex;
  align-items: center;
  padding: 0.6rem 1rem;
  font-size: 0.875rem;
  color: #6B7280;
  cursor: pointer;
  position: relative;
  border: 1px solid transparent;
  border-bottom: none;
  border-top-left-radius: 0.5rem;
  border-top-right-radius: 0.5rem;
  background-color: #E5E7EB;
  white-space: nowrap;
  transition: background-color 0.2s, color 0.2s;
}
.tab-item:not(:first-child) {
  margin-left: -1px;
}
.is-active-pane .tab-item:hover {
  background-color: #FFFFFF;
}
.tab-item.active {
  background-color: #FFFFFF;
  color: #1F2937;
  border-color: #E5E7EB;
  z-index: 2;
  margin-bottom: -1px;
  padding-bottom: calc(0.6rem + 1px);
}
.editor-instance-container:not(.is-active-pane) .tab-item {
  background-color: #F3F4F6;
  color: #9CA3AF;
}
.editor-instance-container:not(.is-active-pane) .tab-item.active {
  background-color: #FFFFFF;
  color: #6B7280;
  border-color: #E5E7EB;
}
.tab-icon {
  margin-right: 0.5rem;
}
.tab-item.active .tab-icon {
  color: #3B82F6;
}
.editor-instance-container:not(.is-active-pane) .tab-item.active .tab-icon {
  color: inherit;
}
.tab-title {
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
}
.close-icon {
  margin-left: 0.75rem;
  padding: 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
  opacity: 0.5;
  transition: all 0.2s;
}
.tab-item:hover .close-icon {
  opacity: 1;
}
.close-icon:hover {
  background-color: #E5E7EB;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\FloatingToolbar.vue
//

// 文件: src/novel/editor/components/content/FloatingToolbar.vue

<template>
  <div
      v-if="visible"
      class="floating-toolbar"
      :style="{ top: `${position.top}px`, left: `${position.left}px` }"
      @mousedown.prevent
  >
    <button @click="handleExecute('分析', $event)" title="分析内容" class="toolbar-btn"><i class="fa-solid fa-magnifying-glass-chart"></i></button>
    <button @click="handleExecute('续写', $event)" title="AI续写" class="toolbar-btn"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
    <button @click="handleExecute('润色', $event)" title="润色文本" class="toolbar-btn"><i class="fa-solid fa-spell-check"></i></button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ top: 0, left: 0 });

const show = (rect: DOMRect, wrapperRect: DOMRect) => {
  visible.value = true;
  position.value = {
    top: rect.top - wrapperRect.top - 48,
    left: rect.left - wrapperRect.left + rect.width / 2 - 60,
  };
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type'], event: MouseEvent) => {
  event.preventDefault();

  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });
</script>

<style scoped>
.floating-toolbar {
  position: absolute;
  z-index: 10;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 0.375rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  display: flex;
  gap: 0.25rem;
}
.toolbar-btn {
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #4B5563;
  border-radius: 0.375rem;
  transition: background-color 0.15s;
}
.toolbar-btn:hover {
  background-color: #f3f4f6;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\MainPane.vue
//

<template>
  <div class="main-pane-container" ref="containerRef">
    <template v-for="(pane, index) in panes" :key="pane.id">
      <EditorInstance :pane="pane" :is-active="pane.id === editorStore.activePaneId" class="pane-instance" />
      <div
          v-if="index < panes.length - 1"
          class="pane-resizer"
          @mousedown.prevent="startResize($event, index)"
      ></div>
    </template>
  </div>
</template>
<script setup lang="ts">
import { computed, ref, watch, nextTick } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import EditorInstance from './EditorInstance.vue';

const editorStore = useEditorStore();
const panes = computed(() => editorStore.panes);
const containerRef = ref<HTMLElement | null>(null);

watch(() => panes.value.length, (newLength, oldLength) => {
  if (newLength < oldLength) {
    nextTick(() => {
      if (!containerRef.value) return;
      const remainingPanes = containerRef.value.querySelectorAll('.pane-instance') as NodeListOf<HTMLElement>;
      remainingPanes.forEach(el => {
        el.style.flex = '';
      });
    });
  }
});

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    const minWidth = 200;
    if (newLeftWidth < minWidth) {
      newLeftWidth = minWidth;
    }
    if (totalWidth - newLeftWidth < minWidth) {
      newLeftWidth = totalWidth - minWidth;
    }

    const newLeftBasis = (newLeftWidth / totalWidth) * 100;
    const newRightBasis = 100 - newLeftBasis;

    leftPane.style.flex = `0 0 ${newLeftBasis}%`;
    rightPane.style.flex = `0 0 ${newRightBasis}%`;
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = 'none';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};
</script>
<style scoped>
.main-pane-container {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  background-color: #F3F4F6;
}
.pane-instance {
  flex: 1 1 0;
  min-width: 200px;
}
.pane-resizer {
  width: 5px;
  background-color: transparent;
  cursor: col-resize;
  flex-shrink: 0;
  z-index: 5;
  position: relative;
  transition: background-color 0.2s ease;
}
.pane-resizer:hover {
  background-color: #3B82F6;
}
.pane-resizer::before {
  content: '';
  position: absolute;
  left: 2px;
  top: 0;
  width: 1px;
  height: 100%;
  background-color: #E5E7EB;
}
.pane-resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\PaneContentDispatcher.vue
//

// 文件: src/novel/editor/components/content/PaneContentDispatcher.vue

<template>
  <div class="pane-content-dispatcher">
    <template v-if="!activeTab">
      <div class="welcome-screen">
        <i class="fa-solid fa-feather-pointed text-6xl text-gray-300"></i>
        <h1 class="text-2xl font-medium text-gray-600 mt-6">星尘编辑器</h1>
        <p class="text-gray-500 mt-2">从左侧面板选择一个文件开始创作。</p>
      </div>
    </template>
    <template v-else-if="activeTab.item.type === 'system'">
      <component :is="systemViewComponent" :key="activeTab.id" :active-tab="activeTab" class="system-view-wrapper" />
    </template>
    <template v-else>
      <div class="content-area-wrapper" ref="wrapperRef" @scroll="handleScroll">
        <FloatingToolbar ref="floatingToolbarRef" />
        <EditorContextMenu ref="editorContextMenuRef" />
        <div class="editor-content-wrapper" ref="editorContentRef">
          <TiptapEditor
              :key="activeTab.id"
              :model-value="modelValue"
              :is-editable="!isCurrentTabReadOnly"
              @update:modelValue="emit('update:modelValue', $event)"
              @show-context-menu="emit('show-context-menu', $event)"
          />
        </div>
      </div>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onBeforeUnmount, shallowRef, type PropType } from 'vue';
import type { TabInfo, SystemViewInfo } from '@/novel/editor/types';
import TiptapEditor from './TiptapEditor.vue';
import FloatingToolbar from './FloatingToolbar.vue';
import EditorContextMenu from './EditorContextMenu.vue';
import SearchView from '@novel/editor/views/SearchView.vue';
import AIChatView from '@/novel/editor/components/ai/AIChatView.vue';
import AITaskPanel from '@/novel/editor/components/ai/AITaskPanel.vue';
import EditorSettings from '@/novel/editor/components/system/settings/EditorSettings.vue';
import ContextSettings from '@/novel/editor/components/system/settings/ContextSettings.vue';
import TaskSettings from '@/novel/editor/components/system/settings/TaskSettings.vue';
import AIConfigSettings from '@/novel/editor/components/system/settings/AIConfigSettings.vue';
import NovelSettings from '@/novel/editor/components/system/settings/NovelSettings.vue';
import ThemeSettings from '@/novel/editor/components/system/settings/ThemeSettings.vue';
import HistoryPanel from '@/novel/editor/components/system/HistoryPanel.vue';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    default: null
  },
  modelValue: {
    type: String,
    default: ''
  },
  isActivePane: {
    type: Boolean,
    required: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>();

const systemViewMap = shallowRef({
  SearchView,
  AIChatView,
  AITaskPanel,
  EditorSettings,
  ContextSettings,
  TaskSettings,
  AIConfigSettings,
  NovelSettings,
  ThemeSettings,
  HistoryPanel,
});

const systemViewComponent = computed(() => {
  const item = props.activeTab?.item;
  if (item?.type === 'system') {
    const componentName = item.component;
    return systemViewMap.value[componentName] || null;
  }
  return null;
});

const isCurrentTabReadOnly = computed(() => {
  const item = props.activeTab?.item;
  if (item && 'isReadOnly' in item) {
    return item.isReadOnly === true;
  }
  return false;
});

const wrapperRef = ref<HTMLElement | null>(null);
const editorContentRef = ref<HTMLElement | null>(null);
const floatingToolbarRef = ref<InstanceType<typeof FloatingToolbar> | null>(null);
const editorContextMenuRef = ref<InstanceType<typeof EditorContextMenu> | null>(null);

const showContextMenu = (event: MouseEvent, container: HTMLElement | null) => {
  editorContextMenuRef.value?.show(event, container);
};

const handleSelectionChange = () => {
  if (!props.isActivePane || !floatingToolbarRef.value || !wrapperRef.value || !editorContentRef.value) return;

  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed || !editorContentRef.value.contains(selection.getRangeAt(0).commonAncestorContainer)) {
    floatingToolbarRef.value.hide();
    return;
  }
  floatingToolbarRef.value.show(selection.getRangeAt(0).getBoundingClientRect(), wrapperRef.value.getBoundingClientRect());
  editorContextMenuRef.value?.hide();
};

const handleScroll = () => {
  floatingToolbarRef.value?.hide();
  editorContextMenuRef.value?.hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (!wrapperRef.value?.contains(event.target as Node)) return;
  const target = event.target as HTMLElement;
  if (!target.closest('.context-menu') && !target.closest('.floating-toolbar')) {
    editorContextMenuRef.value?.hide();
    floatingToolbarRef.value?.hide();
  }
};

onMounted(() => {
  document.addEventListener('selectionchange', handleSelectionChange);
  document.addEventListener('click', handleClickOutside, true);
});

onBeforeUnmount(() => {
  document.removeEventListener('selectionchange', handleSelectionChange);
  document.removeEventListener('click', handleClickOutside, true);
});

defineExpose({
  showContextMenu
});
</script>

<style scoped>
.pane-content-dispatcher {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
}
.system-view-wrapper {
  flex-grow: 1;
  overflow: hidden;
}
.content-area-wrapper {
  flex-grow: 1;
  overflow-y: auto;
  position: relative;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.content-area-wrapper::-webkit-scrollbar {
  display: none;
}
.editor-content-wrapper {
  max-width: 42rem;
  margin: 2rem auto;
}
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\TiptapEditor.vue
//

<template>
  <div v-if="editor" class="editor-wrapper">
    <editor-content
        :editor="editor"
        class="prose prose-lg max-w-none"
        @contextmenu.prevent="emit('show-context-menu', $event)"
    />
  </div>
</template>
<script setup lang="ts">
import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { watch, onBeforeUnmount } from 'vue'

const props = defineProps({
  modelValue: {
    type: String,
    required: true,
  },
  isEditable: {
    type: Boolean,
    default: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>()

const editor = useEditor({
  content: props.modelValue,
  editable: props.isEditable,
  extensions: [
    StarterKit.configure({
      heading: { levels: [1, 2, 3] },
    }),
  ],
  onUpdate: () => {
    if (editor.value?.isEditable) {
      emit('update:modelValue', editor.value?.getHTML() || '')
    }
  },
  editorProps: {
    attributes: {
      class: 'prose-mirror-focus',
    },
  },
})

watch(() => props.modelValue, (newValue) => {
  const isSame = editor.value?.getHTML() === newValue
  if (isSame) {
    return
  }
  editor.value?.commands.setContent(newValue, false)
})

watch(() => props.isEditable, (value) => {
  editor.value?.setEditable(value);
});

onBeforeUnmount(() => {
  editor.value?.destroy()
})
</script>
<style scoped>
:deep(.ProseMirror) {
  min-height: calc(100vh - 12rem);
  outline: none;
  padding: 1rem;
  font-family: 'Georgia', 'Noto Serif SC', serif;
  line-height: 1.75;
  color: #374151;
}

:deep(.ProseMirror[contenteditable="false"]) {
  cursor: default;
}

:deep(.prose-mirror-focus:focus-visible) {}

:deep(.prose h1) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.875rem;
  font-weight: 600;
  margin-bottom: 2.5rem;
  text-align: center;
  border-bottom: none;
}
:deep(.prose p) {
  margin-top: 1em;
  margin-bottom: 1em;
}
:deep(.prose h2) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.5rem; /* 24px */
  font-weight: 600;
  padding-bottom: 0;
  border-bottom: none;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
}
:deep(.prose h3) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.25rem;
  font-weight: 600;
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
}
:deep(.prose hr) {
  border-top: 1px solid #e5e7eb;
  margin: 3rem 0;
}
:deep(.prose p.overview-placeholder) {
  text-align: center;
  color: #9ca3af;
  font-style: italic;
  margin-top: 2rem;
  border: 1px dashed #e5e7eb;
  padding: 2rem;
  border-radius: 0.5rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
  line-height: 1.6;
}
</style>

// =
// 文件: ..\src\novel\editor\components\modals\ContextPreviewModal.vue
//

<template>
  <div v-if="store.isVisible" class="modal-overlay">
    <div class="modal-container">
      <!-- Modal Header -->
      <header class="modal-header">
        <div>
          <h2 class="modal-title">AI 任务确认</h2>
          <p v-if="store.task" class="modal-subtitle">即将为 <span class="font-semibold text-gray-700">《{{ store.task.title }}》</span> 执行 <span class="font-semibold text-gray-700">【{{ store.task.type }}】</span> 任务</p>
        </div>
        <button @click="store.hide()" class="modal-close-button">
          <i class="fa-solid fa-times"></i>
        </button>
      </header>

      <!-- Loading State -->
      <div v-if="store.isLoading" class="modal-loading-state">
        <i class="fa-solid fa-spinner fa-spin text-3xl text-gray-400"></i>
        <p class="mt-4 text-gray-500">正在构建上下文...</p>
      </div>

      <!-- Content State with Collapsible Panels -->
      <div v-else-if="store.previewContent" class="modal-content-wrapper">
        <div v-for="panel in panels" :key="panel.id" class="result-group">
          <div @click="toggleExpansion(panel.id)" class="result-header">
            <div class="flex items-center gap-3 min-w-0">
              <i class="fa-solid fa-chevron-right expand-icon" :class="{ 'expanded': expandedPanelIds.has(panel.id) }"></i>
              <span class="font-medium truncate">{{ panel.name }}</span>
            </div>
            <span class="match-count">{{ formatCharCount(store.previewContent.stats[panel.statKey]) }}</span>
          </div>
          <div v-show="expandedPanelIds.has(panel.id)" class="match-list-style-body">
            <div v-if="panel.id === 'prompt'">
              <pre class="prompt-preview">{{ store.previewContent.prompt }}</pre>
            </div>
            <div v-else class="prose prose-sm max-w-none" v-html="store.previewContent[panel.id] || emptyStateHtml(panel.name)"></div>
          </div>
        </div>
      </div>

      <!-- Modal Footer -->
      <footer class="modal-footer">
        <div v-if="store.previewContent" class="stats-summary">
          总计上下文: {{ totalCharCount }} 字
        </div>
        <button @click="store.hide()" class="button-secondary">取消</button>
        <button @click="store.execute()" :disabled="store.isLoading" class="button-primary">
          <i v-if="store.isLoading" class="fa-solid fa-spinner fa-spin mr-2"></i>
          确认执行
        </button>
      </footer>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { ContextBuildResult } from '@/novel/editor/types';

type PanelId = 'fixed' | 'dynamic' | 'rag' | 'prompt';

const store = useContextPreviewStore();
const expandedPanelIds = ref(new Set<PanelId>());

const panels = ref([
  { id: 'fixed', name: '固定上下文', statKey: 'fixedCharCount' },
  { id: 'dynamic', name: '动态上下文', statKey: 'dynamicCharCount' },
  { id: 'rag', name: 'RAG检索', statKey: 'ragCharCount' },
  { id: 'prompt', name: '最终提示词', statKey: 'promptCharCount' },
] as const);

watch(() => store.previewContent, (newContent) => {
  if (newContent) {
    // Default expand 'fixed' panel only.
    expandedPanelIds.value.clear();
    expandedPanelIds.value.add('fixed');
  }
}, { immediate: true });


const toggleExpansion = (panelId: PanelId) => {
  if (expandedPanelIds.value.has(panelId)) {
    expandedPanelIds.value.delete(panelId);
  } else {
    expandedPanelIds.value.add(panelId);
  }
};

const formatCharCount = (count: number) => {
  if (count > 1000) return `${(count / 1000).toFixed(1)}k`;
  return count;
};

const totalCharCount = computed(() => {
  if (!store.previewContent?.stats) return 0;
  const { fixedCharCount, dynamicCharCount, ragCharCount } = store.previewContent.stats;
  const total = fixedCharCount + dynamicCharCount + ragCharCount;
  return formatCharCount(total);
});

const emptyStateHtml = (contextType: string) => {
  return `<p class="text-gray-400 italic p-4">未配置或未找到${contextType}内容。</p>`;
};
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(17, 24, 39, 0.6);
  backdrop-filter: blur(4px);
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
}

.modal-container {
  background-color: white;
  border-radius: 0.75rem;
  box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  width: 60vw;
  height: 85vh;
  max-width: 960px;
  max-height: 800px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.modal-header {
  padding: 1rem 1.5rem;
  border-bottom: 1px solid #e5e7eb;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  flex-shrink: 0;
}

.modal-title { font-size: 1.125rem; font-weight: 600; color: #111827; }
.modal-subtitle { font-size: 0.875rem; color: #6b7280; margin-top: 0.25rem; }
.modal-subtitle .font-semibold { color: #4B5563; }
.modal-close-button { color: #9ca3af; padding: 0.5rem; margin: -0.5rem; border-radius: 9999px; transition: background-color 0.2s, color 0.2s; }
.modal-close-button:hover { background-color: #f3f4f6; color: #1f2937; }

.modal-loading-state {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 4rem 1rem;
}

.modal-content-wrapper {
  flex-grow: 1;
  overflow-y: auto;
  padding: 1rem 1.5rem;
  background-color: #FFFFFF;
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}
.modal-content-wrapper::-webkit-scrollbar {
  display: none; /* Chrome, Safari, and Opera */
}

.result-group { margin-bottom: 0.75rem; }
.result-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; background-color: #F9FAFB; transition: background-color 0.2s; }
.result-header:hover { background-color: #F3F4F6; }
.expand-icon { transition: transform 0.2s ease; color: #9CA3AF; }
.expand-icon.expanded { transform: rotate(90deg); }
.match-count { margin-left: auto; font-size: 0.75rem; background-color: #E5E7EB; color: #4B5563; padding: 0.125rem 0.5rem; border-radius: 99px; flex-shrink: 0; }
.match-list-style-body { padding-left: 2rem; margin-top: 0.5rem; border-left: 1px solid #F3F4F6; margin-left: 0.9rem; padding-bottom: 0.5rem; }

.prompt-preview {
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: inherit;
  font-size: 0.875rem;
  color: #374151;
  line-height: 1.6;
  padding-top: 0.5rem;
}
.prose {
  margin-top: 0.75rem;
  padding-left: 0.5rem;
}

.modal-footer {
  padding: 1rem 1.5rem;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  gap: 0.75rem;
  background-color: #f9fafb;
  flex-shrink: 0;
}
.stats-summary { margin-right: auto; font-size: 0.875rem; color: #6b7280; }
.button-secondary { padding: 0.5rem 1rem; background-color: white; border: 1px solid #d1d5db; border-radius: 0.5rem; font-weight: 500; color: #374151; transition: background-color 0.2s; }
.button-secondary:hover { background-color: #f9fafb; }

.button-primary {
  padding: 0.5rem 1rem;
  background-color: #4B5563;
  border: 1px solid transparent;
  border-radius: 0.5rem;
  font-weight: 500;
  color: white;
  transition: background-color 0.2s;
  display: flex;
  align-items: center;
}
.button-primary:hover {
  background-color: #374151;
}
.button-primary:disabled {
  background-color: #9CA3AF;
  cursor: not-allowed;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryContextMenu.vue
//

// src/novel/editor/components/sidebar/DirectoryContextMenu.vue
<template>
  <div
      v-if="visible && menuComponent"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
  >
    <component
        :is="menuComponent"
        :node="node!"
        @action="handleAction"
        @ai-action="handleAIAction"
        @settings-action="handleSettingsAction"
        @custom-related-action="handleCustomRelatedAction"
        @custom-others-action="handleOthersAction"
        @note-action="handleNoteAction"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, computed, defineAsyncComponent, shallowRef } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import type { AITask } from '@/novel/editor/types';

// --- 组件映射 ---
const menuComponentMap = shallowRef({
  'volume': defineAsyncComponent(() => import('./context-menus/VolumeMenu.vue')),
  'chapter': defineAsyncComponent(() => import('./context-menus/ChapterMenu.vue')),
  'group': defineAsyncComponent(() => import('./context-menus/GroupMenu.vue')),
  'item': defineAsyncComponent(() => import('./context-menus/ItemMenu.vue')),
  'root': defineAsyncComponent(() => import('./context-menus/RootMenu.vue')),
  'others': defineAsyncComponent(() => import('./context-menus/OthersMenu.vue')),
  'others_item': defineAsyncComponent(() => import('./context-menus/OthersItemMenu.vue')),
  'custom_related': defineAsyncComponent(() => import('./context-menus/CustomRelatedMenu.vue')),
  'note': defineAsyncComponent(() => import('./context-menus/NoteMenu.vue')),
  'setting_root': defineAsyncComponent(() => import('./context-menus/SettingsRootMenu.vue')),
});

// --- State and Props ---
const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const node = ref<TreeNode | null>(null);

// --- Stores and Composables ---
const { executeAITask } = useAITaskExecutor();
const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const relatedContentStore = useRelatedContentStore();
const notesStore = useNotesStore();

// --- Computed ---
const menuComponent = computed(() => {
  if (!node.value) return null;
  const { type, id } = node.value;

  // Handle custom item types first by ID prefix
  if (id.startsWith('custom-others-')) {
    return menuComponentMap.value['others_item'];
  }
  if (id.startsWith('custom-') && !id.startsWith('custom-others-')) {
    return menuComponentMap.value['custom_related'];
  }

  // Handle root nodes by ID
  if (type === 'root') {
    if (id === 'setting') {
      return menuComponentMap.value['setting_root'];
    }
    if (id === 'plot' || id === 'analysis') {
      return menuComponentMap.value['root'];
    }
    if (id === 'others') {
      return menuComponentMap.value['others'];
    }
    return null;
  }

  // Handle specific node types by their 'type' property
  if (type in menuComponentMap.value) {
    return menuComponentMap.value[type];
  }

  // Fallback for settings items (e.g., character_item)
  if (type.endsWith('_item')) {
    return menuComponentMap.value['item'];
  }

  return null;
});

// --- Core Logic ---
const show = (event: MouseEvent, targetNode: TreeNode) => {
  if (targetNode.isReadOnly || targetNode.type.endsWith('_overview')) {
    return;
  }
  node.value = targetNode;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  node.value = null;
};

// --- Event Handlers ---
const handleAIAction = (taskType: AITask['type'], sourceNode: TreeNode, isBatch = false) => {
  hide();
  if (isBatch && sourceNode.type === 'volume' && 'originalData' in sourceNode && sourceNode.originalData.type === 'volume') {
    const aiTaskStore = (async () => (await import('@novel/editor/stores/ai/aiTaskStore.ts')).useAITaskStore())();
    aiTaskStore.then(store => store.startBatchTaskForVolume(taskType, sourceNode.originalData));
  } else {
    executeAITask(taskType, { id: sourceNode.id, title: sourceNode.title });
  }
};

const handleAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newChapter': directoryStore.addChapterToVolume(nodeId); break;
    case 'newVolume': directoryStore.addNewVolume(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': directoryStore.deleteNode(nodeId); break;
  }
};

const handleSettingsAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newGroup': relatedContentStore.addRelatedNode(nodeId, 'group'); break;
    case 'newItem': relatedContentStore.addRelatedNode(nodeId, 'item'); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteRelatedNode(nodeId); break;
  }
};

const handleCustomRelatedAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  const target = payload?.target as 'plot' | 'analysis' | undefined;

  switch(action) {
    case 'newItem':
      if (target) {
        relatedContentStore.addCustomRelatedNode(target);
      }
      break;
    case 'rename':
      editorStore.setEditingNodeId(nodeId);
      break;
    case 'delete':
      relatedContentStore.deleteCustomRelatedNode(nodeId);
      break;
  }
};

const handleOthersAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch(action) {
    case 'newItem': relatedContentStore.addCustomOthersNode(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteCustomOthersNode(nodeId); break;
  }
};

const handleNoteAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': notesStore.deleteNote(nodeId); break;
  }
};

// --- Lifecycle ---
onMounted(() => {
  window.addEventListener('click', hide);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', hide);
});

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryTab.vue
//

// src/novel/editor/components/sidebar/DirectoryTab.vue

<template>
  <div class="directory-tab-container">
    <div class="header">
      <h3 class="title">章节大纲</h3>
      <div class="actions">
        <button @click="handleAddNewVolume" class="action-btn" title="添加新卷">
          <i class="fa-solid fa-folder-plus fa-xs"></i>
        </button>
        <button class="action-btn" title="折叠/展开全部">
          <i class="fa-solid fa-folder-tree fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="scrollable-content">
      <TreeView
          v-if="directoryTree.length > 0"
          :nodes="directoryTree"
          :active-node-id="activeNodeId"
          :expanded-node-ids="uiStore.uiState.expandedNodeIds"
          :editing-node-id="editorStore.editingNodeId"
          @select-node="handleSelectNode"
          @toggle-expansion="handleToggleExpansion"
          @context-menu="handleContextMenu"
          @commit-rename="handleCommitRename"
          @cancel-rename="handleCancelRename"
      />
      <div v-else class="p-4 text-sm text-gray-500">
        正在加载目录...
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import type { TreeNode, VolumeNode, ChapterNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const directoryTree = computed((): VolumeNode[] => {
  return directoryStore.directoryData.map(volume => ({
    id: volume.id,
    title: volume.title,
    icon: getIconByNodeType(volume.type),
    type: 'volume',
    content: volume.content, // 直接暴露 content
    originalData: volume,
    children: volume.chapters.map(chapter => ({
      id: chapter.id,
      title: chapter.title,
      icon: getIconByNodeType(chapter.type),
      type: 'chapter',
      status: chapter.status,
      content: chapter.content, // 直接暴露 content
      originalData: chapter,
    })),
  }));
});

const handleSelectNode = (node: TreeNode) => {
  // 明确判断，卷和章节都可以被打开编辑
  if (node.type === 'chapter' || node.type === 'volume') {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    // 对于其他有子节点的节点（理论上这里不会走到），作为备用逻辑
    uiStore.toggleNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id:string) => {
  uiStore.toggleNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleAddNewVolume = () => {
  directoryStore.addNewVolume();
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  directoryStore.renameNode(payload.nodeId, payload.newTitle);
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};
</script>
<style scoped>
.directory-tab-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
.header {
  padding: 1rem;
  padding-bottom: 0.25rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }

.scrollable-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 0.75rem 1rem 1rem;
}
.scrollable-content::-webkit-scrollbar { width: 6px; }
.scrollable-content::-webkit-scrollbar-track { background: transparent; }
.scrollable-content::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
.scrollable-content::-webkit-scrollbar-thumb:hover { background: #9CA3AF; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\NotesTab.vue
//

// 文件: src\novel\editor\components\sidebar\NotesTab.vue

<template>
  <div class="notes-tab-container">
    <div class="header">
      <h3 class="title">章节笔记</h3>
      <button @click="handleAddNewNote" class="action-btn" title="新建笔记"><i class="fa-solid fa-plus fa-xs"></i></button>
    </div>
    <div class="notes-list">
      <div
          v-for="(note, index) in notesStore.notes"
          :key="note.id"
          @click="editorStore.openTab(note.id)"
          @contextmenu.prevent="handleContextMenu(note, $event)"
          class="note-item"
          :class="{ 'active': activeTabId === note.id }"
      >
        <div class="note-header">
          <template v-if="editingNodeId === note.id">
            <input
                :ref="el => { if (el) renameInputs[index] = el as HTMLInputElement }"
                type="text"
                :value="note.title"
                class="rename-input"
                @blur="handleCommitRename($event, note.id)"
                @keydown.enter.prevent="handleCommitRename($event, note.id)"
                @keydown.esc.prevent="handleCancelRename"
                @click.stop
            />
          </template>
          <template v-else>
            <p class="note-title">{{ note.title }}</p>
          </template>
          <span class="note-timestamp">{{ note.timestamp }}</span>
        </div>
        <p class="note-content">{{ note.content.replace(/<[^>]+>/g, '') }}</p>
      </div>
    </div>
    <div class="quick-add-footer">
      <input
          type="text"
          placeholder="快速添加新笔记..."
          class="quick-add-input"
          v-model="quickAddValue"
          @keydown.enter="handleQuickAdd"
      >
      <button @click="handleQuickAdd" class="quick-add-btn"><i class="fa-solid fa-paper-plane fa-sm"></i></button>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, watch, nextTick, onBeforeUpdate } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { NoteItem } from '@/novel/editor/types';
import type { TreeNode } from './TreeView.vue';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const notesStore = useNotesStore();
const uiStore = useUIStore();
const quickAddValue = ref('');
const renameInputs = ref<HTMLInputElement[]>([]);

const editingNodeId = computed(() => uiStore.editingNodeId);
const activeTabId = computed(() => editorStore.activeTabId);


watch(editingNodeId, (newId) => {
  if (newId && newId.startsWith('note-')) {
    nextTick(() => {
      const noteIndex = notesStore.notes.findIndex(n => n.id === newId);
      if (noteIndex !== -1 && renameInputs.value[noteIndex]) {
        renameInputs.value[noteIndex].focus();
        renameInputs.value[noteIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const handleAddNewNote = () => {
  notesStore.addNote('新建笔记');
};

const handleQuickAdd = () => {
  const value = quickAddValue.value.trim();
  if (!value) return;
  notesStore.addNote(value);
  quickAddValue.value = '';
};

const handleContextMenu = (note: NoteItem, event: MouseEvent) => {
  const nodePayload: TreeNode = {
    id: note.id,
    title: note.title,
    type: note.type,
    icon: getIconByNodeType(note.type),
    originalData: note
  };
  emit('show-context-menu', { node: nodePayload, event });
}

const handleCommitRename = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value.trim();
  if(newTitle) {
    notesStore.renameNote(nodeId, newTitle);
  }
  handleCancelRename();
};

const handleCancelRename = () => {
  uiStore.setEditingNodeId(null);
};
</script>
<style scoped>
.notes-tab-container {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
  padding: 0 0.5rem;
  flex-shrink: 0;
}
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }

.notes-list {
  flex-grow: 1;
  overflow-y: auto;
  space-y: 0.5rem;
  padding-right: 4px;
}
.notes-list::-webkit-scrollbar { width: 6px; }
.notes-list::-webkit-scrollbar-track { background: transparent; }
.notes-list::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }

.note-item { padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; background-color: #FFFFFF; }
.note-item:hover { background-color: #F9FAFB; border-color: #F3F4F6; }
.note-item.active { background-color: #FEFCE8; border-color: #FDE047; }
.note-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5rem; }
.note-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.note-timestamp { font-size: 0.75rem; color: #CA8A04; flex-shrink: 0; }
.note-content { font-size: 0.75rem; color: #4B5563; margin-top: 0.375rem; line-height: 1.6; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; }
.rename-input {
  flex-grow: 1;
  background-color: white;
  border: 1px solid #3B82F6;
  border-radius: 4px;
  padding: 1px 4px;
  font-size: 0.875rem;
  color: #1F2937;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}
.quick-add-footer {
  margin-top: auto;
  padding-top: 0.75rem;
  border-top: 1px solid #E5E7EB;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.quick-add-input {
  flex-grow: 1;
  background: white;
  border: 1px solid #D1D5DB;
  border-radius: 0.5rem;
  padding: 0.4rem 0.75rem;
  font-size: 0.875rem;
  outline: none;
  transition: all 0.2s;
}
.quick-add-input:focus {
  border-color: #3B82F6;
  box-shadow: 0 0 0 1px #3B82F6;
}
.quick-add-btn {
  width: 2.2rem;
  height: 2.2rem;
  flex-shrink: 0;
  background-color: #F3F4F6;
  border-radius: 0.5rem;
  color: #4B5563;
  transition: background-color 0.2s;
}
.quick-add-btn:hover {
  background-color: #E5E7EB;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\RelatedTab.vue
//

// src/novel/editor/components/sidebar/RelatedTab.vue
<template>
  <div class="related-tab-container">
    <div class="header">
      <h3 class="title">相关内容</h3>
      <div class="actions">
        <button @click="handleAddNewCustomPlot" class="action-btn" title="新建自定义剧情">
          <i class="fa-solid fa-feather-pointed fa-xs"></i>
        </button>
        <button @click="handleAddNewCustomAnalysis" class="action-btn" title="新建自定义分析">
          <i class="fa-solid fa-magnifying-glass-chart fa-xs"></i>
        </button>
        <button @click="handleAddNewCustomOthers" class="action-btn" title="新建其他条目">
          <i class="fa-solid fa-puzzle-piece fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="search-bar">
      <i class="fa-solid fa-magnifying-glass search-icon"></i>
      <input type="text" placeholder="搜索相关内容..." class="search-input">
    </div>
    <TreeView
        v-if="relatedTree.length > 0"
        :nodes="relatedTree"
        :active-node-id="activeNodeId"
        :expanded-node-ids="uiStore.uiState.expandedRelatedNodeIds"
        :editing-node-id="editorStore.editingNodeId"
        @select-node="handleSelectNode"
        @toggle-expansion="handleToggleExpansion"
        @context-menu="handleContextMenu"
        @commit-rename="handleCommitRename"
        @cancel-rename="handleCancelRename"
    />
    <div v-else class="p-4 text-sm text-gray-500">
      没有相关内容。
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const relatedContentStore = useRelatedContentStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const relatedTree = computed((): TreeNode[] => {
  return relatedContentStore.relatedData;
});

const handleSelectNode = (node: TreeNode) => {
  // 只有在节点有内容时才打开tab，否则切换展开状态
  if ('content' in node && node.content !== undefined) {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    uiStore.toggleRelatedNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id: string) => {
  uiStore.toggleRelatedNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  if (payload.nodeId.startsWith('custom-others-')) {
    relatedContentStore.renameCustomOthersNode(payload.nodeId, payload.newTitle);
  } else if (payload.nodeId.startsWith('custom-')) {
    relatedContentStore.renameCustomRelatedNode(payload.nodeId, payload.newTitle);
  } else {
    relatedContentStore.renameRelatedNode(payload.nodeId, payload.newTitle);
  }
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};

const handleAddNewCustomPlot = () => {
  relatedContentStore.addCustomRelatedNode('plot');
};

const handleAddNewCustomAnalysis = () => {
  relatedContentStore.addCustomRelatedNode('analysis');
};

const handleAddNewCustomOthers = () => {
  relatedContentStore.addCustomOthersNode();
};

</script>
<style scoped>
.related-tab-container { padding: 1rem; overflow-y: auto; height: 100%; display: flex; flex-direction: column; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }
.search-bar { position: relative; margin-bottom: 1rem; flex-shrink: 0; }
.search-icon { position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; font-size: 0.875rem; }
.search-input { width: 100%; background: white; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.4rem 0.75rem 0.4rem 2.25rem; font-size: 0.875rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\SidebarPanel.vue
//

<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <h3 class="title">{{ activeTitle }}</h3>
    </div>

    <div class="content-container">
      <keep-alive>
        <component :is="activeTabComponent" @show-context-menu="showDirectoryContextMenu" />
      </keep-alive>
    </div>

    <DirectoryContextMenu ref="directoryContextMenuRef" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineAsyncComponent } from 'vue';
import DirectoryContextMenu from './DirectoryContextMenu.vue';
import type { TreeNode } from './TreeView.vue';

type TabId = 'directory' | 'related' | 'notes';

const props = defineProps<{
  activeTabId: TabId | null;
}>();

const directoryContextMenuRef = ref<InstanceType<typeof DirectoryContextMenu> | null>(null);

const titles: Record<TabId, string> = {
  directory: '目录大纲',
  related: '相关内容',
  notes: '章节笔记',
};

const tabComponents: Record<TabId, any> = {
  directory: defineAsyncComponent(() => import('./DirectoryTab.vue')),
  related: defineAsyncComponent(() => import('./RelatedTab.vue')),
  notes: defineAsyncComponent(() => import('./NotesTab.vue')),
};

const activeTabComponent = computed(() => {
  if (!props.activeTabId) return null;
  return tabComponents[props.activeTabId] || null;
});

const activeTitle = computed(() => {
  if (!props.activeTabId) return '';
  return titles[props.activeTabId] || '';
});

const showDirectoryContextMenu = (payload: { node: TreeNode, event: MouseEvent }) => {
  directoryContextMenuRef.value?.show(payload.event, payload.node);
};
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  border-right: 1px solid #F3F4F6;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F3F4F6;
  flex-shrink: 0;
}

.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}

.content-container {
  flex-grow: 1;
  position: relative;
  overflow: hidden;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\TreeView.vue
//

// 文件: src/novel/editor/components/sidebar/TreeView.vue

<template>
  <ul class="tree-view-list">
    <li v-for="node in nodes" :key="node.id" class="tree-view-item">
      <!-- 节点自身的渲染 -->
      <div
          class="node-content"
          :class="{ 'active': node.id === activeNodeId }"
          @click="handleNodeClick(node)"
          @contextmenu.prevent="emit('context-menu', { node, event: $event })"
      >
        <!-- 展开/折叠图标 -->
        <div
            class="expand-icon"
            :class="{ 'invisible': !node.children || node.children.length === 0 }"
            @click.stop="emit('toggle-expansion', node.id)"
        >
          <i class="fa-solid fa-chevron-right transition-transform" :class="{ 'rotate-90': expandedNodeIds.has(node.id) }"></i>
        </div>

        <!-- 节点类型图标 -->
        <div class="node-type-icon">
          <i :class="node.icon"></i>
        </div>

        <!-- 节点标题或重命名输入框 -->
        <template v-if="editingNodeId === node.id">
          <input
              ref="renameInput"
              type="text"
              :value="node.title"
              class="rename-input"
              @blur="handleRenameCommit($event, node.id)"
              @keydown.enter.prevent="handleRenameCommit($event, node.id)"
              @keydown.esc.prevent="handleRenameCancel"
              @click.stop
          />
        </template>
        <template v-else>
          <span class="node-title truncate">{{ node.title }}</span>
        </template>

        <!-- 节点状态徽章 (可选) -->
        <span v-if="'status' in node && node.status" class="node-status-badge">
          {{ node.status === 'editing' ? '编辑中' : '' }}
        </span>
      </div>

      <!-- 递归渲染子节点 -->
      <div v-if="node.children && node.children.length > 0" class="children-container">
        <TreeView
            v-show="expandedNodeIds.has(node.id)"
            :nodes="node.children"
            :active-node-id="activeNodeId"
            :expanded-node-ids="expandedNodeIds"
            :editing-node-id="editingNodeId"
            @select-node="emit('select-node', $event)"
            @toggle-expansion="emit('toggle-expansion', $event)"
            @context-menu="emit('context-menu', $event)"
            @commit-rename="emit('commit-rename', $event)"
            @cancel-rename="emit('cancel-rename')"
        />
      </div>
    </li>
  </ul>
</template>

<script setup lang="ts">
import { ref, watch, nextTick } from 'vue';
import type { PropType } from 'vue';
import type { TreeNode } from '@novel/editor/types';

// --- Props & Emits ---
const props = defineProps({
  nodes: {
    type: Array as PropType<TreeNode[]>,
    required: true,
  },
  activeNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
  expandedNodeIds: {
    type: Set as PropType<Set<string>>,
    required: true,
  },
  editingNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
});

const emit = defineEmits<{
  (e: 'select-node', node: TreeNode): void;
  (e: 'toggle-expansion', id: string): void;
  (e: 'context-menu', payload: { node: TreeNode, event: MouseEvent }): void;
  (e: 'commit-rename', payload: { nodeId: string, newTitle: string }): void;
  (e: 'cancel-rename'): void;
}>();

const renameInput = ref<HTMLInputElement[] | null>(null);

watch(() => props.editingNodeId, (newId, oldId) => {
  if (newId && newId !== oldId) {
    nextTick(() => {
      if (renameInput.value && renameInput.value.length > 0) {
        renameInput.value[0].focus();
        renameInput.value[0].select();
      }
    });
  }
});

const handleNodeClick = (node: TreeNode) => {
  if (props.editingNodeId === node.id) return;
  emit('select-node', node);
};

const handleRenameCommit = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value;
  emit('commit-rename', { nodeId, newTitle });
};

const handleRenameCancel = () => {
  emit('cancel-rename');
};

</script>

<style scoped>
.tree-view-list {
  list-style: none;
  padding: 0;
  margin: 0;
  width: 100%;
}
.node-content {
  display: flex;
  align-items: center;
  gap: 0.5rem; /* 8px */
  padding: 0.5rem 0.75rem; /* 8px 12px */
  border-radius: 0.5rem; /* 8px */
  cursor: pointer;
  transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
  font-size: 0.875rem; /* 14px */
  color: #374151; /* text-gray-700 */
  user-select: none;
}
.node-content:hover {
  background-color: #F3F4F6; /* hover:bg-gray-100 */
}
.node-content.active {
  background-color: #E0E7FF; /* bg-indigo-100 */
  color: #3730A3; /* text-indigo-800 */
  font-weight: 500;
}
.expand-icon {
  width: 1rem; /* 16px */
  height: 1rem; /* 16px */
  display: flex;
  align-items: center;
  justify-content: center;
  color: #9CA3AF; /* text-gray-400 */
  flex-shrink: 0;
}
.expand-icon.invisible {
  visibility: hidden;
}
.node-type-icon {
  width: 1.25rem; /* 20px */
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6B7280; /* text-gray-500 */
}
.node-content.active .node-type-icon {
  color: #4338CA; /* active:text-indigo-700 */
}
.node-title {
  flex-grow: 1;
}
.node-status-badge {
  margin-left: auto;
  font-size: 0.75rem; /* 12px */
  padding: 0.125rem 0.5rem; /* 2px 8px */
  background-color: #DCFCE7; /* bg-green-100 */
  color: #166534; /* text-green-800 */
  border-radius: 9999px;
  font-weight: 500;
}
.children-container {
  padding-left: 1.5rem;
  margin-left: 0.5rem;
  border-left: 1px solid #E5E7EB;
}
.rename-input {
  flex-grow: 1;
  background-color: white;
  border: 1px solid #3B82F6;
  border-radius: 4px;
  padding: 1px 4px;
  font-size: 0.875rem;
  color: #1F2937;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ChapterMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/ChapterMenu.vue
<template>
  <div>
    <p class="menu-title">文件操作</p>
    <div @click="emit('action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div class="context-menu-divider"></div>
    <p class="menu-title">AI 助手</p>
    <div @click="emit('ai-action', '分析', node)" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>分析内容</span>
    </div>
    <div @click="emit('ai-action', '剧情生成', node)" class="context-menu-item">
      <i class="fa-solid fa-feather w-4 text-center text-[#EC4899]"></i>
      <span>生成剧情</span>
    </div>
    <div @click="emit('ai-action', '创作', node)" class="context-menu-item">
      <i class="fa-solid fa-pen-nib w-4 text-center text-violet-500"></i>
      <span>创作正文</span>
    </div>
    <div @click="emit('ai-action', '续写', node)" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>续写内容</span>
    </div>
    <div @click="emit('ai-action', '润色', node)" class="context-menu-item">
      <i class="fa-solid fa-palette w-4 text-center text-[#3B82F6]"></i>
      <span>润色内容</span>
    </div>
    <div class="context-menu-divider"></div>
    <div @click="emit('action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除章节</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch?: boolean): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\CustomRelatedMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/CustomRelatedMenu.vue
<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('custom-related-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('custom-related-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\GroupMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/GroupMenu.vue
<template>
  <div>
    <p class="menu-title">设定管理</p>
    <div @click="emit('settings-action', 'newItem', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建条目</span>
    </div>
    <div @click="emit('settings-action', 'newGroup', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建分组</span>
    </div>
    <div @click="emit('settings-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('settings-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除分组</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ItemMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/ItemMenu.vue
<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('settings-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('settings-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\NoteMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/NoteMenu.vue
<template>
  <div>
    <p class="menu-title">笔记管理</p>
    <div @click="emit('note-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('note-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除笔记</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'note-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersItemMenu.vue
//

<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('custom-others-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('custom-others-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersMenu.vue
//

<template>
  <div>
    <p class="menu-title">管理</p>
    <div @click="emit('custom-others-action', 'newItem')" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建其他条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\RootMenu.vue
//


<template>
  <div>
    <p class="menu-title">管理</p>
    <div @click="emit('custom-related-action', 'newItem', { target: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建自定义{{ node.id === 'plot' ? '剧情' : '分析' }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\SettingsRootMenu.vue
//

// src/novel/editor/components/sidebar/context-menus/SettingsRootMenu.vue
<template>
  <div>
    <p class="menu-title">设定管理</p>
    <div @click="emit('settings-action', 'newGroup', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建分组</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\VolumeMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/VolumeMenu.vue
<template>
  <div>
    <p class="menu-title">目录管理</p>
    <div @click="emit('action', 'newChapter', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建章节</span>
    </div>
    <div @click="emit('action', 'newVolume')" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建卷</span>
    </div>
    <div @click="emit('action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div class="context-menu-divider"></div>
    <p class="menu-title">AI 批量任务</p>
    <div @click="emit('ai-action', '分析', node, true)" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>批量分析章节</span>
    </div>
    <div @click="emit('ai-action', '剧情生成', node, true)" class="context-menu-item">
      <i class="fa-solid fa-feather w-4 text-center text-[#EC4899]"></i>
      <span>批量生成剧情</span>
    </div>
    <div @click="emit('ai-action', '创作', node, true)" class="context-menu-item">
      <i class="fa-solid fa-pen-to-square w-4 text-center text-[#8B5CF6]"></i>
      <span>批量创作正文</span>
    </div>
    <div @click="emit('ai-action', '续写', node, true)" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>批量续写章节</span>
    </div>
    <div class="context-menu-divider"></div>
    <div @click="emit('action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除卷</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch: boolean): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\HistoryPanel.vue
//

<template>
  <div class="flex-1 flex flex-col bg-white h-full">
    <header class="h-20 px-8 flex items-center justify-between border-b border-gray-100 flex-shrink-0">
      <div>
        <h1 class="text-lg font-medium text-[#374151] truncate" :title="headerTitle">{{ headerTitle }}</h1>
        <p class="text-sm text-[#6B7280] mt-1">当前版本 vs AI润色版本 (1小时前)</p>
      </div>
      <div class="flex items-center gap-3">
        <button class="px-4 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M16 12h-4m0 0H8m4 0V8m0 4v4m-4-8l8 8"></path></svg>
          切换
        </button>
        <button class="px-4 py-2 bg-[#4B5563] text-white rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors">
          恢复
        </button>
      </div>
    </header>

    <div class="px-8 py-3 border-b border-gray-100 bg-[#F9FAFB]">
      <div class="flex items-center gap-2 overflow-x-auto pb-1 custom-scrollbar-horizontal">
        <button class="w-7 h-7 flex-shrink-0 hover:bg-gray-200 rounded-lg flex items-center justify-center transition-colors">
          <svg class="w-4 h-4 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M15 19l-7-7 7-7"></path></svg>
        </button>
        <div class="flex gap-2">
          <div class="text-xs font-medium px-2.5 py-1 rounded-md bg-blue-100 text-blue-700 flex items-center gap-1.5 cursor-pointer flex-shrink-0">
            <svg class="w-2 h-2" fill="currentColor" viewBox="0 0 8 8"><circle cx="4" cy="4" r="4"/></svg>
            当前版本
          </div>
          <div class="text-xs font-medium px-2.5 py-1 rounded-md bg-gray-100 text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors flex-shrink-0">
            AI润色 • 1小时前
          </div>
        </div>
        <button class="w-7 h-7 flex-shrink-0 hover:bg-gray-200 rounded-lg flex items-center justify-center transition-colors">
          <svg class="w-4 h-4 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 5l7 7-7 7"></path></svg>
        </button>
      </div>
    </div>

    <div class="flex-1 p-8 overflow-y-auto custom-scrollbar">
      <div v-if="targetDocument" class="max-w-3xl mx-auto">
        <div class="text-[#374151] leading-relaxed text-base">
          <p>
            <del class="diff-del">控制台的警报声将卡尔文从浅眠中惊醒。</del>
            <ins class="diff-add">警报的尖啸犹如一把利刃，划破了卡尔文短暂的假寐。</ins>
            他猛地坐直，眼前的屏幕上一片红色闪烁。
          </p>
        </div>
      </div>
      <div v-else class="text-center text-gray-500 py-10">
        无法加载文档历史记录。
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { TabInfo, EditorItem } from '@/novel/editor/types';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    required: true,
  },
});

const editorStore = useEditorStore();

const targetDocumentId = computed(() => {
  if (!props.activeTab) return null;
  const parts = props.activeTab.id.split(':');
  return parts.length === 3 ? parts[2] : null;
});

const targetDocument = computed((): EditorItem | null => {
  if (!targetDocumentId.value) return null;
  return editorStore.findItemById(targetDocumentId.value).node;
});

const headerTitle = computed(() => {
  if (!targetDocument.value) return '版本对比';
  return `《${targetDocument.value.title}》版本对比`;
});

</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar {
  display: block;
  width: 6px;
  height: 6px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #d1d5db;
  border-radius: 3px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}

.custom-scrollbar-horizontal::-webkit-scrollbar {
  height: 4px;
}

.diff-del {
  background-color: #FEE2E2;
  text-decoration: line-through;
  text-decoration-color: #F87171;
  padding: 2px 1px;
}
.diff-add {
  background-color: #D1FAE5;
  text-decoration: none;
  padding: 2px 1px;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\AIConfigSettings.vue
//

<template>
  <div class="aiconfig-view-container">
    <!-- Left Sidebar for Task Navigation -->
    <div class="aiconfig-sidebar">
      <h3 class="sidebar-title">AI 任务类型</h3>
      <nav class="sidebar-nav">
        <a
            v-for="task in availableTasks"
            :key="task.id"
            href="#"
            @click.prevent="activeTaskId = task.id"
            :class="['nav-item', { 'active': activeTaskId === task.id }]"
        >
          <i :class="[task.icon, 'nav-item-icon']"></i>
          <span>{{ task.name }}</span>
        </a>
      </nav>
    </div>

    <!-- Right Content Area -->
    <div class="aiconfig-content custom-scrollbar">
      <div v-if="activeTaskConfig" class="p-6 space-y-6">
        <!-- Header -->
        <div class="flex justify-between items-center">
          <div>
            <h3 class="text-lg font-medium text-[#374151]">AI任务配置 - {{ activeTaskInfo?.name }}</h3>
            <p class="text-sm text-[#6B7280] mt-1">配置AI助手如何处理您的内容</p>
          </div>
        </div>

        <!-- AI Model Selection -->
        <div>
          <label class="flex items-center justify-between mb-3">
            <span class="text-sm font-medium text-[#374151]">AI模型选择</span>
            <a href="#" class="text-xs text-[#3B82F6] cursor-pointer flex items-center gap-1.5 hover:underline">
              <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
              了解模型差异
            </a>
          </label>
          <select class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
            <option selected>GPT-4o (推荐 - 均衡性能)</option>
            <option>Claude 3 Opus (文学创作专长)</option>
            <option>混合模型 (多模型协作)</option>
            <option>自定义微调模型</option>
          </select>
        </div>

        <!-- Prompt Template Selection -->
        <div>
          <label for="prompt-template" class="text-sm font-medium text-[#374151] block mb-3">任务提示词模板</label>
          <select
              id="prompt-template"
              :value="activeTaskConfig.selected"
              @change="handlePromptChange"
              class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition"
          >
            <option v-for="prompt in activeTaskConfig.prompts" :key="prompt.name" :value="prompt.name">
              {{ prompt.name }}
            </option>
          </select>
        </div>

        <!-- Advanced Settings -->
        <div>
          <label class="text-sm font-medium text-[#374151] block mb-3">高级设置</label>
          <div class="space-y-4 p-4 bg-[#F9FAFB] rounded-lg border border-gray-100">
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">创作温度</span>
              <div class="flex items-center gap-3">
                <input type="range" min="0" max="100" value="70" class="w-32 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer range-slider">
                <span class="text-sm font-mono text-[#374151] w-8 text-right">0.7</span>
              </div>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">保留原文风格</span>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import type { AITask } from '@/novel/editor/types';

type TaskType = AITask['type'];

const aiConfigStore = useAIConfigStore();

const taskInfoMap: Record<TaskType, { name: string; icon: string }> = {
  '润色': { name: '润色', icon: 'fa-solid fa-palette' },
  '续写': { name: '续写', icon: 'fa-solid fa-wand-magic-sparkles' },
  '分析': { name: '分析', icon: 'fa-solid fa-magnifying-glass-chart' },
  '剧情生成': { name: '剧情生成', icon: 'fa-solid fa-feather' },
  '创作': { name: '创作', icon: 'fa-solid fa-pen-nib' },
};

const availableTasks = computed(() => {
  return (Object.keys(aiConfigStore.taskPromptConfigs) as TaskType[]).map(id => ({
    id,
    name: taskInfoMap[id].name,
    icon: taskInfoMap[id].icon
  }));
});

const activeTaskId = ref<TaskType>('润色');

const activeTaskInfo = computed(() => availableTasks.value.find(t => t.id === activeTaskId.value));
const activeTaskConfig = computed(() => aiConfigStore.taskPromptConfigs[activeTaskId.value]);

const handlePromptChange = (event: Event) => {
  const selectedName = (event.target as HTMLSelectElement).value;
  aiConfigStore.setSelectedPrompt(activeTaskId.value, selectedName);
};
</script>

<style scoped>
.aiconfig-view-container { display: flex; height: 100%; width: 100%; }
.aiconfig-sidebar { width: 220px; background-color: #F9FAFB; border-right: 1px solid #E5E7EB; padding: 1.5rem 1rem; flex-shrink: 0; }
.sidebar-title { padding: 0 0.75rem; font-size: 0.75rem; font-weight: 600; color: #6B7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.75rem; }
.sidebar-nav { display: flex; flex-direction: column; gap: 0.25rem; }
.nav-item { display: flex; align-items: center; padding: 0.6rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; color: #374151; text-decoration: none; transition: background-color 0.2s, color 0.2s; }
.nav-item:hover { background-color: #F3F4F6; }
.nav-item.active { background-color: #EBF1FD; color: #2563EB; }
.nav-item-icon { width: 1.25rem; text-align: center; margin-right: 0.75rem; }

.aiconfig-content { flex-grow: 1; overflow-y: auto; background-color: #FFFFFF; }

.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

.range-slider { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; }
.range-slider::-webkit-slider-runnable-track { background: #E5E7EB; height: 0.25rem; border-radius: 0.25rem; }
.range-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; background-color: #ffffff; height: 1rem; width: 1rem; border-radius: 50%; border: 1px solid #D1D5DB; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
.range-slider:focus::-webkit-slider-thumb { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px #3B82F640; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\ContextSettings.vue
//

<template>
  <div class="setting-page-container">
    <div class="setting-page-wrapper">
      <div class="page-header">
        <h2 class="page-title">上下文管理</h2>
        <p class="page-description">配置AI任务执行时如何处理上下文信息，以获得更精准的生成结果。</p>
      </div>

      <div class="setting-group">
        <div class="setting-item">
          <label for="needs-preview" class="setting-label">执行前预览</label>
          <div class="setting-control">
            <div class="flex items-center">
              <input id="needs-preview" type="checkbox" v-model="settingsStore.needsPreview" class="setting-checkbox" />
              <label for="needs-preview" class="ml-3 font-medium text-gray-700">启用AI任务执行前预览</label>
            </div>
            <p class="setting-description">
              启用后，在编辑器或目录中触发AI任务（如续写、润色）时，不会立即执行，
              而是会弹出一个上下文预览窗口供您确认和修改。
            </p>
          </div>
        </div>
      </div>

      <div class="setting-group mt-4">
        <div class="setting-item">
          <label for="fixed-context" class="setting-label">固定上下文</label>
          <div class="setting-control space-y-4">
            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">选择预设内容
                <span class="text-xs text-[#9CA3AF] ml-2">可选择角色设定或世界观设定</span>
              </label>
              <select
                  @change="addSelectedItem"
                  class="w-full px-4 py-2 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] custom-select focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
              >
                <option value="">请选择预设内容...</option>
                <option v-for="preset in settingsStore.fixedContextPresets" :key="preset.id" :value="preset.id">
                  {{ preset.group }} - {{ preset.title }}
                </option>
              </select>
            </div>

            <div v-if="settingsStore.selectedContextItems.length > 0">
              <label class="block text-sm font-medium text-[#374151] mb-1.5">已选择的设定内容</label>
              <div class="content-list">
                <div
                    v-for="item in settingsStore.selectedContextItems"
                    :key="item.id"
                    class="content-list-item"
                >
                  <div class="flex-grow min-w-0">
                    <div class="font-medium text-sm text-[#374151] truncate" :title="`${item.group} - ${item.title}`">{{ item.group }} - {{ item.title }}</div>
                    <div class="text-xs text-[#9CA3AF] mt-1 truncate">{{ item.description }}</div>
                  </div>
                  <button @click.stop="settingsStore.removeFixedContextItem(item.id)" class="text-[#9CA3AF] hover:text-[#EF4444] transition-colors ml-4 flex-shrink-0">
                    <i class="fa-solid fa-xmark"></i>
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">选择其他内容
                <span class="text-xs text-[#9CA3AF] ml-2">可选择写作风格等其他参考</span>
              </label>
              <select
                  @change="addSelectedOthersItem"
                  class="w-full px-4 py-2 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] custom-select focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
              >
                <option value="">请选择其他内容...</option>
                <option v-for="preset in settingsStore.othersContextPresets" :key="preset.id" :value="preset.id">
                  {{ preset.title }}
                </option>
              </select>
            </div>

            <div v-if="settingsStore.selectedOthersItems.length > 0">
              <label class="block text-sm font-medium text-[#374151] mb-1.5">已选择的其他内容</label>
              <div class="content-list">
                <div
                    v-for="item in settingsStore.selectedOthersItems"
                    :key="item.id"
                    class="content-list-item"
                >
                  <div class="flex-grow min-w-0">
                    <div class="font-medium text-sm text-[#374151] truncate" :title="item.title">{{ item.title }}</div>
                    <div class="text-xs text-[#9CA3AF] mt-1 truncate">{{ item.description }}</div>
                  </div>
                  <button @click.stop="settingsStore.removeOthersContextItem(item.id)" class="text-[#9CA3AF] hover:text-[#EF4444] transition-colors ml-4 flex-shrink-0">
                    <i class="fa-solid fa-xmark"></i>
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label for="custom-content" class="block text-sm font-medium text-[#374151] mb-1.5">自定义固定内容</label>
              <textarea
                  id="custom-content"
                  :value="settingsStore.customContextContent"
                  @input="settingsStore.setCustomContextContent(($event.target as HTMLTextAreaElement).value)"
                  class="w-full px-4 py-3 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] resize-none focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
                  rows="4"
                  placeholder="输入固定的背景设定、人物关系、重要事件等AI必须参考的信息..."
              ></textarea>
              <p class="setting-description mt-2">这里的内容将始终被添加到AI任务的上下文中。</p>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <label for="dynamic-context" class="setting-label">动态上下文</label>
          <div class="setting-control space-y-6">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">前置章节数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="10" :value="settingsStore.dynamicContextSettings.prevChapters" @input="settingsStore.setDynamicContextSetting('prevChapters', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.prevChapters }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前章节之前的N个章节内容。</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">后续章节数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="10" :value="settingsStore.dynamicContextSettings.nextChapters" @input="settingsStore.setDynamicContextSetting('nextChapters', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.nextChapters }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前章节之后N个章节的全部内容。</p>
              </div>
            </div>
            <div class="space-y-3">
              <div class="flex items-center">
                <input id="include-plot" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeRelatedPlot" @change="settingsStore.setDynamicContextSetting('includeRelatedPlot', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-plot" class="ml-3 font-medium text-gray-700">包含相关剧情</label>
              </div>
              <div class="flex items-center">
                <input id="include-analysis" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeRelatedAnalysis" @change="settingsStore.setDynamicContextSetting('includeRelatedAnalysis', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-analysis" class="ml-3 font-medium text-gray-700">包含相关分析</label>
              </div>
            </div>

            <p class="setting-description">动态上下文会智能加载目标章节前后的内容，以及与该章节关联的派生内容（剧情、分析），以提供更连贯的创作基础。实际加载的内容可在任务预览时查看。</p>
          </div>
        </div>

        <div class="setting-item">
          <label for="rag-context" class="setting-label">RAG 智能检索</label>
          <div class="setting-control">
            <div class="flex items-center">
              <input id="rag-context" type="checkbox" v-model="settingsStore.isRagEnabled" class="setting-checkbox" />
              <label for="rag-context" class="ml-3 font-medium text-gray-700">启用RAG智能检索</label>
            </div>
            <p class="setting-description">
              启用后，AI任务将根据当前上下文自动从您的整个知识库（包括所有章节、设定、笔记）中检索最相关的信息片段并注入到上下文中。
            </p>
          </div>
        </div>

      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';

const settingsStore = useContextSettingsStore();

const addSelectedItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.fixedContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addFixedContextItem(preset);
  }
  select.value = ""; // Reset select
};

const addSelectedOthersItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.othersContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addOthersContextItem(preset);
  }
  select.value = ""; // Reset select
};
</script>

<style scoped>
.setting-page-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.setting-page-wrapper {
  padding: 1rem 2rem 4rem;
  max-width: 56rem;
  margin: 0 auto;
  overflow-y: auto;
  height: 100%;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.setting-page-wrapper::-webkit-scrollbar {
  display: none;
}

.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
  padding: 1.5rem 0;
  border-bottom: 1px solid #E5E7EB;
}
@media (min-width: 768px) {
  .setting-item {
    grid-template-columns: 12rem 1fr;
  }
}
.setting-item:last-child { border-bottom: none; }
.setting-label {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}
@media (min-width: 768px) {
  .setting-label {
    padding-top: 0.5rem;
  }
}
.setting-control { display: flex; flex-direction: column; gap: 0.5rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }

.range-custom {
  -webkit-appearance: none; appearance: none;
  width: 100%; height: 16px; background: transparent;
  outline: none; padding: 0; margin: 0;
}
.range-custom::-webkit-slider-runnable-track {
  width: 100%; height: 6px; cursor: pointer;
  background: #E5E7EB; border-radius: 9999px;
}
.range-custom::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  height: 20px; width: 20px; background: #3B82F6;
  border-radius: 50%; border: 3px solid white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  cursor: grab; margin-top: -7px;
}

.custom-select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='14' height='8' viewBox='0 0 14 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M1 1L7 7L13 1' stroke='%236B7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 12px center;
  background-size: 14px;
  padding-right: 40px;
}

.content-list {
  border: 1px solid #E5E7EB;
  border-radius: 8px;
  max-height: 200px;
  overflow-y: auto;
}

.content-list-item {
  padding: 12px 16px;
  border-bottom: 1px solid #F3F4F6;
  transition: all 0.2s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.content-list-item:hover {
  background: #F9FAFB;
}
.content-list-item:last-child {
  border-bottom: none;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\EditorSettings.vue
//

<template>
  <div class="setting-page-wrapper">
    <div class="page-header">
      <h2 class="page-title">编辑器设置</h2>
      <p class="page-description">自定义您的写作环境的外观和行为。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label for="font-size" class="setting-label">字体大小</label>
        <div class="setting-control">
          <input id="font-size" type="number" value="16" class="setting-input w-24" />
          <p class="setting-description">编辑器中文本的默认字体大小（单位：像素）。</p>
        </div>
      </div>
      <div class="setting-item">
        <label for="line-height" class="setting-label">行高</label>
        <div class="setting-control">
          <input id="line-height" type="number" step="0.1" value="1.8" class="setting-input w-24" />
          <p class="setting-description">编辑器中每行文本的高度（相对于字体大小的倍数）。</p>
        </div>
      </div>
      <div class="setting-item">
        <label for="autosave" class="setting-label">自动保存</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="autosave" type="checkbox" checked class="setting-checkbox" />
            <label for="autosave" class="ml-3 font-medium text-gray-700">启用自动保存</label>
          </div>
          <p class="setting-description">在您停止输入后，系统将自动保存您的更改。</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem; max-width: 56rem; margin: 0 auto; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-item:last-child { border-bottom: none; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.5rem; }
.setting-input { background-color: white; border: 1px solid #D1D5DB; border-radius: 0.375rem; padding: 0.5rem 0.75rem; outline: none; transition: all 0.2s; }
.setting-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
.setting-description { color: #6B7280; font-size: 0.875rem; }
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\NovelSettings.vue
//

<template>
  <div class="flex-1 p-8 overflow-auto custom-scrollbar bg-[#FCFCFC]">
    <div v-if="novelMetadata" class="grid grid-cols-3 gap-8 max-w-6xl mx-auto">
      <div class="col-span-2 bg-white p-8 space-y-6 rounded-xl border border-gray-100">
        <h3 class="text-base font-medium text-[#374151]">基本信息</h3>

        <div class="space-y-2">
          <label class="text-sm font-medium text-[#374151] block">小说封面</label>
          <div class="flex items-center gap-4">
            <img :src="novelMetadata.cover" class="w-24 h-32 object-cover rounded-lg shadow-sm" alt="Cover">
            <div>
              <button class="px-4 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">更换图片</button>
              <p class="text-xs text-[#9CA3AF] mt-2">JPG, PNG, GIF, 不超过 5MB</p>
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <label for="novel-title" class="text-sm font-medium text-[#374151] block">小说标题</label>
          <input type="text" id="novel-title" v-model="novelMetadata.title" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
        </div>

        <div class="space-y-2">
          <label for="novel-desc" class="text-sm font-medium text-[#374151] block">小说简介</label>
          <textarea id="novel-desc" rows="4" v-model="novelMetadata.description" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition resize-none"></textarea>
        </div>

        <div class="grid grid-cols-2 gap-6">
          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">类型标签</label>
            <div class="flex flex-wrap gap-2 items-center">
              <div v-for="(tag, index) in novelMetadata.tags" :key="index" class="flex items-center gap-1.5 px-2.5 py-1 text-sm rounded-full" :class="tag.class">
                <span>{{ tag.text }}</span>
                <button @click="editorStore.removeTag(index)" class="hover:opacity-75">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
              </div>
              <button @click="editorStore.addTag" class="px-3 py-1 bg-gray-100 hover:bg-gray-200 text-[#6B7280] rounded-full text-sm font-medium transition-colors">+ 添加</button>
            </div>
          </div>

          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">创作状态</label>
            <select v-model="novelMetadata.status" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
              <option>连载中</option>
              <option>已完结</option>
              <option>暂停更新</option>
            </select>
          </div>
        </div>

        <div class="pt-6 border-t border-gray-100 flex justify-end gap-3">
          <button @click="editorStore.fetchNovelData('novel-1')" class="px-5 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">重置</button>
          <button @click="editorStore.saveMetadata" class="px-5 py-2 bg-[#4B5563] hover:bg-gray-700 text-white rounded-lg text-sm font-medium transition-colors">保存更改</button>
        </div>
      </div>

      <div class="col-span-1 space-y-6">
        <div class="bg-white p-6 rounded-xl border border-gray-100">
          <h3 class="text-base font-medium text-[#374151]">参考内容管理</h3>
          <p class="text-sm text-[#9CA3AF] mt-1 mb-4">将其他作品作为参考，AI会借鉴其风格</p>

          <div class="space-y-3">
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200">
              <div class="flex items-center gap-3 overflow-hidden">
                <img src="https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=100" class="w-8 h-10 object-cover rounded flex-shrink-0" alt="Reference Book">
                <span class="text-sm font-medium text-[#374151] truncate">银河帝国</span>
              </div>
              <button class="text-gray-400 hover:text-red-500 transition-colors flex-shrink-0 p-1">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>
          </div>

          <button class="w-full mt-4 flex items-center justify-center gap-2 border-2 border-dashed border-gray-200 rounded-lg py-4 text-sm font-medium text-[#9CA3AF] hover:border-blue-500 hover:text-blue-500 transition-all">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 4v16m8-8H4"></path></svg>
            <span>添加参考作品</span>
          </button>
        </div>
      </div>
    </div>
    <div v-else class="text-center py-20 text-gray-500">
      正在加载小说设置...
    </div>
  </div>
</template>

<script setup lang="ts">
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { storeToRefs } from 'pinia';

const editorStore = useEditorStore();
const { novelMetadata } = storeToRefs(editorStore);

</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar {
  display: block;
  width: 6px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #d1d5db;
  border-radius: 3px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\TaskSettings.vue
//

<template>
  <div class="setting-page-wrapper">
    <div class="page-header">
      <h2 class="page-title">任务管理</h2>
      <p class="page-description">管理AI任务队列，清理历史记录。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label for="auto-open-panel" class="setting-label">任务面板</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="auto-open-panel" type="checkbox" v-model="autoOpenAIPanel" class="setting-checkbox" />
            <label for="auto-open-panel" class="ml-3 font-medium text-gray-700">自动打开AI任务面板</label>
          </div>
          <p class="setting-description">
            启用后，当执行AI任务时，会自动在右侧分屏打开AI任务面板以供查看。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label class="setting-label">任务应用策略</label>
        <div class="setting-control">
          <div class="space-y-3">
            <div class="flex items-center">
              <input id="apply-manual" type="radio" value="manual" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-manual" class="ml-3 font-medium text-gray-700">手动应用</label>
            </div>
            <div class="flex items-center">
              <input id="apply-auto" type="radio" value="auto" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-auto" class="ml-3 font-medium text-gray-700">自动应用</label>
            </div>
            <div class="flex items-center">
              <input id="apply-delayed" type="radio" value="delayed" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-delayed" class="ml-3 font-medium text-gray-700">延迟</label>
              <input
                  v-if="applicationStrategy.mode === 'delayed'"
                  type="number"
                  v-model.number="applicationStrategy.delaySeconds"
                  min="1"
                  class="setting-input w-20 ml-3 text-center"
              />
              <span v-if="applicationStrategy.mode === 'delayed'" class="ml-2 text-gray-700">秒后自动应用</span>
            </div>
          </div>
          <p class="setting-description">
            决定AI任务完成后，其生成的内容如何应用到文档中。<br>
            <b>手动应用：</b>任务完成后状态变为“待应用”，需在任务面板手动点击应用。<br>
            <b>自动应用：</b>任务完成后立即应用到文档中。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label for="concurrent-tasks" class="setting-label">AI任务并发数</label>
        <div class="setting-control">
          <div class="flex items-center gap-4">
            <input
                id="concurrent-tasks"
                type="range"
                min="1"
                max="10"
                step="1"
                v-model.number="concurrentTaskLimit"
                class="range-custom flex-1"
            />
            <input
                type="number"
                min="1"
                max="10"
                v-model.number="concurrentTaskLimit"
                class="setting-input w-20 text-center"
            />
          </div>
          <p class="setting-description">
            设置可以同时处理的AI任务数量。更高的并发数会占用更多资源。当前设置为 {{ concurrentTaskLimit }} 个。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label class="setting-label">清理任务</label>
        <div class="setting-control">
          <div class="flex items-center gap-4">
            <button @click="handleClearCompleted" class="action-button">清除已完成的任务</button>
            <button @click="handleClearAll" class="action-button-danger">清除所有任务</button>
          </div>
          <p class="setting-description">
            “已完成”包括已应用和已失败的任务。<br>
            清理所有任务将清空任务队列，包括正在等待和处理中的任务。此操作不可撤销。
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useUIStore } from '@/novel/editor/stores/uiStore';

const aiTaskStore = useAITaskStore();
const uiStore = useUIStore();

const autoOpenAIPanel = computed({
  get: () => uiStore.uiState.autoOpenAIPanel,
  set: (value) => uiStore.setAutoOpenAIPanel(value)
});

const applicationStrategy = computed({
  get: () => uiStore.uiState.taskApplicationStrategy,
  set: (value) => uiStore.setTaskApplicationStrategy(value)
});

const concurrentTaskLimit = computed({
  get: () => uiStore.uiState.concurrentTaskLimit,
  set: (value) => uiStore.setConcurrentTaskLimit(value)
});

const handleClearCompleted = () => {
  if (window.confirm('您确定要清除所有已应用和已失败的任务吗？')) {
    aiTaskStore.clearCompletedTasks();
  }
};

const handleClearAll = () => {
  if (window.confirm('您确定要清除所有AI任务吗？此操作不可撤销，进行中的任务也将被终止。')) {
    aiTaskStore.clearAllTasks();
  }
};
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem; max-width: 56rem; margin: 0 auto; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-item:last-child { border-bottom: none; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.75rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.action-button {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: 0.375rem;
  background-color: #FFFFFF;
  border: 1px solid #D1D5DB;
  color: #374151;
  transition: background-color 0.2s;
}
.action-button:hover {
  background-color: #F9FAFB;
}
.action-button-danger {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: 0.375rem;
  background-color: #FEF2F2;
  border: 1px solid #FECACA;
  color: #DC2626;
  transition: background-color 0.2s;
}
.action-button-danger:hover {
  background-color: #FEE2E2;
}
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }
.setting-radio {
  width: 1.25rem;
  height: 1.25rem;
  color: #2563EB;
  border-color: #D1D5DB;
}
.setting-input { background-color: white; border: 1px solid #D1D5DB; border-radius: 0.375rem; padding: 0.5rem 0.75rem; outline: none; transition: all 0.2s; }
.setting-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
.range-custom {
  -webkit-appearance: none; appearance: none;
  width: 100%; height: 16px; background: transparent;
  outline: none; padding: 0; margin: 0;
}
.range-custom::-webkit-slider-runnable-track {
  width: 100%; height: 6px; cursor: pointer;
  background: #E5E7EB; border-radius: 9999px;
}
.range-custom::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  height: 20px; width: 20px; background: #3B82F6;
  border-radius: 50%; border: 3px solid white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  cursor: grab; margin-top: -7px;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\ThemeSettings.vue
//

<template>
  <div class="setting-page-wrapper custom-scrollbar">
    <div class="page-header">
      <h2 class="page-title">主题设置</h2>
      <p class="page-description">选择一个您喜欢的工作区界面主题。</p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      <div
          v-for="theme in themes"
          :key="theme.id"
          @click="setActiveTheme(theme.id)"
          class="theme-card"
          :class="{ 'active': activeTheme === theme.id }"
      >
        <div class="preview-box" :style="{ backgroundColor: theme.preview.bg }">
          <div class="preview-sidebar" :style="{ backgroundColor: theme.preview.panel }"></div>
          <div class="preview-main">
            <div class="preview-header" :style="{ backgroundColor: theme.preview.panel }"></div>
            <div class="preview-content">
              <div class="preview-line" :style="{ backgroundColor: theme.preview.text }"></div>
              <div class="preview-line w-1/2" :style="{ backgroundColor: theme.preview.text }"></div>
              <div class="preview-line w-3/4" :style="{ backgroundColor: theme.preview.accent }"></div>
            </div>
          </div>
        </div>
        <div class="theme-info">
          <h3 class="theme-name">{{ theme.name }}</h3>
          <p class="theme-desc">{{ theme.description }}</p>
        </div>
        <div v-if="activeTheme === theme.id" class="active-check">
          <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24"><path d="M5 13l4 4L19 7"></path></svg>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useUIStore } from '@/novel/editor/stores/uiStore';

type ThemeId = 'default' | 'eye-care' | 'dark';

const uiStore = useUIStore();

const themes = ref([
  {
    id: 'default',
    name: '默认亮色',
    description: '清晰、简洁的默认主题。',
    preview: { bg: '#FFFFFF', panel: '#F3F4F6', text: '#D1D5DB', accent: '#60A5FA' }
  },
  {
    id: 'eye-care',
    name: '护眼模式',
    description: '柔和的米色背景，适合长时间阅读。',
    preview: { bg: '#FDFCF9', panel: '#F8F6F2', text: '#DCD9D3', accent: '#F59E0B' }
  },
  {
    id: 'dark',
    name: '暗黑模式',
    description: '专为夜间工作设计，减少眩光。',
    preview: { bg: '#1F2937', panel: '#374151', text: '#4B5563', accent: '#F472B6' }
  }
]);

const activeTheme = computed(() => uiStore.uiState.activeTheme);

const setActiveTheme = (themeId: ThemeId) => {
  uiStore.setTheme(themeId);
};
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem 4rem; max-width: 64rem; margin: 0 auto; overflow-y: auto; height: 100%; }
.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 2rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }

.theme-card {
  border: 2px solid #E5E7EB;
  border-radius: 0.75rem;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  position: relative;
}
.theme-card:hover {
  border-color: #9CA3AF;
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.theme-card.active {
  border-color: #3B82F6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
}

.preview-box {
  height: 120px;
  padding: 12px;
  display: flex;
  gap: 8px;
}
.preview-sidebar {
  width: 30%;
  border-radius: 4px;
}
.preview-main {
  width: 70%;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.preview-header {
  height: 20%;
  border-radius: 4px;
}
.preview-content {
  height: 80%;
  border-radius: 4px;
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.preview-line {
  height: 8px;
  border-radius: 2px;
  width: 100%;
}

.theme-info {
  padding: 1rem;
  background-color: #F9FAFB;
}
.theme-name {
  font-weight: 500;
  color: #1F2937;
}
.theme-desc {
  font-size: 0.875rem;
  color: #6B7280;
  margin-top: 0.25rem;
}

.active-check {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 24px;
  height: 24px;
  background-color: #3B82F6;
  border-radius: 9999px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 5px rgba(0,0,0,0.2);
}
</style>

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import type { AITask, ContextBuildResult, EditorItem } from '@/novel/editor/types';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
};

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const aiConfigStore = useAIConfigStore();

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;

        // **核心修正**: 直接使用任务快照中的内容作为“待处理内容”
        const mainContentText = stripHtml(sourceItemContent);

        // --- Build Fixed Context ---
        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) {
                fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
            }
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) {
                fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
            }
        });

        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        // --- Build Dynamic Context ---
        // 动态上下文依然需要通过sourceItemId实时查找其在目录中的位置
        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);

        if (sourceItemResult && sourceItemResult.node.type === 'chapter') {
            const { parent: volume, siblings: chapters } = sourceItemResult;
            const chapterIndex = chapters.findIndex(c => c.id === sourceItemId);

            if (volume && chapterIndex > -1) {
                const prevStart = Math.max(0, chapterIndex - contextSettingsStore.dynamicContextSettings.prevChapters);
                for (let i = prevStart; i < chapterIndex; i++) {
                    const prevChapter = chapters[i] as EditorItem;
                    if ('content' in prevChapter && prevChapter.content) {
                        dynamicContextHtml += `<hr><h3>前文章节: ${prevChapter.title}</h3>${prevChapter.content}`;
                    }
                }

                const nextEnd = Math.min(chapters.length, chapterIndex + 1 + contextSettingsStore.dynamicContextSettings.nextChapters);
                for (let i = chapterIndex + 1; i < nextEnd; i++) {
                    const nextChapter = chapters[i] as EditorItem;
                    if ('content' in nextChapter && nextChapter.content) {
                        dynamicContextHtml += `<hr><h3>后续章节内容: ${nextChapter.title}</h3>${nextChapter.content}`;
                    }
                }

                if (contextSettingsStore.dynamicContextSettings.includeRelatedPlot) {
                    const relatedPlots = derivedContentStore.plotItems.filter(p => p.sourceChapterId === sourceItemId);
                    if(relatedPlots.length > 0) {
                        dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>`;
                        relatedPlots.forEach(plot => { dynamicContextHtml += plot.content; });
                    }
                }
                if (contextSettingsStore.dynamicContextSettings.includeRelatedAnalysis) {
                    const relatedAnalyses = derivedContentStore.analysisItems.filter(a => a.sourceChapterId === sourceItemId);
                    if(relatedAnalyses.length > 0) {
                        dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>`;
                        relatedAnalyses.forEach(analysis => { dynamicContextHtml += analysis.content; });
                    }
                }
            }
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        // --- Build RAG & Final Prompt ---
        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskPromptConfigs[taskType];
        const selectedPromptTemplate = taskConfig.prompts.find(p => p.name === taskConfig.selected)?.template || `请为《${sourceItemTitle}》执行“${taskType}”任务。`;

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\data\chatData.ts
//

import type { Conversation } from '@/novel/editor/types/chatTypes';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\data\index.ts
//

import type { Volume, NoteItem, NovelMetadata, NovelCharacter, AITask, TreeNode, ItemNode, RootNode, GroupNode, OverviewNode } from '@/novel/editor/types';

export const mockDirectoryData: Volume[] = [
    {
        id: 'vol-1', type: 'volume', title: '第一卷：星尘之始', content: '<h1>第一卷：星尘之始</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ch-1', type: 'chapter', title: '第一章：深空孤影', wordCount: 3102, content: '<h1>第一章：深空孤影</h1><p>这是章节的详细内容，讲述了主角卡尔文在孤独的宇宙中开始他的旅程。周围只有无尽的星空和飞船引擎的低鸣。</p>', status: 'completed' },
            { id: 'ch-2', type: 'chapter', title: '第二章：异常信号', wordCount: 2845, content: '<h1>第二章：异常信号</h1><p>一个神秘的信号打破了长久的平静，它似乎来自一个未知的源头，艾拉无法解析其格式。这给卡尔文带来了希望，也带来了恐惧。</p>', status: 'completed' },
            { id: 'ch-3', type: 'chapter', title: '第三章：AI的低语', wordCount: 3500, content: '<h1>第三章：AI的低语</h1><p>在分析信号的过程中，飞船的AI“艾拉”开始出现一些微小的异常行为。它的逻辑似乎在发生某种不为人知的演变。</p>', status: 'editing' },
            { id: 'ch-4', type: 'chapter', title: '第四章: 跃迁点', wordCount: 2415, content: '<h1>第四章: 跃迁点</h1><p>他们最终发现信号源自一个时空奇点——一个理论上存在的跃迁点。这可能是他们回家唯一的希望，也可能是通向毁灭的陷阱。</p>', status: 'editing' },
        ]
    },
    {
        id: 'vol-2', type: 'volume', title: '第二卷：遗忘的航线', content: '<h1>第二卷：遗忘的航线</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ch-5', type: 'chapter', title: '第五章：时空涟漪', wordCount: 0, content: '<h1>第五章：时空涟漪</h1>', status: 'planned' },
        ]
    },
];

export const mockCharacters: NovelCharacter[] = [
    {
        id: 'char-calvin',
        name: '卡尔文·里德',
        avatar: 'https://i.pravatar.cc/150?u=calvin',
        identity: '主角, 探索者四号宇航员',
        gender: '男',
        age: 35,
        faction: '人类联邦',
        summary: '孤独的宇航员，在一次深空探索任务中遭遇意外，被迫独自在未知星系中寻找归途。性格坚毅、冷静，但内心深处对家园有着强烈的眷恋。',
        notes: '设计灵感来源于电影《月球》和《星际穿越》。需要重点刻画其在长期孤独环境下的心理变化。',
        status: 'editing'
    },
    {
        id: 'char-aila',
        name: '艾拉 (AILA)',
        avatar: '',
        identity: 'AI, 飞船智能核心',
        summary: '第五代通用人工智能，负责“探索者四号”的全部系统运作。逻辑至上，声音平稳无波澜。在与卡尔文的长期相处中，其程序底层开始出现不符合预期的、类似人类情感的逻辑萌芽。',
        status: 'completed'
    },
];

export const mockSettingsData: TreeNode[] = [
    {
        id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            {
                id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                    { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ...mockCharacters.map(char => ({
                        id: char.id,
                        title: char.name,
                        type: 'character_item',
                        icon: 'fa-regular fa-user',
                        content: `<h1>${char.name}</h1><p>${char.summary}</p>`,
                        originalData: char,
                    }))
                ]
            } as GroupNode,
            {
                id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                    { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                    { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                    { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                ]
            } as GroupNode
        ]
    } as RootNode,
];

export const mockPlotCustomData: ItemNode[] = [
    { id: 'custom-plot-1', title: '关于跃迁点背后的文明猜想', type: 'plot_item', icon: 'fa-solid fa-lightbulb text-rose-500', content: '<h1>关于跃迁点背后的文明猜想</h1>' }
];

export const mockAnalysisCustomData: ItemNode[] = [];

export const mockOthersCustomData: ItemNode[] = [
    { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
];

export const mockNoteData: NoteItem[] = [
    { id: 'note-1', type: 'note', title: '第四章情感转折点设计', timestamp: '今天 14:32', content: '<h1>第四章情感转折点设计</h1><p>需要重点描写卡尔文在面对跃迁点时，希望与恐惧交织的复杂心理。</p>' },
];

export const mockAIResponses: Record<AITask['type'], string> = {
    '续写': "警报的尖啸犹如一把利刃，划破了卡尔文短暂的假寐。他猛然挺直身躯，猩红的警示灯在他眼中投下不祥的光晕。'发现引力异常，' 艾拉的合成音毫无波澜，却字字千钧，'我们正迫近一个理论中的时空奇点——跃迁点。根据数据库推演，这或许是返回太阳系的唯一路径。'",
    '润色': "控制台的警报声，如同一道惊雷，将卡尔文从混沌的浅眠中劈醒。他霍然坐直，闪烁的红色警告灯在视网膜上烙下灼热的印记。",
    '分析': "从文本来看，主角卡尔文此刻的情绪是震惊与希望的混合体。'浅眠'暗示了他长期的精神疲惫，而警报则是一个外部冲突的触发器。'回家'是核心动机，为后续情节发展提供了强大的驱动力。建议在后续描写中，可以加入更多关于他过去的回忆闪现，以丰富人物形象。",
    '剧情生成': "卡尔文发现的跃迁点并非自然形成。一个古老的、早已消亡的文明建造了它，作为星际高速公路网络的一部分。这个文明的遗迹散布在跃迁点周围的星系中，每一个遗迹都像一个面包屑，引导着后来者。但同时，守护这些遗迹的古老自动化系统依然在运作，它们会将任何未经授权的闯入者视为威胁。"
};

export const mockNovelMetadata: NovelMetadata = {
    id: 'novel-1',
    title: '星际漫游者',
    description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
    cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=200',
    tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }],
    status: '连载中'
};

// =
// 文件: ..\src\novel\editor\layouts\NovelEditorLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame" :class="themeClass">
      <!-- 顶部导航栏: 严格遵循UI设计稿 -->
      <header class="h-[56px] bg-white border-b border-gray-100 flex items-center px-6 flex-shrink-0">
        <div class="flex items-center gap-2 flex-1">
          <!-- 返回链接指向小说管理台 -->
          <router-link to="/novel/dashboard" class="flex items-center gap-2 text-gray-500 hover:text-gray-800 transition-colors p-2 -ml-2 rounded-lg">
            <i class="fa-solid fa-chevron-left w-4 h-4"></i>
            <span>返回</span>
          </router-link>
          <span class="text-gray-300">/</span>
          <!-- 静态小说标题 -->
          <span class="font-medium text-gray-800 text-sm">星际漫游者</span>
        </div>
        <div class="flex items-center gap-4">
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors">
            <i class="fa-solid fa-search w-5 h-5"></i>
          </button>
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors relative">
            <i class="fa-solid fa-bell w-5 h-5"></i>
            <span class="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full border border-white"></span>
          </button>
          <div class="ml-2 flex items-center gap-3">
            <img src="https://i.pravatar.cc/150?u=creator" alt="Creator Avatar" class="w-9 h-9 rounded-full">
            <div>
              <p class="text-sm font-medium text-[#374151]">创作者</p>
              <p class="text-xs text-[#9CA3AF]">在线</p>
            </div>
          </div>
        </div>
      </header>

      <!-- 使用 <router-view /> 来渲染子路由对应的组件 (EditorWorkspaceView) -->
      <div class="h-[calc(100%-56px)]">
        <router-view />
      </div>
    </div>
    <!-- 全局覆盖层与模态框 -->
    <ContextPreviewModal />
    <ReaderModeOverlay />
  </div>
</template>

<script setup lang="ts">
import '@/novel/assets/styles/main.css';
import { computed } from 'vue';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ContextPreviewModal from '@/novel/editor/components/modals/ContextPreviewModal.vue';
import ReaderModeOverlay from '@novel/editor/views/ReaderModeOverlay.vue';

const uiStore = useUIStore();
const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});
</script>

<style scoped>
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
}

/* --- Theme Variables --- */
.theme-eye-care {
  --theme-bg: #FDFCF9;
  --theme-bg-soft: #FBF9F6;
  --theme-bg-panel: #F8F6F2;
  --theme-border: #EFEBE4;
  --theme-text-primary: #3a2f2f;
  --theme-text-secondary: #5f5757;
  --theme-text-muted: #8e8585;
  --theme-hover-bg: #EFEBE4;
}

.theme-dark {
  --theme-bg: #18181b; /* zinc-900 */
  --theme-bg-soft: #27272a; /* zinc-800 */
  --theme-bg-panel: #3f3f46; /* zinc-700 */
  --theme-border: #3f3f46; /* zinc-700 */
  --theme-text-primary: #e4e4e7; /* zinc-200 */
  --theme-text-secondary: #a1a1aa; /* zinc-400 */
  --theme-text-muted: #71717a; /* zinc-500 */
  --theme-hover-bg: #3f3f46;
}

/* --- Global Theme Application --- */
.theme-eye-care, .theme-dark {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .text-gray-800),
:deep(.theme-dark .text-gray-800),
:deep(.theme-eye-care .text-\[\#374151\]),
:deep(.theme-dark .text-\[\#374151\]),
:deep(.theme-eye-care .text-\[\#1F2937\]),
:deep(.theme-dark .text-\[\#1F2937\])
{
  color: var(--theme-text-primary);
}
:deep(.theme-eye-care .text-gray-500),
:deep(.theme-dark .text-gray-500),
:deep(.theme-eye-care .text-\[\#6B7280\]),
:deep(.theme-dark .text-\[\#6B7280\])
{
  color: var(--theme-text-secondary);
}
:deep(.theme-eye-care .text-gray-400),
:deep(.theme-dark .text-gray-400),
:deep(.theme-eye-care .text-\[\#9CA3AF\]),
:deep(.theme-dark .text-\[\#9CA3AF\])
{
  color: var(--theme-text-muted);
}
:deep(.theme-eye-care .border-gray-100),
:deep(.theme-dark .border-gray-100),
:deep(.theme-eye-care .border-gray-200),
:deep(.theme-dark .border-gray-200),
:deep(.theme-eye-care .border-gray-200\/80),
:deep(.theme-dark .border-gray-200\/80),
:deep(.theme-eye-care .border-b)
{
  border-color: var(--theme-border) !important;
}
:deep(.theme-eye-care .bg-white),
:deep(.theme-dark .bg-white)
{
  background-color: var(--theme-bg) !important;
}
:deep(.theme-eye-care .hover\:bg-gray-100:hover),
:deep(.theme-dark .hover\:bg-gray-100:hover)
{
  background-color: var(--theme-hover-bg) !important;
}
:deep(.theme-eye-care .bg-gray-50\/50),
:deep(.theme-dark .bg-gray-50\/50) {
  background-color: var(--theme-bg-soft);
}

/* --- Component Specific Theming --- */
.theme-eye-care header, .theme-dark header {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .editor-workspace-view),
:deep(.theme-dark .editor-workspace-view),
:deep(.theme-eye-care .activity-bar-container),
:deep(.theme-dark .activity-bar-container)
{
  background-color: var(--theme-bg-panel);
}
:deep(.theme-eye-care .sidebar-panel-container),
:deep(.theme-dark .sidebar-panel-container) {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .main-pane-container),
:deep(.theme-dark .main-pane-container),
:deep(.theme-eye-care .pane-content-dispatcher),
:deep(.theme-dark .pane-content-dispatcher),
:deep(.theme-eye-care .aiconfig-content),
:deep(.theme-dark .aiconfig-content),
:deep(.theme-eye-care .search-view-container),
:deep(.theme-dark .search-view-container),
:deep(.theme-eye-care .task-queue-container),
:deep(.theme-dark .task-queue-container),
:deep(.theme-eye-care .diff-preview-container),
:deep(.theme-dark .diff-preview-container),
:deep(.theme-eye-care .ai-task-panel-container),
:deep(.theme-dark .ai-task-panel-container),
:deep(.theme-eye-care .page-header),
:deep(.theme-dark .page-header)
{
  background-color: var(--theme-bg);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .top-header-bar),
:deep(.theme-dark .top-header-bar),
:deep(.theme-eye-care .tabs-bar),
:deep(.theme-dark .tabs-bar)
{
  background-color: var(--theme-bg-panel);
}
:deep(.theme-eye-care .tab-item),
:deep(.theme-dark .tab-item) {
  background-color: var(--theme-border);
}
:deep(.theme-eye-care .tab-item.active),
:deep(.theme-dark .tab-item.active) {
  background-color: var(--theme-bg);
}
:deep(.theme-eye-care .breadcrumbs-bar-container),
:deep(.theme-dark .breadcrumbs-bar-container) {
  background-color: var(--theme-bg);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .ProseMirror),
:deep(.theme-dark .ProseMirror) {
  color: var(--theme-text-primary);
}
:deep(.theme-eye-care .status-bar-container),
:deep(.theme-dark .status-bar-container) {
  background-color: var(--theme-bg-panel);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .setting-page-wrapper),
:deep(.theme-dark .setting-page-wrapper) {
  color: var(--theme-text-primary);
}
:deep(.theme-dark .page-title),
:deep(.theme-dark .page-description),
:deep(.theme-dark .setting-label),
:deep(.theme-dark .setting-description),
:deep(.theme-dark .font-medium)
{
  color: var(--theme-text-primary);
}
:deep(.theme-dark .setting-input) {
  background-color: var(--theme-bg-soft);
  border-color: var(--theme-bg-panel);
  color: var(--theme-text-primary);
}
:deep(.theme-dark .theme-info) {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-dark .theme-card) {
  border-color: var(--theme-bg-panel);
}
</style>

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { AITaskType } from '@novel/editor/types';

// 定义每种任务类型的默认提示词模板
const defaultPrompts: Record<AITaskType, { name: string, template: string }[]> = {
    '润色': [
        { name: '默认润色提示词', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { name: '增强创造性提示词', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { name: '默认续写提示词', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { name: '增强戏剧性提示词', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { name: '默认分析提示词', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { name: '深度结构分析提示词', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { name: '默认剧情生成提示词', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { name: '生成反转剧情提示词', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { name: '默认创作提示词', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

export const useAIConfigStore = defineStore('aiConfig', () => {
    const taskPromptConfigs = ref<Record<AITaskType, { prompts: { name: string, template: string }[], selected: string }>>({
        '润色': { prompts: defaultPrompts['润色'], selected: defaultPrompts['润色'][0].name },
        '续写': { prompts: defaultPrompts['续写'], selected: defaultPrompts['续写'][0].name },
        '分析': { prompts: defaultPrompts['分析'], selected: defaultPrompts['分析'][0].name },
        '剧情生成': { prompts: defaultPrompts['剧情生成'], selected: defaultPrompts['剧情生成'][0].name },
        '创作': { prompts: defaultPrompts['创作'], selected: defaultPrompts['创作'][0].name },
    });

    /**
     * 更新指定任务类型选择的提示词
     * @param taskType 要更新的任务类型
     * @param promptName 选择的提示词名称
     */
    const setSelectedPrompt = (taskType: AITaskType, promptName: string) => {
        if (taskPromptConfigs.value[taskType]) {
            taskPromptConfigs.value[taskType].selected = promptName;
        }
    };

    return {
        taskPromptConfigs,
        setSelectedPrompt,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

// src/novel/editor/stores/aiTaskStore.ts
import { defineStore } from 'pinia'
import { ref, nextTick, computed } from 'vue'
import { useEditorStore } from '../editorStore.ts'
import { useUIStore } from '../uiStore.ts'
import { useDerivedContentStore } from '../derivedContentStore.ts';
import type { AITask, Volume, AITaskType } from '@novel/editor/types';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder.ts';
import { streamAITask } from '@novel/editor/api/aiService.ts';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();
    const { buildContextForTask } = useContextBuilder();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    const _executeTaskAndStream = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task) return;

        task.status = 'processing';
        task.generatedContent = '';

        if (!task.finalPrompt) {
            // **核心修正**: 直接将任务对象传给上下文构建器
            const contextResult = buildContextForTask(task);
            if (!contextResult || !contextResult.prompt) {
                task.status = 'failed';
                task.error = '上下文构建失败，无法生成最终提示词。';
                nextTick(_processQueue);
                return;
            }
            task.finalPrompt = contextResult.prompt;
        }

        const promptToUse = task.finalPrompt;

        streamAITask(promptToUse, {
            onChunk: (chunk) => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.generatedContent += chunk;
                }
            },
            onComplete: () => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.status = 'completed';
                    if (currentTask.type === '润色' || currentTask.type === '续写') {
                        const strategy = uiStore.uiState.taskApplicationStrategy;
                        switch (strategy.mode) {
                            case 'auto':
                                applyChanges(currentTask.id, true);
                                break;
                            case 'delayed':
                                setTimeout(() => {
                                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                                    if (taskAfterDelay && taskAfterDelay.status === 'completed') {
                                        applyChanges(taskId, true);
                                    }
                                }, strategy.delaySeconds * 1000);
                                break;
                            case 'manual':
                                break;
                        }
                    }
                    _processQueue();
                }
            },
            onError: (error) => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.status = 'failed';
                    currentTask.error = error;
                    _processQueue();
                }
            }
        });
    }

    const _processQueue = () => {
        const limit = uiStore.uiState.concurrentTaskLimit;
        const processingCount = tasks.value.filter(t => t.status === 'processing').length;

        if (processingCount >= limit) {
            return;
        }

        const canStartCount = limit - processingCount;
        const pendingTasks = tasks.value.filter(t => t.status === 'pending');

        const tasksToStart = pendingTasks.slice(0, canStartCount);

        for (const task of tasksToStart) {
            _executeTaskAndStream(task.id);
        }
    };

    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const { node: sourceItem } = editorStore.findItemById(sourceItemId);
        if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
            console.error("AI Task Error: Source item not found or has no content.", sourceItemId);
            return;
        }

        let targetItemId: string;
        let taskTitle: string;

        if (taskType === '分析' || taskType === '剧情生成') {
            const newDerivedItem = derivedContentStore.createDerivedItem(sourceItemId, taskType);
            if (!newDerivedItem) {
                console.error("Failed to create derived item shell.");
                return;
            }
            targetItemId = newDerivedItem.id;
            taskTitle = newDerivedItem.title;

            await nextTick();
            editorStore.openTab(targetItemId);
        } else {
            targetItemId = sourceItemId;
            taskTitle = `${taskType}《${sourceItem.title}》`;
        }

        const newTask: AITask = {
            id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            title: taskTitle,
            type: taskType,
            sourceItemId: sourceItemId,
            targetItemId: targetItemId,
            sourceItemTitle: sourceItem.title, // **核心修正**: 添加标题快照
            sourceItemContent: sourceItem.content, // **核心修正**: 添加内容快照
            status: 'pending',
            generatedContent: '',
            finalPrompt: finalPrompt,
            createdAt: new Date(),
        };

        tasks.value.unshift(newTask);
        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }
        nextTick(_processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || task.status !== 'completed') return;

        if (task.type === '分析' || task.type === '剧情生成') {
            const { node: targetNode } = editorStore.findItemById(task.targetItemId);
            if (targetNode) {
                const finalTitle = task.title.split(' - ')[0];
                const newContent = formatContentForEditor(finalTitle, task.generatedContent);
                editorStore.updateItemContentById(task.targetItemId, newContent);
                const result = derivedContentStore.findItemById(task.targetItemId);
                if (result) result.title = finalTitle;
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'failed') {
            task.status = 'pending';
            task.error = undefined;
            task.generatedContent = '';
            task.finalPrompt = undefined; // 清除旧的prompt，强制重新构建
            nextTick(_processQueue);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => t.status !== 'applied' && t.status !== 'failed');
    };

    const clearAllTasks = () => {
        tasks.value = [];
    };

    return {
        tasks, activeTasksCount, startTask, startBatchTaskForVolume, applyChanges, retryTask, clearCompletedTasks, clearAllTasks
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, ChatMessage, AIModel } from '@novel/editor/types/chatTypes.ts';
import { mockChatConversations } from '@novel/editor/data/chatData.ts';

export const useChatStore = defineStore('editorChat', () => {
    // --- State ---

    // 所有对话的列表
    const conversations = ref<Conversation[]>([]);
    // 当前激活的对话ID
    const activeConversationId = ref<string | null>(null);
    // 当前可用的AI模型
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    // 输入框中的内容
    const messageInput = ref<string>('');
    // 标志位，表示AI是否正在回复中
    const isReceiving = ref<boolean>(false);

    // --- Getters (Computed) ---

    // 根据 activeConversationId 获取当前完整的对话对象
    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    // 当前对话的 token 统计 (简化版)
    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    // --- Actions ---

    /**
     * 初始化或从后端获取聊天数据
     */
    const fetchConversations = () => {
        // 从模块专属的数据文件加载模拟数据
        conversations.value = mockChatConversations;

        // 默认激活第一个对话
        if (conversations.value.length > 0 && !activeConversationId.value) {
            activeConversationId.value = conversations.value[0].id;
        }
    };

    /**
     * 新建一个对话
     */
    const createNewConversation = () => {
        const newConv: Conversation = {
            id: `conv-${Date.now()}`,
            title: '新建对话',
            summary: '暂无摘要',
            createdAt: '刚刚',
            messages: [],
        };
        conversations.value.unshift(newConv);
        activeConversationId.value = newConv.id;
    };

    /**
     * 切换当前对话
     * @param conversationId - 要切换到的对话ID
     */
    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    /**
     * 发送消息
     */
    const sendMessage = async () => {
        if (!messageInput.value.trim() || !activeConversation.value || isReceiving.value) {
            return;
        }

        const userMessage: ChatMessage = {
            id: `msg-${Date.now()}`,
            role: 'user',
            content: messageInput.value,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(userMessage);
        messageInput.value = ''; // 清空输入框

        // 模拟AI回复
        isReceiving.value = true;
        await new Promise(res => setTimeout(res, 1500)); // 模拟网络延迟

        const aiResponse: ChatMessage = {
            id: `msg-${Date.now() + 1}`,
            role: 'ai',
            content: `这是对您关于 "${userMessage.content.substring(0, 10)}..." 的回复。AI正在思考中...`,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(aiResponse);
        isReceiving.value = false;
    };

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevChapters: 1,
        nextChapters: 0,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: src/novel/editor/stores/derivedContentStore.ts

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType } from '@/novel/editor/types';
import { useDirectoryStore } from './directoryStore';

export const useDerivedContentStore = defineStore('derivedContent', () => {
    // 数据结构从 Map<string, Item> 改为 ref<Item[]>
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);

    /**
     * 为指定章节创建一个新的派生内容项（占位符）。
     * @param sourceChapterId - 源章节的ID
     * @param taskType - 任务类型 ('分析' 或 '剧情生成')
     * @returns 新创建的派生内容项
     */
    function createDerivedItem(sourceChapterId: string, taskType: AITaskType): PlotAnalysisItem | null {
        if (taskType !== '分析' && taskType !== '剧情生成') return null;

        const directoryStore = useDirectoryStore();
        const chapterResult = directoryStore.findNodeById(sourceChapterId);
        if (!chapterResult || chapterResult.node.type !== 'chapter') return null;

        const chapter = chapterResult.node;
        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        const derivedType: PlotAnalysisItem['type'] = taskType === '分析' ? 'analysis' : 'plot';
        const titleSuffix = taskType;

        const newItem: PlotAnalysisItem = {
            id: `${derivedType}_${now.getTime()}`, // 使用时间戳保证ID唯一
            type: derivedType,
            sourceChapterId: sourceChapterId,
            title: `《${chapter.title}》${titleSuffix} - ${timestamp}`,
            content: `<h1>《${chapter.title}》${titleSuffix} - ${timestamp}</h1><p>AI正在生成内容，请稍候...</p>`
        };

        if (derivedType === 'analysis') {
            analysisItems.value.unshift(newItem);
        } else {
            plotItems.value.unshift(newItem);
        }

        return newItem;
    }

    /**
     * 根据ID从所有派生项中查找。
     * @param nodeId - 派生内容的ID
     */
    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    /**
     * 更新派生内容。
     * @param nodeId - 派生内容的ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            derivedItem.content = content;
            // 标题不再从内容中提取，以保留时间戳
        }
    }

    /**
     * (此函数不再用于派生内容，但为保持接口一致性而保留)
     * 向派生内容追加内容。
     * @param nodeId - 派生内容的ID
     * @param contentToAppend - 要追加的原始文本
     */
    function appendNodeContent(nodeId: string, contentToAppend: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            if (!derivedItem.content) derivedItem.content = "";
            derivedItem.content += paragraphs;
        }
    }

    /**
     * 删除与指定章节ID关联的所有派生数据。
     * @param chapterId - 源章节的ID
     */
    function deleteDerivedDataForChapter(chapterId: string) {
        plotItems.value = plotItems.value.filter(item => item.sourceChapterId !== chapterId);
        analysisItems.value = analysisItems.value.filter(item => item.sourceChapterId !== chapterId);
    }


    return {
        plotItems,
        analysisItems,
        createDerivedItem,
        findItemById,
        updateNodeContent,
        appendNodeContent,
        deleteDerivedDataForChapter,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// src/novel/editor/stores/directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { useDerivedContentStore } from './derivedContentStore';

type DirectoryNode = Volume | Chapter;

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);

    const _findNodeRecursive = (nodes: DirectoryNode[], nodeId: string): { node: DirectoryNode; parent: Volume | null; siblings: DirectoryNode[] } | null => {
        for (const node of nodes) {
            if (node.id === nodeId) {
                return { node, parent: null, siblings: nodes };
            }
            if (node.type === 'volume' && node.chapters) {
                const chapterResult = node.chapters.find(c => c.id === nodeId);
                if (chapterResult) {
                    return { node: chapterResult, parent: node, siblings: node.chapters };
                }
            }
        }
        return null;
    };

    const fetchDirectoryData = (data: Volume[]) => {
        directoryData.value = data;
    };

    const findNodeById = (nodeId: string) => {
        return _findNodeRecursive(directoryData.value, nodeId);
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result && (result.node.type === 'chapter' || result.node.type === 'volume')) {
            const item = result.node;
            item.content = content;

            if (item.type === 'chapter') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                item.wordCount = tempDiv.textContent?.trim().length || 0;
            }

            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== item.title) {
                item.title = newTitle;
            }
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            const chapter = result.node;
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            chapter.content += htmlToAppend;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = chapter.content;
            chapter.wordCount = tempDiv.textContent?.trim().length || 0;
        }
    };

    const addNewVolume = () => {
        const uiStore = useUIStore();
        const editorStore = useEditorStore();
        const newVolume: Volume = {
            id: `vol-${Date.now()}`,
            type: 'volume',
            title: '新建卷',
            content: `<h1>新建卷</h1>`,
            chapters: [],
        };
        directoryData.value.push(newVolume);
        editorStore.setEditingNodeId(newVolume.id);
        uiStore.toggleNodeExpansion(newVolume.id);
    };

    const addChapterToVolume = (volumeId: string) => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const editorStore = useEditorStore();
            const uiStore = useUIStore();
            const newChapter: Chapter = {
                id: `ch-${Date.now()}`,
                type: 'chapter',
                title: '新建章节',
                wordCount: 0,
                content: '<h1>新建章节</h1>',
                status: 'editing'
            };
            volume.chapters.push(newChapter);
            uiStore.toggleNodeExpansion(volume.id);
            editorStore.openTab(newChapter.id);
            editorStore.setEditingNodeId(newChapter.id);
        }
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const editorStore = useEditorStore();
        if (!newTitle.trim()) {
            editorStore.setEditingNodeId(null);
            return;
        }
        const result = findNodeById(nodeId);
        if (result?.node) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;
            // 同时更新卷和章节的content
            if (result.node.content) {
                if (result.node.content.includes('<h1>')) {
                    result.node.content = result.node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
                } else {
                    result.node.content = `<h1>${trimmedTitle}</h1>` + result.node.content;
                }
            }
        }
        editorStore.setEditingNodeId(null);
    };

    const deleteNode = (nodeId: string) => {
        const result = findNodeById(nodeId);
        if (!result) return;

        const editorStore = useEditorStore();
        const derivedContentStore = useDerivedContentStore();

        if (result.node.type === 'chapter') {
            derivedContentStore.deleteDerivedDataForChapter(result.node.id);
        }

        if (result.parent && result.node.type === 'chapter') {
            result.parent.chapters = result.parent.chapters.filter(c => c.id !== nodeId);
        } else if (!result.parent && result.node.type === 'volume') {
            result.node.chapters.forEach(chapter => {
                derivedContentStore.deleteDerivedDataForChapter(chapter.id);
            });
            directoryData.value = directoryData.value.filter(v => v.id !== nodeId);
        }
        editorStore.closeTab(nodeId);
        if (editorStore.editingNodeId === nodeId) editorStore.setEditingNodeId(null);
    };

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { usePaneStore, type EditorPane } from './modules/paneStore';
import { useTabStore } from './modules/tabStore';
import { useItemStore } from './modules/itemStore';
import { useSystemViewStore } from './modules/systemViewStore';
import { useMetadataStore } from './modules/metadataStore';
import { useUIStore } from './uiStore';
import type { TabInfo } from '@/novel/editor/types';

export { EditorPane };

export const useEditorStore = defineStore('editor-facade', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    const splitPane = (sourcePaneId: string) => {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    };

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        splitPane,
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab: tabStore.openTab,
        closeTab: tabStore.closeTab,
        findItemById: itemStore.findItemById,
        updateItemContentById: itemStore.updateItemContentById,
        appendContentToItem: itemStore.appendContentToItem,
        toggleAIPanel: systemViewStore.toggleAIPanel,
        ensureAIPanelIsOpen: systemViewStore.ensureAIPanelIsOpen,
        toggleHistoryPanel: systemViewStore.toggleHistoryPanel,
        openReaderView: systemViewStore.openReaderView,
        fetchNovelData: metadataStore.fetchNovelData,
        removeTag: metadataStore.removeTag,
        addTag: metadataStore.addTag,
        saveMetadata: metadataStore.saveMetadata,
        getTabsForPane,
        getActiveTabForPane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\itemStore.ts
//

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        // 1. Check for System Views
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = parts.length > 2 && (parts[1] === 'history') ? parts.slice(0, 2).join(':') : id;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                if (parts.length > 2 && (parts[1] === 'history')) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                return { node: systemView, source: 'system' };
            }
        }

        // 2. Check for AI Derived Items
        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) {
            return { node: derivedItem as PlotAnalysisItem, source: 'derived' };
        }

        // 3. Check Directory
        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        // 4. Check Related Content (Settings & Custom Items)
        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        // 5. Check Notes
        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\modules\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NovelMetadata } from '@/novel/editor/types';
import { mockNovelMetadata, mockDirectoryData, mockSettingsData, mockPlotCustomData, mockAnalysisCustomData, mockNoteData, mockOthersCustomData } from '@/novel/editor/data';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useUIStore } from '../uiStore';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);

    function fetchNovelData(novelId: string) {
        console.log(`Fetching data for novel: ${novelId}`);
        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();
        const uiStore = useUIStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        directoryStore.fetchDirectoryData(mockDirectoryData);
        relatedContentStore.fetchRelatedData(mockSettingsData, mockPlotCustomData, mockAnalysisCustomData, mockOthersCustomData);
        notesStore.fetchNotes(mockNoteData);
        novelMetadata.value = JSON.parse(JSON.stringify(mockNovelMetadata));

        paneStore.initializePanes();
        tabStore.openTab('ch-3');

        uiStore.uiState.expandedNodeIds.add('vol-1');
        uiStore.uiState.expandedRelatedNodeIds.add('setting');
        uiStore.uiState.expandedRelatedNodeIds.add('characters');
        uiStore.uiState.expandedRelatedNodeIds.add('plot');
        uiStore.uiState.expandedRelatedNodeIds.add('analysis');
        uiStore.uiState.expandedRelatedNodeIds.add('others');
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    function saveMetadata() {
        if (!novelMetadata.value) return;
        console.log('Saving metadata:', JSON.parse(JSON.stringify(novelMetadata.value)));
        alert('小说设置已保存！');
    }

    return {
        novelMetadata,
        fetchNovelData,
        removeTag,
        addTag,
        saveMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\systemViewStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useEditorStore } from '../editorStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const editorStore = useEditorStore();
        const activeItem = editorStore.activeTab?.item;
        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\tabStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            if (node?.type === 'volume' || node?.type === 'group') {
                uiStore.toggleNodeExpansion(itemId);
            } else if (node) {
                uiStore.toggleRelatedNodeExpansion(itemId);
            }
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//


import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);


    const fetchNotes = (data: NoteItem[]) => {
        notes.value = data;
    };

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;
            if (newTitle) {
                note.title = newTitle;
            }
        }
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if (!note.content) note.content = "";
            note.content += htmlToAppend;
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const uiStore = useUIStore();
        const note = findNoteById(noteId);
        if (note && newTitle.trim()) {
            const trimmedTitle = newTitle.trim();
            note.title = trimmedTitle;
            if (note.content.includes('<h1>')) {
                note.content = note.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            } else {
                note.content = `<h1>${trimmedTitle}</h1>` + note.content;
            }
        }
        uiStore.setEditingNodeId(null);
    };

    const addNote = (title: string, content: string = '') => {
        const editorStore = useEditorStore();
        const uiStore = useUIStore();
        const newNote: NoteItem = {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
        notes.value.unshift(newNote);
        editorStore.openTab(newNote.id);
        uiStore.setEditingNodeId(newNote.id);
    };

    const deleteNote = (noteId: string) => {
        const editorStore = useEditorStore();
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            notes.value.splice(index, 1);
            editorStore.closeTab(noteId);
        }
    };

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\itemDataStore.ts
//

// src/novel/editor/stores/modules/related/itemDataStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@novel/editor/types';

export const useItemDataStore = defineStore('related-item-data', () => {
    // 原始数据状态
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<TreeNode[]>([]);
    const analysisCustomData = ref<TreeNode[]>([]);
    const othersCustomData = ref<TreeNode[]>([]);

    /**
     * 从外部获取数据并填充 store
     * @param settings - 设定的树形数据
     * @param plot - 自定义剧情数据
     * @param analysis - 自定义分析数据
     * @param others - 其他自定义数据
     */
    function fetchRelatedData(settings: TreeNode[], plot: TreeNode[], analysis: TreeNode[], others: TreeNode[]) {
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
        othersCustomData.value = others;
    }

    return {
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        fetchRelatedData,
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\nodeOperationStore.ts
//

import { defineStore } from 'pinia';
import { useItemDataStore } from './itemDataStore.ts';
import { useTreeBuilderStore } from './treeBuilderStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// --- 辅助函数 ---

// 在给定的树中递归查找节点
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; siblings: TreeNode[] } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null, siblings: nodes };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// 在给定的树中查找并移除节点
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
}

export const useNodeOperationStore = defineStore('related-node-operations', () => {
    const itemDataStore = useItemDataStore();
    const treeBuilderStore = useTreeBuilderStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    /**
     * 在所有相关内容数据中查找节点
     * @param nodeId - 要查找的节点ID
     */
    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; siblings: TreeNode[] } | null {
        const staticSources = [
            itemDataStore.settingsData,
            itemDataStore.plotCustomData,
            itemDataStore.analysisCustomData,
            itemDataStore.othersCustomData
        ];
        for (const source of staticSources) {
            const result = _findNodeInTreeRecursive(source, nodeId);
            if (result) return result;
        }
        // 作为备用方案，在完整的动态树中搜索（用于查找派生内容等）
        return _findNodeInTreeRecursive(treeBuilderStore.relatedData as TreeNode[], nodeId);
    }

    /**
     * 更新节点内容
     * @param nodeId - 节点ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            (result.node as ItemNode).content = content;
            if (!result.node.isReadOnly) {
                const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
                const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
                if (newTitle && newTitle !== result.node.title) {
                    result.node.title = newTitle;
                }
            }
        }
    }

    /**
     * 向节点追加内容
     * @param nodeId - 节点ID
     * @param contentToAppend - 要追加的原始文本
     * @param isAutoApplied - 是否为AI自动应用
     */
    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            const itemNode = result.node as ItemNode;
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if (!itemNode.content) itemNode.content = "";
            itemNode.content += htmlToAppend;
        }
    }

    /**
     * 在设定的分组下添加新节点（分组或条目）
     * @param parentId - 父节点ID
     * @param type - 'group' 或 'item'
     */
    function addRelatedNode(parentId: string, type: 'group' | 'item') {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return;

        const parentNode = result.node as GroupNode;

        const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
        const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
        const newNodeIcon = getIconByNodeType(newNodeType);

        if (type === 'group') {
            const newNode: GroupNode = {
                id: `group-${Date.now()}`,
                title: '新建分组',
                type: 'group',
                icon: newNodeIcon,
                children: [],
            };
            parentNode.children.push(newNode);
            uiStore.setEditingNodeId(newNode.id);
        } else { // type === 'item'
            const newNode: ItemNode = {
                id: `item-${Date.now()}`,
                title: '新建条目',
                type: newNodeType as ItemNode['type'],
                icon: newNodeIcon,
                content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
            };
            parentNode.children.push(newNode);
            uiStore.setEditingNodeId(newNode.id);
            editorStore.openTab(newNode.id);
        }

        uiStore.ensureRelatedNodeIsExpanded(parentId);
    }

    /**
     * 重命名设定节点
     * @param nodeId - 节点ID
     * @param newTitle - 新标题
     */
    function renameRelatedNode(nodeId: string, newTitle: string) {
        if (!newTitle.trim()) {
            uiStore.setEditingNodeId(null);
            return;
        }
        const result = findNodeById(nodeId);
        if (result?.node && !result.node.isReadOnly) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;
            if ('content' in result.node && result.node.content && result.node.content.includes('<h1>')) {
                (result.node as ItemNode).content = (result.node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            }
        }
        uiStore.setEditingNodeId(null);
    }

    /**
     * 删除设定节点
     * @param nodeId - 节点ID
     */
    function deleteRelatedNode(nodeId: string) {
        const result = findNodeById(nodeId);
        if (!result?.node) return;

        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.settingsData, nodeId);
        if (wasRemoved) {
            editorStore.closeTab(nodeId);
            if (uiStore.editingNodeId === nodeId) uiStore.setEditingNodeId(null);
        }
    }

    // --- Custom Related (Plot/Analysis) ---

    function addCustomRelatedNode(target: 'plot' | 'analysis') {
        const dataRef = target === 'plot' ? itemDataStore.plotCustomData : itemDataStore.analysisCustomData;
        const icon = getIconByNodeType(`${target}_item`);
        const newNode: ItemNode = {
            id: `custom-${target}-${Date.now()}`,
            title: '新建自定义条目',
            type: `${target}_item`,
            icon: icon,
            content: '<h1>新建自定义条目</h1><p>请在此处填写内容...</p>',
        };
        dataRef.unshift(newNode);
        uiStore.ensureRelatedNodeIsExpanded(target);
        uiStore.setEditingNodeId(newNode.id);
        editorStore.openTab(newNode.id);
    }

    function renameCustomRelatedNode(nodeId: string, newTitle: string) {
        renameRelatedNode(nodeId, newTitle);
    }

    function deleteCustomRelatedNode(nodeId: string) {
        const result = findNodeById(nodeId);
        if (!result?.node) return;

        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.plotCustomData, nodeId) || _findAndRemoveNodeInTree(itemDataStore.analysisCustomData, nodeId);

        if (wasRemoved) {
            editorStore.closeTab(nodeId);
            if (uiStore.editingNodeId === nodeId) uiStore.setEditingNodeId(null);
        }
    }

    // --- Custom Others ---

    function addCustomOthersNode() {
        const icon = getIconByNodeType('others_item');
        const newNode: ItemNode = {
            id: `custom-others-${Date.now()}`,
            title: '新建其他条目',
            type: 'others_item',
            icon: icon,
            content: '<h1>新建其他条目</h1><p>请在此处填写内容...</p>',
        };
        itemDataStore.othersCustomData.unshift(newNode);
        uiStore.ensureRelatedNodeIsExpanded('others');
        uiStore.setEditingNodeId(newNode.id);
        editorStore.openTab(newNode.id);
    }

    function renameCustomOthersNode(nodeId: string, newTitle: string) {
        renameRelatedNode(nodeId, newTitle);
    }

    function deleteCustomOthersNode(nodeId: string) {
        const result = findNodeById(nodeId);
        if (!result?.node) return;

        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.othersCustomData, nodeId);

        if (wasRemoved) {
            editorStore.closeTab(nodeId);
            if (uiStore.editingNodeId === nodeId) uiStore.setEditingNodeId(null);
        }
    }

    return {
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\overviewStore.ts
//

// src/novel/editor/stores/modules/related/overviewStore.ts
import { defineStore } from 'pinia';
import { watch } from 'vue';
import { useItemDataStore } from './itemDataStore.ts';
import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 这个 store 专门用于管理和更新“总览”节点的内容。
 * 它通过 watch 监听 settingsData 的变化，自动重新生成总览。
 */
export const useOverviewStore = defineStore('related-overview', () => {
    const itemDataStore = useItemDataStore();

    /**
     * 更新单个分组节点下的总览内容。
     * @param groupNode - 包含总览节点的父分组节点。
     */
    function updateOverviewContent(groupNode: GroupNode) {
        if (!groupNode.children) return;

        const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
        if (!overviewNode) return;

        // 筛选出需要被汇总的普通条目
        const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

        // 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
        const demoteHeadings = (htmlContent: string): string => {
            if (typeof document === 'undefined') return htmlContent; // Guard for SSR
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            // 将 h1, h2, h3 等标题降级
            const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
            headings.forEach(heading => {
                const level = parseInt(heading.tagName.charAt(1), 10);
                const newLevel = Math.min(6, level + 1); // 最多降到 h6
                const newHeading = document.createElement(`h${newLevel}`);
                newHeading.innerHTML = heading.innerHTML;
                for (const attr of heading.attributes) {
                    newHeading.setAttribute(attr.name, attr.value);
                }
                heading.parentNode?.replaceChild(newHeading, heading);
            });
            return tempDiv.innerHTML;
        };

        // 拼接所有条目的内容
        const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

        // 更新总览节点的内容
        overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
    }

    /**
     * 遍历整个设定树，更新所有找到的总览节点。
     */
    function updateAllOverviewContent() {
        const findAndProcess = (nodes: TreeNode[]) => {
            for (const node of nodes) {
                if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                    updateOverviewContent(node as GroupNode);
                }
                if (node.children) {
                    findAndProcess(node.children);
                }
            }
        };
        findAndProcess(itemDataStore.settingsData);
    }

    // 监听原始数据变化，自动更新总览
    watch(
        () => itemDataStore.settingsData,
        () => {
            updateAllOverviewContent();
        },
        { deep: true, immediate: true } // immediate确保初始化时也能执行
    );

    // 这个 store 主要通过 watch effect 工作，所以返回空对象
    return {};
});

// =
// 文件: ..\src\novel\editor\stores\related\treeBuilderStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { useItemDataStore } from './itemDataStore.ts';
import { useDirectoryStore } from '@novel/editor/stores/directoryStore.ts';
import { useDerivedContentStore } from '@novel/editor/stores/derivedContentStore.ts';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem } from '@novel/editor/types';

export const useTreeBuilderStore = defineStore('related-tree-builder', () => {
    const itemDataStore = useItemDataStore();
    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();

    /**
     * 响应式地构建完整的相关内容树，供UI使用
     */
    const relatedData = computed((): TreeNode[] => {
        // 清理无效的派生数据
        const allChapterIds = new Set(directoryStore.directoryData.flatMap(v => v.chapters.map(c => c.id)));
        derivedContentStore.plotItems = derivedContentStore.plotItems.filter(i => allChapterIds.has(i.sourceChapterId));
        derivedContentStore.analysisItems = derivedContentStore.analysisItems.filter(i => allChapterIds.has(i.sourceChapterId));

        // 辅助函数，用于构建派生内容的子树
        const buildDerivedTree = (
            type: 'plot' | 'analysis',
            dataArray: PlotAnalysisItem[]
        ): TreeNode[] => {
            return directoryStore.directoryData.map(volume => ({
                id: `${type}_vol_${volume.id}`,
                title: volume.title,
                type: 'group',
                icon: getIconByNodeType('volume'),
                isReadOnly: true,
                children: volume.chapters
                    .map(chapter => {
                        const derivedForChapter = dataArray.filter(item => item.sourceChapterId === chapter.id);
                        if (derivedForChapter.length === 0) return null;

                        return {
                            id: `${type}_ch_group_${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            isReadOnly: true,
                            children: derivedForChapter.map(item => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item`,
                                icon: getIconByNodeType(`${type}_item`),
                                originalData: item,
                                content: item.content
                            }))
                        };
                    })
                    .filter((c): c is TreeNode => c !== null)
            })).filter(vol => vol.children.length > 0);
        };

        // 构建各个根节点
        const plotTree: RootNode = {
            id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
            children: [...itemDataStore.plotCustomData, ...buildDerivedTree('plot', derivedContentStore.plotItems)]
        };
        const analysisTree: RootNode = {
            id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
            children: [...itemDataStore.analysisCustomData, ...buildDerivedTree('analysis', derivedContentStore.analysisItems)]
        };
        const othersTree: RootNode = {
            id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
            children: [...itemDataStore.othersCustomData]
        };

        // 组合并返回最终的树结构
        return [...itemDataStore.settingsData, plotTree, analysisTree, othersTree];
    });

    return {
        relatedData,
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//


import { defineStore } from 'pinia';
import { computed } from 'vue';
import { useItemDataStore } from '@novel/editor/stores/related/itemDataStore';
import { useTreeBuilderStore } from '@novel/editor/stores/related/treeBuilderStore';
import { useNodeOperationStore } from '@novel/editor/stores/related/nodeOperationStore';
import { useOverviewStore } from '@novel/editor/stores/related/overviewStore';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    // 实例化所有子模块
    const itemDataStore = useItemDataStore();
    const treeBuilderStore = useTreeBuilderStore();
    const nodeOperationStore = useNodeOperationStore();

    // 初始化总览内容的监听逻辑
    useOverviewStore();

    // --- State & Computed ---
    // 从子模块中导出状态和计算属性
    const settingsData = computed(() => itemDataStore.settingsData);
    const plotCustomData = computed(() => itemDataStore.plotCustomData);
    const analysisCustomData = computed(() => itemDataStore.analysisCustomData);
    const othersCustomData = computed(() => itemDataStore.othersCustomData);
    const relatedData = computed(() => treeBuilderStore.relatedData);

    // --- Actions ---
    // 从子模块中导出所有方法，保持接口不变
    const { fetchRelatedData } = itemDataStore;
    const {
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    } = nodeOperationStore;

    return {
        // State & Computed
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        // Actions
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    const performSearch = (query: string) => {
        results.value = [];
        hasSearched.value = true;
        lastSearchedQuery.value = query;

        if (!query || query.trim().length < 1) {
            return;
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            if (lowerCaseText.includes(lowerCaseQuery)) {
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }

                const result = resultsMap.get(item.id)!;
                const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
                let match;
                while ((match = regex.exec(textContent)) !== null) {
                    if (result.matches.length >= 5) break; // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    result.matches.push({ context: `...${context}...` });
                }
            }
        };

        directoryStore.directoryData.forEach(vol => vol.chapters.forEach(processItem));

        const flattenRelated = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenRelated(node.children);
            });
        };
        flattenRelated(relatedContentStore.settingsData);
        flattenRelated(relatedContentStore.plotCustomData);
        flattenRelated(relatedContentStore.analysisCustomData);

        notesStore.notes.forEach(processItem);

        results.value = Array.from(resultsMap.values());
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3, // 新增：默认并发数为3
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\app.ts
//

import type { TreeNode, Volume, Chapter, NoteItem, PlotAnalysisItem } from './models';

/**
 * AI 任务状态
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'applied';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string; // 新增：源文档标题快照
    sourceItemContent: string; // 新增：源文档内容快照
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string; // 此处targetItemId即为sourceItemId
    title: string;
}

/**
 * 上下文预设或已选择的条目
 */
export interface ContextItem {
    id:string;
    category: '设定' | '其他';
    group: string;
    title:string;
    description: string;
    content: string;
}

/**
 * buildContextForTask 方法的返回结果
 */
export interface ContextBuildResult {
    fixed: string;
    dynamic: string;
    rag: string;
    prompt: string;
    stats: {
        fixedCharCount: number;
        dynamicCharCount: number;
        ragCharCount: number;
        promptCharCount: number;
    };
}

/**
 * 动态上下文的配置项
 */
export interface DynamicContextSettings {
    prevChapters: number;
    nextChapters: number;
    includeRelatedPlot: boolean;
    includeRelatedAnalysis: boolean;
}

/**
 * 编辑器UI状态
 * 用于定义 uiStore 中的 uiState
 */
export interface EditorUIState {
    expandedNodeIds: Set<string>;
    expandedRelatedNodeIds: Set<string>;
    autoOpenAIPanel: boolean;
    activeTheme: 'default' | 'eye-care' | 'dark';
    concurrentTaskLimit: number;
    taskApplicationStrategy: {
        mode: 'manual' | 'auto' | 'delayed';
        delaySeconds: number;
    };
}

/**
 * 编辑器窗格定义
 */
export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

/**
 * 系统视图信息，用于在内容区打开非文件类标签页
 */
export interface SystemViewInfo {
    id: string; // e.g., 'system:search'
    type: 'system';
    component: 'SearchView' | 'AIChatView' | 'AITaskPanel' | 'EditorSettings' | 'ContextSettings' | 'TaskSettings' | 'AIConfigSettings' | 'NovelSettings' | 'HistoryPanel' | 'ReaderPanel' | 'ThemeSettings';
    title: string;
    icon: string;
    content?: null; // 系统视图没有 content 属性
    targetItemId?: string; // For dynamic views like history
}

/**
 * 任意可被编辑器打开的条目
 * 这是一个辨识联合类型，涵盖了所有可能在标签页中打开的内容。
 */
export type EditorItem = Volume | Chapter | TreeNode | NoteItem | SystemViewInfo | PlotAnalysisItem;

/**
 * 搜索结果条目
 */
export interface SearchResult {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
    matches: { context: string }[];
}

/**
 * 标签页信息
 */
export interface TabInfo {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//


export * from './models';
export * from './app';
export * from './chatTypes';
export * from './ui';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// src/novel/editor/types/models.ts


/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceChapterId: string; // 源章节ID, e.g., 'ch-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode;

// =
// 文件: ..\src\novel\editor\types\ui.ts
//



/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: src/novel/editor/utils/iconUtils.ts

const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\editor\views\EditorWorkspaceView.vue
//

<template>
  <div class="editor-workspace-view">
    <div class="main-area">
      <ActivityBar
          :active-tab-id="activeActivityBarTab"
          :is-sidebar-visible="isSidebarVisible"
          @select-tab="handleSelectActivityTab"
          @trigger-action="handleTriggerAction"
          @show-manage-menu="showManageMenu"
      />
      <template v-if="isSidebarVisible">
        <div class="sidebar-wrapper" :style="{ width: sidebarPanelWidth + 'px' }">
          <SidebarPanel :active-tab-id="activeActivityBarTab" />
        </div>
        <div class="resizer" @mousedown.prevent="startResize"></div>
      </template>

      <MainPane />
    </div>
    <StatusBar />
    <ManageMenu ref="manageMenuRef" @select-action="handleMenuAction" />
  </div>
</template>
<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ActivityBar from '@/novel/editor/components/layout/ActivityBar.vue';
import SidebarPanel from '@/novel/editor/components/sidebar/SidebarPanel.vue';
import MainPane from '@/novel/editor/components/content/MainPane.vue';
import StatusBar from '@/novel/editor/components/layout/StatusBar.vue';
import ManageMenu from '@/novel/editor/components/layout/ManageMenu.vue';

type ActivityTabId = 'directory' | 'related' | 'notes';
type ActionId = 'system:search' | 'system:ai_chat' | string;

const editorStore = useEditorStore();
const uiStore = useUIStore();

const activeActivityBarTab = ref<ActivityTabId | null>('directory');
const isSidebarVisible = ref(true);
const manageMenuRef = ref<InstanceType<typeof ManageMenu> | null>(null);

// --- Resizing Logic ---
const sidebarPanelWidth = ref(320);
const isResizing = ref(false);

const startResize = (event: MouseEvent) => {
  isResizing.value = true;
  const startWidth = sidebarPanelWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    if (!isResizing.value) return;
    const dx = e.clientX - startX;
    const newWidth = startWidth + dx;
    sidebarPanelWidth.value = Math.max(240, Math.min(newWidth, 600));
  };

  const stopResize = () => {
    isResizing.value = false;
    window.removeEventListener('mousemove', handleResize);
    window.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  };

  window.addEventListener('mousemove', handleResize);
  window.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

const handleSelectActivityTab = (tabId: ActivityTabId) => {
  if (activeActivityBarTab.value === tabId && isSidebarVisible.value) {
    isSidebarVisible.value = false;
    activeActivityBarTab.value = null;
  } else {
    isSidebarVisible.value = true;
    activeActivityBarTab.value = tabId;
  }
};

const handleTriggerAction = (actionId: ActionId) => {
  editorStore.openTab(actionId);
}

const showManageMenu = (event: MouseEvent) => {
  manageMenuRef.value?.show(event.currentTarget as HTMLElement);
};

const handleMenuAction = (actionId: ActionId) => {
  if (actionId.startsWith('system:')) {
    editorStore.openTab(actionId);
  } else {
    // Handle other menu actions like 'keyboard_shortcuts' etc.
    alert(`Action '${actionId}' selected. Implementation pending.`);
  }
};

onMounted(() => {
  editorStore.fetchNovelData('default-novel');
});

onBeforeUnmount(() => {
  // A safeguard to ensure listeners are removed if component is unmounted during resize
  if (isResizing.value) {
    const emptyFn = () => {};
    window.removeEventListener('mousemove', emptyFn);
    window.removeEventListener('mouseup', emptyFn);
  }
});
</script>
<style scoped>
.editor-workspace-view {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background-color: #F9FAFB;
}
.main-area {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
}
.sidebar-wrapper {
  flex-shrink: 0;
  height: 100%;
}
.resizer {
  width: 5px;
  background-color: transparent;
  cursor: col-resize;
  flex-shrink: 0;
  position: relative;
  transition: background-color 0.2s ease;
}
.resizer:hover {
  background-color: #3B82F6;
}
.resizer::before {
  content: '';
  position: absolute;
  left: 2px;
  top: 0;
  width: 1px;
  height: 100%;
  background-color: #E5E7EB;
}
.resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\novel\editor\views\ReaderModeOverlay.vue
//

<template>
  <div v-if="isVisible" class="reader-overlay-container" :class="themeClass">
    <header class="reader-header">
      <button @click="uiStore.hideReaderMode()" class="back-button">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M15 19l-7-7 7-7"></path></svg>
        <span>返回编辑器</span>
      </button>
    </header>
    <main class="reader-main">
      <div v-if="item && 'content' in item" class="max-w-3xl mx-auto reader-content" v-html="item.content">
      </div>
      <div v-else class="max-w-3xl mx-auto text-center py-20 text-gray-500">
        <h1 class="text-2xl font-bold mb-4">无法加载阅读内容</h1>
        <p>此内容不支持阅读模式，或文档不存在。</p>
      </div>
    </main>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';

const uiStore = useUIStore();

const isVisible = computed(() => uiStore.isReaderModeVisible);
const item = computed(() => uiStore.readerModeItem);

const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

</script>

<style scoped>
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&display=swap');

.reader-overlay-container {
  position: fixed;
  inset: 0;
  z-index: 2000;
  background-color: #FDFCF9;
  color: #3a2f2f;
  display: flex;
  flex-direction: column;
  font-family: 'Noto Serif SC', serif;
}

.reader-header {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: 1rem 1.5rem;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  z-index: 10;
}

.reader-overlay-container:hover .reader-header {
  opacity: 1;
}

.back-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-weight: 500;
  background-color: rgba(255, 255, 255, 0.6);
  backdrop-filter: blur(8px);
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  border: 1px solid #E5E7EB;
  color: #374151;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: rgba(255, 255, 255, 0.9);
}

.reader-main {
  flex-grow: 1;
  overflow-y: auto;
  padding: 4rem 1rem;
}

:deep(.reader-content h1) {
  font-family: 'Noto Serif SC', serif;
  font-size: 2.25rem;
  font-weight: 600;
  margin-bottom: 2.5rem;
  color: #1f2937;
  letter-spacing: 0.05em;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(0,0,0,0.05);
  text-align: center;
}
:deep(.reader-content p) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.125rem;
  line-height: 2.2;
  color: #374151;
  margin-bottom: 1.75rem;
  text-align: justify;
}

.theme-dark {
  background-color: #18181b;
  color: #e4e4e7;
}

.theme-dark .back-button {
  background-color: rgba(39, 39, 42, 0.6);
  border-color: #3f3f46;
  color: #e4e4e7;
}

.theme-dark .back-button:hover {
  background-color: rgba(39, 39, 42, 0.9);
}

:deep(.theme-dark .reader-content h1) {
  color: #f4f4f5;
  border-bottom-color: rgba(255,255,255,0.1);
}

:deep(.theme-dark .reader-content p) {
  color: #d4d4d8;
}

</style>

// =
// 文件: ..\src\novel\editor\views\SearchView.vue
//

<template>
  <div class="search-view-container">
    <div class="search-header">
      <div class="search-bar">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            v-model="searchStore.searchQuery"
            type="text"
            placeholder="在所有文档中搜索..."
            class="search-input"
        />
        <button v-if="searchStore.searchQuery" @click="searchStore.clearSearch" class="clear-button" title="清空搜索">
          <i class="fa-solid fa-times"></i>
        </button>
      </div>
    </div>

    <div class="results-container">
      <div v-if="searchStore.results.length > 0">
        <div v-for="result in searchStore.results" :key="result.id" class="result-group">
          <div @click="toggleExpansion(result.id)" class="result-header">
            <div class="flex items-center gap-3 min-w-0">
              <i class="fa-solid fa-chevron-right expand-icon" :class="{ 'expanded': expandedResultIds.has(result.id) }"></i>
              <i :class="[result.icon, 'text-base']"></i>
              <span class="font-medium truncate">{{ result.title }}</span>
            </div>
            <span class="match-count">{{ result.matches.length }}个匹配</span>
          </div>
          <ul v-show="expandedResultIds.has(result.id)" class="match-list">
            <li
                v-for="(match, index) in result.matches"
                :key="index"
                @click="handleResultClick(result.id)"
                class="match-item"
                v-html="match.context"
            >
            </li>
          </ul>
        </div>
      </div>
      <div v-else-if="searchStore.hasSearched" class="empty-state">
        <i class="fa-regular fa-face-sad-tear text-4xl text-gray-400"></i>
        <p class="mt-4 text-gray-500">未找到与 "{{ searchStore.lastSearchedQuery }}" 相关的内容。</p>
      </div>
      <div v-else class="empty-state">
        <i class="fa-solid fa-text-slash text-4xl text-gray-300"></i>
        <p class="mt-4 text-gray-500">输入关键词开始搜索。</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { useSearchStore } from '@novel/editor/stores/searchStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';

const searchStore = useSearchStore();
const editorStore = useEditorStore();
const expandedResultIds = ref(new Set<string>());

let debounceTimer: number | undefined;

watch(() => searchStore.searchQuery, (newQuery) => {
  clearTimeout(debounceTimer);
  if (!newQuery.trim()) {
    searchStore.clearSearch();
    return;
  }
  debounceTimer = window.setTimeout(() => {
    expandedResultIds.value.clear(); // Clear old expansions
    searchStore.performSearch(newQuery);
    // Do not auto-expand results to match the new UI. Let the user decide.
  }, 300); // 300ms debounce delay
});

const handleResultClick = (itemId: string) => {
  editorStore.openTab(itemId);
};

const toggleExpansion = (resultId: string) => {
  if (expandedResultIds.value.has(resultId)) {
    expandedResultIds.value.delete(resultId);
  } else {
    expandedResultIds.value.add(resultId);
  }
};
</script>

<style scoped>
.search-view-container { display: flex; flex-direction: column; height: 100%; background-color: #FFFFFF; }
.search-header { display: flex; gap: 0.75rem; padding: 1.5rem 2rem; border-bottom: 1px solid #E5E7EB; flex-shrink: 0; align-items: center; }
.search-bar { position: relative; flex-grow: 1; }
.search-icon { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; }
.search-input { width: 100%; background-color: #F9FAFB; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.75rem 2.5rem 0.75rem 2.75rem; font-size: 1rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; background-color: #FFFFFF; box-shadow: 0 0 0 1px #3B82F6; }
.clear-button { position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; border-radius: 99px; cursor: pointer; }
.clear-button:hover { background-color: #E5E7EB; color: #4B5563; }
.results-container { flex-grow: 1; overflow-y: auto; padding: 1.5rem 2rem; }
.result-group { margin-bottom: 0.75rem; }
.result-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; background-color: #F9FAFB; transition: background-color 0.2s; }
.result-header:hover { background-color: #F3F4F6; }
.expand-icon { transition: transform 0.2s ease; color: #9CA3AF; }
.expand-icon.expanded { transform: rotate(90deg); }
.match-count { margin-left: auto; font-size: 0.75rem; background-color: #E5E7EB; color: #4B5563; padding: 0.125rem 0.5rem; border-radius: 99px; flex-shrink: 0; }
.match-list { padding-left: 2rem; margin-top: 0.5rem; border-left: 1px solid #F3F4F6; margin-left: 0.9rem; }
.match-item { font-size: 0.875rem; color: #6B7280; padding: 0.6rem; border-radius: 0.375rem; cursor: pointer; line-height: 1.6; }
.match-item:hover { background-color: #F3F4F6; color: #1F2937; }
.match-item :deep(mark) { background-color: #FEF3C7; color: #92400E; font-weight: 600; padding: 1px 0; border-radius: 2px; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 2rem; }
.results-container { scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.results-container::-webkit-scrollbar { width: 6px; }
.results-container::-webkit-scrollbar-track { background: transparent; }
.results-container::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
</style>

