// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\core\components\CommandPalette.vue
//

<template>
  <div v-if="isVisible" class="palette-overlay" @click="store.hide">
    <div class="palette-container" @click.stop>
      <div class="search-wrapper">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            ref="searchInput"
            v-model="searchQuery"
            type="text"
            placeholder="Type a command"
            class="search-input"
            @keydown.down.prevent="store.navigate(1)"
            @keydown.up.prevent="store.navigate(-1)"
            @keydown.enter.prevent="commandPaletteService.executeSelected()"
        />
      </div>
      <ul class="results-list">
        <li
            v-for="(command, index) in filteredCommands"
            :key="command.id"
            :class="{ 'selected': index === selectedIndex }"
            @click="commandPaletteService.executeCommand(command.id)"
            @mouseenter="store.setSelectedIndex(index)"
        >
          <i v-if="command.icon" :class="[command.icon, 'command-icon']"></i>
          <span>{{ command.label }}</span>
        </li>
        <li v-if="filteredCommands.length === 0" class="no-results">
          No matching commands
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, onMounted, onUnmounted } from 'vue';
import { useCommandPaletteStore } from '@/core/stores/commandPaletteStore';
import { commandPaletteService } from '@/core/services/CommandPaletteService';
import { storeToRefs } from 'pinia';

const store = useCommandPaletteStore();
const { isVisible, searchQuery, filteredCommands, selectedIndex } = storeToRefs(store);

const searchInput = ref<HTMLInputElement | null>(null);

watch(isVisible, (newValue) => {
  if (newValue) {
    nextTick(() => {
      searchInput.value?.focus();
    });
  }
});

const handleGlobalKey = (e: KeyboardEvent) => {
  if (e.key === 'Escape' && isVisible.value) {
    store.hide();
  }
}

onMounted(() => window.addEventListener('keydown', handleGlobalKey));
onUnmounted(() => window.removeEventListener('keydown', handleGlobalKey));
</script>

<style scoped>
.palette-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  display: flex;
  justify-content: center;
  padding-top: 15vh;
}
.palette-container {
  width: 100%;
  max-width: 600px;
  background-color: white;
  border-radius: 0.75rem;
  box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: min-content;
  max-height: 70vh;
}
.search-wrapper {
  position: relative;
  border-bottom: 1px solid #e5e7eb;
  padding: 0.75rem;
}
.search-icon {
  position: absolute;
  left: 1.5rem;
  top: 50%;
  transform: translateY(-50%);
  color: #9ca3af;
}
.search-input {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem 1rem 0.75rem 2.5rem;
  border: none;
  outline: none;
  background: transparent;
}
.results-list {
  overflow-y: auto;
  padding: 0.5rem;
}
.results-list li {
  padding: 0.75rem 1rem;
  border-radius: 0.375rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}
.results-list li.selected {
  background-color: #3B82F6;
  color: white;
}
.no-results {
  color: #9ca3af;
  text-align: center;
  padding: 2rem;
  cursor: default;
}
</style>

// =
// 文件: ..\src\core\components\ContextMenu.vue
//

<template>
  <div
      v-if="isVisible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
      @contextmenu.prevent
  >
    <ul class="menu-list">
      <template v-for="item in items" :key="item.id">
        <li v-if="item.isDivider" class="menu-divider"></li>
        <li
            v-else
            :class="['menu-item', { 'disabled': item.isDisabled }]"
            @click.prevent="contextMenuService.execute(item)"
        >
          <i v-if="item.icon" :class="[item.icon, 'menu-icon']"></i>
          <span>{{ item.label }}</span>
        </li>
      </template>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { onMounted, onBeforeUnmount } from 'vue';
import { storeToRefs } from 'pinia';
import { useContextMenuStore } from '@/core/stores/contextMenuStore';
import { contextMenuService } from '@/core/services/ContextMenuService';

const contextMenuStore = useContextMenuStore();
const { isVisible, position, items } = storeToRefs(contextMenuStore);

const handleClickOutside = () => contextMenuStore.hideMenu();

onMounted(() => window.addEventListener('click', handleClickOutside));
onBeforeUnmount(() => window.removeEventListener('click', handleClickOutside));
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
.menu-list { list-style: none; padding: 0; margin: 0; }
.menu-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  color: #374151;
  cursor: pointer;
  user-select: none;
}
.menu-item:not(.disabled):hover { background-color: #f3f4f6; }
.menu-item.disabled { color: #9ca3af; cursor: not-allowed; }
.menu-icon { width: 1rem; text-align: center; color: #6B7280; }
.menu-item:not(.disabled):hover .menu-icon { color: #374151; }
.menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\core\components\ErrorDisplay.vue
//

<!-- 文件: src/core/components/ErrorDisplay.vue -->
<template>
  <div class="error-display-container">
    <i class="fa-solid fa-circle-exclamation error-icon"></i>
    <h3 class="error-title">Failed to Load Content</h3>
    <p class="error-message">{{ message }}</p>
    <p class="error-suggestion">
      You can try to <a href="#" @click.prevent="reload">reload</a> the item or close this tab.
    </p>
  </div>
</template>

<script setup lang="ts">
defineProps({
  message: {
    type: String,
    required: true,
  },
});

const emit = defineEmits(['reload']);

const reload = () => {
  emit('reload');
};
</script>

<style scoped>
.error-display-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 2rem;
  text-align: center;
  user-select: none;
  background-color: #FFFFFF;
}
.error-icon {
  font-size: 3rem;
  color: #F87171;
}
.error-title {
  font-size: 1.25rem;
  font-weight: 500;
  color: #4B5563;
  margin-top: 1.5rem;
}
.error-message {
  color: #6B7280;
  margin-top: 0.5rem;
  max-width: 500px;
}
.error-suggestion {
  color: #9CA3AF;
  margin-top: 1.5rem;
  font-size: 0.875rem;
}
.error-suggestion a {
  color: #3B82F6;
  text-decoration: none;
}
.error-suggestion a:hover {
  text-decoration: underline;
}
</style>

// =
// 文件: ..\src\core\components\MainPane.vue
//

<!-- 文件: src/core/components/MainPane.vue -->
<template>
  <div class="main-pane-container">
    <PaneNodeRenderer v-if="root" :node="root" />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import PaneNodeRenderer from './PaneNodeRenderer.vue';

const paneStore = usePaneStore();
const root = computed(() => paneStore.root);
</script>

<style scoped>
.main-pane-container {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  background-color: #F3F4F6;
}
</style>

// =
// 文件: ..\src\core\components\PaneInstance.vue
//

<template>
  <div class="pane-instance-container" @click="paneManagementService.setActivePane(pane.id)">
    <TabBar :tabs="tabsForPane" :active-tab-id="pane.activeTabId" :pane-id="pane.id" :is-active-pane="isActive" />
    <div class="content-area">
      <div v-if="isLoading" class="loading-screen">
        <p>Loading...</p>
      </div>
      <ErrorDisplay
          v-else-if="loadingError"
          :message="loadingError"
          @reload="reloadContent"
      />
      <template v-else-if="activeCoreItem && activeTab">
        <component
            :is="resolvedView"
            :key="activeTab.id"
            :tab="activeTab"
            :item="activeCoreItem"
        />
      </template>
      <WelcomeScreen v-else />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, toRef, type PropType } from 'vue';
import { useTabStore } from '@/core/stores/tabStore';
import { usePaneContent } from '@/core/composables/usePaneContent';
import { paneManagementService } from '@/core/services/PaneManagementService';
import type { LeafPaneNode, Tab } from '@/core/types';
import TabBar from './TabBar.vue';
import WelcomeScreen from './WelcomeScreen.vue';
import ErrorDisplay from './ErrorDisplay.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<LeafPaneNode>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  },
});

const tabStore = useTabStore();

const {
  activeTab,
  activeCoreItem,
  isLoading,
  loadingError,
  resolvedView,
  reloadContent,
} = usePaneContent(toRef(props, 'pane'));

const tabsForPane = computed((): Tab[] => {
  return tabStore.getTabsForPane(props.pane.id);
});
</script>

<style scoped>
.pane-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  border-left: 1px solid #E5E7EB;
}
.pane-instance-container:first-child {
  border-left: none;
}
.content-area {
  flex-grow: 1;
  overflow: auto;
  position: relative;
}
.loading-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #9CA3AF;
  user-select: none;
}
</style>

// =
// 文件: ..\src\core\components\PaneNodeRenderer.vue
//

<template>
  <template v-if="node">
    <PaneInstance
        v-if="node.type === 'leaf'"
        :pane="node"
        :is-active="node.id === paneStore.activePaneId"
        class="pane-instance"
    />
    <div
        v-else-if="node.type === 'split'"
        class="split-pane-container"
        :style="{ flexDirection: node.direction === 'horizontal' ? 'row' : 'column' }"
    >
      <template v-for="(child, index) in node.children" :key="child.id">
        <PaneNodeRenderer
            :node="child"
            :style="{ flexBasis: `${node.sizes[index]}%` }"
            class="pane-node-renderer"
        />
        <div
            v-if="index < node.children.length - 1"
            class="pane-resizer"
            :class="node.direction"
            @mousedown.prevent="startResize($event, index)"
        ></div>
      </template>
    </div>
  </template>
</template>

<script setup lang="ts">
import { type PropType, toRef } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { usePaneResizer } from '@/core/composables/usePaneResizer';
import type { PaneNode } from '@/core/types';
import PaneInstance from './PaneInstance.vue';

const props = defineProps({
  node: {
    type: Object as PropType<PaneNode>,
    required: true,
  },
});

const paneStore = usePaneStore();

const { startResize } = usePaneResizer(
    toRef(props, 'node')
);

</script>

<style scoped>
.split-pane-container {
  display: flex;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.pane-node-renderer {
  min-width: 0;
  min-height: 0;
  overflow: hidden;
}
.pane-resizer {
  flex-shrink: 0;
  background-color: transparent;
  transition: background-color 0.2s ease;
  z-index: 5;
  position: relative;
}
.pane-resizer.horizontal {
  width: 5px;
  cursor: col-resize;
}
.pane-resizer.vertical {
  height: 5px;
  cursor: row-resize;
}
.pane-resizer:hover {
  background-color: #3B82F6;
}
.pane-resizer.horizontal::before {
  content: ''; position: absolute; left: 2px; top: 0; width: 1px;
  height: 100%; background-color: #E5E7EB;
}
.pane-resizer.vertical::before {
  content: ''; position: absolute; top: 2px; left: 0; height: 1px;
  width: 100%; background-color: #E5E7EB;
}
.pane-resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\core\components\TabBar.vue
//

<template>
  <div class="tab-bar-container">
    <div
        v-for="tab in tabs"
        :key="tab.id"
        class="tab-item"
        :class="{ 'active': tab.id === activeTabId, 'inactive-pane-tab': !isActivePane }"
        @click.stop="tabManagementService.activateTab(tab.id)"
    >
      <i :class="[tab.icon, 'tab-icon']"></i>
      <span class="tab-title">{{ tab.title }}</span>
      <div class="close-icon-wrapper">
        <i
            v-if="!tab.isDirty"
            class="fa-solid fa-times close-icon"
            @click.stop="tabManagementService.closeTab(tab.id)"
        ></i>
        <div v-else class="dirty-indicator" @click.stop="tabManagementService.closeTab(tab.id)"></div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from 'vue';
import { tabManagementService } from '@/core/services/TabManagementService';
import type { Tab } from '@/core/types';

defineProps({
  tabs: { type: Array as PropType<Tab[]>, required: true },
  activeTabId: { type: String as PropType<string | null>, required: true },
  paneId: { type: String, required: true },
  isActivePane: { type: Boolean, required: true },
});
</script>

<style scoped>
.tab-bar-container {
  display: flex; flex-shrink: 0; background-color: #F3F4F6;
  border-bottom: 1px solid #E5E7EB; padding-top: 0.5rem; padding-left: 0.5rem;
  overflow-x: auto;
}
.tab-item {
  display: flex; align-items: center; padding: 0.6rem 0.5rem 0.6rem 1rem;
  font-size: 0.875rem; color: #6B7280; cursor: pointer;
  border: 1px solid transparent; border-bottom: none;
  border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem;
  background-color: #E5E7EB; white-space: nowrap; transition: background-color 0.2s, color 0.2s;
}
.tab-item:not(:first-child) { margin-left: -1px; }
.tab-item:hover { background-color: #FFFFFF; }
.tab-item.active {
  background-color: #FFFFFF; color: #1F2937;
  border-color: #E5E7EB; z-index: 2; margin-bottom: -1px;
  padding-bottom: calc(0.6rem + 1px);
}
.inactive-pane-tab { background-color: #F3F4F6; color: #9CA3AF; }
.inactive-pane-tab:hover { background-color: #E5E7EB; }
.inactive-pane-tab.active { background-color: #F9FAFB; color: #6B7280; }
.tab-icon { margin-right: 0.5rem; }
.active .tab-icon { color: #3B82F6; }
.inactive-pane-tab.active .tab-icon { color: inherit; }
.tab-title { max-width: 150px; overflow: hidden; text-overflow: ellipsis; }

.close-icon-wrapper {
  margin-left: 0.75rem;
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 99px;
  flex-shrink: 0;
}
.close-icon {
  font-size: 0.8rem;
  opacity: 0.5;
  transition: all 0.2s;
  padding: 0.25rem;
}
.tab-item:hover .close-icon { opacity: 1; }
.close-icon:hover { background-color: #E5E7EB; border-radius: 99px; }

.dirty-indicator {
  width: 0.5rem;
  height: 0.5rem;
  background-color: #6B7280;
  border-radius: 99px;
  transition: all 0.2s;
}
.tab-item:hover .dirty-indicator {
  background-color: transparent;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%236B7280'%3E%3Cpath d='M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z'/%3E%3C/svg%3E");
  background-size: 100% 100%;
  width: 1rem;
  height: 1rem;
}
</style>

// =
// 文件: ..\src\core\components\WelcomeScreen.vue
//

<!-- 文件: src/core/components/WelcomeScreen.vue -->
<!-- 描述: 空窗格的欢迎界面，提供更友好的用户体验。 -->
<template>
  <div class="welcome-screen">
    <i class="fa-solid fa-feather-pointed welcome-icon"></i>
    <h1 class="welcome-title">Editor Core</h1>
    <p class="welcome-subtitle">Select a file from the sidebar to begin.</p>
  </div>
</template>

<style scoped>
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
  background-color: #FFFFFF;
}
.welcome-icon {
  font-size: 4rem; /* 64px */
  color: #E5E7EB; /* gray-200 */
}
.welcome-title {
  font-size: 1.5rem; /* 24px */
  font-weight: 500;
  color: #4B5563; /* gray-600 */
  margin-top: 1.5rem;
}
.welcome-subtitle {
  color: #9CA3AF; /* gray-400 */
  margin-top: 0.5rem;
}
</style>

// =
// 文件: ..\src\core\components\layout\CoreLayout.vue
//

<template>
  <div class="core-layout-container" :class="{'sidebar-hidden': !isSidebarVisible}">
    <div class="activity-bar-area">
      <slot name="activity-bar"></slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-area" :style="{ width: `${sidebarWidth}px` }">
      <slot name="sidebar">
        <SidebarPanel />
      </slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-resizer" @mousedown="startResizeWrapper"></div>

    <div class="main-content-area">
      <MainPane />
    </div>

    <div class="status-bar-area">
      <slot name="status-bar"></slot>
    </div>

    <div class="global-components-area">
      <slot name="global">
        <NotificationCenter />
        <CommandPalette />
        <ContextMenu />
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted, onUnmounted } from 'vue';
import { useLayoutStore } from '@/core/stores/layoutStore';
import { storeToRefs } from 'pinia';
import type { EditorKernel } from '@/core/services/EditorKernel';
import { useResizable } from '@/core/composables/useResizable';

import MainPane from '../MainPane.vue';
import SidebarPanel from './SidebarPanel.vue';
import NotificationCenter from './NotificationCenter.vue';
import CommandPalette from '../CommandPalette.vue';
import ContextMenu from '../ContextMenu.vue';

const props = defineProps<{
  kernel: EditorKernel;
}>();

const layoutStore = useLayoutStore();
const { isSidebarVisible, sidebarWidth } = storeToRefs(layoutStore);

onMounted(() => {
  props.kernel.startup();
});

onUnmounted(() => {
  props.kernel.shutdown();
});

let initialWidth = 0;
const { startResize } = useResizable({
  onResize: ({ dx }) => {
    layoutStore.setSidebarWidth(initialWidth + dx);
  },
});

const startResizeWrapper = (event: MouseEvent) => {
  initialWidth = sidebarWidth.value;
  startResize(event);
};
</script>

<style scoped>
.core-layout-container {
  display: flex; height: 100%; width: 100%; overflow: hidden; background-color: #FFFFFF;
}
.activity-bar-area, .sidebar-area { flex-shrink: 0; height: 100%; }
.activity-bar-area { z-index: 20; border-right: 1px solid #E5E7EB; }
.sidebar-area { z-index: 10; border-right: 1px solid #E5E7EB; }
.sidebar-resizer {
  width: 5px; background-color: transparent; cursor: col-resize; flex-shrink: 0;
  position: relative; z-index: 15;
}
.sidebar-resizer:hover { background-color: #3B82F6; }
.main-content-area {
  flex-grow: 1; display: flex; flex-direction: column; min-width: 0;
  position: relative;
}
.status-bar-area {
  position: relative; z-index: 20; flex-shrink: 0;
  height: 28px; border-top: 1px solid #E5E7EB;
  background-color: #F3F4F6;
}
.global-components-area > :deep(*) {
  pointer-events: all;
}
.global-components-area {
  position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 9999; pointer-events: none;
}
</style>

// =
// 文件: ..\src\core\components\layout\NotificationCenter.vue
//

<template>
  <div class="notification-center">
    <transition-group name="notification-fade" tag="div">
      <div
          v-for="notification in notifications"
          :key="notification.id"
          :class="['notification-toast', `notification-${notification.type}`]"
          @click="notificationStore.remove(notification.id)"
      >
        <span class="message">{{ notification.message }}</span>
      </div>
    </transition-group>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useNotificationStore } from '@/core/stores/notificationStore';

const notificationStore = useNotificationStore();
const notifications = computed(() => notificationStore.notifications);
</script>

<style scoped>
.notification-center {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  pointer-events: all; /* Re-enable pointer events for toasts */
}
.notification-toast {
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  cursor: pointer;
  color: white;
  font-weight: 500;
  transition: all 0.3s ease;
}
.notification-info { background-color: #3B82F6; }
.notification-success { background-color: #16A34A; }
.notification-warning { background-color: #F59E0B; }
.notification-error { background-color: #DC2626; }

.notification-fade-enter-active,
.notification-fade-leave-active {
  transition: opacity 0.5s, transform 0.5s;
}
.notification-fade-enter-from,
.notification-fade-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>

// =
// 文件: ..\src\core\components\layout\SidebarPanel.vue
//


<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <!-- The title can be passed down via a slot or a prop -->
      <slot name="header">
        <h3 class="title">Sidebar</h3>
      </slot>
    </div>
    <div class="content">
      <slot>
        <!-- Default content if no content is provided by the app -->
        <div class="p-4 text-sm text-gray-500">
          This is the default sidebar content.
        </div>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}
.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F0F0F0;
  flex-shrink: 0;
}
.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}
.content {
  flex-grow: 1;
  position: relative;
  overflow: auto;
}
</style>

// =
// 文件: ..\src\core\composables\useEditableView.ts
//

// 文件: src/core/composables/useEditableView.ts

import { onMounted, onUnmounted, watch, ref, computed, type Ref } from 'vue';
import { activeEditorService } from '@/core/services/ActiveEditorService';
import { useTabStore } from '@/core/stores/tabStore';
import { useNotificationStore } from '@/core/stores/notificationStore';
import type { CoreItem, Tab } from '@/core/types';

interface UseEditableViewOptions {
    tab: Ref<Tab>;
    coreItem: Ref<CoreItem>;
    content: Ref<string>;
}

export function useEditableView({ tab, coreItem, content }: UseEditableViewOptions) {
    const tabStore = useTabStore();
    const notificationStore = useNotificationStore();
    const initialContent = ref('');

    const isDirty = computed(() => initialContent.value !== content.value);

    const initializeContent = () => {
        const newInitialContent = coreItem.value.metadata?.content || '';
        initialContent.value = newInitialContent;
        if (content.value !== newInitialContent) {
            content.value = newInitialContent;
        }
    };

    onMounted(() => {
        initializeContent();

        activeEditorService.register(tab.value.id, {
            getContent: () => content.value,
            setContent: (newContent: string) => {
                content.value = newContent;
                initialContent.value = newContent; // Mark as saved by resetting the baseline
            },
        });
    });

    onUnmounted(() => {
        activeEditorService.unregister(tab.value.id);
    });

    watch(isDirty, (newValue) => {
        tabStore.updateTabState(tab.value.id, { isDirty: newValue });
    });

    // This watcher handles cases where the underlying file is changed externally
    // (e.g., git pull, external editor save) and reloaded.
    watch(() => coreItem.value.metadata?.content, (newContent) => {
        if (newContent !== undefined && content.value !== newContent) {
            if (isDirty.value) {
                // If the editor has unsaved changes, do not overwrite them.
                // Instead, notify the user about the conflict.
                notificationStore.add(
                    `'${tab.value.title}' has been modified on disk. Your version has unsaved changes.`,
                    'warning',
                    0 // Persistent notification
                );
            } else {
                // The editor is clean, so it's safe to update the content.
                initializeContent();
            }
        }
    });

    return {
        isDirty,
    };
}

// =
// 文件: ..\src\core\composables\usePaneContent.ts
//


import { ref, computed, watch, type Ref } from 'vue';
import { useTabStore } from '@/core/stores/tabStore';
import { viewRegistry } from '@/core/services/ViewRegistry';
import { tabManagementService } from '@/core/services/TabManagementService';
import type { LeafPaneNode, CoreItem, Tab } from '@/core/types';

export function usePaneContent(pane: Ref<LeafPaneNode>) {
    const tabStore = useTabStore();

    const activeCoreItem = ref<CoreItem | null>(null);
    const isLoading = ref(false);
    const loadingError = ref<string | null>(null);

    const activeTab = computed((): Tab | undefined => {
        return pane.value.activeTabId ? tabStore.getTabById(pane.value.activeTabId) : undefined;
    });

    const resolvedView = computed(() => {
        if (activeCoreItem.value?.viewType) {
            return viewRegistry.resolve(activeCoreItem.value.viewType);
        }
        return null;
    });

    const loadContentForTab = async (tabId: string | null) => {
        if (!tabId) {
            activeCoreItem.value = null;
            isLoading.value = false;
            loadingError.value = null;
            return;
        }

        isLoading.value = true;
        loadingError.value = null;
        activeCoreItem.value = null;

        try {
            const item = await tabManagementService.loadCoreItemForTab(tabId);
            if (pane.value.activeTabId === tabId) {
                activeCoreItem.value = item;
                if (!item) {
                    loadingError.value = "The associated item could not be found. It might have been deleted.";
                }
            }
        } catch (error: any) {
            console.error(`Failed to load content for tab ${tabId}`, error);
            if (pane.value.activeTabId === tabId) {
                loadingError.value = error.message || 'An unknown error occurred.';
            }
        } finally {
            if (pane.value.activeTabId === tabId) {
                isLoading.value = false;
            }
        }
    };

    const reloadContent = () => {
        loadContentForTab(pane.value.activeTabId);
    };

    watch(
        () => pane.value.activeTabId,
        (newTabId) => {
            loadContentForTab(newTabId);
        },
        { immediate: true }
    );

    return {
        activeTab,
        activeCoreItem,
        isLoading,
        loadingError,
        resolvedView,
        reloadContent,
    };
}

// =
// 文件: ..\src\core\composables\usePaneResizer.ts
//

import { type Ref } from 'vue';
import { useResizable } from '@/core/composables/useResizable';
import { paneManagementService } from '@/core/services/PaneManagementService';
import { configService } from '@/core/services/ConfigService';
import type { SplitPaneNode, PaneNode } from '@/core/types';

export function usePaneResizer(nodeRef: Ref<PaneNode | undefined>) {

    let initialSizes: number[] = [];
    let totalSize = 0;
    let activeIndex = 0;
    let container: HTMLElement | null = null;
    let firstElement: HTMLElement | null = null;
    let secondElement: HTMLElement | null = null;

    const { startResize: start } = useResizable({
        cursor: (nodeRef.value as SplitPaneNode)?.direction === 'horizontal' ? 'col-resize' : 'row-resize',
        onResize: ({ dx, dy }) => {
            const node = nodeRef.value;
            if (!node || node.type !== 'split') return;

            const delta = node.direction === 'horizontal' ? dx : dy;
            const deltaPercent = (delta / totalSize) * 100;

            const newSizes = [...initialSizes];
            newSizes[activeIndex] += deltaPercent;
            newSizes[activeIndex + 1] -= deltaPercent;

            const minSize = configService.get('pane.resizer.minSize', 10);
            if (newSizes[activeIndex] < minSize || newSizes[activeIndex + 1] < minSize) {
                return;
            }

            paneManagementService.updatePaneNodeSize(node.id, newSizes);
        }
    });

    const startResize = (event: MouseEvent, index: number) => {
        const node = nodeRef.value;
        if (!node || node.type !== 'split') return;

        container = (event.currentTarget as HTMLElement).parentElement;
        if (!container) return;

        firstElement = container.children[index * 2] as HTMLElement;
        secondElement = container.children[index * 2 + 2] as HTMLElement;
        if (!firstElement || !secondElement) return;

        activeIndex = index;
        initialSizes = [...node.sizes];
        totalSize = node.direction === 'horizontal'
            ? firstElement.offsetWidth + secondElement.offsetWidth
            : firstElement.offsetHeight + secondElement.offsetHeight;

        start(event);
    };

    return {
        startResize,
    };
}

// =
// 文件: ..\src\core\composables\useResizable.ts
//

// 文件: src/core/composables/useResizable.ts
// 描述: 一个可复用的 Vue Composable，用于处理元素拖拽调整大小的逻辑。

import { onUnmounted } from 'vue';

interface ResizableOptions {
    onResize: (delta: { dx: number; dy: number }) => void;
    onResizeEnd?: () => void;
    cursor?: 'col-resize' | 'row-resize';
}

export function useResizable(options: ResizableOptions) {
    const { onResize, onResizeEnd, cursor = 'col-resize' } = options;
    let startX = 0;
    let startY = 0;

    const handleMouseMove = (e: MouseEvent) => {
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        onResize({ dx, dy });
    };

    const handleMouseUp = () => {
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        onResizeEnd?.();
    };

    const startResize = (event: MouseEvent) => {
        event.preventDefault();
        startX = event.clientX;
        startY = event.clientY;

        document.body.style.cursor = cursor;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    };

    onUnmounted(() => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    });

    return {
        startResize,
    };
}

// =
// 文件: ..\src\core\constants.ts
//

export const CoreEvent = {
    STATE_CHANGED: 'core:state-changed',
    PANE_INITIALIZED: 'core:pane.initialized',
    PANE_ACTIVATED: 'core:pane.activated',
    PANE_SPLITTED: 'core:pane.splitted',
    PANE_CLOSED: 'core:pane.closed',
    TAB_OPENED: 'core:tab.opened',
    TAB_CLOSED: 'core:tab.closed',
    TAB_ACTIVATED: 'core:tab.activated',
    TAB_STATE_CHANGED: 'core:tab.stateChanged',
} as const;

export const CoreContext = {
    PANE_IS_SPLIT: 'pane.isSplit',
} as const;

export const CoreCommand = {
    PANE_SPLIT_HORIZONTAL: 'core.pane.split-horizontal',
    PANE_SPLIT_VERTICAL: 'core.pane.split-vertical',
    PANE_CLOSE: 'core.pane.close',
    SAVE_TAB: 'core.saveTab',
    COMMAND_PALETTE_SHOW: 'core.commandPalette.show',
} as const;

// =
// 文件: ..\src\core\features\command-palette\palette.commands.ts
//

import type { CommandService } from '@/core/services/CommandService';
import { commandPaletteService } from '@/core/services/CommandPaletteService';
import { CoreCommand } from '@/core/constants';

export function registerPaletteCommands(commandService: CommandService) {
    commandService.register({
        id: CoreCommand.COMMAND_PALETTE_SHOW,
        label: 'View: Show Command Palette',
        execute: () => {
            commandPaletteService.show();
        },
    });
}

// =
// 文件: ..\src\core\features\command-palette\palette.keybindings.ts
//

import type { KeybindingService } from '@/core/services/KeybindingService';
import { CoreCommand } from '@/core/constants';

export function registerPaletteKeybindings(keybindingService: KeybindingService) {
    keybindingService.register({
        key: 'ctrl+shift+p',
        commandId: CoreCommand.COMMAND_PALETTE_SHOW,
    });
}

// =
// 文件: ..\src\core\features\command-palette\palette.module.ts
//

import { commandService } from "@/core/services/CommandService";
import { keybindingService } from "@/core/services/KeybindingService";
import { registerPaletteCommands } from "./palette.commands";
import { registerPaletteKeybindings } from "./palette.keybindings";

export class CommandPaletteModule {
    public install(): void {
        registerPaletteCommands(commandService);
        registerPaletteKeybindings(keybindingService);
    }
}

// =
// 文件: ..\src\core\features\file-operations\file.commands.ts
//

import type { CommandService } from '@/core/services/CommandService';
import type { ItemProvider } from '@/core/types';
import { usePaneStore } from '@/core/stores/paneStore';
import { useTabStore } from '@/core/stores/tabStore';
import { useNotificationStore } from '@/core/stores/notificationStore';
import { activeEditorService } from '@/core/services/ActiveEditorService';
import { CoreCommand } from '@/core/constants';

export function registerFileCommands(commandService: CommandService, itemProvider: ItemProvider) {
    const tabStore = useTabStore();
    const paneStore = usePaneStore();
    const notificationStore = useNotificationStore();

    commandService.register({
        id: CoreCommand.SAVE_TAB,
        label: 'File: Save',
        icon: 'fa-solid fa-save',
        when: (context) => {
            const tabId = context?.tabId || paneStore.activePane?.activeTabId;
            if (!tabId) return false;
            const tab = tabStore.getTabById(tabId);
            return tab?.isDirty || false;
        },
        execute: async (context) => {
            const tabId = context?.tabId || paneStore.activePane?.activeTabId;
            if (!tabId) return;

            const tab = tabStore.getTabById(tabId);
            if (!tab || !tab.isDirty) return;

            const content = activeEditorService.getContent(tabId);
            if (content === null) return;

            try {
                await itemProvider.updateItem(tab.itemId, content);
                activeEditorService.setContent(tabId, content);
                notificationStore.add(`'${tab.title}' saved.`, 'success', 2000);
            } catch (error) {
                console.error(`Failed to save item ${tab.itemId}`, error);
                notificationStore.add(`Error saving '${tab.title}'.`, 'error');
            }
        },
    });
}

// =
// 文件: ..\src\core\features\file-operations\file.keybindings.ts
//

import type { KeybindingService } from '@/core/services/KeybindingService';
import { CoreCommand } from '@/core/constants';

export function registerFileKeybindings(keybindingService: KeybindingService) {
    keybindingService.register({
        key: 'ctrl+s',
        commandId: CoreCommand.SAVE_TAB,
    });
}

// =
// 文件: ..\src\core\features\file-operations\file.module.ts
//

import { commandService } from "@/core/services/CommandService";
import { keybindingService } from "@/core/services/KeybindingService";
import type { ItemProvider } from "@/core/types";
import { registerFileCommands } from "./file.commands";
import { registerFileKeybindings } from "./file.keybindings";

export class FileOperationsModule {
    public install(itemProvider: ItemProvider): void {
        registerFileCommands(commandService, itemProvider);
        registerFileKeybindings(keybindingService);
    }
}

// =
// 文件: ..\src\core\features\pane-management\pane.commands.ts
//

import { usePaneStore } from '@/core/stores/paneStore';
import { tabManagementService } from '@/core/services/TabManagementService';
import { paneManagementService } from '@/core/services/PaneManagementService';
import type { CommandService } from '@/core/services/CommandService';
import { CoreCommand, CoreContext } from '@/core/constants';

export function registerPaneCommands(commandService: CommandService) {
    const paneStore = usePaneStore();

    commandService.register({
        id: CoreCommand.PANE_SPLIT_HORIZONTAL,
        label: 'Pane: Split Horizontal',
        icon: 'fa-solid fa-columns',
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (paneId) paneManagementService.splitPane(paneId, 'horizontal');
        },
    });

    commandService.register({
        id: CoreCommand.PANE_SPLIT_VERTICAL,
        label: 'Pane: Split Vertical',
        icon: 'fa-solid fa-grip-lines',
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (paneId) paneManagementService.splitPane(paneId, 'vertical');
        },
    });

    commandService.register({
        id: CoreCommand.PANE_CLOSE,
        label: 'Pane: Close Pane',
        icon: 'fa-solid fa-xmark',
        when: CoreContext.PANE_IS_SPLIT,
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (!paneId) return;

            const orphanedTabIds = paneManagementService.closePane(paneId);

            if (orphanedTabIds && orphanedTabIds.length > 0) {
                const targetPaneId = paneStore.activePaneId;
                if (targetPaneId) {
                    orphanedTabIds.forEach(tabId => {
                        paneManagementService.addTabToPane(tabId, targetPaneId);
                    });
                    paneManagementService.setActiveTab(targetPaneId, orphanedTabIds[0]);
                } else {
                    // Edge case: No panes left. Close the tabs.
                    orphanedTabIds.forEach(tabId => tabManagementService.closeTab(tabId));
                }
            }
        },
    });
}

// =
// 文件: ..\src\core\features\pane-management\pane.contexts.ts
//

import { watch } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { contextService } from '@/core/services/ContextService';
import { CoreContext } from '@/core/constants';

export function initializePaneContexts() {
    const paneStore = usePaneStore();

    const updateContext = () => {
        const isSplit = (paneStore.root?.type ?? 'leaf') === 'split';
        contextService.set(CoreContext.PANE_IS_SPLIT, isSplit);
    };

    watch(() => paneStore.root, updateContext, { immediate: true, deep: true });
}

// =
// 文件: ..\src\core\features\pane-management\pane.module.ts
//

import { commandService } from "@/core/services/CommandService";
import { registerPaneCommands } from "./pane.commands";
import { initializePaneContexts } from "./pane.contexts";

export class PaneManagementModule {
    public install(): void {
        registerPaneCommands(commandService);
        initializePaneContexts();
    }
}

// =
// 文件: ..\src\core\services\ActiveEditorService.ts
//

// 文件: src/core/services/ActiveEditorService.ts

interface EditorAPI {
    getContent: () => string;
    setContent: (newContent: string) => void;
}

class ActiveEditorService {
    // The key is now the unique Tab ID, not the Item ID.
    private activeEditors: Map<string, EditorAPI> = new Map();

    public register(tabId: string, api: EditorAPI): void {
        this.activeEditors.set(tabId, api);
    }

    public unregister(tabId: string): void {
        this.activeEditors.delete(tabId);
    }

    public getContent(tabId: string): string | null {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.getContent === 'function') {
            return editor.getContent();
        }
        return null;
    }

    public setContent(tabId: string, newContent: string): boolean {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.setContent === 'function') {
            editor.setContent(newContent);
            return true;
        }
        return false;
    }
}

export const activeEditorService = new ActiveEditorService();

// =
// 文件: ..\src\core\services\CommandPaletteService.ts
//

import { useCommandPaletteStore, type PaletteCommand } from '@/core/stores/commandPaletteStore';
import { commandService } from '@/core/services/CommandService';

class CommandPaletteService {
    public show(): void {
        const commandPaletteStore = useCommandPaletteStore();

        const availableCommands: PaletteCommand[] = [];
        for (const command of commandService.getAllCommands()) {
            if (commandService.canExecute(command.id)) {
                const label = typeof command.label === 'function' ? command.label({}) : command.label;
                availableCommands.push({
                    id: command.id,
                    label: label,
                    icon: command.icon
                });
            }
        }

        commandPaletteStore._setCommands(availableCommands);
        commandPaletteStore.show();
    }

    public executeSelected(): void {
        const store = useCommandPaletteStore();
        const command = store.filteredCommands[store.selectedIndex];
        if (command) {
            this.executeCommand(command.id);
        }
    }

    public executeCommand(commandId: string): void {
        const store = useCommandPaletteStore();
        commandService.execute(commandId);
        store.hide();
    }
}

export const commandPaletteService = new CommandPaletteService();

// =
// 文件: ..\src\core\services\CommandService.ts
//

// 文件: src/core/services/CommandService.ts

import type { Command, CommandContext } from '@/core/types';
import { usePaneStore } from '@/core/stores/paneStore';
import { contextService } from './ContextService';

export class CommandService {
    private commands: Map<string, Command> = new Map();

    public register(command: Command): void {
        if (this.commands.has(command.id)) {
            console.warn(`[CommandService] Command "${command.id}" is already registered. Overwriting.`);
        }
        this.commands.set(command.id, command);
    }

    public find(commandId: string): Command | undefined {
        return this.commands.get(commandId);
    }

    private getGlobalContext(): CommandContext {
        const paneStore = usePaneStore();
        return {
            activePaneId: paneStore.activePaneId,
            activeTabId: paneStore.activePane?.activeTabId,
        };
    }

    public canExecute(commandId: string, specificContext?: CommandContext): boolean {
        const command = this.find(commandId);
        if (!command) return false;

        const context = { ...this.getGlobalContext(), ...specificContext };

        if (typeof command.when === 'string') {
            return contextService.check(command.when);
        }
        if (typeof command.when === 'function') {
            return command.when(context);
        }

        return true;
    }

    public execute(commandId: string, specificContext?: CommandContext): void {
        if (!this.canExecute(commandId, specificContext)) {
            console.warn(`[CommandService] Execution of command "${commandId}" was prevented by its 'when' condition.`);
            return;
        }

        const command = this.find(commandId);
        if (!command) {
            console.error(`[CommandService] Command "${commandId}" not found.`);
            return;
        }

        const context = { ...this.getGlobalContext(), ...specificContext };
        command.execute(context);
    }

    public *getAllCommands() {
        for (const command of this.commands.values()) {
            yield command;
        }
    }
}

export const commandService = new CommandService();

// =
// 文件: ..\src\core\services\ConfigService.ts
//

// 文件: src/core/services/ConfigService.ts
// 描述: 全局配置服务，允许应用层覆盖内核的默认行为。

class ConfigService {
    private config: Map<string, any> = new Map();

    /**
     * 设置一个配置项。
     * 应用层在初始化时调用此方法来注入自定义配置。
     * @param key - 配置项的键 (e.g., 'pane.minWidth')。
     * @param value - 配置项的值。
     */
    public set(key: string, value: any): void {
        this.config.set(key, value);
    }

    /**
     * 获取一个配置项。
     * 如果配置未被设置，则返回提供的默认值。
     * @param key - 配置项的键。
     * @param defaultValue - 当找不到键时返回的默认值。
     * @returns 配置项的值或默认值。
     */
    public get<T>(key: string, defaultValue: T): T {
        if (this.config.has(key)) {
            return this.config.get(key) as T;
        }
        return defaultValue;
    }
}

// 导出一个单例，确保整个应用共享同一个配置服务。
export const configService = new ConfigService();

// =
// 文件: ..\src\core\services\ContextMenuService.ts
//

import type { ContextMenuItem, CommandContext, Command, ProcessedMenuItem } from '@/core/types';
import { useContextMenuStore } from '@/core/stores/contextMenuStore';
import { commandService } from './CommandService';

type ContextMenuProvider = (context: CommandContext) => ContextMenuItem[];

class ContextMenuService {
    private providers: Map<string, ContextMenuProvider[]> = new Map();

    public registerProvider(contextType: string, provider: ContextMenuProvider): void {
        if (!this.providers.has(contextType)) {
            this.providers.set(contextType, []);
        }
        this.providers.get(contextType)!.push(provider);
    }

    private getItemsForContext(contextType: string, context: CommandContext): ContextMenuItem[] {
        const providers = this.providers.get(contextType) || [];
        let allItems: ContextMenuItem[] = [];

        providers.forEach((provider, index) => {
            const items = provider(context);
            if (items.length > 0) {
                if (index > 0 && allItems.length > 0 && !allItems[allItems.length - 1].isDivider) {
                    allItems.push({ commandId: `divider-${index}`, isDivider: true });
                }
                allItems = allItems.concat(items);
            }
        });

        return allItems;
    }

    public show(event: MouseEvent, contextType: string, context: CommandContext): void {
        event.preventDefault();
        event.stopPropagation();

        const contextMenuStore = useContextMenuStore();
        const rawItems = this.getItemsForContext(contextType, context);

        if (rawItems.length === 0) {
            contextMenuStore.hideMenu();
            return;
        }

        const processedItems = this.processItems(rawItems);

        if (processedItems.length > 0) {
            contextMenuStore.showMenu(event, processedItems);
        } else {
            contextMenuStore.hideMenu();
        }
    }

    public execute(item: ProcessedMenuItem): void {
        if (!item.isDisabled) {
            commandService.execute(item.command.id, item.context);
            useContextMenuStore().hideMenu();
        }
    }

    private processItems(items: ContextMenuItem[]): ProcessedMenuItem[] {
        return items.map((item, index) => {
            if (item.isDivider) {
                return { id: `d-${index}`, isDivider: true, isDisabled: true, label: '', command: {} as Command, context: undefined };
            }
            const command = commandService.find(item.commandId);
            const isDisabled = !command || !commandService.canExecute(item.commandId, item.context);
            const label = command
                ? (typeof command.label === 'function' ? command.label({ ...item.context }) : command.label)
                : 'Unknown Command';

            return {
                id: `${item.commandId}-${index}`,
                isDivider: false,
                isDisabled,
                label,
                icon: command?.icon,
                command: command!,
                context: item.context,
            };
        });
    }
}

export const contextMenuService = new ContextMenuService();

// =
// 文件: ..\src\core\services\ContextService.ts
//

// 文件: src/core/services/ContextService.ts
// 描述: 一个新的服务，用于管理和广播响应式的UI上下文状态。

import { reactive } from 'vue';

type ContextValue = boolean | string | number;

class ContextService {
    private contextState: Map<string, ContextValue> = reactive(new Map());

    constructor() {
        this.contextState.set('alwaysTrue', true); // A default context for commands without a 'when' clause
    }

    /**
     * 设置一个上下文键的值。
     * @param key - 上下文键 (e.g., 'editorFocus', 'isReadOnly').
     * @param value - 上下文的值.
     */
    public set(key: string, value: ContextValue): void {
        if (this.contextState.get(key) !== value) {
            this.contextState.set(key, value);
        }
    }

    /**
     * 获取一个上下文键的值。
     * @param key - 上下文键。
     * @returns The value of the context key, or undefined if not set.
     */
    public get(key: string): ContextValue | undefined {
        return this.contextState.get(key);
    }

    /**
     * 检查一个基于字符串的 'when' 表达式是否为真。
     * 目前仅支持 '&&', '||', '!', '==', '!=' 和键名。
     * @param when - The when clause string, e.g., "editorFocus && !isReadOnly".
     * @returns True if the expression evaluates to true, false otherwise.
     */
    public check(when: string): boolean {
        try {
            const keys = Array.from(this.contextState.keys());
            // This is a safer alternative to eval(). It creates a function where
            // context keys are arguments, preventing access to the global scope.
            const func = new Function(...keys, `return !!(${when});`);
            const values = keys.map(key => this.contextState.get(key));
            return func(...values);
        } catch (error) {
            console.error(`[ContextService] Error evaluating 'when' clause: "${when}"`, error);
            return false;
        }
    }
}

export const contextService = new ContextService();

// =
// 文件: ..\src\core\services\EditorKernel.ts
//

import type { ItemProvider } from '@/core/types/providers';
import { usePaneStore } from '@/core/stores/paneStore';
import { keybindingService } from './KeybindingService';
import { workspaceService } from './WorkspaceService';
import { tabManagementService } from './TabManagementService';
import { PaneManagementModule } from '../features/pane-management/pane.module';
import { FileOperationsModule } from '../features/file-operations/file.module';
import { CommandPaletteModule } from '../features/command-palette/palette.module';

export class EditorKernel {
    private itemProvider: ItemProvider;

    constructor(provider: ItemProvider) {
        this.itemProvider = provider;
    }

    public async startup(): Promise<void> {
        console.log('[EditorKernel] Starting up...');

        this.setupServices();
        this.registerCoreModules();

        keybindingService.initialize();
        workspaceService.initialize();
        workspaceService.loadAndHydrateStores();
        usePaneStore().initializePanes();

        console.log('[EditorKernel] Startup complete.');
    }

    public shutdown(): void {
        keybindingService.destroy();
        workspaceService.destroy();
        console.log('[EditorKernel] Shutdown complete.');
    }

    private setupServices(): void {
        tabManagementService.setItemProvider(this.itemProvider);
    }

    private registerCoreModules(): void {
        new PaneManagementModule().install();
        new FileOperationsModule().install(this.itemProvider);
        new CommandPaletteModule().install();
    }
}

// =
// 文件: ..\src\core\services\EventBusService.ts
//

// 文件: src/core/services/EventBusService.ts
// 描述: 一个轻量级的全局事件总线，用于实现模块间的解耦通信。

type EventHandler = (payload?: any) => void;

class EventBusService {
    private events: Map<string, EventHandler[]> = new Map();

    /**
     * 订阅一个事件。
     * @param eventName - 事件名称 (e.g., 'core:tab.opened')。
     * @param handler - 事件处理函数。
     */
    public on(eventName: string, handler: EventHandler): void {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }
        this.events.get(eventName)!.push(handler);
    }

    /**
     * 取消订阅一个事件。
     * @param eventName - 事件名称。
     * @param handler - 要移除的事件处理函数。
     */
    public off(eventName: string, handler: EventHandler): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }

    /**
     * 触发一个事件，通知所有订阅者。
     * @param eventName - 事件名称。
     * @param payload - （可选）随事件传递的数据。
     */
    public emit(eventName: string, payload?: any): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            // 创建副本以防在处理过程中有订阅/取消订阅操作
            [...handlers].forEach(handler => handler(payload));
        }
    }
}

// 导出一个单例，确保整个应用共享同一个事件总线。
export const eventBus = new EventBusService();

// =
// 文件: ..\src\core\services\KeybindingService.ts
//

import { commandService } from './CommandService';

interface Keybinding {
    key: string;
    commandId: string;
    when?: () => boolean; // Optional, specific condition for this keybinding
}

class KeybindingService {
    private keybindings: Map<string, Keybinding> = new Map();

    public initialize(): void {
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
    }

    public destroy(): void {
        window.removeEventListener('keydown', this.handleKeyDown.bind(this));
    }

    public register(keybinding: Keybinding): void {
        const key = this.normalizeKey(keybinding.key);
        this.keybindings.set(key, keybinding);
    }

    private handleKeyDown(event: KeyboardEvent): void {
        const key = this.eventToKey(event);
        const binding = this.keybindings.get(key);

        if (binding) {
            // Check both the keybinding's specific 'when' and the command's global 'when'
            const isKeybindingConditionMet = !binding.when || binding.when();
            const isCommandConditionMet = commandService.canExecute(binding.commandId);

            if (isKeybindingConditionMet && isCommandConditionMet) {
                event.preventDefault();
                event.stopPropagation();
                commandService.execute(binding.commandId);
            }
        }
    }

    private normalizeKey(key: string): string {
        const parts = key.toLowerCase().split('+').map(part => part.trim());
        const modifiers = parts.filter(p => ['ctrl', 'shift', 'alt', 'meta'].includes(p)).sort();
        const mainKey = parts.find(p => !['ctrl', 'shift', 'alt', 'meta'].includes(p));
        return [...modifiers, mainKey].join('+');
    }

    private eventToKey(event: KeyboardEvent): string {
        const parts: string[] = [];
        if (event.ctrlKey) parts.push('ctrl');
        if (event.shiftKey) parts.push('shift');
        if (event.altKey) parts.push('alt');
        if (event.metaKey) parts.push('meta');

        const key = event.key.toLowerCase();
        if (!['control', 'shift', 'alt', 'meta'].includes(key)) {
            parts.push(key);
        }

        return this.normalizeKey(parts.join('+'));
    }
}

export const keybindingService = new KeybindingService();

// =
// 文件: ..\src\core\services\PaneManagementService.ts
//

import { usePaneStore } from '@/core/stores/paneStore';
import { useNotificationStore } from '@/core/stores/notificationStore';
import { paneTreeService } from '@/core/services/PaneTreeService';
import { eventBus } from '@/core/services/EventBusService';
import type { PaneNode } from '@/core/types';
import { CoreEvent } from '@/core/constants';

class PaneManagementService {
    public initializePanes() {
        const paneStore = usePaneStore();
        if (!paneStore.root) {
            const initialPaneId = `pane-${Date.now()}`;
            const initialRoot: PaneNode = { id: initialPaneId, type: 'leaf', tabIds: [], activeTabId: null };
            paneStore._setRoot(initialRoot);
            this.setActivePane(initialPaneId);
            eventBus.emit(CoreEvent.PANE_INITIALIZED, { initialPaneId });
        }
    }

    public setActivePane(paneId: string | null) {
        const paneStore = usePaneStore();
        if (paneId && paneStore.activePaneId !== paneId) {
            paneStore._setActivePaneId(paneId);
            eventBus.emit(CoreEvent.PANE_ACTIVATED, { paneId });
        }
    }

    public setActiveTab(paneId: string, tabId: string | null) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.findNodeAndParent(paneStore.root, paneId);
        if (result && result.node.type === 'leaf' && result.node.activeTabId !== tabId) {
            result.node.activeTabId = tabId;
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public addTabToPane(tabId: string, paneId: string) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.findNodeAndParent(paneStore.root, paneId);
        if (result && result.node.type === 'leaf' && !result.node.tabIds.includes(tabId)) {
            result.node.tabIds.push(tabId);
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public removeTabFromPane(tabId: string) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const leaf = paneStore.findLeafContainingTab(tabId);
        if (leaf) {
            const index = leaf.tabIds.indexOf(tabId);
            if (index > -1) {
                leaf.tabIds.splice(index, 1);
                if (leaf.activeTabId === tabId) {
                    const newActiveIndex = Math.max(0, index - 1);
                    leaf.activeTabId = leaf.tabIds[newActiveIndex] || null;
                }
                eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
            }
        }
    }

    public updatePaneNodeSize(splitNodeId: string, newSizes: number[]) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const findResult = paneTreeService.findNodeAndParent(paneStore.root, splitNodeId);
        if (findResult && findResult.node.type === 'split') {
            findResult.node.sizes = newSizes;
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public splitPane(sourcePaneId: string, direction: 'horizontal' | 'vertical' = 'horizontal') {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.splitPane(paneStore.root, sourcePaneId, direction);
        if (result) {
            paneStore._setRoot(result.newRoot);
            this.setActivePane(result.newPaneId);
            eventBus.emit(CoreEvent.PANE_SPLITTED, { sourcePaneId, newPaneId: result.newPaneId });
        }
    }

    public closePane(paneId: string): string[] | null {
        const paneStore = usePaneStore();
        if (!paneStore.root) return null;
        const result = paneTreeService.closePane(paneStore.root, paneId);
        if (result) {
            paneStore._setRoot(result.newRoot);
            if (paneStore.activePaneId === paneId) {
                const firstLeaf = paneTreeService.findLeaf(paneStore.root);
                this.setActivePane(firstLeaf ? firstLeaf.id : null);
            }
            eventBus.emit(CoreEvent.PANE_CLOSED, { closedPaneId: paneId });
            return result.closedPane.tabIds;
        } else {
            useNotificationStore().add('Cannot close the last pane.', 'warning');
            return null;
        }
    }
}

export const paneManagementService = new PaneManagementService();

// =
// 文件: ..\src\core\services\PaneTreeService.ts
//

// 文件: src/core/services/PaneTreeService.ts

import type { PaneNode, LeafPaneNode, SplitPaneNode } from '@/core/types/pane';

class PaneTreeService {

    public findNodeAndParent(
        startNode: PaneNode,
        id: string,
        parent: SplitPaneNode | null = null
    ): { node: PaneNode; parent: SplitPaneNode | null } | null {
        if (startNode.id === id) return { node: startNode, parent };
        if (startNode.type === 'split') {
            for (const child of startNode.children) {
                const found = this.findNodeAndParent(child, id, startNode);
                if (found) return found;
            }
        }
        return null;
    }

    public findLeaf(node: PaneNode): LeafPaneNode | null {
        if (node.type === 'leaf') return node;
        for(const child of node.children) {
            const leaf = this.findLeaf(child);
            if (leaf) return leaf;
        }
        return null;
    }

    public findLeafContainingTab(node: PaneNode, tabId: string): LeafPaneNode | null {
        if (node.type === 'leaf') {
            return node.tabIds.includes(tabId) ? node : null;
        }
        for (const child of node.children) {
            const found = this.findLeafContainingTab(child, tabId);
            if (found) return found;
        }
        return null;
    }

    public splitPane(
        root: PaneNode,
        sourcePaneId: string,
        direction: 'horizontal' | 'vertical'
    ): { newRoot: PaneNode; newPaneId: string } | null {
        const findResult = this.findNodeAndParent(root, sourcePaneId);
        if (!findResult || findResult.node.type !== 'leaf') return null;

        const { node: sourceNode, parent: parentNode } = findResult;

        const newLeaf: LeafPaneNode = { id: `pane-${Date.now()}`, type: 'leaf', tabIds: [], activeTabId: null };
        const newSplit: SplitPaneNode = {
            id: `split-${Date.now()}`,
            type: 'split',
            direction,
            children: [sourceNode, newLeaf],
            sizes: [50, 50]
        };

        if (parentNode) {
            const index = parentNode.children.findIndex(c => c.id === sourceNode.id);
            parentNode.children.splice(index, 1, newSplit);
            return { newRoot: { ...root }, newPaneId: newLeaf.id };
        } else {
            return { newRoot: newSplit, newPaneId: newLeaf.id };
        }
    }

    public closePane(
        root: PaneNode,
        paneId: string
    ): { newRoot: PaneNode, closedPane: LeafPaneNode } | null {
        if (root.type === 'leaf') return null; // Cannot close the root pane if it's the only one

        const findResult = this.findNodeAndParent(root, paneId);
        if (!findResult || findResult.node.type !== 'leaf' || !findResult.parent) return null;

        const { node: closedPane, parent } = findResult;
        const siblingIndex = parent.children.findIndex(c => c.id === paneId);

        // Distribute the size of the closed pane to its sibling
        const sizeToDistribute = parent.sizes[siblingIndex];
        parent.children.splice(siblingIndex, 1);
        parent.sizes.splice(siblingIndex, 1);
        parent.sizes[siblingIndex > 0 ? siblingIndex - 1 : 0] += sizeToDistribute;

        // If the parent split pane has only one child left, it should be replaced by that child.
        if (parent.children.length === 1) {
            const remainingChild = parent.children[0];
            const grandparent = this.findNodeAndParent(root, parent.id)?.parent;
            if (grandparent) {
                const parentIndex = grandparent.children.findIndex(p => p.id === parent.id);
                grandparent.children[parentIndex] = remainingChild;
                // Distribute size up to the grandparent
                grandparent.sizes[parentIndex] = grandparent.sizes.reduce((a, b) => a + b, 0);
            } else {
                root = remainingChild; // The parent was the root
            }
        }

        return { newRoot: { ...root }, closedPane };
    }
}

export const paneTreeService = new PaneTreeService();

// =
// 文件: ..\src\core\services\TabManagementService.ts
//

import { useTabStore } from '@/core/stores/tabStore';
import { usePaneStore } from '@/core/stores/paneStore';
import { useNotificationStore } from '@/core/stores/notificationStore';
import { commandService } from '@/core/services/CommandService';
import { uiService } from '@/core/services/UIService';
import { eventBus } from '@/core/services/EventBusService';
import { paneManagementService } from '@/core/services/PaneManagementService';
import { CoreEvent, CoreCommand } from '@/core/constants';
import type { ItemProvider, CoreItem, Tab } from '@/core/types';

class TabManagementService {
    private itemProvider: ItemProvider | null = null;

    public setItemProvider(provider: ItemProvider) {
        this.itemProvider = provider;
    }

    public async openTab(itemId: string, targetPaneId?: string) {
        const tabStore = useTabStore();
        const paneStore = usePaneStore();
        const notificationStore = useNotificationStore();

        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) {
            notificationStore.add('No active pane to open the tab in.', 'error');
            return;
        }

        const existingTab = tabStore.findTabByItemId(itemId);
        if (existingTab) {
            this.activateTab(existingTab.id);
            return;
        }

        if (!this.itemProvider) throw new Error('[TabManagementService] ItemProvider has not been set.');

        const item = await this.itemProvider.getItem(itemId);
        if (!item) {
            notificationStore.add(`Failed to open: Item "${itemId}" not found.`, 'error');
            return;
        }

        const newTab: Tab = {
            id: `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            itemId: item.id,
            title: item.title,
            icon: item.icon,
            isDirty: false,
        };

        tabStore._addTab(newTab);
        paneManagementService.addTabToPane(newTab.id, paneId);
        this.activateTab(newTab.id);
        eventBus.emit(CoreEvent.TAB_OPENED, { tab: newTab, paneId });
    }

    public async closeTab(tabId: string) {
        const tabStore = useTabStore();
        const notificationStore = useNotificationStore();
        const tabToClose = tabStore.getTabById(tabId);

        if (!tabToClose) return;

        if (tabToClose.isDirty) {
            const userChoice = await uiService.requestConfirmation({
                title: 'Unsaved Changes',
                message: `Do you want to save the changes for '${tabToClose.title}'?`,
                confirmText: 'Save',
                cancelText: "Don't Save",
            });

            if (userChoice) {
                await commandService.execute(CoreCommand.SAVE_TAB, { tabId });
                if (!tabStore.getTabById(tabId)?.isDirty) {
                    this._forceCloseTab(tabId);
                } else {
                    notificationStore.add(`Failed to save '${tabToClose.title}'. Close aborted.`, 'error');
                }
            } else {
                this._forceCloseTab(tabId);
            }
        } else {
            this._forceCloseTab(tabId);
        }
    }

    public activateTab(tabId: string) {
        const paneStore = usePaneStore();
        const paneId = paneStore.findLeafContainingTab(tabId)?.id;
        if (!paneId) return;

        paneManagementService.setActivePane(paneId);
        paneManagementService.setActiveTab(paneId, tabId);
        eventBus.emit(CoreEvent.TAB_ACTIVATED, { tabId, paneId });
    }

    public async loadCoreItemForTab(tabId: string): Promise<CoreItem | null> {
        const tabStore = useTabStore();
        const notificationStore = useNotificationStore();

        if (!this.itemProvider) {
            console.error('[TabManagementService] ItemProvider not set.');
            return null;
        }
        const tab = tabStore.getTabById(tabId);
        if (!tab) return null;

        try {
            const item = await this.itemProvider.getItem(tab.itemId);
            if (!item) {
                notificationStore.add(`Item for tab '${tab.title}' not found. It may have been deleted.`, 'error');
                await this.closeTab(tabId);
            }
            return item;
        } catch (error) {
            console.error(`Error loading item ${tab.itemId}`, error);
            notificationStore.add(`An error occurred while loading '${tab.title}'.`, 'error');
            await this.closeTab(tabId);
            return null;
        }
    }

    private _forceCloseTab(tabId: string) {
        const tabStore = useTabStore();
        const closedTab = tabStore.getTabById(tabId);
        if (!closedTab) return;

        paneManagementService.removeTabFromPane(tabId);
        tabStore._removeTab(tabId);

        eventBus.emit(CoreEvent.TAB_CLOSED, { tab: closedTab });
    }
}

export const tabManagementService = new TabManagementService();

// =
// 文件: ..\src\core\services\UIService.ts
//

// 文件: src/core/services/UIService.ts
// 描述: 提供与用户界面交互的抽象服务，将核心逻辑与具体UI实现解耦。

interface ConfirmationOptions {
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
}

class UIService {
    private confirmHandler: (options: ConfirmationOptions) => Promise<boolean> = async (options) => {
        const fullMessage = `${options.title}\n\n${options.message}`;
        return window.confirm(fullMessage);
    };

    /**
     * 请求用户确认。这会显示一个对话框并等待用户响应。
     * @param options - 配置对话框的内容。
     * @returns 一个解析为布尔值的 Promise，true 表示用户确认，false 表示取消。
     */
    public requestConfirmation(options: ConfirmationOptions): Promise<boolean> {
        return this.confirmHandler(options);
    }

    /**
     * 允许UI层（如Vue组件）注册一个自定义的确认对话框处理器。
     * @param handler - 一个接收选项并返回Promise<boolean>的函数。
     */
    public registerConfirmHandler(handler: (options: ConfirmationOptions) => Promise<boolean>): void {
        this.confirmHandler = handler;
    }
}

export const uiService = new UIService();

// =
// 文件: ..\src\core\services\ViewRegistry.ts
//

// 文件: src/core/services/ViewRegistry.ts
// 描述: 视图注册表服务，负责管理 "viewType" 字符串到 Vue 组件的映射。

import type { Component } from 'vue';

class ViewRegistry {
    private views: Map<string, Component> = new Map();

    /**
     * 注册一个视图类型及其对应的Vue组件。
     * 应用层在启动时调用此方法，告诉内核如何渲染特定类型的内容。
     * @param viewType - 视图的唯一标识符字符串 (e.g., 'novel-chapter-editor')。
     * @param component - 要渲染的Vue组件。
     */
    public register(viewType: string, component: Component): void {
        if (this.views.has(viewType)) {
            console.warn(`[ViewRegistry] View type "${viewType}" is already registered. Overwriting.`);
        }
        this.views.set(viewType, component);
    }

    /**
     * 根据视图类型解析并返回对应的Vue组件。
     * PaneInstance组件会调用此方法来动态渲染内容。
     * @param viewType - 视图的唯一标识符字符串。
     * @returns 如果找到，则返回Vue组件；否则返回null。
     */
    public resolve(viewType: string): Component | null {
        if (!this.views.has(viewType)) {
            console.error(`[ViewRegistry] No view component registered for type "${viewType}".`);
            return null;
        }
        return this.views.get(viewType) || null;
    }
}

// 导出一个单例，确保整个应用共享同一个视图注册表。
export const viewRegistry = new ViewRegistry();

// =
// 文件: ..\src\core\services\WorkspaceService.ts
//

import { useLayoutStore } from '@/core/stores/layoutStore';
import { usePaneStore } from '@/core/stores/paneStore';
import { useTabStore } from '@/core/stores/tabStore';

const WORKSPACE_STORAGE_KEY = 'editorCoreWorkspaceState';
const WORKSPACE_STATE_VERSION = 'v2.1';

type Unsubscribe = () => void;

class WorkspaceService {
    private debouncedPersistState: () => void;
    private subscriptions: Unsubscribe[] = [];

    constructor() {
        this.debouncedPersistState = this.debounce(this.persistState.bind(this), 500);
    }

    public initialize() {
        const layoutStore = useLayoutStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        // Subscribe to each store and save the unsubscribe function
        this.subscriptions.push(layoutStore.$subscribe(this.debouncedPersistState));
        this.subscriptions.push(paneStore.$subscribe(this.debouncedPersistState));
        this.subscriptions.push(tabStore.$subscribe(this.debouncedPersistState));

        console.log('[WorkspaceService] Initialized and subscribed to stores.');
    }

    public destroy() {
        // Unsubscribe from all stores to prevent memory leaks
        this.subscriptions.forEach(unsubscribe => unsubscribe());
        this.subscriptions = [];
        console.log('[WorkspaceService] Destroyed store subscriptions.');
    }

    private getStoresState() {
        const layoutStore = useLayoutStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        return {
            version: WORKSPACE_STATE_VERSION,
            state: {
                layout: layoutStore.dehydrate(),
                paneLayout: paneStore.dehydrate(),
                tabs: tabStore.dehydrate(),
            }
        };
    }

    private persistState(): void {
        try {
            const statePayload = this.getStoresState();
            const stateJSON = JSON.stringify(statePayload);
            localStorage.setItem(WORKSPACE_STORAGE_KEY, stateJSON);
        } catch (error) {
            console.error('[WorkspaceService] Failed to persist state:', error);
        }
    }

    public loadAndHydrateStores(): void {
        const savedStateJSON = localStorage.getItem(WORKSPACE_STORAGE_KEY);
        if (!savedStateJSON) {
            console.log('[WorkspaceService] No saved workspace state found.');
            return;
        }

        try {
            const savedPayload = JSON.parse(savedStateJSON);

            if (savedPayload.version !== WORKSPACE_STATE_VERSION) {
                console.warn(
                    `[WorkspaceService] Mismatch in workspace state version. Expected '${WORKSPACE_STATE_VERSION}', found '${savedPayload.version}'. Discarding saved state.`
                );
                localStorage.removeItem(WORKSPACE_STORAGE_KEY);
                return;
            }

            const savedState = savedPayload.state;
            const layoutStore = useLayoutStore();
            const paneStore = usePaneStore();
            const tabStore = useTabStore();

            if (savedState.layout) {
                layoutStore.hydrate(savedState.layout);
            }
            if (savedState.paneLayout) {
                paneStore.hydrate(savedState.paneLayout);
            }
            if (savedState.tabs) {
                tabStore.hydrate(savedState.tabs);
            }
            console.log('[WorkspaceService] Stores hydrated from saved state.');
        } catch (error) {
            console.error('[WorkspaceService] Failed to hydrate stores:', error);
            localStorage.removeItem(WORKSPACE_STORAGE_KEY);
        }
    }

    private debounce<T extends (...args: any[]) => any>(func: T, delay: number): () => void {
        let timeoutId: number | undefined;
        return () => {
            clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => func(), delay);
        };
    }
}

export const workspaceService = new WorkspaceService();

// =
// 文件: ..\src\core\stores\commandPaletteStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export interface PaletteCommand {
    id: string;
    label: string;
    icon?: string;
}

export const useCommandPaletteStore = defineStore('core-command-palette', () => {
    const isVisible = ref(false);
    const searchQuery = ref('');
    const allCommands = ref<PaletteCommand[]>([]);
    const selectedIndex = ref(0);

    const filteredCommands = computed(() => {
        if (!searchQuery.value) {
            return allCommands.value;
        }
        const query = searchQuery.value.toLowerCase();
        return allCommands.value.filter(cmd =>
            cmd.label.toLowerCase().includes(query)
        );
    });

    function show() {
        isVisible.value = true;
    }

    function hide() {
        isVisible.value = false;
        searchQuery.value = '';
        allCommands.value = [];
    }

    function _setCommands(commands: PaletteCommand[]) {
        allCommands.value = commands;
        setSelectedIndex(0);
        searchQuery.value = '';
    }

    function setSelectedIndex(index: number) {
        if (index >= 0 && index < filteredCommands.value.length) {
            selectedIndex.value = index;
        }
    }

    function navigate(direction: 1 | -1) {
        const newIndex = selectedIndex.value + direction;
        setSelectedIndex(newIndex);
    }

    return {
        isVisible,
        searchQuery,
        selectedIndex,
        filteredCommands,
        allCommands,
        show,
        hide,
        _setCommands,
        navigate,
        setSelectedIndex,
    };
});

// =
// 文件: ..\src\core\stores\contextMenuStore.ts
//

// 文件: src/core/stores/contextMenuStore.ts
// 描述: 一个新的 Pinia Store，用于管理全局右键菜单的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { ContextMenuItem } from '@/core/types';

export const useContextMenuStore = defineStore('core-context-menu', () => {
    const isVisible = ref(false);
    const position = ref({ x: 0, y: 0 });
    const items = ref<ContextMenuItem[]>([]);

    function showMenu(event: MouseEvent, menuItems: ContextMenuItem[]) {
        isVisible.value = true;
        position.value = { x: event.clientX, y: event.clientY };
        items.value = menuItems;
    }

    function hideMenu() {
        isVisible.value = false;
        items.value = [];
    }

    return {
        isVisible,
        position,
        items,
        showMenu,
        hideMenu,
    };
});

// =
// 文件: ..\src\core\stores\layoutStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { configService } from '@/core/services/ConfigService';

export const useLayoutStore = defineStore('core-layout', () => {
    const isSidebarVisible = ref(true);
    const sidebarWidth = ref(configService.get('layout.sidebar.defaultWidth', 320));

    function toggleSidebar() {
        isSidebarVisible.value = !isSidebarVisible.value;
    }

    function setSidebarWidth(width: number) {
        const min = configService.get('layout.sidebar.minWidth', 240);
        const max = configService.get('layout.sidebar.maxWidth', 600);
        const newWidth = Math.max(min, Math.min(width, max));
        if (sidebarWidth.value !== newWidth) {
            sidebarWidth.value = newWidth;
        }
    }

    function dehydrate() {
        return {
            isSidebarVisible: isSidebarVisible.value,
            sidebarWidth: sidebarWidth.value,
        };
    }

    function hydrate(state: { isSidebarVisible?: boolean; sidebarWidth?: number; }) {
        if (typeof state.isSidebarVisible === 'boolean') {
            isSidebarVisible.value = state.isSidebarVisible;
        }
        if (typeof state.sidebarWidth === 'number') {
            setSidebarWidth(state.sidebarWidth);
        }
    }

    return {
        isSidebarVisible,
        sidebarWidth,
        toggleSidebar,
        setSidebarWidth,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\stores\notificationStore.ts
//

// 文件: src/core/stores/notificationStore.ts
// 描述: 管理全局通知（Toast）的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';

export type NotificationType = 'info' | 'success' | 'warning' | 'error';

export interface Notification {
    id: number;
    message: string;
    type: NotificationType;
    duration?: number;
}

let nextId = 0;

export const useNotificationStore = defineStore('core-notification', () => {
    const notifications = ref<Notification[]>([]);

    /**
     * 添加一条新通知。
     * @param message - 通知内容。
     * @param type - 通知类型。
     * @param duration - （可选）显示时长（毫秒）。默认为3000ms。如果提供一个小于或等于0的值，通知将不会自动关闭，需要用户手动关闭。
     */
    function add(message: string, type: NotificationType = 'info', duration: number = 3000) {
        const id = nextId++;
        notifications.value.push({ id, message, type, duration });

        if (duration > 0) {
            setTimeout(() => {
                remove(id);
            }, duration);
        }
    }

    /**
     * 移除一条通知。
     * @param id - 要移除的通知的ID。
     */
    function remove(id: number) {
        const index = notifications.value.findIndex(n => n.id === id);
        if (index !== -1) {
            notifications.value.splice(index, 1);
        }
    }

    return {
        notifications,
        add,
        remove,
    };
});

// =
// 文件: ..\src\core\stores\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { PaneNode, LeafPaneNode } from '@/core/types';
import { paneTreeService } from '@/core/services/PaneTreeService';
import { paneManagementService } from '@/core/services/PaneManagementService';

export const usePaneStore = defineStore('core-pane', () => {
    const root = ref<PaneNode | null>(null);
    const activePaneId = ref<string | null>(null);

    const activePane = computed((): LeafPaneNode | null => {
        if (!activePaneId.value || !root.value) return null;
        const result = paneTreeService.findNodeAndParent(root.value, activePaneId.value);
        return result && result.node.type === 'leaf' ? result.node : null;
    });

    const findLeafContainingTab = (tabId: string): LeafPaneNode | null => {
        if (!root.value) return null;
        return paneTreeService.findLeafContainingTab(root.value, tabId);
    };

    function _setRoot(newRoot: PaneNode) {
        root.value = newRoot;
    }

    function _setActivePaneId(paneId: string | null) {
        activePaneId.value = paneId;
    }

    function dehydrate() {
        return {
            root: root.value,
            activePaneId: activePaneId.value,
        };
    }

    function hydrate(state: { root: PaneNode, activePaneId: string | null }) {
        if (state.root && state.activePaneId) {
            root.value = state.root;
            activePaneId.value = state.activePaneId;
        }
    }

    function initializePanes() {
        paneManagementService.initializePanes();
    }

    return {
        root,
        activePaneId,
        activePane,
        findLeafContainingTab,
        _setRoot,
        _setActivePaneId,
        initializePanes,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\stores\tabStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { usePaneStore } from './paneStore';
import { paneTreeService } from '@/core/services/PaneTreeService';
import type { Tab } from '@/core/types';
import { eventBus } from '@/core/services/EventBusService';
import { CoreEvent } from '@/core/constants';

export const useTabStore = defineStore('core-tab', () => {
    const tabsById = ref<Map<string, Tab>>(new Map());

    const getTabById = (tabId: string): Tab | undefined => tabsById.value.get(tabId);

    const findTabByItemId = (itemId: string): Tab | undefined => {
        for (const tab of tabsById.value.values()) {
            if (tab.itemId === itemId) {
                return tab;
            }
        }
        return undefined;
    };

    const getTabsForPane = (paneId: string): Tab[] => {
        const paneStore = usePaneStore();
        const pane = paneStore.root ? paneTreeService.findNodeAndParent(paneStore.root, paneId)?.node : undefined;
        if (!pane || pane.type !== 'leaf') return [];
        return pane.tabIds.map(id => getTabById(id)).filter((t): t is Tab => !!t);
    };

    function _addTab(tab: Tab) {
        tabsById.value.set(tab.id, tab);
    }

    function _removeTab(tabId: string) {
        tabsById.value.delete(tabId);
    }

    function updateTabState(tabId: string, state: Partial<Pick<Tab, 'isDirty' | 'title' | 'icon'>>) {
        const tab = getTabById(tabId);
        if (tab) {
            Object.assign(tab, state);
            // This event is for UI reactivity (e.g., command enablement), not persistence. Keep it.
            eventBus.emit(CoreEvent.TAB_STATE_CHANGED, { tabId, newState: state });
        }
    }

    function dehydrate() {
        return {
            tabs: Array.from(tabsById.value.entries()),
        };
    }

    function hydrate(state: { tabs: [string, Tab][] }) {
        if (state.tabs) {
            tabsById.value = new Map(state.tabs);
        }
    }

    return {
        getTabById,
        getTabsForPane,
        findTabByItemId,
        updateTabState,
        _addTab,
        _removeTab,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\types\command.ts
//

export interface CommandContext {
    [key: string]: any;
}

export interface Command {
    id: string;
    label: string | ((context: CommandContext) => string);
    icon?: string;
    when?: ((context: CommandContext) => boolean) | string;
    execute: (context: CommandContext) => void;
}

export interface ContextMenuItem {
    commandId: string;
    context?: CommandContext;
    isDivider?: boolean;
}

export interface ProcessedMenuItem {
    id: string;
    isDivider: boolean;
    isDisabled: boolean;
    label: string;
    icon?: string;
    command: Command;
    context?: CommandContext;
}

// =
// 文件: ..\src\core\types\domain.ts
//

export interface CoreItem {
    id: string;
    title: string;
    icon: string;
    viewType: string;
    metadata: Record<string, any>;
}

export interface Tab {
    id: string;
    itemId: string;
    title: string;
    icon: string;
    isDirty: boolean;
}

// =
// 文件: ..\src\core\types\types.ts
//

export * from './pane';
export * from './domain';
export * from './command';
export * from './providers';

// =
// 文件: ..\src\core\types\pane.ts
//

// 文件: src/core/types/pane.ts

// 定义叶子节点，即实际的窗格
export interface LeafPaneNode {
    id: string;
    type: 'leaf';
    tabIds: string[];
    activeTabId: string | null;
}

// 定义分割节点，用于布局
export interface SplitPaneNode {
    id:string;
    type: 'split';
    direction: 'horizontal' | 'vertical';
    children: PaneNode[];
    sizes: number[]; // 存储每个子节点的尺寸比例
}

// PaneNode 是一个联合类型，可以是叶子节点或分割节点
export type PaneNode = LeafPaneNode | SplitPaneNode;

// =
// 文件: ..\src\core\types\providers.ts
//



import type { CoreItem } from './index';

/**
 * 数据提供者接口 (ItemProvider Interface)。
 * 内核依赖此接口来获取和更新数据。
 * 应用层必须提供一个实现了此接口的对象，并将其注入到内核中。
 */
export interface ItemProvider {
    /**
     * 根据ID异步获取一个项目。
     * @param id - 要获取的项目的唯一ID。
     * @returns 返回一个Promise，解析为CoreItem对象或在找不到时解析为null。
     */
    getItem(id: string): Promise<CoreItem | null>;

    /**
     * 根据ID和新内容更新一个项目。
     * @param id - 要更新的项目的唯一ID。
     * @param content - 项目的新内容。
     * @returns 返回一个Promise，在更新完成后解析。可用于处理保存失败的情况。
     */
    updateItem(id: string, content: string): Promise<void>;
}

