// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\core\components\CommandPalette.vue
//

<template>
  <div v-if="isVisible" class="palette-overlay" @click="hide">
    <div class="palette-container" @click.stop>
      <div class="search-wrapper">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            ref="searchInput"
            v-model="searchQuery"
            type="text"
            placeholder="Type a command"
            class="search-input"
            @keydown.down.prevent="navigate(1)"
            @keydown.up.prevent="navigate(-1)"
            @keydown.enter.prevent="executeSelected"
        />
      </div>
      <ul class="results-list">
        <li
            v-for="(command, index) in filteredCommands"
            :key="command.id"
            :class="{ 'selected': index === selectedIndex }"
            @click="executeCommand(command.id)"
            @mouseenter="selectedIndex = index"
        >
          <i v-if="command.icon" :class="[command.icon, 'command-icon']"></i>
          <span>{{ command.label }}</span>
        </li>
        <li v-if="filteredCommands.length === 0" class="no-results">
          No matching commands
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, nextTick, onMounted, onUnmounted } from 'vue';
import { commandService } from '@/core/services/CommandService';
import type { Command } from '@/core/types';

const isVisible = ref(false);
const searchQuery = ref('');
const allCommands = ref<Command[]>([]);
const selectedIndex = ref(0);
const searchInput = ref<HTMLInputElement | null>(null);

const filteredCommands = computed(() => {
  if (!searchQuery.value) {
    return allCommands.value;
  }
  const query = searchQuery.value.toLowerCase();
  return allCommands.value.filter(cmd =>
      cmd.label.toLowerCase().includes(query)
  );
});

const show = () => {
  allCommands.value = Array.from(commandService.commands.values());
  isVisible.value = true;
  nextTick(() => {
    searchInput.value?.focus();
  });
};

const hide = () => {
  isVisible.value = false;
  searchQuery.value = '';
  selectedIndex.value = 0;
};

const navigate = (direction: 1 | -1) => {
  const newIndex = selectedIndex.value + direction;
  if (newIndex >= 0 && newIndex < filteredCommands.value.length) {
    selectedIndex.value = newIndex;
  }
};

const executeSelected = () => {
  const command = filteredCommands.value[selectedIndex.value];
  if (command) {
    executeCommand(command.id);
  }
};

const executeCommand = (commandId: string) => {
  commandService.execute(commandId);
  hide();
};

const handleGlobalKey = (e: KeyboardEvent) => {
  if(e.ctrlKey && e.shiftKey && e.key === 'P') {
    e.preventDefault();
    show();
  }
  if(e.key === 'Escape' && isVisible.value) {
    hide();
  }
}

onMounted(() => window.addEventListener('keydown', handleGlobalKey));
onUnmounted(() => window.removeEventListener('keydown', handleGlobalKey));

defineExpose({ show, hide });
</script>

<style scoped>
.palette-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  display: flex;
  justify-content: center;
  padding-top: 15vh;
}
.palette-container {
  width: 100%;
  max-width: 600px;
  background-color: white;
  border-radius: 0.75rem;
  box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: min-content;
  max-height: 70vh;
}
.search-wrapper {
  position: relative;
  border-bottom: 1px solid #e5e7eb;
  padding: 0.75rem;
}
.search-icon {
  position: absolute;
  left: 1.5rem;
  top: 50%;
  transform: translateY(-50%);
  color: #9ca3af;
}
.search-input {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem 1rem 0.75rem 2.5rem;
  border: none;
  outline: none;
  background: transparent;
}
.results-list {
  overflow-y: auto;
  padding: 0.5rem;
}
.results-list li {
  padding: 0.75rem 1rem;
  border-radius: 0.375rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}
.results-list li.selected {
  background-color: #3B82F6;
  color: white;
}
.no-results {
  color: #9ca3af;
  text-align: center;
  padding: 2rem;
  cursor: default;
}
</style>

// =
// 文件: ..\src\core\components\ContextMenu.vue
//

<template>
  <div
      v-if="visible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
      @contextmenu.prevent
  >
    <ul class="menu-list">
      <template v-for="item in menuItems" :key="item.commandId || `divider-${Math.random()}`">
        <li v-if="item.isDivider" class="menu-divider"></li>
        <li
            v-else-if="getCommand(item.commandId)"
            :class="['menu-item', { 'disabled': !canExecute(item) }]"
            @click.prevent="execute(item)"
        >
          <i v-if="getCommand(item.commandId).icon" :class="[getCommand(item.commandId).icon, 'menu-icon']"></i>
          <span>{{ getLabel(item) }}</span>
        </li>
      </template>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { commandService } from '@/core/services/CommandService';
import type { ContextMenuItem, Command, CommandContext } from '@/core/types';

const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const menuItems = ref<ContextMenuItem[]>([]);

const show = (event: MouseEvent, items: ContextMenuItem[]) => {
  menuItems.value = items;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  menuItems.value = [];
};

const getCommand = (commandId: string): Command | undefined => {
  return commandService.find(commandId);
};

const canExecute = (item: ContextMenuItem): boolean => {
  return commandService.canExecute(item.commandId, item.context);
};

const getLabel = (item: ContextMenuItem): string => {
  const command = getCommand(item.commandId);
  if (!command) return '';
  return typeof command.label === 'function'
      ? command.label({ ...item.context })
      : command.label;
};

const execute = (item: ContextMenuItem) => {
  if (canExecute(item)) {
    commandService.execute(item.commandId, item.context);
    hide();
  }
};

const handleClickOutside = () => hide();

onMounted(() => window.addEventListener('click', handleClickOutside));
onBeforeUnmount(() => window.removeEventListener('click', handleClickOutside));

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
.menu-list { list-style: none; padding: 0; margin: 0; }
.menu-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  color: #374151;
  cursor: pointer;
  user-select: none;
}
.menu-item:not(.disabled):hover { background-color: #f3f4f6; }
.menu-item.disabled { color: #9ca3af; cursor: not-allowed; }
.menu-icon { width: 1rem; text-align: center; color: #6B7280; }
.menu-item:not(.disabled):hover .menu-icon { color: #374151; }
.menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\core\components\MainPane.vue
//

<template>
  <div class="main-pane-container" ref="containerRef">
    <template v-for="(pane, index) in panes" :key="pane.id">
      <PaneInstance
          :pane="pane"
          :is-active="pane.id === paneStore.activePaneId"
          class="pane-instance"
      />
      <div
          v-if="index < panes.length - 1"
          class="pane-resizer"
          @mousedown.prevent="startResize($event, index)"
      ></div>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { configService } from '@/core/services/ConfigService';
import PaneInstance from './PaneInstance.vue';

const paneStore = usePaneStore();
const panes = computed(() => paneStore.panes);
const containerRef = ref<HTMLElement | null>(null);

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;
  const minWidth = configService.get('pane.minWidth', 200);

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    if (newLeftWidth < minWidth) newLeftWidth = minWidth;
    if (totalWidth - newLeftWidth < minWidth) newLeftWidth = totalWidth - minWidth;

    leftPane.style.flexBasis = `${newLeftWidth}px`;
    rightPane.style.flexBasis = `${totalWidth - newLeftWidth}px`;
    leftPane.style.flexGrow = '0';
    rightPane.style.flexGrow = '0';
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
};
</script>

<style scoped>
.main-pane-container {
  flex-grow: 1; display: flex; overflow: hidden; background-color: #F3F4F6;
}
.pane-instance { flex: 1 1 0px; min-width: 0; }
.pane-resizer {
  width: 5px; background-color: transparent; cursor: col-resize;
  flex-shrink: 0; z-index: 5; position: relative; transition: background-color 0.2s ease;
}
.pane-resizer:hover { background-color: #3B82F6; }
.pane-resizer::before {
  content: ''; position: absolute; left: 2px; top: 0; width: 1px;
  height: 100%; background-color: #E5E7EB;
}
.pane-resizer:hover::before { background-color: transparent; }
</style>

// =
// 文件: ..\src\core\components\PaneInstance.vue
//

// 文件: src/core/components/PaneInstance.vue

<template>
  <div class="pane-instance-container" @click="paneStore.setActivePane(pane.id)">
    <TabBar :tabs="tabsForPane" :active-tab-id="pane.activeTabId" :pane-id="pane.id" :is-active-pane="isActive" />
    <div class="content-area">
      <div v-if="isLoading" class="loading-screen">
        <p>Loading...</p>
      </div>
      <template v-else-if="activeCoreItem && activeTab">
        <component
            :is="resolvedView"
            :key="activeTab.id"
            :tab="activeTab"
            :item="activeCoreItem"
        />
      </template>
      <!-- 使用真正的 WelcomeScreen 组件 -->
      <WelcomeScreen v-else />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, type PropType } from 'vue';
import { usePaneStore } from '@/core/stores/paneStore';
import { useTabStore } from '@/core/stores/tabStore';
import { viewRegistry } from '@/core/services/ViewRegistry';
import type { Pane, CoreItem, Tab } from '@/core/types';
import TabBar from './TabBar.vue';
import WelcomeScreen from './WelcomeScreen.vue'; // <-- 导入组件

const props = defineProps({
  pane: {
    type: Object as PropType<Pane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  },
});

const paneStore = usePaneStore();
const tabStore = useTabStore();

const activeCoreItem = ref<CoreItem | null>(null);
const isLoading = ref(false);

const activeTab = computed((): Tab | undefined => {
  return props.pane.activeTabId ? tabStore.getTabById(props.pane.activeTabId) : undefined;
});

const tabsForPane = computed((): Tab[] => {
  return tabStore.getTabsForPane(props.pane.id);
});

const resolvedView = computed(() => {
  if (activeCoreItem.value?.viewType) {
    return viewRegistry.resolve(activeCoreItem.value.viewType);
  }
  return null;
});

watch(
    () => props.pane.activeTabId,
    async (newTabId) => {
      if (newTabId) {
        const loadingTabId = newTabId;
        isLoading.value = true;
        activeCoreItem.value = null;

        try {
          const item = await tabStore.loadCoreItemForTab(loadingTabId);
          if (props.pane.activeTabId === loadingTabId) {
            activeCoreItem.value = item;
          }
        } catch (error) {
          console.error(`Failed to load content for tab ${loadingTabId}`, error);
          if (props.pane.activeTabId === loadingTabId) {
            activeCoreItem.value = null;
          }
        } finally {
          if (props.pane.activeTabId === loadingTabId) {
            isLoading.value = false;
          }
        }
      } else {
        activeCoreItem.value = null;
        isLoading.value = false;
      }
    },
    { immediate: true }
);
</script>

<style scoped>
.pane-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  border-left: 1px solid #E5E7EB;
}
.pane-instance-container:first-child {
  border-left: none;
}
.content-area {
  flex-grow: 1;
  overflow: auto;
  position: relative;
}
.loading-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #9CA3AF;
  user-select: none;
}
/* WelcomeScreen has its own styles, so we remove the generic one */
</style>

// =
// 文件: ..\src\core\components\TabBar.vue
//

<template>
  <div class="tab-bar-container">
    <div
        v-for="tab in tabs"
        :key="tab.id"
        class="tab-item"
        :class="{ 'active': tab.id === activeTabId, 'inactive-pane-tab': !isActivePane }"
        @click.stop="tabStore.openTab(tab.id, paneId)"
    >
      <i :class="[tab.icon, 'tab-icon']"></i>
      <span class="tab-title">{{ tab.title }}</span>
      <div class="close-icon-wrapper">
        <i
            v-if="!tab.isDirty"
            class="fa-solid fa-times close-icon"
            @click.stop="tabStore.closeTab(tab.id, paneId)"
        ></i>
        <div v-else class="dirty-indicator" @click.stop="tabStore.closeTab(tab.id, paneId)"></div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from 'vue';
import { useTabStore } from '@/core/stores/tabStore';
import type { Tab } from '@/core/types';

defineProps({
  tabs: { type: Array as PropType<Tab[]>, required: true },
  activeTabId: { type: String as PropType<string | null>, required: true },
  paneId: { type: String, required: true },
  isActivePane: { type: Boolean, required: true },
});

const tabStore = useTabStore();
</script>

<style scoped>
.tab-bar-container {
  display: flex; flex-shrink: 0; background-color: #F3F4F6;
  border-bottom: 1px solid #E5E7EB; padding-top: 0.5rem; padding-left: 0.5rem;
  overflow-x: auto;
}
.tab-item {
  display: flex; align-items: center; padding: 0.6rem 0.5rem 0.6rem 1rem;
  font-size: 0.875rem; color: #6B7280; cursor: pointer;
  border: 1px solid transparent; border-bottom: none;
  border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem;
  background-color: #E5E7EB; white-space: nowrap; transition: background-color 0.2s, color 0.2s;
}
.tab-item:not(:first-child) { margin-left: -1px; }
.tab-item:hover { background-color: #FFFFFF; }
.tab-item.active {
  background-color: #FFFFFF; color: #1F2937;
  border-color: #E5E7EB; z-index: 2; margin-bottom: -1px;
  padding-bottom: calc(0.6rem + 1px);
}
.inactive-pane-tab { background-color: #F3F4F6; color: #9CA3AF; }
.inactive-pane-tab:hover { background-color: #E5E7EB; }
.inactive-pane-tab.active { background-color: #F9FAFB; color: #6B7280; }
.tab-icon { margin-right: 0.5rem; }
.active .tab-icon { color: #3B82F6; }
.inactive-pane-tab.active .tab-icon { color: inherit; }
.tab-title { max-width: 150px; overflow: hidden; text-overflow: ellipsis; }

.close-icon-wrapper {
  margin-left: 0.75rem;
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 99px;
  flex-shrink: 0;
}
.close-icon {
  font-size: 0.8rem;
  opacity: 0.5;
  transition: all 0.2s;
  padding: 0.25rem;
}
.tab-item:hover .close-icon { opacity: 1; }
.close-icon:hover { background-color: #E5E7EB; border-radius: 99px; }

.dirty-indicator {
  width: 0.5rem;
  height: 0.5rem;
  background-color: #6B7280;
  border-radius: 99px;
  transition: all 0.2s;
}
.tab-item:hover .dirty-indicator {
  background-color: transparent;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%236B7280'%3E%3Cpath d='M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z'/%3E%3C/svg%3E");
  background-size: 100% 100%;
  width: 1rem;
  height: 1rem;
}
</style>

// =
// 文件: ..\src\core\components\WelcomeScreen.vue
//

<!-- 文件: src/core/components/WelcomeScreen.vue -->
<!-- 描述: 空窗格的欢迎界面，提供更友好的用户体验。 -->
<template>
  <div class="welcome-screen">
    <i class="fa-solid fa-feather-pointed welcome-icon"></i>
    <h1 class="welcome-title">Editor Core</h1>
    <p class="welcome-subtitle">Select a file from the sidebar to begin.</p>
  </div>
</template>

<style scoped>
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
  background-color: #FFFFFF;
}
.welcome-icon {
  font-size: 4rem; /* 64px */
  color: #E5E7EB; /* gray-200 */
}
.welcome-title {
  font-size: 1.5rem; /* 24px */
  font-weight: 500;
  color: #4B5563; /* gray-600 */
  margin-top: 1.5rem;
}
.welcome-subtitle {
  color: #9CA3AF; /* gray-400 */
  margin-top: 0.5rem;
}
</style>

// =
// 文件: ..\src\core\components\layout\CoreLayout.vue
//

// 文件: src/core/components/layout/CoreLayout.vue

<template>
  <div class="core-layout-container" :class="{'sidebar-hidden': !isSidebarVisible}">
    <div class="activity-bar-area">
      <slot name="activity-bar"></slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-area" :style="{ width: `${sidebarWidth}px` }">
      <slot name="sidebar">
        <SidebarPanel />
      </slot>
    </div>
    <div v-if="isSidebarVisible" class="sidebar-resizer" @mousedown.prevent="startResize"></div>

    <div class="main-content-area">
      <MainPane />
    </div>

    <div class="status-bar-area">
      <slot name="status-bar"></slot>
    </div>

    <div class="global-components-area">
      <slot name="global">
        <NotificationCenter />
        <CommandPalette />
        <!-- 添加 ContextMenu 并获取其引用 -->
        <ContextMenu ref="contextMenuRef" />
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, type ComponentPublicInstance } from 'vue';
import { useLayoutStore } from '@/core/stores/layoutStore';
import { storeToRefs } from 'pinia';
import type { EditorKernel } from '@/core/services/EditorKernel';
import { contextMenuService } from '@/core/services/ContextMenuService';

import MainPane from '../MainPane.vue';
import SidebarPanel from './SidebarPanel.vue';
import NotificationCenter from './NotificationCenter.vue';
import CommandPalette from '../CommandPalette.vue';
import ContextMenu from '../ContextMenu.vue'; // <-- 导入组件

const props = defineProps<{
  kernel: EditorKernel;
}>();

const layoutStore = useLayoutStore();
const { isSidebarVisible, sidebarWidth } = storeToRefs(layoutStore);
const contextMenuRef = ref<ComponentPublicInstance | null>(null);

onMounted(() => {
  props.kernel.startup();
  // 注册 ContextMenu 组件实例
  if (contextMenuRef.value) {
    contextMenuService.registerComponent(contextMenuRef.value as any);
  }
});

onUnmounted(() => {
  props.kernel.shutdown();
});

const startResize = (event: MouseEvent) => {
  const startWidth = sidebarWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    layoutStore.setSidebarWidth(startWidth + dx);
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = 'default';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
};
</script>

<style scoped>
.core-layout-container {
  display: flex; height: 100%; width: 100%; overflow: hidden; background-color: #FFFFFF;
}
.activity-bar-area, .sidebar-area { flex-shrink: 0; height: 100%; }
.activity-bar-area { z-index: 20; border-right: 1px solid #E5E7EB; }
.sidebar-area { z-index: 10; border-right: 1px solid #E5E7EB; }
.sidebar-resizer {
  width: 5px; background-color: transparent; cursor: col-resize; flex-shrink: 0;
  position: relative; z-index: 15;
}
.sidebar-resizer:hover { background-color: #3B82F6; }
.main-content-area {
  flex-grow: 1; display: flex; flex-direction: column; min-width: 0;
  position: relative;
}
.status-bar-area {
  position: relative; z-index: 20; flex-shrink: 0;
  height: 28px; border-top: 1px solid #E5E7EB;
  background-color: #F3F4F6;
}
/* ContextMenu 和 CommandPalette 都需要能够接收事件 */
.global-components-area > :deep(*) {
  pointer-events: all;
}
.global-components-area {
  position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 9999; pointer-events: none;
}
</style>

// =
// 文件: ..\src\core\components\layout\NotificationCenter.vue
//

<template>
  <div class="notification-center">
    <transition-group name="notification-fade" tag="div">
      <div
          v-for="notification in notifications"
          :key="notification.id"
          :class="['notification-toast', `notification-${notification.type}`]"
          @click="notificationStore.remove(notification.id)"
      >
        <span class="message">{{ notification.message }}</span>
      </div>
    </transition-group>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useNotificationStore } from '@/core/stores/notificationStore';

const notificationStore = useNotificationStore();
const notifications = computed(() => notificationStore.notifications);
</script>

<style scoped>
.notification-center {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  pointer-events: all; /* Re-enable pointer events for toasts */
}
.notification-toast {
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  cursor: pointer;
  color: white;
  font-weight: 500;
  transition: all 0.3s ease;
}
.notification-info { background-color: #3B82F6; }
.notification-success { background-color: #16A34A; }
.notification-warning { background-color: #F59E0B; }
.notification-error { background-color: #DC2626; }

.notification-fade-enter-active,
.notification-fade-leave-active {
  transition: opacity 0.5s, transform 0.5s;
}
.notification-fade-enter-from,
.notification-fade-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>

// =
// 文件: ..\src\core\components\layout\SidebarPanel.vue
//


<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <!-- The title can be passed down via a slot or a prop -->
      <slot name="header">
        <h3 class="title">Sidebar</h3>
      </slot>
    </div>
    <div class="content">
      <slot>
        <!-- Default content if no content is provided by the app -->
        <div class="p-4 text-sm text-gray-500">
          This is the default sidebar content.
        </div>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}
.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F0F0F0;
  flex-shrink: 0;
}
.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}
.content {
  flex-grow: 1;
  position: relative;
  overflow: auto;
}
</style>

// =
// 文件: ..\src\core\composables\useEditableView.ts
//

// 文件: src/core/composables/useEditableView.ts

import { onMounted, onUnmounted, watch, ref, computed, type Ref } from 'vue';
import { activeEditorService } from '@/core/services/ActiveEditorService';
import { useTabStore } from '@/core/stores/tabStore';
import type { CoreItem, Tab } from '@/core/types';

interface UseEditableViewOptions {
    tab: Ref<Tab>;
    coreItem: Ref<CoreItem>;
    content: Ref<string>;
}

export function useEditableView({ tab, coreItem, content }: UseEditableViewOptions) {
    const tabStore = useTabStore();
    const initialContent = ref('');

    const isDirty = computed(() => initialContent.value !== content.value);

    const initializeContent = () => {
        const newInitialContent = coreItem.value.metadata?.content || '';
        initialContent.value = newInitialContent;
        if (content.value !== newInitialContent) {
            content.value = newInitialContent;
        }
    };

    onMounted(() => {
        initializeContent();

        activeEditorService.register(tab.value.id, {
            getContent: () => content.value,
            setContent: (newContent: string) => {
                content.value = newContent;
                initialContent.value = newContent; // Mark as saved by resetting the baseline
            },
        });
    });

    onUnmounted(() => {
        activeEditorService.unregister(tab.value.id);
    });

    watch(isDirty, (newValue) => {
        tabStore.updateTabState(tab.value.id, { isDirty: newValue });
    });

    // This is no longer called internally, but triggered via activeEditorService.setContent
    function markAsSaved() {
        initialContent.value = content.value;
    }

    // This watcher handles cases where the underlying file is changed externally
    // (e.g., git pull, external editor save) and reloaded.
    watch(() => coreItem.value.metadata?.content, (newContent) => {
        if (newContent !== undefined && content.value !== newContent) {
            initializeContent();
        }
    });

    return {
        isDirty,
        // markAsSaved is now an internal-only concept, handled by setContent
    };
}

// =
// 文件: ..\src\core\services\ActiveEditorService.ts
//

// 文件: src/core/services/ActiveEditorService.ts

interface EditorAPI {
    getContent: () => string;
    setContent: (newContent: string) => void;
}

class ActiveEditorService {
    // The key is now the unique Tab ID, not the Item ID.
    private activeEditors: Map<string, EditorAPI> = new Map();

    public register(tabId: string, api: EditorAPI): void {
        this.activeEditors.set(tabId, api);
    }

    public unregister(tabId: string): void {
        this.activeEditors.delete(tabId);
    }

    public getContent(tabId: string): string | null {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.getContent === 'function') {
            return editor.getContent();
        }
        return null;
    }

    public setContent(tabId: string, newContent: string): boolean {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.setContent === 'function') {
            editor.setContent(newContent);
            return true;
        }
        return false;
    }
}

export const activeEditorService = new ActiveEditorService();

// =
// 文件: ..\src\core\services\CommandService.ts
//

import type { Command, CommandContext } from '@/core/types';
import { usePaneStore } from '@/core/stores/paneStore';

class CommandService {
    private commands: Map<string, Command> = new Map();

    public register(command: Command): void {
        if (this.commands.has(command.id)) {
            console.warn(`[CommandService] Command "${command.id}" is already registered. Overwriting.`);
        }
        this.commands.set(command.id, command);
    }

    public find(commandId: string): Command | undefined {
        return this.commands.get(commandId);
    }

    private getGlobalContext(): CommandContext {
        const paneStore = usePaneStore();
        return {
            activePaneId: paneStore.activePaneId,
            activeTabId: paneStore.activePane?.activeTabId,
        };
    }

    public canExecute(commandId: string, specificContext?: CommandContext): boolean {
        const command = this.find(commandId);
        if (!command) return false;

        const context = { ...this.getGlobalContext(), ...specificContext };

        if (command.when && !command.when(context)) {
            return false;
        }
        return true;
    }

    public execute(commandId: string, specificContext?: CommandContext): void {
        const command = this.find(commandId);
        if (!command) {
            console.error(`[CommandService] Command "${commandId}" not found.`);
            return;
        }

        const context = { ...this.getGlobalContext(), ...specificContext };

        if (!this.canExecute(commandId, context)) {
            console.warn(`[CommandService] Execution of command "${commandId}" was prevented by its 'when' condition.`);
            return;
        }

        command.execute(context);
    }

    public *getAllCommands(context?: CommandContext) {
        for (const command of this.commands.values()) {
            if (this.canExecute(command.id, context)) {
                yield {
                    id: command.id,
                    label: typeof command.label === 'function' ? command.label(context || {}) : command.label,
                    icon: command.icon
                };
            }
        }
    }
}

export const commandService = new CommandService();

// =
// 文件: ..\src\core\services\ConfigService.ts
//

// 文件: src/core/services/ConfigService.ts
// 描述: 全局配置服务，允许应用层覆盖内核的默认行为。

class ConfigService {
    private config: Map<string, any> = new Map();

    /**
     * 设置一个配置项。
     * 应用层在初始化时调用此方法来注入自定义配置。
     * @param key - 配置项的键 (e.g., 'pane.minWidth')。
     * @param value - 配置项的值。
     */
    public set(key: string, value: any): void {
        this.config.set(key, value);
    }

    /**
     * 获取一个配置项。
     * 如果配置未被设置，则返回提供的默认值。
     * @param key - 配置项的键。
     * @param defaultValue - 当找不到键时返回的默认值。
     * @returns 配置项的值或默认值。
     */
    public get<T>(key: string, defaultValue: T): T {
        if (this.config.has(key)) {
            return this.config.get(key) as T;
        }
        return defaultValue;
    }
}

// 导出一个单例，确保整个应用共享同一个配置服务。
export const configService = new ConfigService();

// =
// 文件: ..\src\core\services\ContextMenuService.ts
//

import type { ContextMenuItem, CommandContext } from '@/core/types';
import type { ComponentPublicInstance } from 'vue';

type ContextMenuComponent = ComponentPublicInstance<{
    show: (event: MouseEvent, items: ContextMenuItem[]) => void;
}>;

type ContextMenuProvider = (context: CommandContext) => ContextMenuItem[];

class ContextMenuService {
    private providers: Map<string, ContextMenuProvider[]> = new Map();
    private menuComponent: ContextMenuComponent | null = null;

    public registerComponent(component: ContextMenuComponent): void {
        this.menuComponent = component;
    }

    public registerProvider(contextType: string, provider: ContextMenuProvider): void {
        if (!this.providers.has(contextType)) {
            this.providers.set(contextType, []);
        }
        this.providers.get(contextType)!.push(provider);
    }

    private getItemsForContext(contextType: string, context: CommandContext): ContextMenuItem[] {
        const providers = this.providers.get(contextType) || [];
        let allItems: ContextMenuItem[] = [];

        providers.forEach((provider, index) => {
            const items = provider(context);
            if (items.length > 0) {
                if (index > 0 && allItems.length > 0 && !allItems[allItems.length - 1].isDivider) {
                    // Add a divider between different providers if needed
                    allItems.push({ id: `divider-${index}`, isDivider: true });
                }
                allItems = allItems.concat(items);
            }
        });

        return allItems;
    }

    public show(event: MouseEvent, contextType: string, context: CommandContext): void {
        event.preventDefault();
        event.stopPropagation();

        if (!this.menuComponent) {
            console.error("[ContextMenuService] Menu component is not registered.");
            return;
        }

        const items = this.getItemsForContext(contextType, context);
        if (items.length > 0) {
            this.menuComponent.show(event, items);
        }
    }
}

export const contextMenuService = new ContextMenuService();

// =
// 文件: ..\src\core\services\EditorKernel.ts
//

import type { ItemProvider } from '@/core/types/providers';
import { useTabStore } from '@/core/stores/tabStore';
import { usePaneStore } from '@/core/stores/paneStore';
import { commandService } from './CommandService';
import { keybindingService } from './KeybindingService';
import { workspaceService } from './WorkspaceService';
import { activeEditorService } from './ActiveEditorService';
import { useNotificationStore } from '../stores/notificationStore';

export class EditorKernel {
    private itemProvider: ItemProvider;

    constructor(provider: ItemProvider) {
        this.itemProvider = provider;
    }

    public async startup(): Promise<void> {
        console.log('[EditorKernel] Starting up...');

        this.setupStores();
        this.registerCoreCommands();

        keybindingService.initialize();
        workspaceService.initialize();
        workspaceService.loadAndHydrateStores();
        usePaneStore().initializePanes();

        console.log('[EditorKernel] Startup complete.');
    }

    public shutdown(): void {
        keybindingService.destroy();
        workspaceService.destroy();
        console.log('[EditorKernel] Shutdown complete.');
    }

    private setupStores(): void {
        const tabStore = useTabStore();
        tabStore.setItemProvider(this.itemProvider);
    }

    private registerCoreCommands(): void {
        const paneStore = usePaneStore();
        const tabStore = useTabStore();
        const notificationStore = useNotificationStore();

        commandService.register({
            id: 'core.pane.split',
            label: 'Pane: Split Pane',
            icon: 'fa-solid fa-columns',
            execute: (context) => {
                const paneId = context?.paneId || paneStore.activePaneId;
                if (paneId) paneStore.splitPane(paneId);
            },
        });

        commandService.register({
            id: 'core.pane.close',
            label: 'Pane: Close Pane',
            icon: 'fa-solid fa-xmark',
            when: () => paneStore.panes.length > 1,
            execute: (context) => {
                const paneId = context?.paneId || paneStore.activePaneId;
                if (paneId) paneStore.closePane(paneId);
            },
        });

        commandService.register({
            id: 'core.saveTab',
            label: 'File: Save',
            icon: 'fa-solid fa-save',
            when: (context) => {
                const tabId = context?.tabId || paneStore.activePane?.activeTabId;
                if (!tabId) return false;
                const tab = tabStore.getTabById(tabId);
                return tab?.isDirty || false;
            },
            execute: async (context) => {
                const tabId = context?.tabId || paneStore.activePane?.activeTabId;
                if (!tabId) return;

                const tab = tabStore.getTabById(tabId);
                if (!tab || !tab.isDirty) return;

                const content = activeEditorService.getContent(tabId);
                if (content === null) return;

                try {
                    await this.itemProvider.updateItem(tab.itemId, content);
                    // This is the key: update the editor's baseline content.
                    // The useEditableView composable will see this and mark the tab as not dirty.
                    activeEditorService.setContent(tabId, content);
                    notificationStore.add(`'${tab.title}' saved.`, 'success', 2000);
                } catch (error) {
                    console.error(`Failed to save item ${tab.itemId}`, error);
                    notificationStore.add(`Error saving '${tab.title}'.`, 'error');
                }
            },
        });
    }
}

// =
// 文件: ..\src\core\services\EventBusService.ts
//

// 文件: src/core/services/EventBusService.ts
// 描述: 一个轻量级的全局事件总线，用于实现模块间的解耦通信。

type EventHandler = (payload?: any) => void;

class EventBusService {
    private events: Map<string, EventHandler[]> = new Map();

    /**
     * 订阅一个事件。
     * @param eventName - 事件名称 (e.g., 'core:tab.opened')。
     * @param handler - 事件处理函数。
     */
    public on(eventName: string, handler: EventHandler): void {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }
        this.events.get(eventName)!.push(handler);
    }

    /**
     * 取消订阅一个事件。
     * @param eventName - 事件名称。
     * @param handler - 要移除的事件处理函数。
     */
    public off(eventName: string, handler: EventHandler): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }

    /**
     * 触发一个事件，通知所有订阅者。
     * @param eventName - 事件名称。
     * @param payload - （可选）随事件传递的数据。
     */
    public emit(eventName: string, payload?: any): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            // 创建副本以防在处理过程中有订阅/取消订阅操作
            [...handlers].forEach(handler => handler(payload));
        }
    }
}

// 导出一个单例，确保整个应用共享同一个事件总线。
export const eventBus = new EventBusService();

// =
// 文件: ..\src\core\services\KeybindingService.ts
//

import { commandService } from './CommandService';

interface Keybinding {
    key: string;
    commandId: string;
    when?: () => boolean; // Optional, specific condition for this keybinding
}

class KeybindingService {
    private keybindings: Map<string, Keybinding> = new Map();

    public initialize(): void {
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
    }

    public destroy(): void {
        window.removeEventListener('keydown', this.handleKeyDown.bind(this));
    }

    public register(keybinding: Keybinding): void {
        const key = this.normalizeKey(keybinding.key);
        this.keybindings.set(key, keybinding);
    }

    private handleKeyDown(event: KeyboardEvent): void {
        const key = this.eventToKey(event);
        const binding = this.keybindings.get(key);

        if (binding) {
            // Check both the keybinding's specific 'when' and the command's global 'when'
            const isKeybindingConditionMet = !binding.when || binding.when();
            const isCommandConditionMet = commandService.canExecute(binding.commandId);

            if (isKeybindingConditionMet && isCommandConditionMet) {
                event.preventDefault();
                event.stopPropagation();
                commandService.execute(binding.commandId);
            }
        }
    }

    private normalizeKey(key: string): string {
        const parts = key.toLowerCase().split('+').map(part => part.trim());
        const modifiers = parts.filter(p => ['ctrl', 'shift', 'alt', 'meta'].includes(p)).sort();
        const mainKey = parts.find(p => !['ctrl', 'shift', 'alt', 'meta'].includes(p));
        return [...modifiers, mainKey].join('+');
    }

    private eventToKey(event: KeyboardEvent): string {
        const parts: string[] = [];
        if (event.ctrlKey) parts.push('ctrl');
        if (event.shiftKey) parts.push('shift');
        if (event.altKey) parts.push('alt');
        if (event.metaKey) parts.push('meta');

        const key = event.key.toLowerCase();
        if (!['control', 'shift', 'alt', 'meta'].includes(key)) {
            parts.push(key);
        }

        return this.normalizeKey(parts.join('+'));
    }
}

export const keybindingService = new KeybindingService();

// =
// 文件: ..\src\core\services\ViewRegistry.ts
//

// 文件: src/core/services/ViewRegistry.ts
// 描述: 视图注册表服务，负责管理 "viewType" 字符串到 Vue 组件的映射。

import type { Component } from 'vue';

class ViewRegistry {
    private views: Map<string, Component> = new Map();

    /**
     * 注册一个视图类型及其对应的Vue组件。
     * 应用层在启动时调用此方法，告诉内核如何渲染特定类型的内容。
     * @param viewType - 视图的唯一标识符字符串 (e.g., 'novel-chapter-editor')。
     * @param component - 要渲染的Vue组件。
     */
    public register(viewType: string, component: Component): void {
        if (this.views.has(viewType)) {
            console.warn(`[ViewRegistry] View type "${viewType}" is already registered. Overwriting.`);
        }
        this.views.set(viewType, component);
    }

    /**
     * 根据视图类型解析并返回对应的Vue组件。
     * PaneInstance组件会调用此方法来动态渲染内容。
     * @param viewType - 视图的唯一标识符字符串。
     * @returns 如果找到，则返回Vue组件；否则返回null。
     */
    public resolve(viewType: string): Component | null {
        if (!this.views.has(viewType)) {
            console.error(`[ViewRegistry] No view component registered for type "${viewType}".`);
            return null;
        }
        return this.views.get(viewType) || null;
    }
}

// 导出一个单例，确保整个应用共享同一个视图注册表。
export const viewRegistry = new ViewRegistry();

// =
// 文件: ..\src\core\services\WorkspaceService.ts
//

import { eventBus } from './EventBusService';
import { useLayoutStore } from '@/core/stores/layoutStore';
import { usePaneStore } from '@/core/stores/paneStore';

const WORKSPACE_STORAGE_KEY = 'editorCoreWorkspaceState';

class WorkspaceService {
    constructor() {
        // Debounce persist function to avoid frequent writes
        this.persistState = this.debounce(this.persistState.bind(this), 500);
    }

    public initialize() {
        // Listen for state changes from any store
        eventBus.on('core:state-changed', this.persistState);
        console.log('[WorkspaceService] Initialized and listening for state changes.');
    }

    public destroy() {
        eventBus.off('core:state-changed', this.persistState);
        console.log('[WorkspaceService] Destroyed event listener.');
    }

    private getStoresState() {
        const layoutStore = useLayoutStore();
        const paneStore = usePaneStore();

        return {
            layout: {
                isSidebarVisible: layoutStore.isSidebarVisible,
                sidebarWidth: layoutStore.sidebarWidth,
            },
            panes: {
                panes: paneStore.panes.map(p => ({
                    id: p.id,
                    activeTabId: p.activeTabId,
                    tabs: p.tabs, // Tabs are already simple objects
                })),
                activePaneId: paneStore.activePaneId,
            }
        };
    }

    private persistState(): void {
        try {
            const state = this.getStoresState();
            const stateJSON = JSON.stringify(state);
            localStorage.setItem(WORKSPACE_STORAGE_KEY, stateJSON);
            console.log('[WorkspaceService] Workspace state persisted.');
        } catch (error) {
            console.error('[WorkspaceService] Failed to persist state:', error);
        }
    }

    public loadAndHydrateStores(): void {
        const savedStateJSON = localStorage.getItem(WORKSPACE_STORAGE_KEY);
        if (!savedStateJSON) {
            console.log('[WorkspaceService] No saved workspace state found.');
            return;
        }

        try {
            const savedState = JSON.parse(savedStateJSON);
            const layoutStore = useLayoutStore();
            const paneStore = usePaneStore();

            if (savedState.layout) {
                layoutStore.hydrate(savedState.layout);
            }
            if (savedState.panes) {
                paneStore.hydrate(savedState.panes);
            }
            console.log('[WorkspaceService] Stores hydrated from saved state.');
        } catch (error) {
            console.error('[WorkspaceService] Failed to hydrate stores:', error);
            localStorage.removeItem(WORKSPACE_STORAGE_KEY);
        }
    }

    private debounce<T extends (...args: any[]) => any>(func: T, delay: number): (...args: Parameters<T>) => void {
        let timeoutId: number | undefined;
        return (...args: Parameters<T>) => {
            clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => func(...args), delay);
        };
    }
}

export const workspaceService = new WorkspaceService();

// =
// 文件: ..\src\core\stores\layoutStore.ts
//

// 文件: src/core/stores/layoutStore.ts

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { configService } from '@/core/services/ConfigService';
import { eventBus } from '@/core/services/EventBusService';

export const useLayoutStore = defineStore('core-layout', () => {
    const isSidebarVisible = ref(true);
    const sidebarWidth = ref(configService.get('layout.sidebar.defaultWidth', 320));

    function toggleSidebar() {
        isSidebarVisible.value = !isSidebarVisible.value;
        eventBus.emit('core:state-changed', { store: 'layout' });
    }

    function setSidebarWidth(width: number) {
        const min = configService.get('layout.sidebar.minWidth', 240);
        const max = configService.get('layout.sidebar.maxWidth', 600);
        const newWidth = Math.max(min, Math.min(width, max));
        if (sidebarWidth.value !== newWidth) {
            sidebarWidth.value = newWidth;
            eventBus.emit('core:state-changed', { store: 'layout' });
        }
    }

    function hydrate(state: { isSidebarVisible?: boolean; sidebarWidth?: number; }) {
        if (typeof state.isSidebarVisible === 'boolean') {
            isSidebarVisible.value = state.isSidebarVisible;
        }
        if (typeof state.sidebarWidth === 'number') {
            // Use the setter to respect min/max constraints during hydration
            setSidebarWidth(state.sidebarWidth);
        }
    }

    // $subscribe logic is removed to centralize persistence in WorkspaceService

    return {
        isSidebarVisible,
        sidebarWidth,
        toggleSidebar,
        setSidebarWidth,
        hydrate,
    };
});

// =
// 文件: ..\src\core\stores\notificationStore.ts
//

// 文件: src/core/stores/notificationStore.ts
// 描述: 管理全局通知（Toast）的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';

export type NotificationType = 'info' | 'success' | 'warning' | 'error';

export interface Notification {
    id: number;
    message: string;
    type: NotificationType;
    duration?: number; // 显示时长（毫秒），可选
}

let nextId = 0;

export const useNotificationStore = defineStore('core-notification', () => {
    const notifications = ref<Notification[]>([]);

    /**
     * 添加一条新通知。
     * @param message - 通知内容。
     * @param type - 通知类型。
     * @param duration - （可选）显示时长，默认3000ms。
     */
    function add(message: string, type: NotificationType = 'info', duration: number = 3000) {
        const id = nextId++;
        notifications.value.push({ id, message, type, duration });

        if (duration > 0) {
            setTimeout(() => {
                remove(id);
            }, duration);
        }
    }

    /**
     * 移除一条通知。
     * @param id - 要移除的通知的ID。
     */
    function remove(id: number) {
        const index = notifications.value.findIndex(n => n.id === id);
        if (index !== -1) {
            notifications.value.splice(index, 1);
        }
    }

    return {
        notifications,
        add,
        remove,
    };
});

// =
// 文件: ..\src\core\stores\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Pane } from '@/core/types';
import { eventBus } from '@/core/services/EventBusService';
import { useNotificationStore } from './notificationStore';
import { workspaceService } from '@/core/services/WorkspaceService';

export const usePaneStore = defineStore('core-pane', () => {
    const panes = ref<Pane[]>([]);
    const activePaneId = ref<string | null>(null);

    const activePane = computed(() => {
        if (!activePaneId.value) return null;
        return panes.value.find(p => p.id === activePaneId.value) || null;
    });

    function initializePanes() {
        if (panes.value.length === 0) {
            const initialPaneId = `pane-${Date.now()}`;
            panes.value.push({ id: initialPaneId, tabIds: [], activeTabId: null });
            activePaneId.value = initialPaneId;
            eventBus.emit('core:pane.initialized', { initialPaneId });
            eventBus.emit('core:state-changed', { store: 'pane' });
        }
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId) && activePaneId.value !== paneId) {
            activePaneId.value = paneId;
            eventBus.emit('core:pane.activated', { paneId });
            eventBus.emit('core:state-changed', { store: 'pane' });
        }
    }

    function setActiveTab(paneId: string, tabId: string | null) {
        const pane = panes.value.find(p => p.id === paneId);
        if (pane && pane.activeTabId !== tabId) {
            pane.activeTabId = tabId;
            eventBus.emit('core:state-changed', { store: 'pane' });
        }
    }

    function addTabToPane(tabId: string, paneId: string) {
        const pane = panes.value.find(p => p.id === paneId);
        if (pane && !pane.tabIds.includes(tabId)) {
            pane.tabIds.push(tabId);
            eventBus.emit('core:state-changed', { store: 'pane' });
        }
    }

    function removeTabFromPane(tabId: string) {
        for (const pane of panes.value) {
            const index = pane.tabIds.indexOf(tabId);
            if (index > -1) {
                pane.tabIds.splice(index, 1);
                if (pane.activeTabId === tabId) {
                    const newActiveIndex = Math.max(0, index - 1);
                    pane.activeTabId = pane.tabIds[newActiveIndex] || null;
                }
                eventBus.emit('core:state-changed', { store: 'pane' });
                return;
            }
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) {
            useNotificationStore().add(`Cannot split: pane with ID "${sourcePaneId}" not found.`, 'error');
            return '';
        }

        const newPaneId = `pane-${Date.now()}`;
        const newPane: Pane = { id: newPaneId, tabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        eventBus.emit('core:pane.splitted', { sourcePaneId, newPaneId });
        eventBus.emit('core:state-changed', { store: 'pane' });
        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) {
            useNotificationStore().add('Cannot close the last pane.', 'warning');
            return;
        }

        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        const closedPane = panes.value[paneIndex];
        panes.value.splice(paneIndex, 1);

        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            const newActivePaneId = panes.value[newActiveIndex]?.id || null;
            activePaneId.value = newActivePaneId;
            eventBus.emit('core:pane.activated', { paneId: newActivePaneId });
        }

        eventBus.emit('core:pane.closed', { closedPaneId: paneId, tabIds: closedPane.tabIds });
        eventBus.emit('core:state-changed', { store: 'pane' });
    }

    function hydrate(state: { panes: Pane[], activePaneId: string | null }) {
        panes.value = state.panes;
        activePaneId.value = state.activePaneId;
    }



    return {
        panes,
        activePaneId,
        activePane,
        initializePanes,
        setActivePane,
        setActiveTab,
        addTabToPane,
        removeTabFromPane,
        splitPane,
        closePane,
        hydrate,
    };
});

// =
// 文件: ..\src\core\stores\tabStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { usePaneStore } from './paneStore';
import { useNotificationStore } from './notificationStore';
import type { ItemProvider, CoreItem } from '@/core/types/providers';
import type { Tab } from '@/core/types';
import { eventBus } from '@/core/services/EventBusService';
import { commandService } from '@/core/services/CommandService';

export const useTabStore = defineStore('core-tab', () => {
    const paneStore = usePaneStore();
    const notificationStore = useNotificationStore();
    let itemProvider: ItemProvider | null = null;

    const tabsById = ref<Map<string, Tab>>(new Map()); // Key: unique tab.id
    const tabPaneMap = ref<Map<string, string>>(new Map()); // Key: unique tab.id, Value: paneId

    const getTabById = (tabId: string) => tabsById.value.get(tabId);

    const getTabsForPane = (paneId: string) => {
        const pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.tabIds.map(id => getTabById(id)).filter((t): t is Tab => !!t);
    };

    function setItemProvider(provider: ItemProvider) {
        itemProvider = provider;
    }

    async function loadCoreItemForTab(tabId: string): Promise<CoreItem | null> {
        if (!itemProvider) {
            console.error('[TabStore] ItemProvider not set.');
            return null;
        }
        const tab = getTabById(tabId);
        if (!tab) {
            console.error(`[TabStore] Cannot load CoreItem, tab with id ${tabId} not found.`);
            return null;
        }

        try {
            const item = await itemProvider.getItem(tab.itemId);
            if (!item) {
                notificationStore.add(`Item for tab '${tab.title}' not found. It may have been deleted.`, 'error');
                await closeTab(tabId);
            }
            return item;
        } catch (error) {
            console.error(`Error loading item ${tab.itemId}`, error);
            notificationStore.add(`An error occurred while loading '${tab.title}'.`, 'error');
            await closeTab(tabId);
            return null;
        }
    }

    function activateTab(tabId: string) {
        const paneId = tabPaneMap.value.get(tabId);
        if (!paneId) return;

        paneStore.setActivePane(paneId);
        paneStore.setActiveTab(paneId, tabId);
        eventBus.emit('core:tab.activated', { tabId, paneId });
    }

    async function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) {
            notificationStore.add('No active pane to open the tab in.', 'error');
            return;
        }

        const paneTabs = getTabsForPane(paneId);
        const existingTab = paneTabs.find(t => t.itemId === itemId);
        if (existingTab) {
            activateTab(existingTab.id);
            return;
        }

        if (!itemProvider) throw new Error('[TabStore] ItemProvider has not been set.');

        const item = await itemProvider.getItem(itemId);
        if (!item) {
            notificationStore.add(`Failed to open: Item "${itemId}" not found.`, 'error');
            return;
        }

        const newTab: Tab = {
            id: `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            itemId: item.id,
            title: item.title,
            icon: item.icon,
            isDirty: false,
        };

        tabsById.value.set(newTab.id, newTab);
        tabPaneMap.value.set(newTab.id, paneId);

        paneStore.addTabToPane(newTab.id, paneId);
        activateTab(newTab.id);

        eventBus.emit('core:tab.opened', { tab: newTab, paneId });
        eventBus.emit('core:state-changed', { store: 'tab' });
    }

    async function forceCloseTab(tabId: string) {
        if (!tabsById.value.has(tabId)) return;

        const closedTab = tabsById.value.get(tabId)!;
        const paneId = tabPaneMap.value.get(tabId)!;

        tabsById.value.delete(tabId);
        tabPaneMap.value.delete(tabId);

        paneStore.removeTabFromPane(tabId);

        eventBus.emit('core:tab.closed', { tab: closedTab, paneId });
        eventBus.emit('core:state-changed', { store: 'tab' });
    }

    async function closeTab(tabId: string) {
        const tabToClose = tabsById.value.get(tabId);
        if (!tabToClose) return;

        if (tabToClose.isDirty) {
            // A more modern approach than window.confirm/prompt
            const userChoice = confirm(`Save changes for '${tabToClose.title}' before closing? \n\n'OK' to Save, 'Cancel' to Discard.`);
            if (userChoice) { // Save
                await commandService.execute('core.saveTab', { tabId });
                const stillDirty = tabsById.value.get(tabId)?.isDirty;
                if (!stillDirty) {
                    await forceCloseTab(tabId);
                } else {
                    notificationStore.add(`Failed to save '${tabToClose.title}'. Close aborted.`, 'error');
                }
            } else { // Discard
                await forceCloseTab(tabId);
            }
        } else {
            await forceCloseTab(tabId);
        }
    }

    function updateTabState(tabId: string, state: Partial<Pick<Tab, 'isDirty' | 'title' | 'icon'>>) {
        const tab = tabsById.value.get(tabId);
        if (tab) {
            Object.assign(tab, state);
            eventBus.emit('core:tab.stateChanged', { tabId, newState: state });
            eventBus.emit('core:state-changed', { store: 'tab' });
        }
    }

    eventBus.on('core:pane.closed', ({ tabIds }: { tabIds: string[] }) => {
        tabIds.forEach(id => forceCloseTab(id));
    });

    return {
        getTabById,
        getTabsForPane,
        setItemProvider,
        loadCoreItemForTab,
        openTab,
        closeTab,
        activateTab,
        updateTabState,
    };
});

// =
// 文件: ..\src\core\types\index.ts
//



export interface CoreItem {
    id: string;
    title: string;
    icon: string;
    viewType: string;
    metadata: Record<string, any>;
}

export interface Tab {
    id: string; // <-- 唯一的标签页实例ID
    itemId: string; // <-- 所代表的CoreItem的ID
    title: string;
    icon: string;
    isDirty: boolean;
}

export interface Pane {
    id:string;
    tabIds: string[];
    activeTabId: string | null;
}

export interface CommandContext {
    [key: string]: any;
}

export interface Command {
    id: string;
    label: string | ((context: CommandContext) => string);
    icon?: string;
    when?: (context: CommandContext) => boolean;
    execute: (context: CommandContext) => void;
}

export interface ContextMenuItem {
    commandId: string;
    context?: CommandContext;
    isDivider?: boolean;

}

// =
// 文件: ..\src\core\types\providers.ts
//



import type { CoreItem } from './index';

/**
 * 数据提供者接口 (ItemProvider Interface)。
 * 内核依赖此接口来获取和更新数据。
 * 应用层必须提供一个实现了此接口的对象，并将其注入到内核中。
 */
export interface ItemProvider {
    /**
     * 根据ID异步获取一个项目。
     * @param id - 要获取的项目的唯一ID。
     * @returns 返回一个Promise，解析为CoreItem对象或在找不到时解析为null。
     */
    getItem(id: string): Promise<CoreItem | null>;

    /**
     * 根据ID和新内容更新一个项目。
     * @param id - 要更新的项目的唯一ID。
     * @param content - 项目的新内容。
     * @returns 返回一个Promise，在更新完成后解析。可用于处理保存失败的情况。
     */
    updateItem(id: string, content: string): Promise<void>;
}

