// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\editor\assets\styles\main.css
//

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
}

// =
// 文件: ..\src\novel\editor\components\ai\AIChatView.vue
//

<template>
  <div class="flex-1 flex overflow-hidden h-full">
    <ConversationList />

    <main v-if="activeConversation" class="flex-1 flex flex-col bg-white">
      <ChatHeader :active-conversation="activeConversation" :current-model="currentModel" />
      <ChatMessageHistory :conversation="activeConversation" :is-receiving="isReceiving" />
      <ChatInputArea />
    </main>

    <div v-else class="flex-1 flex items-center justify-center bg-white text-gray-400">
      请从左侧选择或新建一个对话
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { useChatStore } from '../../stores/chatStore';
import { storeToRefs } from 'pinia';
import ConversationList from './chat/ConversationList.vue';
import ChatHeader from './chat/ChatHeader.vue';
import ChatMessageHistory from './chat/ChatMessageHistory.vue';
import ChatInputArea from './chat/ChatInputArea.vue';

const chatStore = useChatStore();
const { activeConversation, currentModel, isReceiving } = storeToRefs(chatStore);

onMounted(() => {
  chatStore.fetchConversations();
});
</script>

// =
// 文件: ..\src\novel\editor\components\ai\AIDiffPreview.vue
//

<template>
  <div class="diff-preview-container">
    <div class="header">
      <h3 class="title">AI生成预览</h3>
      <div class="actions">
        <button v-if="previewTask && previewTask.status === 'completed'" @click="$emit('apply-changes', previewTask.id)" class="apply-btn">
          <i class="fa-solid fa-check"></i>
          应用修改
        </button>
      </div>
    </div>
    <div class="content-area">
      <div v-if="previewTask">
        <div class="prose-preview">
          <div v-html="previewTask.generatedContent.replace(/\n/g, '<br>')"></div>
          <span v-if="previewTask.status === 'processing'" class="blinking-cursor">▍</span>
        </div>
      </div>
      <div v-else class="empty-state">
        <i class="fa-regular fa-eye text-3xl text-gray-300"></i>
        <p class="mt-2">请从上方任务队列中</p>
        <p>选择一个任务来查看预览。</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask } from '../../types';

defineProps({
  previewTask: { type: Object as PropType<AITask | null>, default: null }
});
defineEmits<{ (e: 'apply-changes', taskId: string): void; }>();
</script>

<style scoped>
.diff-preview-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; height: 32px; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.apply-btn { display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background-color: #16A34A; color: white; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 500; }
.apply-btn:hover { background-color: #15803D; }
.content-area { flex-grow: 1; background-color: #FFFFFF; border-radius: 0.5rem; border: 1px solid #E5E7EB; padding: 1rem; overflow-y: auto; font-size: 0.875rem; line-height: 1.7; color: #374151; scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.content-area::-webkit-scrollbar { width: 6px; }
.content-area::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
.prose-preview { white-space: pre-wrap; }
.blinking-cursor { font-weight: 500; font-size: 1em; color: #3B82F6; animation: blink 1s step-end infinite; }
@keyframes blink { from, to { color: transparent; } 50% { color: #3B82F6; } }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskPanel.vue
//

<template>
  <div class="flex flex-col h-full bg-[#F9FAFB]">
    <div class="flex-1 min-h-0">
      <AITaskQueue @select-task="handleSelectTask" />
    </div>
    <div class="flex-1 min-h-0">
      <AIDiffPreview :preview-task="selectedTask" @apply-changes="handleApplyChanges" />
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed } from 'vue';
import AITaskQueue from './AITaskQueue.vue';
import AIDiffPreview from './AIDiffPreview.vue';
import { useAITaskStore } from '../../stores/aiTaskStore';
import type { AITask } from '../../types';

const selectedTaskId = ref<string | null>(null);
const aiTaskStore = useAITaskStore();

const selectedTask = computed((): AITask | null => {
  if (!selectedTaskId.value) return null;
  return aiTaskStore.tasks.find(t => t.id === selectedTaskId.value) ?? null;
});

const handleSelectTask = (task: AITask) => {
  selectedTaskId.value = task.id;
};

const handleApplyChanges = (taskId: string) => {
  aiTaskStore.applyChanges(taskId);
  selectedTaskId.value = null;
};
</script>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskQueue.vue
//

<template>
  <div class="task-queue-container">
    <div class="header">
      <h3 class="title">AI任务队列</h3>
      <span v-if="activeTasksCount > 0" class="badge">{{ activeTasksCount }}个活跃</span>
    </div>
    <div v-if="tasks.length > 0" class="task-list">
      <div
          v-for="task in tasks"
          :key="task.id"
          :class="['task-item', `status-${task.status}`, { 'clickable': isClickable(task.status) }]"
          @click="handleTaskClick(task)"
      >
        <div class="task-item-header">
          <p class="task-title" :title="task.title">{{ task.title }}</p>
          <span class="task-status-text">
            <i :class="getStatusIcon(task.status)" class="status-icon"></i>
            {{ getStatusText(task.status) }}
          </span>
        </div>
        <div class="task-item-body">
          <div v-if="task.status === 'processing'" class="progress-bar-container">
            <div class="progress-bar"></div>
          </div>
          <p v-if="task.status === 'failed'" class="error-message">
            {{ task.error }} <a href="#" @click.prevent.stop="handleRetry(task)" class="retry-link">重试</a>
          </p>
          <p v-else class="message">{{ getStatusMessage(task.status) }}</p>
        </div>
      </div>
    </div>
    <div v-else class="empty-state">
      <i class="fa-regular fa-folder-open text-3xl text-gray-300"></i>
      <p class="mt-2">当前没有AI任务</p>
      <p class="text-xs text-gray-400 mt-1">在编辑器中右键开始</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useAITaskStore } from '../../stores/aiTaskStore';
import type { AITask, AITaskStatus } from '../../types';

const emit = defineEmits<{ (e: 'select-task', task: AITask): void; }>();

const aiTaskStore = useAITaskStore();
const tasks = computed(() => aiTaskStore.tasks);
const activeTasksCount = computed(() => aiTaskStore.activeTasksCount);

const getStatusText = (status: AITaskStatus) => ({ pending: '等待中', processing: '进行中...', completed: '待应用', failed: '失败', applied: '已应用' }[status]);
const getStatusIcon = (status: AITaskStatus) => ({ pending: 'fa-solid fa-hourglass-half', processing: 'fa-solid fa-spinner fa-spin', completed: 'fa-solid fa-check-circle', failed: 'fa-solid fa-times-circle', applied: 'fa-solid fa-check-double' }[status]);
const getStatusMessage = (status: AITaskStatus) => ({ processing: '点击查看实时生成', completed: '点击预览与应用', applied: '已自动应用，点击查看详情' }[status] || '');
const isClickable = (status: AITaskStatus) => ['completed', 'processing', 'applied'].includes(status);

const handleTaskClick = (task: AITask) => isClickable(task.status) && emit('select-task', task);
const handleRetry = (task: AITask) => aiTaskStore.retryTask(task.id);
</script>

<style scoped>
.task-queue-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; border-bottom: 1px solid #E5E7EB; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.badge { font-size: 0.75rem; font-weight: 500; padding: 0.125rem 0.5rem; border-radius: 9999px; color: #1D4ED8; background-color: #DBEAFE; }
.task-list { flex-grow: 1; overflow-y: auto; space-y: 0.5rem; padding-right: 4px; scrollbar-width: thin; scrollbar-color: #D1D5DB #f9fafb; }
.task-list::-webkit-scrollbar { width: 6px; }
.task-list::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
.task-item { padding: 0.75rem; border-radius: 0.5rem; border: 1px solid #E5E7EB; transition: all 0.2s ease; background-color: #FFFFFF;}
.task-item.clickable { cursor: pointer; }
.task-item.clickable:hover { border-color: #D1D5DB; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.task-item-header { display: flex; justify-content: space-between; align-items: center; }
.task-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.task-status-text { font-size: 0.75rem; font-weight: 500; display: flex; align-items: center; gap: 0.25rem; flex-shrink: 0; }
.status-icon { width: 1rem; text-align: center; }
.status-processing .task-status-text { color: #2563EB; }
.status-completed .task-status-text { color: #16A34A; }
.status-failed .task-status-text { color: #DC2626; }
.task-item-body { margin-top: 0.5rem; }
.progress-bar-container { width: 100%; background-color: #E5E7EB; border-radius: 9999px; height: 0.25rem; overflow: hidden; }
.progress-bar { background-color: #3B82F6; height: 100%; width: 100%; border-radius: 9999px; animation: indeterminate-progress 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
@keyframes indeterminate-progress { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
.error-message, .message { font-size: 0.75rem; margin-top: 0.25rem; }
.error-message { color: #B91C1C; }
.message { color: #6B7280; }
.retry-link { text-decoration: underline; font-weight: 500; }
.empty-state { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatHeader.vue
//

<template>
  <header class="h-20 px-8 flex items-center justify-between border-b border-gray-100 flex-shrink-0">
    <div class="flex items-center gap-4">
      <div class="w-10 h-10 bg-gradient-to-br from-[#4B5563] to-[#374151] rounded-full flex items-center justify-center">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 21v-1.5M15.75 3v1.5M12 4.5v15M15.75 21v-1.5" /></svg>
      </div>
      <div>
        <h2 class="font-medium text-[#374151]">{{ activeConversation.title }}</h2>
        <button class="text-sm text-[#6B7280] flex items-center gap-2 hover:text-[#374151] transition-colors mt-1">
          <span class="w-2 h-2 rounded-full" :class="currentModel.status === 'online' ? 'bg-[#10B981]' : 'bg-gray-400'"></span>
          {{ currentModel.status === 'online' ? '在线' : '离线' }} • {{ currentModel.name }}
          <svg class="w-3 h-3 text-gray-500" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"></path></svg>
        </button>
      </div>
    </div>
    <div class="flex items-center gap-2">
      <button class="w-9 h-9 flex items-center justify-center text-gray-500 hover:bg-gray-100 rounded-lg transition-colors" title="上下文管理">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" /></svg>
      </button>
      <button class="w-9 h-9 flex items-center justify-center text-gray-500 hover:bg-gray-100 rounded-lg transition-colors" title="设置">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-1.007 1.11-.95.542.057 1.007.56 1.061 1.11L12 8.583l.235-3.535c.057-.542.56-1.007 1.11-.95.542.057 1.007.56 1.061 1.11L15.417 8.583l3.536-.235c.542-.057 1.007.56 1.061 1.11.057.542-.42 1.007-.95 1.061l-3.536.235.235 3.536c.057.542-.42 1.007-.95 1.061-.542.057-1.007-.42-1.061-.95L12 15.417l-.235 3.536c-.057.542-.56 1.007-1.11.95-.542-.057-1.007-.56-1.061-1.11L9.417 15.417l-3.536.235c-.542-.057-1.007-.42-.95-1.061.057-.542.42-1.007.95-1.061l3.536-.235-.235-3.536c-.057-.542.42-1.007.95-1.061.542-.057 1.007.42 1.061.95L12 9.417l.235-3.536zM12 14.25a2.25 2.25 0 100-4.5 2.25 2.25 0 000 4.5z" /></svg>
      </button>
    </div>
  </header>
</template>
<script setup lang="ts">
import type { PropType } from 'vue';
import type { Conversation, AIModel } from '../../../types';

defineProps({
  activeConversation: { type: Object as PropType<Conversation>, required: true },
  currentModel: { type: Object as PropType<AIModel>, required: true },
});
</script>

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatInputArea.vue
//

<template>
  <div class="p-4 border-t border-gray-100 bg-[#FAFAFA]">
    <div class="flex gap-3 items-end max-w-5xl mx-auto">
      <button class="w-9 h-9 flex-shrink-0 flex items-center justify-center text-gray-500 hover:bg-gray-200 rounded-lg transition-colors">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M18.375 12.739l-7.693 7.693a4.5 4.5 0 01-6.364-6.364l10.94-10.94A3.375 3.375 0 1118.375 12.74z" /></svg>
      </button>
      <div class="flex-1 bg-white border border-gray-200 rounded-lg focus-within:ring-1 focus-within:ring-blue-500 focus-within:border-blue-500 transition-shadow">
        <textarea
            v-model="messageInput"
            @keydown.enter.exact.prevent="sendMessage"
            class="w-full bg-transparent p-2.5 text-sm text-[#374151] resize-none outline-none hide-scrollbar"
            placeholder="输入您的问题，按 Enter 发送"
            rows="1"
            ref="textareaRef"
        ></textarea>
      </div>
      <button
          @click="sendMessage"
          :disabled="isReceiving || !messageInput.trim()"
          class="w-10 h-10 flex-shrink-0 bg-[#4B5563] text-white rounded-lg hover:bg-[#374151] transition-colors flex items-center justify-center disabled:bg-gray-300 disabled:cursor-not-allowed"
      >
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5"></path></svg>
      </button>
    </div>
    <div class="text-center mt-2 text-xs text-[#9CA3AF]">
      <span>按 Shift+Enter 换行 • 当前会话: {{ currentTokenCount }} tokens</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { useChatStore } from '../../../stores/chatStore';
import { storeToRefs } from 'pinia';

const chatStore = useChatStore();
const { messageInput, isReceiving, currentTokenCount } = storeToRefs(chatStore);
const textareaRef = ref<HTMLTextAreaElement | null>(null);
const sendMessage = () => chatStore.sendMessage();
watch(messageInput, (newValue) => {
  const el = textareaRef.value;
  if (el) {
    el.style.height = 'auto';
    el.style.height = `${el.scrollHeight}px`;
    if (!newValue) el.style.height = 'auto';
  }
});
</script>
<style scoped>
.hide-scrollbar::-webkit-scrollbar { display: none; }
.hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatMessageHistory.vue
//

<template>
  <div class="flex-1 p-6 overflow-y-auto" ref="chatHistoryContainer">
    <div class="max-w-5xl mx-auto space-y-6">
      <div v-if="conversation" v-for="message in conversation.messages" :key="message.id" class="group relative">
        <!-- 用户消息 -->
        <div v-if="message.role === 'user'" class="flex justify-end items-center gap-2">
          <div class="flex items-center gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity">
            <button class="w-7 h-7 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"><i class="fa-solid fa-pen-to-square"></i></button>
            <button class="w-7 h-7 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"><i class="fa-solid fa-copy"></i></button>
          </div>
          <div class="bg-[#3B82F6] text-white p-4 rounded-xl rounded-br-lg max-w-[70%] text-sm" v-html="message.content"></div>
        </div>

        <!-- AI回复 -->
        <div v-if="message.role === 'ai'" class="flex items-start gap-3">
          <div class="w-8 h-8 bg-gradient-to-br from-[#4B5563] to-[#374151] rounded-full flex items-center justify-center flex-shrink-0 shadow-sm">
            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 21v-1.5M15.75 3v1.5M12 4.5v15M15.75 21v-1.5" /></svg>
          </div>
          <div class="bg-[#F3F4F6] text-[#374151] p-4 rounded-xl rounded-bl-lg max-w-[70%] text-sm" v-html="message.content"></div>
          <div class="flex items-center gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity self-center">
            <button class="w-7 h-7 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"><i class="fa-solid fa-rotate-right"></i></button>
            <button class="w-7 h-7 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-lg hover:bg-gray-100"><i class="fa-solid fa-copy"></i></button>
          </div>
        </div>
      </div>

      <!-- AI正在输入指示器 -->
      <div v-if="isReceiving" class="flex items-start gap-3">
        <div class="w-8 h-8 bg-gradient-to-br from-[#4B5563] to-[#374151] rounded-full flex items-center justify-center flex-shrink-0 shadow-sm">
          <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 21v-1.5M15.75 3v1.5M12 4.5v15M15.75 21v-1.5" /></svg>
        </div>
        <div class="bg-[#F3F4F6] text-[#374151] p-4 rounded-xl rounded-bl-lg text-sm">
          <span class="blinking-cursor">▍</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, type PropType } from 'vue';
import type { Conversation } from '../../../types';

const props = defineProps({
  conversation: { type: Object as PropType<Conversation | null>, required: true },
  isReceiving: { type: Boolean, required: true },
});
const chatHistoryContainer = ref<HTMLElement | null>(null);
const scrollToBottom = () => nextTick(() => {
  if (chatHistoryContainer.value) chatHistoryContainer.value.scrollTop = chatHistoryContainer.value.scrollHeight;
});
watch(() => props.conversation?.messages, scrollToBottom, { deep: true, flush: 'post' });
watch(() => props.isReceiving, (isReceiving) => isReceiving && scrollToBottom(), { flush: 'post' });
</script>

<style scoped>
.blinking-cursor { font-weight: 500; animation: blink 1s step-end infinite; }
@keyframes blink { 50% { color: #3B82F6; } }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\chat\ConversationList.vue
//

<template>
  <aside class="w-80 bg-gray-50/50 border-r border-gray-200/80 flex flex-col flex-shrink-0">
    <div class="p-4 border-b border-gray-200/80 h-20 flex items-center">
      <button
          @click="chatStore.createNewConversation"
          class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-gray-800 text-white rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors"
      >
        <i class="fa-solid fa-plus fa-sm"></i>
        新建对话
      </button>
    </div>

    <div class="flex-1 p-2 space-y-1 overflow-y-auto hide-scrollbar">
      <a
          v-for="conv in chatStore.conversations"
          :key="conv.id"
          href="#"
          @click.prevent="chatStore.selectConversation(conv.id)"
          class="block p-3 rounded-lg transition-colors"
          :class="{
            'bg-blue-100': chatStore.activeConversationId === conv.id,
            'hover:bg-gray-200/60': chatStore.activeConversationId !== conv.id
          }"
      >
        <div class="flex items-start gap-3">
          <div class="w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0" :class="chatStore.activeConversationId === conv.id ? 'bg-blue-600' : 'bg-gray-200'">
            <svg class="w-4 h-4" :class="chatStore.activeConversationId === conv.id ? 'text-white' : 'text-gray-600'" fill="currentColor" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z"></path></svg>
          </div>
          <div class="flex-1 min-w-0">
            <p class="font-medium text-sm text-gray-800 truncate">{{ conv.title }}</p>
            <p class="text-xs text-gray-500 truncate mt-1">{{ conv.summary }}</p>
            <p class="text-xs text-gray-400 mt-2">{{ conv.createdAt }}</p>
          </div>
        </div>
      </a>
    </div>
  </aside>
</template>

<script setup lang="ts">
import { useChatStore } from '../../../stores/chatStore';
const chatStore = useChatStore();
</script>
<style scoped>
.hide-scrollbar::-webkit-scrollbar { display: none; }
.hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\FloatingToolbar.vue
//

<template>
  <div
      v-if="visible"
      class="floating-toolbar"
      :style="{ top: `${position.top}px`, left: `${position.left}px` }"
      @mousedown.prevent
  >
    <button @click="execute('novel.ai.analyze')" title="分析内容" class="toolbar-btn"><i class="fa-solid fa-magnifying-glass-chart"></i></button>
    <button @click="execute('novel.ai.continue')" title="AI续写" class="toolbar-btn"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
    <button @click="execute('novel.ai.polish')" title="润色文本" class="toolbar-btn"><i class="fa-solid fa-spell-check"></i></button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { commandService } from '@core/services/CommandService';
import { usePaneStore } from '@core/panes/stores/paneStore';

const visible = ref(false);
const position = ref({ top: 0, left: 0 });

const show = (rect: DOMRect, wrapperRect: DOMRect) => {
  visible.value = true;
  position.value = {
    top: rect.top - wrapperRect.top - 48,
    left: rect.left - wrapperRect.left + rect.width / 2 - 60,
  };
};

const hide = () => {
  visible.value = false;
};

const execute = (commandId: string) => {
  const paneStore = usePaneStore();
  const activeTabId = paneStore.activePane?.activeTabId;
  if (activeTabId) {
    commandService.execute(commandId, { itemId: activeTabId });
  }
  hide();
};

defineExpose({ show, hide });
</script>

<style scoped>
.floating-toolbar { position: absolute; z-index: 10; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.375rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); display: flex; gap: 0.25rem; }
.toolbar-btn { width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center; color: #4B5563; border-radius: 0.375rem; }
.toolbar-btn:hover { background-color: #f3f4f6; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\TiptapEditor.vue
//

<template>
  <div v-if="editor" class="editor-wrapper">
    <editor-content
        :editor="editor"
        class="prose prose-lg max-w-none"
    />
  </div>
</template>
<script setup lang="ts">
import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { watch, onBeforeUnmount } from 'vue'
const props = defineProps<{ modelValue: string }>()
const emit = defineEmits<{ (e: 'update:modelValue', value: string): void }>()
const editor = useEditor({
  content: props.modelValue,
  extensions: [ StarterKit.configure({ heading: { levels: [1, 2, 3] } }) ],
  onUpdate: () => emit('update:modelValue', editor.value?.getHTML() || ''),
  editorProps: { attributes: { class: 'prose-mirror-focus' } },
})
watch(() => props.modelValue, (newValue) => {
  if (editor.value?.getHTML() === newValue) return;
  editor.value?.commands.setContent(newValue, false)
})
onBeforeUnmount(() => editor.value?.destroy())
</script>
<style scoped>
:deep(.ProseMirror) { outline: none; padding: 1rem; font-family: 'Georgia', 'Noto Serif SC', serif; line-height: 1.75; color: #374151; }
:deep(.prose h1) { font-family: 'Noto Serif SC', serif; font-size: 1.875rem; font-weight: 600; margin-bottom: 1.5rem; }
:deep(.prose p) { margin-top: 1em; margin-bottom: 1em; }
:deep(.prose h2) { font-family: 'Noto Serif SC', serif; font-size: 1.5rem; font-weight: 600; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb; margin-top: 2rem; margin-bottom: 1rem; }
:deep(.prose h3) { font-family: 'Noto Serif SC', serif; font-size: 1.25rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.75rem; }
</style>

// =
// 文件: ..\src\novel\editor\components\layout\ActivityBar.vue
//

<template>
  <div class="activity-bar-container">
    <div class="main-actions">
      <button
          v-for="tab in mainTabs"
          :key="tab.id"
          class="action-item"
          :class="{ 'active': editorStore.activeSidebarPanelId === tab.id && editorStore.isSidebarVisible }"
          :title="tab.title"
          @click="commandService.execute('novel.sidebar.show-panel', { panelId: tab.id })"
      >
        <i :class="tab.icon"></i>
      </button>

      <div class="divider"></div>

      <button
          v-for="action in actionButtons"
          :key="action.id"
          class="action-item"
          :title="action.title"
          @click="commandService.execute('novel.system-view.open', { viewId: action.id })"
      >
        <i :class="action.icon"></i>
      </button>

    </div>
    <div class="footer-actions">
      <button class="action-item" title="管理" @click.stop="showManageMenu">
        <i class="fa-solid fa-gear"></i>
      </button>
      <button class="action-item" title="账户">
        <i class="fa-solid fa-user-circle"></i>
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useEditorStore } from '../../stores/editorStore';
import { commandService } from '@core/services/CommandService';
import { eventBus } from '@core/common/services/EventBusService';

const editorStore = useEditorStore();

const mainTabs = ref([
  { id: 'directory', title: '目录', icon: 'fa-solid fa-list-ul' },
  { id: 'related', title: '相关', icon: 'fa-solid fa-sitemap' },
  { id: 'notes', title: '笔记', icon: 'fa-solid fa-book-medical' },
]);

const actionButtons = ref([
  { id: 'system:search', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
  { id: 'system:ai_chat', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
]);

const showManageMenu = (event: MouseEvent) => {
  eventBus.emit('show-manage-menu', event.currentTarget);
};
</script>

<style scoped>
.activity-bar-container { width: 52px; height: 100%; background-color: #F3F4F6; display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 0.5rem 0; flex-shrink: 0; }
.main-actions, .footer-actions { display: flex; flex-direction: column; gap: 0.5rem; }
.action-item { width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; color: #6B7280; border-radius: 0.5rem; transition: all 0.2s ease-in-out; position: relative; }
.action-item:hover { color: #1F2937; background-color: #E5E7EB; }
.action-item.active { color: #2563EB; background-color: #DBEAFE; }
.action-item.active::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 3px; height: 24px; background-color: #2563EB; border-radius: 0 4px 4px 0; }
.divider { height: 1px; width: 28px; background-color: #E5E7EB; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\novel\editor\components\layout\BreadcrumbsBar.vue
//

<template>
  <div class="breadcrumbs-bar-container" :class="{'is-active-pane': isActive}">
    <div class="breadcrumbs">
      <template v-if="activeTab">
        <span>{{ volumeTitle }}</span>
        <i class="fa-solid fa-chevron-right separator"></i>
        <span class="font-medium title-highlight">{{ activeTab.title }}</span>
      </template>
      <template v-else>
        <span></span>
      </template>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, type PropType } from 'vue';
import { useDirectoryStore } from '../../stores/directoryStore';
import type { Tab } from '@core/types';

const props = defineProps<{
  activeTab: Tab | null;
  isActive: boolean;
}>();

const directoryStore = useDirectoryStore();

const volumeTitle = computed(() => {
  if (!props.activeTab) return '...';

  const result = directoryStore.findNodeById(props.activeTab.itemId);
  if (result?.parent) {
    return result.parent.title;
  }
  return '根目录';
});
</script>
<style scoped>
.breadcrumbs-bar-container { height: 40px; display: flex; align-items: center; padding: 0 1rem; background-color: #FFFFFF; border-bottom: 1px solid #E5E7EB; flex-shrink: 0; overflow-x: auto; transition: color 0.2s; }
.breadcrumbs { display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: #6B7280; white-space: nowrap; }
.title-highlight { color: #374151; }
.breadcrumbs-bar-container:not(.is-active-pane) .breadcrumbs { color: #B0B3B8; }
.breadcrumbs-bar-container:not(.is-active-pane) .title-highlight { color: #9CA3AF; }
.separator { font-size: 0.625rem; color: #D1D5DB; }
</style>

// =
// 文件: ..\src\novel\editor\components\layout\ManageMenu.vue
//

<template>
  <div
      v-if="visible"
      ref="menuRef"
      class="manage-menu-container"
      :style="menuStyle"
      @click.stop
  >
    <ul class="menu-list">
      <li v-for="item in menuItems" :key="item.id">
        <div v-if="item.isDivider" class="menu-divider"></div>
        <a v-else href="#" class="menu-item" @click.prevent="selectItem(item.id)">
          <span>{{ item.label }}</span>
          <span v-if="item.shortcut" class="shortcut">{{ item.shortcut }}</span>
        </a>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { eventBus } from '@core/common/services/EventBusService';
import { commandService } from '@core/services/CommandService';
import { CoreCommand } from '@core/constants';

const visible = ref(false);
const position = ref({ bottom: 0, left: 0 });
const menuRef = ref<HTMLElement | null>(null);

const menuItems = ref([
  { id: CoreCommand.COMMAND_PALETTE_SHOW, label: '命令面板...', shortcut: 'Ctrl+Shift+P' },
  { isDivider: true, id:'d1' },
  { id: 'system:settings_novel', label: '小说设置', shortcut: '' },
  { id: 'system:settings_context', label: '上下文管理', shortcut: '' },
  { id: 'system:settings_ai_config', label: 'AI 任务配置', shortcut: '' },
  { isDivider: true, id:'d2' },
  { id: 'system:settings_editor', label: '编辑器设置', shortcut: '' },
  { id: 'system:settings_tasks', label: '任务管理', shortcut: '' },
]);

const menuStyle = computed(() => ({
  bottom: `${position.value.bottom}px`,
  left: `${position.value.left}px`,
}));

const show = (buttonElement: HTMLElement) => {
  const rect = buttonElement.getBoundingClientRect();
  position.value.bottom = window.innerHeight - rect.top + 8;
  position.value.left = rect.left;
  visible.value = true;
};

const hide = () => {
  visible.value = false;
};

const selectItem = (commandId: string) => {
  if(commandId.startsWith('system:')) {
    commandService.execute('novel.system-view.open', { viewId: commandId });
  } else {
    commandService.execute(commandId);
  }
  hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (menuRef.value && !menuRef.value.contains(event.target as Node)) {
    hide();
  }
};

const handleShowMenu = (target: any) => {
  if (target instanceof HTMLElement) {
    show(target);
  }
};

onMounted(() => {
  window.addEventListener('click', handleClickOutside);
  eventBus.on('show-manage-menu', handleShowMenu);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', handleClickOutside);
  eventBus.off('show-manage-menu', handleShowMenu);
});
</script>

<style scoped>
.manage-menu-container { position: fixed; z-index: 1000; width: 260px; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 0.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1); color: #374151; }
.menu-list { list-style: none; }
.menu-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; cursor: pointer; text-decoration: none; color: inherit; transition: background-color 0.15s; }
.menu-item:hover { background-color: #f3f4f6; color: #1f2937; }
.shortcut { color: #9ca3af; }
.menu-item:hover .shortcut { color: #6b7280; }
.menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\novel\editor\components\layout\PaneActions.vue
//

<template>
  <div class="pane-actions-container" :class="{'is-active-pane': isActive}">
    <button @click="commandService.execute('novel.system-view.open', { viewId: 'system:ai_tasks' })" class="toolbar-btn" title="AI 任务面板">
      <i class="fa-solid fa-list-check"></i>
    </button>
    <button @click="commandService.execute('novel.history-view.open')" class="toolbar-btn" title="版本历史">
      <i class="fa-solid fa-code-compare"></i>
    </button>
    <div class="divider"></div>
    <button @click="commandService.execute(CoreCommand.PANE_SPLIT_HORIZONTAL, { paneId })" class="toolbar-btn" title="分屏">
      <i class="fa-solid fa-columns"></i>
    </button>
    <button v-if="isPaneClosable" @click="commandService.execute(CoreCommand.PANE_CLOSE, { paneId })" class="toolbar-btn" title="关闭窗格">
      <i class="fa-solid fa-xmark"></i>
    </button>
    <button @click="commandService.execute('novel.reader-view.open')" class="toolbar-btn" title="阅读模式">
      <i class="fa-solid fa-book-open"></i>
    </button>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import { usePaneStore } from '@core/panes/stores/paneStore';
import { commandService } from '@core/services/CommandService';
import { CoreCommand, CoreContext } from '@core/constants';
import { contextService } from '@core/common/services/ContextService';

defineProps<{
  paneId: string;
  isActive: boolean;
}>();

const paneStore = usePaneStore();
const isPaneClosable = computed(() => paneStore.root?.type === 'split' && contextService.check(CoreContext.PANE_IS_SPLIT));

</script>
<style scoped>
.pane-actions-container { display: flex; align-items: center; gap: 0.5rem; padding: 0 1rem; flex-shrink: 0; transition: color 0.2s; }
.toolbar-btn { width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: all 0.2s; }
.pane-actions-container.is-active-pane .toolbar-btn:hover { background-color: #E5E7EB; color: #1F2937; }
.pane-actions-container:not(.is-active-pane) .toolbar-btn { color: #B0B3B8; }
.divider { width: 1px; height: 16px; background-color: #E5E7EB; margin: 0 0.25rem; }
</style>

// =
// 文件: ..\src\novel\editor\components\layout\StatusBar.vue
//

<template>
  <div class="status-bar-container">
    <div class="status-bar-left">
      <div v-if="editorStore.activeTabId" class="status-item">
        <i class="fa-solid fa-check-double text-green-500"></i>
        <span>已保存</span>
      </div>
      <div v-if="editorStore.wordCount > 0" class="status-item">
        <span>{{ editorStore.wordCount }} 字</span>
      </div>
      <div v-if="editorStore.readingTime > 0" class="status-item">
        <span>约 {{ editorStore.readingTime }} 分钟阅读</span>
      </div>
    </div>
    <div class="status-bar-right">
      <div class="status-item">
        <span>Ln 1, Col 1</span>
      </div>
      <div class="status-item">
        <span>UTF-8</span>
      </div>
      <div class="status-item" title="通知">
        <i class="fa-regular fa-bell"></i>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useEditorStore } from '../../stores/editorStore';
const editorStore = useEditorStore();
</script>

<style scoped>
.status-bar-container { height: 28px; background-color: #F3F4F6; display: flex; align-items: center; justify-content: space-between; padding: 0 1rem; font-size: 0.75rem; color: #4B5563; flex-shrink: 0; user-select: none; }
.status-bar-left, .status-bar-right { display: flex; align-items: center; gap: 1rem; }
.status-item { display: flex; align-items: center; gap: 0.375rem; cursor: pointer; }
.status-item:hover { color: #1F2937; }
</style>

// =
// 文件: ..\src\novel\editor\components\modals\ContextPreviewModal.vue
//

<template>
  <div
      v-if="store.isVisible"
      class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4"
      @click.self="store.hide()"
  >
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
      <!-- 头部 -->
      <div class="flex-shrink-0 px-8 py-5 border-b border-gray-100 flex justify-between items-center">
        <div>
          <h1 class="text-xl font-semibold text-[#374151]">上下文预览</h1>
          <p class="text-sm text-[#6B7280] mt-1">{{ taskInfoText }}</p>
        </div>
        <button @click="store.hide()" class="p-2 rounded-full text-gray-400 hover:bg-gray-100 hover:text-gray-600 transition-colors">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
        </button>
      </div>

      <!-- 上下文列表 (可滚动) -->
      <div class="flex-grow p-6 space-y-4 overflow-y-auto bg-gray-50/50">
        <!-- 固定上下文 -->
        <div class="border border-gray-200/70 rounded-lg overflow-hidden bg-white shadow-sm">
          <div @click="toggleCollapse('fixed')" class="px-6 py-4 cursor-pointer hover:bg-gray-50 transition-colors flex items-center justify-between">
            <div class="flex items-center gap-4">
              <svg class="w-5 h-5 text-gray-400 collapse-arrow" :class="{ 'expanded': collapsedStates.fixed }" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 5l7 7-7 7"/></svg>
              <svg class="w-6 h-6 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/></svg>
              <div>
                <h3 class="font-medium text-[#374151]">固定上下文</h3>
                <p class="text-xs text-[#9CA3AF] mt-0.5">始终包含在 AI 对话中的基础信息</p>
              </div>
            </div>
          </div>
          <div class="collapse-content" :class="{ 'expanded': collapsedStates.fixed }">
            <div class="px-6 pb-4 border-t border-gray-100 pt-4 text-sm text-gray-600">固定上下文内容占位...</div>
          </div>
        </div>

        <!-- 动态上下文 -->
        <div class="border border-gray-200/70 rounded-lg overflow-hidden bg-white shadow-sm">
          <div @click="toggleCollapse('dynamic')" class="px-6 py-4 cursor-pointer hover:bg-gray-50 transition-colors flex items-center justify-between">
            <div class="flex items-center gap-4">
              <svg class="w-5 h-5 text-gray-400 collapse-arrow" :class="{ 'expanded': collapsedStates.dynamic }" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 5l7 7-7 7"/></svg>
              <svg class="w-6 h-6 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
              <div>
                <h3 class="font-medium text-[#374151]">动态上下文</h3>
                <p class="text-xs text-[#9CA3AF] mt-0.5">根据当前创作内容自动更新的信息</p>
              </div>
            </div>
          </div>
          <div class="collapse-content" :class="{ 'expanded': collapsedStates.dynamic }">
            <div class="px-6 pb-4 border-t border-gray-100 pt-4 text-sm text-gray-600">动态上下文内容占位...</div>
          </div>
        </div>

        <!-- 提示词 -->
        <div class="border border-gray-200/70 rounded-lg overflow-hidden bg-white shadow-sm">
          <div @click="toggleCollapse('prompt')" class="px-6 py-4 cursor-pointer hover:bg-gray-50 transition-colors flex items-center justify-between">
            <div class="flex items-center gap-4">
              <svg class="w-5 h-5 text-gray-400 collapse-arrow" :class="{ 'expanded': collapsedStates.prompt }" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 5l7 7-7 7"/></svg>
              <svg class="w-6 h-6 text-emerald-500" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
              <div>
                <h3 class="font-medium text-[#374151]">提示词</h3>
                <p class="text-xs text-[#9CA3AF] mt-0.5">当前任务的具体指令</p>
              </div>
            </div>
          </div>
          <div class="collapse-content" :class="{ 'expanded': collapsedStates.prompt }">
            <div class="border-t border-gray-100">
              <textarea class="context-textarea" readonly>请续写下一段内容，要求：

1. 延续当前紧张神秘的氛围
2. 详细描写空间站内部的环境细节
3. 通过卡尔文的视角展现他的内心活动</textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- 尾部 -->
      <div class="flex-shrink-0 px-6 py-4 bg-white border-t border-gray-100 flex justify-end gap-3">
        <button @click="store.hide()" class="px-5 py-2 text-sm font-medium text-[#374151] bg-white border border-gray-300 rounded-lg hover:bg-gray-100 transition-colors">
          取消
        </button>
        <button @click="store.execute()" class="px-5 py-2 bg-emerald-600 text-white rounded-lg text-sm font-medium hover:bg-emerald-700 transition-colors flex items-center gap-2">
          <i class="fa-solid fa-bolt fa-sm"></i>
          <span>执行</span>
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, reactive } from 'vue';
import { useContextMenuStore } from '../../stores/contextPreviewModalStore';

const store = useContextMenuStore();

const collapsedStates = reactive({
  fixed: false,
  dynamic: false,
  rag: false,
  prompt: true,
});

const taskInfoText = computed(() => {
  if (store.task) {
    return `即将对《${store.task.title}》执行AI任务：${store.task.type}。`;
  }
  return '检查并确认将要提供给AI的全部信息。';
});

const toggleCollapse = (section: keyof typeof collapsedStates) => {
  collapsedStates[section] = !collapsedStates[section];
};
</script>

<style scoped>
.collapse-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
.collapse-content.expanded { max-height: 500px; transition: max-height 0.35s ease-in; }
.collapse-arrow { transition: transform 0.3s ease; }
.collapse-arrow.expanded { transform: rotate(90deg); }
.context-textarea { background: transparent; border: none; resize: none; outline: none; width: 100%; line-height: 1.7; color: #4B5563; font-size: 14px; padding: 1rem 1.5rem; min-height: 150px; cursor: default; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryTab.vue
//

<template>
  <div class="directory-tab-container">
    <div class="header">
      <h3 class="title">章节大纲</h3>
      <div class="actions">
        <button @click="commandService.execute('novel.volume.create')" class="action-btn" title="添加新卷">
          <i class="fa-solid fa-folder-plus fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="scrollable-content">
      <TreeView
          v-if="directoryTree.length > 0"
          :nodes="directoryTree"
          :active-node-id="activeTabId"
          :expanded-node-ids="uiStore.uiState.expandedNodeIds"
          :editing-node-id="uiStore.editingNodeId"
      />
      <div v-else class="p-4 text-sm text-gray-500">
        正在加载目录...
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView, { type TreeNode } from './TreeView.vue';
import { useEditorStore } from '../../stores/editorStore';
import { useDirectoryStore } from '../../stores/directoryStore';
import { useUIStore } from '../../stores/uiStore';
import { getIconByNodeType } from '../../utils/iconUtils';
import { commandService } from '@core/services/CommandService';

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const uiStore = useUIStore();

const activeTabId = computed(() => editorStore.activeTabId);

const directoryTree = computed((): TreeNode[] => {
  return directoryStore.directoryData.map(volume => ({
    id: volume.id,
    title: volume.title,
    icon: getIconByNodeType(volume.type),
    type: 'volume',
    originalData: volume,
    children: volume.chapters.map(chapter => ({
      id: chapter.id,
      title: chapter.title,
      icon: getIconByNodeType(chapter.type),
      status: chapter.status,
      type: 'chapter',
      originalData: chapter,
      children: [],
    })),
  }));
});
</script>
<style scoped>
.directory-tab-container { display: flex; flex-direction: column; height: 100%; width: 100%; overflow: hidden; }
.header { padding: 1rem; padding-bottom: 0.25rem; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }
.scrollable-content { flex-grow: 1; overflow-y: auto; padding: 0.75rem 1rem 1rem; }
.scrollable-content::-webkit-scrollbar { width: 6px; }
.scrollable-content::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\NotesTab.vue
//

<template>
  <div class="notes-tab-container">
    <div class="header">
      <h3 class="title">章节笔记</h3>
      <button @click="commandService.execute('novel.note.create')" class="action-btn" title="新建笔记"><i class="fa-solid fa-plus fa-xs"></i></button>
    </div>
    <div class="notes-list">
      <div
          v-for="(note, index) in notesStore.notes"
          :key="note.id"
          @click="tabManagementService.openTab(note.id)"
          @contextmenu.prevent="handleContextMenu(note, $event)"
          class="note-item"
          :class="{ 'active': activeTabId === note.id }"
      >
        <div class="note-header">
          <template v-if="editingNodeId === note.id">
            <input
                :ref="el => { if (el) renameInputs[index] = el as HTMLInputElement }"
                type="text"
                :value="note.title"
                class="rename-input"
                @blur="commitRename($event, note.id)"
                @keydown.enter.prevent="commitRename($event, note.id)"
                @keydown.esc.prevent="cancelRename"
                @click.stop
            />
          </template>
          <template v-else>
            <p class="note-title">{{ note.title }}</p>
          </template>
          <span class="note-timestamp">{{ note.timestamp }}</span>
        </div>
        <p class="note-content">{{ note.content.replace(/<[^>]+>/g, '') }}</p>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, watch, nextTick, onBeforeUpdate } from 'vue';
import { useEditorStore } from '../../stores/editorStore';
import { useNotesStore } from '../../stores/notesStore';
import { useUIStore } from '../../stores/uiStore';
import { commandService } from '@core/services/CommandService';
import { tabManagementService } from '@core/tabs/service/TabManagementService';
import { contextMenuService } from '@core/panes/service/ContextMenuService';
import type { NoteItem } from '../../types';
import type { TreeNode } from './TreeView.vue';
import { getIconByNodeType } from '../../utils/iconUtils';

const editorStore = useEditorStore();
const notesStore = useNotesStore();
const uiStore = useUIStore();
const renameInputs = ref<HTMLInputElement[]>([]);

const editingNodeId = computed(() => uiStore.editingNodeId);
const activeTabId = computed(() => editorStore.activeTabId);

watch(editingNodeId, (newId) => {
  if (newId?.startsWith('note-')) {
    nextTick(() => {
      const noteIndex = notesStore.notes.findIndex(n => n.id === newId);
      if (noteIndex !== -1 && renameInputs.value[noteIndex]) {
        renameInputs.value[noteIndex].focus();
        renameInputs.value[noteIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const handleContextMenu = (note: NoteItem, event: MouseEvent) => {
  const nodePayload: TreeNode = { id: note.id, title: note.title, type: note.type, icon: getIconByNodeType(note.type), originalData: note };
  contextMenuService.show(event, 'novel-directory-node', { node: nodePayload });
}

const commitRename = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  notesStore.renameNote(nodeId, input.value);
  uiStore.setEditingNodeId(null);
};

const cancelRename = () => {
  uiStore.setEditingNodeId(null);
};
</script>
<style scoped>
.notes-tab-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; width: 100%; overflow: hidden; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }
.notes-list { flex-grow: 1; overflow-y: auto; space-y: 0.5rem; padding-right: 4px; }
.notes-list::-webkit-scrollbar { width: 6px; }
.notes-list::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
.note-item { padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; background-color: #FFFFFF; }
.note-item:hover { background-color: #F9FAFB; border-color: #F3F4F6; }
.note-item.active { background-color: #FEFCE8; border-color: #FDE047; }
.note-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5rem; }
.note-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.note-timestamp { font-size: 0.75rem; color: #CA8A04; flex-shrink: 0; }
.note-content { font-size: 0.75rem; color: #4B5563; margin-top: 0.375rem; line-height: 1.6; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; }
.rename-input { flex-grow: 1; background-color: white; border: 1px solid #3B82F6; border-radius: 4px; padding: 1px 4px; font-size: 0.875rem; color: #1F2937; outline: none; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\RelatedTab.vue
//

<template>
  <div class="related-tab-container">
    <div class="header">
      <h3 class="title">相关内容</h3>
    </div>
    <div class="search-bar">
      <i class="fa-solid fa-magnifying-glass search-icon"></i>
      <input type="text" placeholder="搜索相关内容..." class="search-input">
    </div>
    <div class="tree-wrapper">
      <TreeView
          v-if="relatedTree.length > 0"
          :nodes="relatedTree"
          :active-node-id="activeTabId"
          :expanded-node-ids="uiStore.uiState.expandedRelatedNodeIds"
          :editing-node-id="uiStore.editingNodeId"
      />
      <div v-else class="p-4 text-sm text-gray-500">
        没有相关内容。
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView, { type TreeNode } from './TreeView.vue';
import { useEditorStore } from '../../stores/editorStore';
import { useRelatedContentStore } from '../../stores/relatedContentStore';
import { useUIStore } from '../../stores/uiStore';
import type { RelatedTree } from '../../types';

const editorStore = useEditorStore();
const relatedContentStore = useRelatedContentStore();
const uiStore = useUIStore();

const activeTabId = computed(() => editorStore.activeTabId);

const relatedTree = computed((): TreeNode[] => {
  const mapNode = (node: RelatedTree): TreeNode => ({
    id: node.id,
    title: node.title,
    icon: node.icon,
    type: node.type,
    originalData: node,
    children: node.children ? node.children.map(mapNode) : []
  });
  return relatedContentStore.relatedData.map(mapNode);
});
</script>
<style scoped>
.related-tab-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.search-bar { position: relative; margin-bottom: 1rem; flex-shrink: 0; }
.search-icon { position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; font-size: 0.875rem; }
.search-input { width: 100%; background: white; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.4rem 0.75rem 0.4rem 2.25rem; font-size: 0.875rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
.tree-wrapper { flex-grow: 1; overflow-y: auto; }
.tree-wrapper::-webkit-scrollbar { width: 6px; }
.tree-wrapper::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\SidebarPanel.vue
//

<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <h3 class="title">{{ activeTitle }}</h3>
      <div class="actions">
        <button
            v-if="editorStore.activeSidebarPanelId === 'directory'"
            @click="commandService.execute('novel.volume.create')"
            class="action-btn"
            title="添加新卷"
        >
          <i class="fa-solid fa-folder-plus fa-xs"></i>
        </button>
        <button
            v-if="editorStore.activeSidebarPanelId === 'notes'"
            @click="commandService.execute('novel.note.create')"
            class="action-btn"
            title="新建笔记"
        >
          <i class="fa-solid fa-plus fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="content-container">
      <component :is="activeTabComponent" />
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, defineAsyncComponent } from 'vue';
import { useEditorStore } from '../../stores/editorStore';
import { commandService } from '@core/services/CommandService';

const editorStore = useEditorStore();

const titles = {
  directory: '目录大纲',
  related: '相关内容',
  notes: '章节笔记',
};

const tabComponents = {
  directory: defineAsyncComponent(() => import('./DirectoryTab.vue')),
  related: defineAsyncComponent(() => import('./RelatedTab.vue')),
  notes: defineAsyncComponent(() => import('./NotesTab.vue')),
};

const activeTabComponent = computed(() => {
  const activeId = editorStore.activeSidebarPanelId;
  return activeId ? tabComponents[activeId] : null;
});

const activeTitle = computed(() => {
  const activeId = editorStore.activeSidebarPanelId;
  return activeId ? titles[activeId] : '';
});
</script>
<style scoped>
.sidebar-panel-container { width: 100%; background-color: #FAFBFC; display: flex; flex-direction: column; height: 100%; overflow: hidden; }
.header { padding: 0 1rem; height: 3.5rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #F0F0F0; flex-shrink: 0; }
.title { font-size: 1rem; font-weight: 500; color: #1F2937; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }
.content-container { flex-grow: 1; position: relative; overflow: auto; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\TreeView.vue
//

<template>
  <ul class="tree-view-list">
    <li v-for="(node, index) in nodes" :key="node.id" class="tree-view-item">
      <div
          class="node-content"
          :class="{ 'active': node.id === activeNodeId }"
          @click="handleNodeClick(node)"
          @contextmenu.prevent="handleContextMenu(node, $event)"
      >
        <div
            class="expand-icon"
            :class="{ 'invisible': !node.children || node.children.length === 0 }"
            @click.stop="uiStore.toggleRelatedNodeExpansion(node.id)"
        >
          <i class="fa-solid fa-chevron-right transition-transform" :class="{ 'rotate-90': expandedNodeIds.has(node.id) }"></i>
        </div>

        <div class="node-type-icon"> <i :class="node.icon"></i> </div>

        <template v-if="editingNodeId === node.id">
          <input
              :ref="el => { if (el) renameInputs[index] = el as HTMLInputElement }"
              type="text"
              :value="node.title"
              class="rename-input"
              @blur="commitRename($event, node)"
              @keydown.enter.prevent="commitRename($event, node)"
              @keydown.esc.prevent="cancelRename"
              @click.stop
          />
        </template>
        <template v-else>
          <span class="node-title truncate">{{ node.title }}</span>
        </template>

      </div>

      <div v-if="node.children && node.children.length > 0" class="children-container">
        <TreeView
            v-show="expandedNodeIds.has(node.id)"
            :nodes="node.children"
            :active-node-id="activeNodeId"
            :expanded-node-ids="expandedNodeIds"
            :editing-node-id="editingNodeId"
        />
      </div>
    </li>
  </ul>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, type PropType, onBeforeUpdate } from 'vue';
import { useUIStore } from '../../stores/uiStore';
import { useDirectoryStore } from '../../stores/directoryStore';
import { useRelatedContentStore } from '../../stores/relatedContentStore';
import { tabManagementService } from '@core/tabs/service/TabManagementService';
import { contextMenuService } from '@core/panes/service/ContextMenuService';

export interface TreeNode {
  id: string;
  title: string;
  icon: string;
  status?: string;
  type: string;
  children?: TreeNode[];
  originalData: any;
}

const props = defineProps({
  nodes: { type: Array as PropType<TreeNode[]>, required: true },
  activeNodeId: { type: String as PropType<string | null>, default: null },
  expandedNodeIds: { type: Set as PropType<Set<string>>, required: true },
  editingNodeId: { type: String as PropType<string | null>, default: null },
});

const uiStore = useUIStore();
const directoryStore = useDirectoryStore();
const relatedContentStore = useRelatedContentStore();
const renameInputs = ref<HTMLInputElement[]>([]);

watch(() => props.editingNodeId, (newId) => {
  if (newId) {
    nextTick(() => {
      const nodeIndex = props.nodes.findIndex(n => n.id === newId);
      if (nodeIndex !== -1 && renameInputs.value[nodeIndex]) {
        renameInputs.value[nodeIndex].focus();
        renameInputs.value[nodeIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const handleNodeClick = (node: TreeNode) => {
  if (props.editingNodeId === node.id) return;
  if (node.type === 'volume' || node.type === 'group') {
    uiStore.toggleNodeExpansion(node.id);
    uiStore.toggleRelatedNodeExpansion(node.id);
  } else {
    tabManagementService.openTab(node.id);
  }
};

const handleContextMenu = (node: TreeNode, event: MouseEvent) => {
  contextMenuService.show(event, 'novel-directory-node', { node });
};

const commitRename = (event: Event, node: TreeNode) => {
  const newTitle = (event.target as HTMLInputElement).value;
  if (node.type === 'volume' || node.type === 'chapter') {
    directoryStore.renameNode(node.id, newTitle);
  } else {
    relatedContentStore.renameRelatedNode(node.id, newTitle);
  }
  cancelRename();
};

const cancelRename = () => {
  uiStore.setEditingNodeId(null);
};

</script>

<style scoped>
.tree-view-list { list-style: none; padding: 0; margin: 0; width: 100%; }
.node-content { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; cursor: pointer; transition: background-color 0.15s, color 0.15s; font-size: 0.875rem; color: #374151; user-select: none; }
.node-content:hover { background-color: #F3F4F6; }
.node-content.active { background-color: #E0E7FF; color: #3730A3; font-weight: 500; }
.expand-icon { width: 1rem; height: 1rem; display: flex; align-items: center; justify-content: center; color: #9CA3AF; flex-shrink: 0; }
.expand-icon.invisible { visibility: hidden; }
.node-type-icon { width: 1.25rem; display: flex; align-items: center; justify-content: center; color: #6B7280; }
.node-content.active .node-type-icon { color: #4338CA; }
.node-title { flex-grow: 1; }
.children-container { padding-left: 1.5rem; margin-left: 0.5rem; border-left: 1px solid #E5E7EB; }
.rename-input { flex-grow: 1; background-color: white; border: 1px solid #3B82F6; border-radius: 4px; padding: 1px 4px; font-size: 0.875rem; color: #1F2937; outline: none; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
</style>

// =
// 文件: ..\src\novel\editor\components\system\HistoryPanel.vue
//

<template>
  <div class="flex-1 flex flex-col bg-white h-full">
    <header class="h-20 px-8 flex items-center justify-between border-b border-gray-100 flex-shrink-0">
      <div>
        <h1 class="text-lg font-medium text-[#374151] truncate" :title="headerTitle">{{ headerTitle }}</h1>
        <p class="text-sm text-[#6B7280] mt-1">当前版本 vs AI润色版本 (1小时前)</p>
      </div>
      <div class="flex items-center gap-3">
        <button class="px-4 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M16 12h-4m0 0H8m4 0V8m0 4v4m-4-8l8 8"></path></svg>
          切换
        </button>
        <button class="px-4 py-2 bg-[#4B5563] text-white rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors">
          恢复
        </button>
      </div>
    </header>

    <div class="px-8 py-3 border-b border-gray-100 bg-[#F9FAFB]">
      <div class="flex items-center gap-2 overflow-x-auto pb-1 custom-scrollbar-horizontal">
        <button class="w-7 h-7 flex-shrink-0 hover:bg-gray-200 rounded-lg flex items-center justify-center transition-colors">
          <svg class="w-4 h-4 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M15 19l-7-7 7-7"></path></svg>
        </button>
        <div class="flex gap-2">
          <div class="text-xs font-medium px-2.5 py-1 rounded-md bg-blue-100 text-blue-700 flex items-center gap-1.5 cursor-pointer flex-shrink-0">
            <svg class="w-2 h-2" fill="currentColor" viewBox="0 0 8 8"><circle cx="4" cy="4" r="4"/></svg>
            当前版本
          </div>
          <div class="text-xs font-medium px-2.5 py-1 rounded-md bg-gray-100 text-gray-700 cursor-pointer hover:bg-gray-200 transition-colors flex-shrink-0">
            AI润色 • 1小时前
          </div>
        </div>
        <button class="w-7 h-7 flex-shrink-0 hover:bg-gray-200 rounded-lg flex items-center justify-center transition-colors">
          <svg class="w-4 h-4 text-[#6B7280]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 5l7 7-7 7"></path></svg>
        </button>
      </div>
    </div>

    <div class="flex-1 p-8 overflow-y-auto custom-scrollbar">
      <div v-if="targetDocument" class="max-w-3xl mx-auto">
        <div class="text-[#374151] leading-relaxed text-base">
          <p>
            <del class="diff-del">控制台的警报声将卡尔文从浅眠中惊醒。</del>
            <ins class="diff-add">警报的尖啸犹如一把利刃，划破了卡尔文短暂的假寐。</ins>
            他猛地坐直，眼前的屏幕上一片红色闪烁。
          </p>
        </div>
      </div>
      <div v-else class="text-center text-gray-500 py-10">
        无法加载文档历史记录。
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, type PropType } from 'vue';
import { useDirectoryStore } from '../../stores/directoryStore';
import type { CoreItem } from '@core/types';

const props = defineProps({
  item: {
    type: Object as PropType<CoreItem>,
    required: true,
  },
});

const directoryStore = useDirectoryStore();
const targetDocument = computed(() => directoryStore.findNodeById(props.item.metadata.targetId)?.node);

const headerTitle = computed(() => {
  if (!targetDocument.value) return '版本对比';
  return `《${targetDocument.value.title}》版本对比`;
});
</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; height: 6px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.custom-scrollbar-horizontal::-webkit-scrollbar { height: 4px; }
.diff-del { background-color: #FEE2E2; text-decoration: line-through; text-decoration-color: #F87171; padding: 2px 1px; }
.diff-add { background-color: #D1FAE5; text-decoration: none; padding: 2px 1px; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\ReaderPanel.vue
//

<template>
  <div class="h-full w-full bg-[#FDFCF9] text-[#3a2f2f] flex flex-col relative font-serif overflow-hidden">
    <main class="flex-1 overflow-y-auto px-4 py-8 pt-16">
      <div v-if="targetDocument && 'content' in targetDocument" class="max-w-3xl mx-auto reader-content" v-html="targetDocument.content">
      </div>
      <div v-else class="max-w-3xl mx-auto text-center py-20 text-gray-500">
        <h1 class="text-2xl font-bold mb-4">无法加载阅读内容</h1>
        <p>此内容不支持阅读模式，或文档不存在。</p>
      </div>
    </main>
  </div>
</template>

<script setup lang="ts">
import { computed, type PropType } from 'vue';
import { useDirectoryStore } from '../../stores/directoryStore';
import type { CoreItem } from '@core/types';

const props = defineProps({
  item: {
    type: Object as PropType<CoreItem>,
    required: true,
  },
});

const directoryStore = useDirectoryStore();
const targetDocument = computed(() => directoryStore.findNodeById(props.item.metadata.targetId)?.node);
</script>

<style>
.reader-content h1 { font-family: 'Noto Serif SC', serif; font-size: 2.25rem; font-weight: 600; margin-bottom: 2.5rem; color: #1f2937; letter-spacing: 0.05em; padding-bottom: 1rem; border-bottom: 1px solid rgba(0,0,0,0.05); text-align: center; }
.reader-content p { font-family: 'Noto Serif SC', serif; font-size: 1.125rem; line-height: 2.2; color: #374151; margin-bottom: 1.75rem; text-align: justify; }
.font-sans { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\SearchView.vue
//

<template>
  <div class="search-view-container">
    <div class="search-header">
      <div class="search-bar">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            v-model="searchQuery"
            type="text"
            placeholder="在所有文档中搜索..."
            class="search-input"
            @keydown.enter="performSearch"
        />
        <button v-if="searchQuery" @click="clearSearch" class="clear-button" title="清空搜索">
          <i class="fa-solid fa-times"></i>
        </button>
      </div>
      <button @click="performSearch" class="search-button">
        搜索
      </button>
    </div>

    <div class="results-container">
      <div v-if="results.length > 0">
        <div v-for="result in results" :key="result.id" class="result-group">
          <div @click="handleResultClick(result.id)" class="result-header">
            <i :class="[result.icon, 'mr-2']"></i>
            <span class="font-medium">{{ result.title }}</span>
            <span class="match-count">{{ result.matches.length }}</span>
          </div>
          <ul class="match-list">
            <li
                v-for="(match, index) in result.matches"
                :key="index"
                @click="handleResultClick(result.id)"
                class="match-item"
                v-html="match.context"
            >
            </li>
          </ul>
        </div>
      </div>
      <div v-else-if="hasSearched" class="empty-state">
        <i class="fa-regular fa-face-sad-tear text-4xl text-gray-400"></i>
        <p class="mt-4 text-gray-500">未找到与 "{{ lastSearchedQuery }}" 相关的内容。</p>
      </div>
      <div v-else class="empty-state">
        <i class="fa-solid fa-text-slash text-4xl text-gray-300"></i>
        <p class="mt-4 text-gray-500">输入关键词开始搜索。</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useUIStore } from '../../stores/uiStore';
import { tabManagementService } from '@core/tabs/service/TabManagementService';

const uiStore = useUIStore();
const searchQuery = ref('');
const lastSearchedQuery = ref('');
const hasSearched = ref(false);
const results = computed(() => uiStore.searchResults);

const performSearch = () => {
  if (!searchQuery.value) return;
  lastSearchedQuery.value = searchQuery.value;
  hasSearched.value = true;
  uiStore.searchAllDocuments(searchQuery.value);
};

const handleResultClick = (itemId: string) => {
  tabManagementService.openTab(itemId);
};

const clearSearch = () => {
  searchQuery.value = '';
  lastSearchedQuery.value = '';
  hasSearched.value = false;
  uiStore.clearSearchResults();
};
</script>

<style scoped>
.search-view-container { display: flex; flex-direction: column; height: 100%; background-color: #FFFFFF; }
.search-header { display: flex; gap: 0.75rem; padding: 1.5rem 2rem; border-bottom: 1px solid #E5E7EB; flex-shrink: 0; align-items: center; }
.search-bar { position: relative; flex-grow: 1; }
.search-icon { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; }
.search-input { width: 100%; background-color: #F9FAFB; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.75rem 2.5rem 0.75rem 2.75rem; font-size: 1rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; background-color: #FFFFFF; box-shadow: 0 0 0 1px #3B82F6; }
.clear-button { position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; border-radius: 99px; }
.clear-button:hover { background-color: #E5E7EB; color: #4B5563; }
.search-button { padding: 0.75rem 1.5rem; background-color: #2563EB; color: white; border-radius: 0.5rem; font-weight: 500; transition: background-color 0.2s; }
.search-button:hover { background-color: #1D4ED8; }
.results-container { flex-grow: 1; overflow-y: auto; padding: 1.5rem 2rem; scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.results-container::-webkit-scrollbar { width: 6px; }
.result-group { margin-bottom: 1.5rem; }
.result-header { display: flex; align-items: center; padding: 0.5rem; border-radius: 0.375rem; cursor: pointer; background-color: #F9FAFB; margin-bottom: 0.5rem; }
.result-header:hover { background-color: #F3F4F6; }
.match-count { margin-left: auto; font-size: 0.75rem; background-color: #E5E7EB; color: #4B5563; padding: 0.125rem 0.5rem; border-radius: 99px; }
.match-list { padding-left: 1rem; margin-top: 0.25rem; }
.match-item { font-size: 0.875rem; color: #6B7280; padding: 0.5rem; border-radius: 0.375rem; cursor: pointer; line-height: 1.6; }
.match-item:hover { background-color: #F3F4F6; }
.match-item :deep(mark) { background-color: #FEF3C7; color: #92400E; font-weight: 600; padding: 1px 0; border-radius: 2px; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 2rem; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\AIConfigSettings.vue
//

<template>
  <div class="aiconfig-view-container">
    <!-- Left Sidebar for Task Navigation -->
    <div class="aiconfig-sidebar">
      <h3 class="sidebar-title">AI 任务类型</h3>
      <nav class="sidebar-nav">
        <a
            v-for="task in availableTasks"
            :key="task.id"
            href="#"
            @click.prevent="activeTaskId = task.id"
            :class="['nav-item', { 'active': activeTaskId === task.id }]"
        >
          <i :class="[task.icon, 'nav-item-icon']"></i>
          <span>{{ task.name }}</span>
        </a>
      </nav>
    </div>

    <!-- Right Content Area -->
    <div class="aiconfig-content custom-scrollbar">
      <div v-if="activeTask" class="p-8 space-y-8 max-w-4xl mx-auto">
        <!-- Header -->
        <div class="flex justify-between items-center">
          <div>
            <h3 class="text-xl font-semibold text-[#374151]">AI任务配置 - {{ activeTask.name }}</h3>
            <p class="text-sm text-[#6B7280] mt-1">为特定任务类型配置AI助手的行为模式</p>
          </div>
        </div>

        <!-- AI模型配置 -->
        <div>
          <label class="flex items-center justify-between mb-3">
            <span class="text-sm font-medium text-[#374151]">AI模型选择</span>
            <a href="#" class="text-xs text-[#3B82F6] cursor-pointer flex items-center gap-1.5 hover:underline">
              <i class="fa-solid fa-circle-info"></i>
              了解模型差异
            </a>
          </label>
          <select class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
            <option selected>GPT-4o (推荐 - 均衡性能)</option>
            <option>Claude 3 Opus (文学创作专长)</option>
            <option>混合模型 (多模型协作)</option>
            <option>自定义微调模型</option>
          </select>
        </div>

        <!-- 提示词选择 -->
        <div>
          <label for="prompt-template" class="text-sm font-medium text-[#374151] block mb-3">任务提示词模板</label>
          <select id="prompt-template" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
            <option v-for="prompt in activeTask.prompts" :key="prompt" :selected="prompt === activeTask.defaultPrompt">{{ prompt }}</option>
          </select>
        </div>

        <!-- 上下文选择 -->
        <div>
          <label class="text-sm font-medium text-[#374151] block mb-3">上下文配置</label>
          <div class="space-y-3">
            <div class="bg-white p-4 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <div class="w-10 h-10 bg-[#F3F4F6] rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-book-bookmark text-[#4B5563]"></i>
                  </div>
                  <div>
                    <p class="font-medium text-sm text-[#374151]">固定上下文</p>
                    <p class="text-xs text-[#9CA3AF]">小说设定、人物档案、世界观</p>
                  </div>
                </div>
                <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" class="sr-only peer" checked><div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div></label>
              </div>
            </div>
            <div class="bg-white p-4 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <div class="w-10 h-10 bg-[#F3F4F6] rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-arrows-left-right-to-line text-[#4B5563]"></i>
                  </div>
                  <div>
                    <p class="font-medium text-sm text-[#374151]">动态上下文</p>
                    <p class="text-xs text-[#9CA3AF]">自动包含前后相关章节</p>
                  </div>
                </div>
                <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" class="sr-only peer" checked><div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div></label>
              </div>
            </div>
            <div class="bg-white p-4 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <div class="w-10 h-10 bg-[#F3F4F6] rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-database text-[#4B5563]"></i>
                  </div>
                  <div>
                    <p class="font-medium text-sm text-[#374151]">RAG智能搜索</p>
                    <p class="text-xs text-[#9CA3AF]">自动检索相关内容</p>
                  </div>
                </div>
                <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" class="sr-only peer"><div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div></label>
              </div>
            </div>
          </div>
        </div>

        <!-- 高级设置 -->
        <div>
          <label class="text-sm font-medium text-[#374151] block mb-3">高级设置</label>
          <div class="space-y-4 p-4 bg-[#F9FAFB] rounded-lg border border-gray-100">
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">创作温度</span>
              <div class="flex items-center gap-3">
                <input type="range" min="0" max="100" value="70" class="w-32 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer range-slider">
                <span class="text-sm font-mono text-[#374151] w-8 text-right">0.7</span>
              </div>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">保留原文风格</span>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
              </label>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';

const activeTaskId = ref('polish');

const availableTasks = ref([
  {
    id: 'polish',
    name: '润色',
    icon: 'fa-solid fa-palette',
    defaultPrompt: '文学润色 - 注重修辞和意境',
    prompts: ['文学润色 - 注重修辞和意境', '简洁优化 - 删繁就简', '情感强化 - 增强情感表达']
  },
  {
    id: 'continue',
    name: '续写',
    icon: 'fa-solid fa-wand-magic-sparkles',
    defaultPrompt: '标准续写',
    prompts: ['标准续写', '悬念式结尾', '对话场景续写', '动作场景续写']
  },
  {
    id: 'analyze',
    name: '分析',
    icon: 'fa-solid fa-magnifying-glass-chart',
    defaultPrompt: '情节结构分析',
    prompts: ['情节结构分析', '人物弧光分析', '修辞手法分析', '市场潜力评估']
  }
]);

const activeTask = computed(() => availableTasks.value.find(t => t.id === activeTaskId.value));
</script>

<style scoped>
.aiconfig-view-container { display: flex; height: 100%; width: 100%; }
.aiconfig-sidebar { width: 220px; background-color: #F9FAFB; border-right: 1px solid #E5E7EB; padding: 1.5rem 1rem; flex-shrink: 0; }
.sidebar-title { padding: 0 0.75rem; font-size: 0.75rem; font-weight: 600; color: #6B7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.75rem; }
.sidebar-nav { display: flex; flex-direction: column; gap: 0.25rem; }
.nav-item { display: flex; align-items: center; padding: 0.6rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; color: #374151; text-decoration: none; transition: background-color 0.2s, color 0.2s; }
.nav-item:hover { background-color: #F3F4F6; }
.nav-item.active { background-color: #EBF1FD; color: #2563EB; }
.nav-item-icon { width: 1.25rem; text-align: center; margin-right: 0.75rem; }

.aiconfig-content { flex-grow: 1; overflow-y: auto; background-color: #FFFFFF; }

.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

.range-slider { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; }
.range-slider::-webkit-slider-runnable-track { background: #E5E7EB; height: 0.25rem; border-radius: 0.25rem; }
.range-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; background-color: #ffffff; height: 1rem; width: 1rem; border-radius: 50%; border: 1px solid #D1D5DB; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
.range-slider:focus::-webkit-slider-thumb { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px #3B82F640; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\ContextSettings.vue
//

<template>
  <div class="setting-page-wrapper custom-scrollbar">
    <div class="page-header">
      <h2 class="page-title">上下文管理</h2>
      <p class="page-description">配置AI任务执行时如何处理上下文信息，以获得更精准的生成结果。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label for="needs-preview" class="setting-label">执行前预览</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="needs-preview" type="checkbox" v-model="uiStore.uiState.needsPreview" class="setting-checkbox" />
            <label for="needs-preview" class="ml-3 font-medium text-gray-700">启用AI任务执行前预览</label>
          </div>
          <p class="setting-description">
            启用后，在编辑器或目录中触发AI任务时，会弹出一个上下文预览窗口供您确认。
          </p>
        </div>
      </div>
    </div>

    <div class="setting-group mt-4">
      <div class="setting-item">
        <label class="setting-label">固定上下文</label>
        <div class="setting-control space-y-4">
          <div>
            <label class="block text-sm font-medium text-[#374151] mb-1.5">选择预设内容
              <span class="text-xs text-[#9CA3AF] ml-2">可选择角色设定或世界观设定</span>
            </label>
            <select
                @change="addSelectedItem"
                class="w-full px-4 py-2 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] custom-select focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
            >
              <option value="">请选择预设内容...</option>
              <option v-for="preset in fixedContextPresets" :key="preset.id" :value="preset.id">
                {{ preset.group }} - {{ preset.title }}
              </option>
            </select>
          </div>

          <div v-if="selectedItems.length > 0">
            <label class="block text-sm font-medium text-[#374151] mb-1.5">已选择的内容</label>
            <div class="content-list">
              <div v-for="(item, index) in selectedItems" :key="item.id" class="content-list-item">
                <div>
                  <div class="font-medium text-sm text-[#374151]">{{ item.group }} - {{ item.title }}</div>
                  <div class="text-xs text-[#9CA3AF] mt-1">{{ item.description }}</div>
                </div>
                <button @click.stop="removeSelectedItem(index)" class="text-[#9CA3AF] hover:text-[#EF4444] transition-colors">
                  <i class="fa-solid fa-xmark"></i>
                </button>
              </div>
            </div>
          </div>
          <div>
            <label for="custom-content" class="block text-sm font-medium text-[#374151] mb-1.5">自定义固定内容</label>
            <textarea
                id="custom-content"
                v-model="uiStore.uiState.customContextContent"
                class="w-full px-4 py-3 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] resize-none focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
                rows="4"
                placeholder="输入固定的背景设定、人物关系、重要事件等AI必须参考的信息..."
            ></textarea>
            <p class="setting-description mt-2">这里的内容将始终被添加到AI任务的上下文中。</p>
          </div>
        </div>
      </div>

      <div class="setting-item">
        <label class="setting-label">动态上下文</label>
        <div class="setting-control space-y-6">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">前置章节数</label>
              <div class="flex items-center gap-3">
                <input type="range" min="0" max="10" v-model.number="uiStore.uiState.dynamicContextSettings.prevChapters" class="range-custom flex-1"/>
                <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ uiStore.uiState.dynamicContextSettings.prevChapters }}</span>
              </div>
              <p class="setting-description mt-1">自动包含当前章节之前的N个章节内容。</p>
            </div>
            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">后续章节数</label>
              <div class="flex items-center gap-3">
                <input type="range" min="0" max="10" v-model.number="uiStore.uiState.dynamicContextSettings.nextChapters" class="range-custom flex-1"/>
                <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ uiStore.uiState.dynamicContextSettings.nextChapters }}</span>
              </div>
              <p class="setting-description mt-1">自动包含当前章节之后N个章节的大纲。</p>
            </div>
          </div>
        </div>
      </div>

      <div class="setting-item">
        <label for="rag-context" class="setting-label">RAG 智能检索</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="rag-context" type="checkbox" v-model="uiStore.uiState.isRagEnabled" class="setting-checkbox" />
            <label for="rag-context" class="ml-3 font-medium text-gray-700">启用RAG智能检索</label>
          </div>
          <p class="setting-description">
            启用后，AI任务将根据当前上下文自动从您的整个知识库（包括所有章节、设定、笔记）中检索最相关的信息片段并注入到上下文中。
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useUIStore } from '../../../stores/uiStore';
import { useRelatedContentStore } from '../../../stores/relatedContentStore';

const uiStore = useUIStore();
const relatedContentStore = useRelatedContentStore();

const selectedItems = computed(() => uiStore.uiState.selectedContextItems);

const fixedContextPresets = computed(() => {
  const presets: { id: string; group: string; title: string; description: string; content: string }[] = [];
  const settingsNode = relatedContentStore.relatedData.find(n => n.id === 'settings');

  if (settingsNode && settingsNode.children) {
    settingsNode.children.forEach(group => {
      if (group.children) {
        group.children.forEach(item => {
          if (item.content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = item.content;
            const description = tempDiv.querySelector('p')?.textContent || item.title;
            presets.push({
              id: item.id,
              group: group.title,
              title: item.title,
              description: description.substring(0, 100) + '...',
              content: item.content
            });
          }
        });
      }
    });
  }
  return presets;
});

const addSelectedItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = fixedContextPresets.value.find(p => p.id === selectedId);
  if (preset) {
    uiStore.addFixedContextItem(preset);
  }
  select.value = ""; // Reset select after choosing
};

const removeSelectedItem = (index: number) => {
  uiStore.removeFixedContextItem(index);
};
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem 4rem; max-width: 56rem; margin: 0 auto; overflow-y: auto; height: 100%; }
.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-item:last-child { border-bottom: none; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.5rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }
.range-custom { -webkit-appearance: none; appearance: none; width: 100%; height: 16px; background: transparent; outline: none; padding: 0; margin: 0; }
.range-custom::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #E5E7EB; border-radius: 9999px; }
.range-custom::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 20px; width: 20px; background: #3B82F6; border-radius: 50%; border: 3px solid white; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); cursor: grab; margin-top: -7px; }
.custom-select { appearance: none; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='14' height='8' viewBox='0 0 14 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M1 1L7 7L13 1' stroke='%236B7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 12px center; background-size: 14px; padding-right: 40px; }
.content-list { border: 1px solid #E5E7EB; border-radius: 8px; max-height: 200px; overflow-y: auto; }
.content-list-item { padding: 12px 16px; border-bottom: 1px solid #F3F4F6; display: flex; justify-content: space-between; align-items: center; }
.content-list-item:last-child { border-bottom: none; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\EditorSettings.vue
//

<template>
  <div class="setting-page-wrapper">
    <div class="page-header">
      <h2 class="page-title">编辑器设置</h2>
      <p class="page-description">自定义您的写作环境的外观和行为。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label for="font-size" class="setting-label">字体大小</label>
        <div class="setting-control">
          <input id="font-size" type="number" value="16" class="setting-input w-24" />
          <p class="setting-description">编辑器中文本的默认字体大小（单位：像素）。</p>
        </div>
      </div>
      <div class="setting-item">
        <label for="line-height" class="setting-label">行高</label>
        <div class="setting-control">
          <input id="line-height" type="number" step="0.1" value="1.8" class="setting-input w-24" />
          <p class="setting-description">编辑器中每行文本的高度（相对于字体大小的倍数）。</p>
        </div>
      </div>
      <div class="setting-item">
        <label for="autosave" class="setting-label">自动保存</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="autosave" type="checkbox" checked class="setting-checkbox" />
            <label for="autosave" class="ml-3 font-medium text-gray-700">启用自动保存</label>
          </div>
          <p class="setting-description">在您停止输入后，系统将自动保存您的更改。</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem; max-width: 56rem; margin: 0 auto; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.5rem; }
.setting-input { background-color: white; border: 1px solid #D1D5DB; border-radius: 0.375rem; padding: 0.5rem 0.75rem; outline: none; transition: all 0.2s; }
.setting-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
.setting-description { color: #6B7280; font-size: 0.875rem; }
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\NovelSettings.vue
//

<template>
  <div class="flex-1 p-8 overflow-auto custom-scrollbar bg-[#FCFCFC]">
    <div v-if="novelMetadata" class="grid grid-cols-3 gap-8 max-w-6xl mx-auto">
      <div class="col-span-2 bg-white p-8 space-y-6 rounded-xl border border-gray-100">
        <h3 class="text-base font-medium text-[#374151]">基本信息</h3>

        <div class="space-y-2">
          <label class="text-sm font-medium text-[#374151] block">小说封面</label>
          <div class="flex items-center gap-4">
            <img :src="novelMetadata.cover" class="w-24 h-32 object-cover rounded-lg shadow-sm" alt="Cover">
            <div>
              <button class="px-4 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">更换图片</button>
              <p class="text-xs text-[#9CA3AF] mt-2">JPG, PNG, GIF, 不超过 5MB</p>
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <label for="novel-title" class="text-sm font-medium text-[#374151] block">小说标题</label>
          <input type="text" id="novel-title" v-model="novelMetadata.title" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
        </div>

        <div class="space-y-2">
          <label for="novel-desc" class="text-sm font-medium text-[#374151] block">小说简介</label>
          <textarea id="novel-desc" rows="4" v-model="novelMetadata.description" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition resize-none"></textarea>
        </div>

        <div class="grid grid-cols-2 gap-6">
          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">类型标签</label>
            <div class="flex flex-wrap gap-2 items-center">
              <div v-for="(tag, index) in novelMetadata.tags" :key="index" class="flex items-center gap-1.5 px-2.5 py-1 text-sm rounded-full" :class="tag.class">
                <span>{{ tag.text }}</span>
                <button @click="editorStore.removeTag(index)" class="hover:opacity-75">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
              </div>
              <button @click="editorStore.addTag()" class="px-3 py-1 bg-gray-100 hover:bg-gray-200 text-[#6B7280] rounded-full text-sm font-medium transition-colors">+ 添加</button>
            </div>
          </div>

          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">创作状态</label>
            <select v-model="novelMetadata.status" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
              <option>连载中</option>
              <option>已完结</option>
              <option>暂停更新</option>
            </select>
          </div>
        </div>

        <div class="pt-6 border-t border-gray-100 flex justify-end gap-3">
          <button @click="editorStore.initialize()" class="px-5 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">重置</button>
          <button @click="editorStore.saveMetadata()" class="px-5 py-2 bg-[#4B5563] hover:bg-gray-700 text-white rounded-lg text-sm font-medium transition-colors">保存更改</button>
        </div>
      </div>

      <div class="col-span-1 space-y-6">
        <div class="bg-white p-6 rounded-xl border border-gray-100">
          <h3 class="text-base font-medium text-[#374151]">参考内容管理</h3>
          <p class="text-sm text-[#9CA3AF] mt-1 mb-4">将其他作品作为参考，AI会借鉴其风格</p>
          <button class="w-full mt-4 flex items-center justify-center gap-2 border-2 border-dashed border-gray-200 rounded-lg py-4 text-sm font-medium text-[#9CA3AF] hover:border-blue-500 hover:text-blue-500 transition-all">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 4v16m8-8H4"></path></svg>
            <span>添加参考作品</span>
          </button>
        </div>
      </div>
    </div>
    <div v-else class="text-center py-20 text-gray-500">
      正在加载小说设置...
    </div>
  </div>
</template>

<script setup lang="ts">
import { useEditorStore } from '../../../stores/editorStore';
import { storeToRefs } from 'pinia';

const editorStore = useEditorStore();
const { novelMetadata } = storeToRefs(editorStore);
</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\TaskSettings.vue
//

<template>
  <div class="setting-page-wrapper">
    <div class="page-header">
      <h2 class="page-title">任务管理</h2>
      <p class="page-description">管理AI任务队列，清理历史记录。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label class="setting-label">清理任务</label>
        <div class="setting-control">
          <div class="flex items-center gap-4">
            <button @click="handleClearCompleted" class="action-button">清除已完成的任务</button>
            <button @click="handleClearAll" class="action-button-danger">清除所有任务</button>
          </div>
          <p class="setting-description">
            “已完成”包括已应用和已失败的任务。<br>
            清理所有任务将清空任务队列，包括正在等待和处理中的任务。此操作不可撤销。
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useAITaskStore } from '../../../stores/aiTaskStore';

const aiTaskStore = useAITaskStore();

const handleClearCompleted = () => {
  if (window.confirm('您确定要清除所有已应用和已失败的任务吗？')) {
    aiTaskStore.clearCompletedTasks();
  }
};

const handleClearAll = () => {
  if (window.confirm('您确定要清除所有AI任务吗？此操作不可撤销，进行中的任务也将被终止。')) {
    aiTaskStore.clearAllTasks();
  }
};
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem; max-width: 56rem; margin: 0 auto; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.75rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.action-button { padding: 0.5rem 1rem; font-size: 0.875rem; font-weight: 500; border-radius: 0.375rem; background-color: #FFFFFF; border: 1px solid #D1D5DB; color: #374151; transition: background-color 0.2s; }
.action-button:hover { background-color: #F9FAFB; }
.action-button-danger { padding: 0.5rem 1rem; font-size: 0.875rem; font-weight: 500; border-radius: 0.375rem; background-color: #FEF2F2; border: 1px solid #FECACA; color: #DC2626; transition: background-color 0.2s; }
.action-button-danger:hover { background-color: #FEE2E2; }
</style>

// =
// 文件: ..\src\novel\editor\data\chatData.ts
//

import type { Conversation } from '../types';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。',
                timestamp: new Date().toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p>当然，这是一个很好的切入点。</p>`,
                timestamp: new Date().toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\data\index.ts
//

import type { Volume, RelatedTree, NoteItem, NovelMetadata, NovelCharacter } from '../types';

export const mockDirectoryData: Volume[] = [
    {
        id: 'vol-1', type: 'volume', title: '第一卷：星尘之始', content: '<h1>第一卷：星尘之始</h1>', chapters: [
            { id: 'ch-1', type: 'chapter', title: '第一章：深空孤影', wordCount: 3102, content: '<h1>第一章：深空孤影</h1><p>这是章节的详细内容...</p>', status: 'completed' },
            { id: 'ch-2', type: 'chapter', title: '第二章：异常信号', wordCount: 2845, content: '<h1>第二章：异常信号</h1><p>一个神秘的信号...</p>', status: 'completed' },
            { id: 'ch-3', type: 'chapter', title: '第三章：AI的低语', wordCount: 3500, content: '<h1>第三章：AI的低语</h1><p>飞船的AI“艾拉”开始出现异常...</p>', status: 'editing' },
        ]
    },
];

export const mockCharacters: NovelCharacter[] = [
    { id: 'char-calvin', name: '卡尔文·里德', avatar: '', identity: '主角', summary: '孤独的宇航员...' },
    { id: 'char-aila', name: '艾拉 (AILA)', avatar: '', identity: 'AI', summary: '第五代通用人工智能...' },
];

export const mockSettingsData: RelatedTree[] = [
    {
        id: 'settings', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            {
                id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                    ...mockCharacters.map(char => ({
                        id: char.id,
                        title: char.name,
                        type: 'character_item',
                        icon: 'fa-regular fa-user',
                        content: `<h1>${char.name}</h1><p>${char.summary}</p>`
                    }))
                ]
            },
        ]
    }
];

export const mockPlotCustomData: RelatedTree[] = [
    { id: 'custom-plot-1', title: '关于跃迁点背后的文明猜想', type: 'plot_item', icon: 'fa-solid fa-lightbulb text-rose-500', content: '<h1>关于跃迁点背后的文明猜想</h1>' }
];

export const mockAnalysisCustomData: RelatedTree[] = [];

export const mockNoteData: NoteItem[] = [
    { id: 'note-1', type: 'note', title: '第四章情感转折点设计', timestamp: '今天 14:32', content: '<h1>第四章情感转折点设计</h1><p>需要重点描写卡尔文的复杂心理。</p>' },
];

export const mockAIResponses: Record<'润色' | '续写' | '分析', string> = {
    '续写': "警报的尖啸犹如一把利刃，划破了卡尔文短暂的假寐。",
    '润色': "控制台的警报声，如同一道惊雷，将卡尔文从混沌的浅眠中劈醒。",
    '分析': "从文本来看，主角卡尔文此刻的情绪是震惊与希望的混合体。",
};

export const mockNovelMetadata: NovelMetadata = {
    id: 'novel-1',
    title: '星际漫游者',
    description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
    cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=200',
    tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }],
    status: '连载中'
};

// =
// 文件: ..\src\novel\editor\features\novel.commands.ts
//

import type { CommandService } from '@core/services/CommandService';
import { useDirectoryStore } from '../stores/directoryStore';
import { useEditorStore } from '../stores/editorStore';
import { useUIStore } from '../stores/uiStore';
import { useNotesStore } from '../stores/notesStore';
import { useRelatedContentStore } from '../stores/relatedContentStore';
import { useContextMenuStore } from '../stores/contextPreviewModalStore'; // UPDATED: Corrected file path
import { useAITaskStore } from '../stores/aiTaskStore';
import { tabManagementService } from '@core/tabs/service/TabManagementService';
import type { Chapter, NoteItem, RelatedTree, Volume } from '../types';

export function registerNovelCommands(commandService: CommandService) {
    const editorStore = useEditorStore();
    const directoryStore = useDirectoryStore();
    const notesStore = useNotesStore();
    const relatedContentStore = useRelatedContentStore();
    const uiStore = useUIStore();
    const contextPreviewStore = useContextMenuStore();
    const aiTaskStore = useAITaskStore();

    // --- 目录操作 ---
    commandService.register({
        id: 'novel.volume.create',
        label: '新建卷',
        execute: () => {
            const newVolume = directoryStore.addNewVolume();
            uiStore.setEditingNodeId(newVolume.id);
            uiStore.toggleNodeExpansion(newVolume.id);
        },
    });
    commandService.register({
        id: 'novel.chapter.create',
        label: '新建章节',
        execute: (context) => {
            const newChapter = directoryStore.addChapterToVolume(context.volumeId);
            if (newChapter) {
                tabManagementService.openTab(newChapter.id);
                uiStore.setEditingNodeId(newChapter.id);
                uiStore.toggleNodeExpansion(context.volumeId);
            }
        },
    });

    // --- 笔记操作 ---
    commandService.register({
        id: 'novel.note.create',
        label: '新建笔记',
        execute: () => {
            const newNote = notesStore.addNote('新建笔记');
            tabManagementService.openTab(newNote.id);
            uiStore.setEditingNodeId(newNote.id);
        },
    });

    // --- 设定与相关内容操作 ---
    commandService.register({
        id: 'novel.related.create-group',
        label: '新建分组',
        execute: (context) => {
            const newNode = relatedContentStore.addRelatedNode(context.nodeId, 'group');
            if (newNode) uiStore.setEditingNodeId(newNode.id);
            uiStore.toggleRelatedNodeExpansion(context.nodeId);
        },
    });
    commandService.register({
        id: 'novel.related.create-item',
        label: '新建条目',
        execute: (context) => {
            const newNode = relatedContentStore.addRelatedNode(context.nodeId, 'item');
            if (newNode) {
                tabManagementService.openTab(newNode.id);
                uiStore.setEditingNodeId(newNode.id);
            }
            uiStore.toggleRelatedNodeExpansion(context.nodeId);
        },
    });
    commandService.register({
        id: 'novel.related.create-custom',
        label: '新建自定义条目',
        execute: (context) => {
            const newNode = relatedContentStore.addCustomRelatedNode(context.nodeId as 'plot' | 'analysis');
            tabManagementService.openTab(newNode.id);
            uiStore.setEditingNodeId(newNode.id);
            uiStore.toggleRelatedNodeExpansion(context.nodeId);
        },
    });

    // --- 通用节点操作 ---
    commandService.register({
        id: 'novel.node.rename',
        label: '重命名',
        execute: (context) => uiStore.setEditingNodeId(context.nodeId),
    });
    commandService.register({
        id: 'novel.node.delete',
        label: '删除',
        execute: (context) => {
            const { nodeId, type } = context;
            if (type === 'volume' || type === 'chapter') {
                directoryStore.deleteNode(nodeId);
            } else if (type === 'note') {
                notesStore.deleteNote(nodeId);
            } else if (nodeId.startsWith('custom-')) {
                relatedContentStore.deleteCustomRelatedNode(nodeId);
            } else {
                relatedContentStore.deleteRelatedNode(nodeId);
            }
            tabManagementService.closeTab(nodeId);
        },
    });

    // --- AI 任务 ---
    const executeAITask = (context: { taskType: '润色' | '续写' | '分析', node: Chapter | RelatedTree | NoteItem, isBatch?: boolean }) => {
        const { taskType, node, isBatch } = context;
        if (isBatch && node.type === 'volume') {
            aiTaskStore.startBatchTaskForVolume(taskType, node as Volume);
            editorStore.ensureAIPanelIsOpen();
            return;
        }

        tabManagementService.openTab(node.id);

        if (uiStore.uiState.needsPreview) {
            contextPreviewStore.show({ type: taskType, targetItemId: node.id, title: node.title });
        } else {
            aiTaskStore.startNewTask(taskType, node.id);
            editorStore.ensureAIPanelIsOpen();
        }
    };

    commandService.register({ id: 'novel.ai.polish', label: '润色内容', execute: (context) => executeAITask({ ...context, taskType: '润色' }) });
    commandService.register({ id: 'novel.ai.continue', label: '续写内容', execute: (context) => executeAITask({ ...context, taskType: '续写' }) });
    commandService.register({ id: 'novel.ai.analyze', label: '分析内容', execute: (context) => executeAITask({ ...context, taskType: '分析' }) });


    // --- UI 交互命令 ---
    commandService.register({
        id: 'novel.sidebar.toggle',
        label: '切换侧边栏',
        execute: () => editorStore.toggleSidebar(),
    });

    commandService.register({
        id: 'novel.sidebar.show-panel',
        label: '显示侧边栏面板',
        execute: (context) => editorStore.setActiveSidebarPanel(context.panelId),
    });

    commandService.register({
        id: 'novel.system-view.open',
        label: '打开系统视图',
        execute: (context) => tabManagementService.openTab(context.viewId),
    });

    commandService.register({
        id: 'novel.history-view.open',
        label: '打开历史记录',
        execute: () => editorStore.openHistoryPanelForActiveTab(),
    });

    commandService.register({
        id: 'novel.reader-view.open',
        label: '打开阅读模式',
        execute: () => editorStore.openReaderViewForActiveTab(),
    });
}

// =
// 文件: ..\src\novel\editor\features\novel.contextMenu.ts
//

import { contextMenuService } from '@core/panes/service/ContextMenuService';
import type { ContextMenuItem } from '@core/types';
import type { TreeNode } from '../components/sidebar/TreeView.vue';

function getDirectoryContextMenu(node: TreeNode): ContextMenuItem[] {
    const items: ContextMenuItem[] = [];
    const context = { nodeId: node.id, type: node.type, node: node.originalData };

    switch (node.type) {
        case 'volume':
            items.push({ commandId: 'novel.chapter.create', context: { volumeId: node.id } });
            items.push({ commandId: 'novel.volume.create' });
            items.push({ commandId: 'novel.node.rename', context });
            items.push({ isDivider: true, commandId: 'd1' });
            items.push({ commandId: 'novel.ai.analyze', context: { ...context, isBatch: true } });
            items.push({ commandId: 'novel.ai.continue', context: { ...context, isBatch: true } });
            items.push({ isDivider: true, commandId: 'd2' });
            items.push({ commandId: 'novel.node.delete', context });
            break;

        case 'chapter':
            items.push({ commandId: 'novel.node.rename', context });
            items.push({ isDivider: true, commandId: 'd1' });
            items.push({ commandId: 'novel.ai.analyze', context });
            items.push({ commandId: 'novel.ai.continue', context });
            items.push({ isDivider: true, commandId: 'd2' });
            items.push({ commandId: 'novel.node.delete', context });
            break;

        case 'note':
            items.push({ commandId: 'novel.node.rename', context });
            items.push({ isDivider: true, commandId: 'd1' });
            items.push({ commandId: 'novel.node.delete', context });
            break;

        case 'root':
            if (node.id === 'settings') {
                items.push({ commandId: 'novel.related.create-group', context });
                items.push({ commandId: 'novel.related.create-item', context });
            } else if (node.id === 'plot' || node.id === 'analysis') {
                items.push({ commandId: 'novel.related.create-custom', context });
            }
            break;

        default: // Handles settings items, related items, etc.
            if (node.type === 'group') {
                items.push({ commandId: 'novel.related.create-item', context });
            }
            if (node.id.startsWith('custom-') || node.type.endsWith('_item') || node.type === 'group') {
                items.push({ isDivider: true, commandId: 'd1' });
                items.push({ commandId: 'novel.node.rename', context });
                items.push({ isDivider: true, commandId: 'd2' });
                items.push({ commandId: 'novel.node.delete', context });
            }
            break;
    }

    return items;
}

export function registerNovelContextMenu() {
    contextMenuService.registerProvider('novel-directory-node', (context) => {
        const node = context.node as TreeNode | undefined;
        if (!node) return [];
        return getDirectoryContextMenu(node);
    });

    contextMenuService.registerProvider('novel-editor-content', () => {
        return [
            { commandId: 'novel.ai.continue' },
            { commandId: 'novel.ai.polish' },
            { isDivider: true, commandId: 'd1' },
            { commandId: 'novel.ai.analyze' }
        ];
    });
}

// =
// 文件: ..\src\novel\editor\features\novel.keybindings.ts
//

import type { KeybindingService } from '@core/common/services/KeybindingService';
import { CoreCommand } from '@core/constants';

export function registerNovelKeybindings(keybindingService: KeybindingService) {
    // 核心命令的快捷键
    keybindingService.register({
        key: 'ctrl+s',
        commandId: CoreCommand.SAVE_TAB,
    });

    keybindingService.register({
        key: 'ctrl+shift+p',
        commandId: CoreCommand.COMMAND_PALETTE_SHOW,
    });

    // 可以在这里添加小说模块专属的快捷键
    // 例如: 新建章节
    // keybindingService.register({
    //     key: 'ctrl+alt+n',
    //     commandId: 'novel.chapter.create',
    //     when: 'activeSidebarPanel == "directory"' // 示例: 仅在目录面板激活时生效
    // });
}

// =
// 文件: ..\src\novel\editor\layouts\NovelEditorLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame">
      <!-- 顶部导航栏: 严格遵循UI设计稿 -->
      <header class="h-[56px] bg-white border-b border-gray-100 flex items-center px-6 flex-shrink-0">
        <div class="flex items-center gap-2 flex-1">
          <!-- 返回链接指向小说管理台 -->
          <router-link to="/novel/dashboard" class="flex items-center gap-2 text-gray-500 hover:text-gray-800 transition-colors p-2 -ml-2 rounded-lg">
            <i class="fa-solid fa-chevron-left w-4 h-4"></i>
            <span>返回</span>
          </router-link>
          <span class="text-gray-300">/</span>
          <!-- 静态小说标题 -->
          <span class="font-medium text-gray-800 text-sm">星际漫游者</span>
        </div>
        <div class="flex items-center gap-4">
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors">
            <i class="fa-solid fa-search w-5 h-5"></i>
          </button>
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors relative">
            <i class="fa-solid fa-bell w-5 h-5"></i>
            <span class="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full border border-white"></span>
          </button>
          <div class="ml-2 flex items-center gap-3">
            <img src="https://i.pravatar.cc/150?u=creator" alt="Creator Avatar" class="w-9 h-9 rounded-full">
            <div>
              <p class="text-sm font-medium text-[#374151]">创作者</p>
              <p class="text-xs text-[#9CA3AF]">在线</p>
            </div>
          </div>
        </div>
      </header>

      <!-- 使用 <router-view /> 来渲染子路由对应的组件 (EditorWorkspaceView) -->
      <div class="h-[calc(100%-56px)]">
        <router-view />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import '../assets/styles/main.css';
</script>

<style scoped>
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
}
</style>

// =
// 文件: ..\src\novel\editor\novel.module.ts
//

import { type Component, defineAsyncComponent } from 'vue';
import type { ViewRegistry } from '@core/common/services/ViewRegistry';
import { commandService } from '@core/services/CommandService';
import { keybindingService } from '@core/common/services/KeybindingService';
import { registerNovelCommands } from './features/novel.commands';
import { registerNovelKeybindings } from './features/novel.keybindings';
import { registerNovelContextMenu } from './features/novel.contextMenu';

// --- 视图组件动态导入 ---
const NovelEditorPane = defineAsyncComponent(() => import('./views/NovelEditorPane.vue'));
const AIChatView = defineAsyncComponent(() => import('./components/ai/AIChatView.vue'));
const AITaskPanel = defineAsyncComponent(() => import('./components/ai/AITaskPanel.vue'));
const SearchView = defineAsyncComponent(() => import('./components/system/SearchView.vue'));
const HistoryPanel = defineAsyncComponent(() => import('./components/system/HistoryPanel.vue'));
const ReaderPanel = defineAsyncComponent(() => import('./components/system/ReaderPanel.vue'));
const EditorSettings = defineAsyncComponent(() => import('./components/system/settings/EditorSettings.vue'));
const ContextSettings = defineAsyncComponent(() => import('./components/system/settings/ContextSettings.vue'));
const TaskSettings = defineAsyncComponent(() => import('./components/system/settings/TaskSettings.vue'));
const AIConfigSettings = defineAsyncComponent(() => import('./components/system/settings/AIConfigSettings.vue'));
const NovelSettings = defineAsyncComponent(() => import('./components/system/settings/NovelSettings.vue'));

const VIEW_MAP: Record<string, Component> = {
    'novel-content-editor': NovelEditorPane,
    'novel-ai-chat-view': AIChatView,
    'novel-ai-task-panel': AITaskPanel,
    'novel-search-view': SearchView,
    'novel-history-panel': HistoryPanel,
    'novel-reader-panel': ReaderPanel,
    'novel-settings-editor': EditorSettings,
    'novel-settings-context': ContextSettings,
    'novel-settings-tasks': TaskSettings,
    'novel-settings-ai-config': AIConfigSettings,
    'novel-settings-novel': NovelSettings,
};

function registerViewComponents(viewRegistry: ViewRegistry) {
    for (const viewType in VIEW_MAP) {
        viewRegistry.register(viewType, VIEW_MAP[viewType]);
    }
}

export class NovelModule {
    public install(viewRegistry: ViewRegistry): void {
        registerViewComponents(viewRegistry);
        registerNovelCommands(commandService);
        registerNovelKeybindings(keybindingService);
        registerNovelContextMenu();
    }
}

// =
// 文件: ..\src\novel\editor\novel.provider.ts
//

import type { ItemProvider, CoreItem } from '@core/types';
import { useDirectoryStore } from './stores/directoryStore';
import { useRelatedContentStore } from './stores/relatedContentStore';
import { useNotesStore } from './stores/notesStore';
import { getIconByNodeType } from './utils/iconUtils';
import type { Chapter, RelatedTree, NoteItem } from './types';
// 定义了模块内可编辑实体的类型联合
type EditableItem = Chapter | RelatedTree | NoteItem;
const SYSTEM_VIEWS_CONFIG = {
    'system:search': { title: '搜索', icon: 'fa-solid fa-magnifying-glass', viewType: 'novel-search-view' },
    'system:ai_chat': { title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles', viewType: 'novel-ai-chat-view' },
    'system:ai_tasks': { title: 'AI 任务', icon: 'fa-solid fa-list-check', viewType: 'novel-ai-task-panel' },
    'system:settings_editor': { title: '编辑器设置', icon: 'fa-solid fa-pencil', viewType: 'novel-settings-editor' },
    'system:settings_context': { title: '上下文管理', icon: 'fa-solid fa-book-open-reader', viewType: 'novel-settings-context' },
    'system:settings_tasks': { title: '任务管理', icon: 'fa-solid fa-list-check', viewType: 'novel-settings-tasks' },
    'system:settings_ai_config': { title: 'AI 任务配置', icon: 'fa-solid fa-microchip', viewType: 'novel-settings-ai-config' },
    'system:settings_novel': { title: '小说设置', icon: 'fa-solid fa-swatchbook', viewType: 'novel-settings-novel' },
    'system:history': { title: '版本历史', icon: 'fa-solid fa-code-compare', viewType: 'novel-history-panel' },
    'system:reader': { title: '阅读模式', icon: 'fa-solid fa-book-open', viewType: 'novel-reader-panel' },
};
class NovelItemProvider implements ItemProvider {
    public async getItem(id: string): Promise<CoreItem | null> {
// 处理系统视图
        const systemViewInfo = this.getSystemView(id);
        if (systemViewInfo) {
            return systemViewInfo;
        }

// 处理内容实体
        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();

        const finders = [
            () => directoryStore.findNodeById(id)?.node,
            () => relatedContentStore.findNodeById(id)?.node,
            () => notesStore.findNoteById(id),
        ];

        for (const find of finders) {
            const item = find() as EditableItem | undefined;
            if (item && 'content' in item) {
                return {
                    id: item.id,
                    title: item.title,
                    icon: getIconByNodeType(item.type),
                    viewType: this.getViewTypeForItem(item),
                    metadata: { ...item }, // 传递完整业务数据
                };
            }
        }

        return null;
    }

    public async updateItem(id: string, content: string): Promise<void> {
        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();

        if (directoryStore.findNodeById(id)?.node) {
            directoryStore.updateChapterContent(id, content);
        } else if (relatedContentStore.findNodeById(id)?.node) {
            relatedContentStore.updateNodeContent(id, content);
        } else if (notesStore.findNoteById(id)) {
            notesStore.updateNoteContent(id, content);
        }
    }

    private getSystemView(id: string): CoreItem | null {
        const parts = id.split(':');
        const baseId = parts.slice(0, 2).join(':');
        const config = SYSTEM_VIEWS_CONFIG[baseId as keyof typeof SYSTEM_VIEWS_CONFIG];

        if (!config) return null;

        let title = config.title;
        // 为动态系统视图（如历史记录）生成唯一标题
        if (parts.length > 2) {
            const targetId = parts.slice(2).join(':');
            // 异步地获取目标项的标题
            // 注意: 这是一个简化的同步查找，实际可能需要异步
            const directoryStore = useDirectoryStore();
            const targetNode = directoryStore.findNodeById(targetId)?.node;
            if (targetNode) {
                title = `《${targetNode.title}》 ${config.title}`;
            }
        }

        return {
            id: id,
            title: title,
            icon: config.icon,
            viewType: config.viewType,
            metadata: { targetId: parts.length > 2 ? parts.slice(2).join(':') : null },
        };
    }

    private getViewTypeForItem(item: EditableItem): string {
        // 关键修复：确保所有拥有 `content` 属性并应被编辑的实体
        // 都明确返回 'novel-content-editor'。
        // 这消除了任何不确定性，确保始终加载正确的视图组件。
        if ('content' in item) {
            return 'novel-content-editor';
        }
        // 对于没有内容视图的项，可以返回一个特定的只读视图或错误视图的类型
        // 为简单起见，这里我们假设所有从 `getItem` 成功返回的项都有编辑器视图
        return 'novel-content-editor';
    }

}
export const novelItemProvider = new NovelItemProvider();

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\stores\aiTaskStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useUIStore } from './uiStore';
import type { AITask, Volume, Chapter, RelatedTree } from '../types';
import { mockAIResponses } from '../data';

type ContentItem = Chapter | RelatedTree;

export const useAITaskStore = defineStore('novel-ai-task', () => {
    const tasks = ref<AITask[]>([]);
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const uiStore = useUIStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    const _findItemContent = (itemId: string): string => {
        const dirNode = directoryStore.findNodeById(itemId)?.node;
        if (dirNode && 'content' in dirNode) return dirNode.content || '';
        const relNode = relatedContentStore.findNodeById(itemId)?.node;
        if (relNode && 'content' in relNode) return relNode.content || '';
        return '';
    };

    const _simulateAIStream = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || task.status !== 'pending') return;

        task.status = 'processing';
        task.generatedContent = '';

        const mockResponseText = mockAIResponses[task.type];
        const words = mockResponseText.split('');
        let wordIndex = 0;
        const willFail = Math.random() < 0.1;

        const intervalId = setInterval(() => {
            const currentTask = tasks.value.find(t => t.id === taskId);
            if (!currentTask || currentTask.status !== 'processing') {
                clearInterval(intervalId);
                return;
            }

            if (wordIndex < words.length) {
                currentTask.generatedContent += words[wordIndex];
                wordIndex++;
                if (willFail && wordIndex > words.length / 2) {
                    clearInterval(intervalId);
                    currentTask.status = 'failed';
                    currentTask.error = '生成超时，请检查网络后重试。';
                    return;
                }
            } else {
                clearInterval(intervalId);
                currentTask.status = 'completed';
                if (!uiStore.uiState.needsPreview) {
                    applyChanges(currentTask.id);
                }
            }
        }, 30);
    };

    const _processQueue = () => {
        const processingCount = tasks.value.filter(t => t.status === 'processing').length;
        if (processingCount > 0) return;

        const pendingTask = tasks.value.find(t => t.status === 'pending');
        if (pendingTask) {
            _simulateAIStream(pendingTask.id);
        }
    };

    const _addTask = (taskType: '润色' | '续写' | '分析', item: ContentItem) => {
        const newTask: AITask = {
            id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            title: `${taskType}《${item.title}》`,
            type: taskType,
            targetItemId: item.id,
            status: 'pending',
            originalContent: item.content || '',
            generatedContent: '',
            createdAt: new Date(),
        };
        tasks.value.unshift(newTask);
    };

    function startNewTask(taskType: '润色' | '续写' | '分析', targetItemId: string) {
        const dirNode = directoryStore.findNodeById(targetItemId)?.node as ContentItem;
        const relNode = relatedContentStore.findNodeById(targetItemId)?.node as ContentItem;
        const item = dirNode || relNode;
        if (item) {
            _addTask(taskType, item);
            nextTick(_processQueue);
        }
    }

    function startBatchTaskForVolume(taskType: '润色' | '续写' | '分析', volume: Volume) {
        volume.chapters.forEach(chapter => _addTask(taskType, chapter));
        nextTick(_processQueue);
    }

    function applyChanges(taskId: string) {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'completed') {
            directoryStore.appendChapterContent(task.targetItemId, task.generatedContent);
            task.status = 'applied';
        }
    }

    function retryTask(taskId: string) {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'failed') {
            task.status = 'pending';
            task.error = undefined;
            task.generatedContent = '';
            nextTick(_processQueue);
        }
    }

    function clearCompletedTasks() {
        tasks.value = tasks.value.filter(t => t.status !== 'applied' && t.status !== 'failed');
    }

    function clearAllTasks() {
        tasks.value = [];
    }

    return {
        tasks,
        activeTasksCount,
        startNewTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
    };
});

// =
// 文件: ..\src\novel\editor\stores\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, ChatMessage, AIModel } from '../types';
import { mockChatConversations } from '../data/chatData';

export const useChatStore = defineStore('novel-chat', () => {
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);

    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    function fetchConversations() {
        conversations.value = mockChatConversations;
        if (conversations.value.length > 0 && !activeConversationId.value) {
            activeConversationId.value = conversations.value[0].id;
        }
    }

    function createNewConversation() {
        const newConv: Conversation = {
            id: `conv-${Date.now()}`,
            title: '新建对话',
            summary: '暂无摘要',
            createdAt: '刚刚',
            messages: [],
        };
        conversations.value.unshift(newConv);
        activeConversationId.value = newConv.id;
    }

    function selectConversation(conversationId: string) {
        activeConversationId.value = conversationId;
    }

    async function sendMessage() {
        if (!messageInput.value.trim() || !activeConversation.value || isReceiving.value) {
            return;
        }

        const userMessage: ChatMessage = {
            id: `msg-${Date.now()}`,
            role: 'user',
            content: messageInput.value,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(userMessage);
        const currentInput = messageInput.value;
        messageInput.value = '';

        isReceiving.value = true;
        await new Promise(res => setTimeout(res, 1500));

        const aiResponse: ChatMessage = {
            id: `msg-${Date.now() + 1}`,
            role: 'ai',
            content: `这是对您关于 "${currentInput.substring(0, 10)}..." 的回复。AI正在思考中...`,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(aiResponse);
        isReceiving.value = false;
    }

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewModalStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from './aiTaskStore';
import { useEditorStore } from './editorStore';
import type { PreviewTask } from '../types';

export const useContextMenuStore = defineStore('novel-context-preview-modal', () => {
    const isVisible = ref(false);
    const task = ref<PreviewTask | null>(null);

    function show(previewTask: PreviewTask) {
        task.value = previewTask;
        isVisible.value = true;
    }

    function hide() {
        isVisible.value = false;
        task.value = null;
    }

    function execute() {
        if (!task.value) return;

        const aiTaskStore = useAITaskStore();
        const editorStore = useEditorStore();

        aiTaskStore.startNewTask(task.value.type, task.value.targetItemId);

        if (editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen();
        }

        hide();
    }

    return {
        isVisible,
        task,
        show,
        hide,
        execute,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '../types';

type DirectoryNode = Volume | Chapter;

export const useDirectoryStore = defineStore('novel-directory', () => {
    const directoryData = ref<Volume[]>([]);

    function findNodeById(nodeId: string): { node: DirectoryNode; parent: Volume | null } | null {
        for (const volume of directoryData.value) {
            if (volume.id === nodeId) {
                return { node: volume, parent: null };
            }
            const chapter = volume.chapters.find(c => c.id === nodeId);
            if (chapter) {
                return { node: chapter, parent: volume };
            }
        }
        return null;
    }

    function fetchDirectoryData(data: Volume[]) {
        directoryData.value = data;
    }

    function updateChapterContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node.type === 'chapter') {
            const chapter = result.node;
            chapter.content = content;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            chapter.wordCount = tempDiv.textContent?.trim().length || 0;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== chapter.title) {
                chapter.title = newTitle;
            }
        }
    }

    function appendChapterContent(nodeId: string, contentToAppend: string) {
        const result = findNodeById(nodeId);
        if (result?.node.type === 'chapter') {
            const chapter = result.node;
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            chapter.content += paragraphs;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = chapter.content;
            chapter.wordCount = tempDiv.textContent?.trim().length || 0;
        }
    }

    function addNewVolume(): Volume {
        const newVolume: Volume = {
            id: `vol-${Date.now()}`,
            type: 'volume',
            title: '新建卷',
            content: `<h1>新建卷</h1>`,
            chapters: [],
        };
        directoryData.value.push(newVolume);
        return newVolume;
    }

    function addChapterToVolume(volumeId: string): Chapter | null {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const newChapter: Chapter = {
                id: `ch-${Date.now()}`,
                type: 'chapter',
                title: '新建章节',
                wordCount: 0,
                content: '<h1>新建章节</h1>',
                status: 'editing'
            };
            volume.chapters.push(newChapter);
            return newChapter;
        }
        return null;
    }

    function renameNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            const trimmedTitle = newTitle.trim();
            if(!trimmedTitle) return;
            result.node.title = trimmedTitle;
            if ('content' in result.node && result.node.content?.includes('<h1>')) {
                result.node.content = result.node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            }
        }
    }

    function deleteNode(nodeId: string) {
        const result = findNodeById(nodeId);
        if (!result) return;
        if (!window.confirm(`您确定要删除 "${result.node.title}" 吗？此操作无法撤销。`)) return;

        if (result.parent && result.node.type === 'chapter') {
            result.parent.chapters = result.parent.chapters.filter(c => c.id !== nodeId);
        } else if (!result.parent && result.node.type === 'volume') {
            directoryData.value = directoryData.value.filter(v => v.id !== nodeId);
        }
    }

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { useUIStore } from './uiStore';
import { usePaneStore } from '@core/panes/stores/paneStore';
import { tabManagementService } from '@core/tabs/service/TabManagementService';
import { paneManagementService } from '@core/panes/service/PaneManagementService';
import { mockNovelMetadata, mockDirectoryData, mockSettingsData, mockPlotCustomData, mockAnalysisCustomData, mockNoteData } from '../data';
import type { NovelMetadata } from '../types';
type SidebarPanelId = 'directory' | 'related' | 'notes';
export const useEditorStore = defineStore('novel-editor', () => {
    const directoryStore = useDirectoryStore();
    const paneStore = usePaneStore();
    const uiStore = useUIStore();


    const isSidebarVisible = ref(true);
    const activeSidebarPanelId = ref<SidebarPanelId>('directory');
    const novelMetadata = ref<NovelMetadata | null>(null);

// --- Computed Properties for UI ---
    const activePaneId = computed(() => paneStore.activePaneId);
    const activeTabId = computed(() => paneStore.activePane?.activeTabId ?? null);

    const wordCount = computed(() => {
        if (!activeTabId.value) return 0;
        const item = directoryStore.findNodeById(activeTabId.value)?.node;
        if (item && item.type === 'chapter') {
            return item.wordCount;
        }
        return 0;
    });

    const readingTime = computed(() => {
        if (!wordCount.value) return 0;
        const time = Math.ceil(wordCount.value / 400);
        return time > 0 ? time : 1;
    });

// --- Actions ---
    function initialize() {
        directoryStore.fetchDirectoryData(mockDirectoryData);
        useRelatedContentStore().fetchRelatedData(mockSettingsData, mockPlotCustomData, mockAnalysisCustomData);
        useNotesStore().fetchNotes(mockNoteData);
        novelMetadata.value = JSON.parse(JSON.stringify(mockNovelMetadata));

        // Restore default expanded state
        uiStore.uiState.expandedNodeIds.clear();
        uiStore.uiState.expandedRelatedNodeIds.clear();
        uiStore.toggleNodeExpansion('vol-1');
        uiStore.toggleRelatedNodeExpansion('settings');
        uiStore.toggleRelatedNodeExpansion('characters');

        // Open a default tab
        tabManagementService.openTab('ch-3');
    }

    function toggleSidebar() {
        isSidebarVisible.value = !isSidebarVisible.value;
    }

    function setActiveSidebarPanel(panelId: SidebarPanelId) {
        if (isSidebarVisible.value && activeSidebarPanelId.value === panelId) {
            toggleSidebar();
        } else {
            activeSidebarPanelId.value = panelId;
            if (!isSidebarVisible.value) {
                isSidebarVisible.value = true;
            }
        }
    }

    function ensureAIPanelIsOpen() {
        const activePane = paneStore.activePane;
        if (!activePane) return;

        const allTabsInAllPanes = paneStore.root?.type === 'split'
            ? paneStore.root.children.flatMap(c => c.type === 'leaf' ? c.tabIds : [])
            : (paneStore.root?.tabIds ?? []);

        if (!allTabsInAllPanes.includes('system:ai_tasks')) {
            const newPaneId = paneManagementService.splitPane(activePane.id, 'horizontal');
            if(newPaneId) {
                tabManagementService.openTab('system:ai_tasks', newPaneId);
                paneManagementService.setActivePane(activePane.id); // Set focus back
            }
        }
    }

    function openHistoryPanelForActiveTab() {
        if (activeTabId.value) {
            tabManagementService.openTab(`system:history:${activeTabId.value}`);
        }
    }

    function openReaderViewForActiveTab() {
        if (activeTabId.value) {
            tabManagementService.openTab(`system:reader:${activeTabId.value}`);
        }
    }

// --- Metadata Actions ---
    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    function saveMetadata() {
        if (!novelMetadata.value) return;
        console.log('Saving metadata:', JSON.parse(JSON.stringify(novelMetadata.value)));
        alert('小说设置已保存！');
    }


    return {
        isSidebarVisible,
        activeSidebarPanelId,
        activePaneId,
        activeTabId,
        novelMetadata,
        wordCount,
        readingTime,
        initialize,
        toggleSidebar,
        setActiveSidebarPanel,
        ensureAIPanelIsOpen,
        openHistoryPanelForActiveTab,
        openReaderViewForActiveTab,
        removeTag,
        addTag,
        saveMetadata,
    };
})

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '../types';

export const useNotesStore = defineStore('novel-notes', () => {
    const notes = ref<NoteItem[]>([]);

    function fetchNotes(data: NoteItem[]) {
        notes.value = data;
    }

    function findNoteById(noteId: string): NoteItem | undefined {
        return notes.value.find(note => note.id === noteId);
    }

    function updateNoteContent(noteId: string, content: string) {
        const note = findNoteById(noteId);
        if (note) {
            note.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;
            if (newTitle) note.title = newTitle;
        }
    }

    function addNote(title: string, content: string = ''): NoteItem {
        const newNote: NoteItem = {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
        notes.value.unshift(newNote);
        return newNote;
    }

    function renameNote(noteId: string, newTitle: string) {
        const note = findNoteById(noteId);
        if (note && newTitle.trim()) {
            const trimmedTitle = newTitle.trim();
            note.title = trimmedTitle;
            if (note.content.includes('<h1>')) {
                note.content = note.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            } else {
                note.content = `<h1>${trimmedTitle}</h1>` + note.content;
            }
        }
    }

    function deleteNote(noteId: string) {
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            if (!window.confirm(`您确定要删除笔记 "${notes.value[index].title}" 吗？`)) return;
            notes.value.splice(index, 1);
        }
    }

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        addNote,
        renameNote,
        deleteNote,
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useDirectoryStore } from './directoryStore';
import type { RelatedTree, Volume } from '../types';
import { getIconByNodeType } from '../utils/iconUtils';

export const useRelatedContentStore = defineStore('novel-related-content', () => {
    const settingsData = ref<RelatedTree[]>([]);
    const plotCustomData = ref<RelatedTree[]>([]);
    const analysisCustomData = ref<RelatedTree[]>([]);

    const _findNodeRecursive = (nodes: RelatedTree[], nodeId: string): { node: RelatedTree; parent: RelatedTree | null } | null => {
        for (const node of nodes) {
            if (node.id === nodeId) return { node, parent: null };
            if (node.children) {
                const foundInChild = _findNodeRecursive(node.children, nodeId);
                if (foundInChild) {
                    if (!foundInChild.parent) foundInChild.parent = node;
                    return foundInChild;
                }
            }
        }
        return null;
    };

    const relatedData = computed((): RelatedTree[] => {
        const directoryStore = useDirectoryStore();

        const generateMirroredTree = (sourceNodes: Volume[], prefix: string, suffix: string, iconMap: { volume: string; chapter: string }): RelatedTree[] => {
            return sourceNodes.map(volume => ({
                id: `${prefix}_vol_${volume.id}`,
                title: `${volume.title}${suffix}`,
                type: `${prefix}_volume`,
                icon: iconMap.volume,
                content: `<h1>${volume.title}${suffix}</h1>`,
                children: volume.chapters.map(chapter => ({
                    id: `${prefix}_ch_${chapter.id}`,
                    title: `${chapter.title}${suffix}`,
                    type: `${prefix}_chapter`,
                    icon: iconMap.chapter,
                    content: `<h1>${chapter.title}${suffix}</h1>`,
                }))
            }));
        };

        const plotTree: RelatedTree = {
            id: 'plot', title: '剧情', type: 'root', icon: 'fa-solid fa-feather-pointed',
            children: [...plotCustomData.value, ...generateMirroredTree(directoryStore.directoryData, 'plot', ' 剧情', { volume: 'fa-solid fa-book-bible text-rose-500', chapter: 'fa-solid fa-scroll text-rose-500' })]
        };
        const analysisTree: RelatedTree = {
            id: 'analysis', title: '分析', type: 'root', icon: 'fa-solid fa-magnifying-glass-chart',
            children: [...analysisCustomData.value, ...generateMirroredTree(directoryStore.directoryData, 'analysis', ' 分析', { volume: 'fa-solid fa-chart-pie text-orange-500', chapter: 'fa-solid fa-chart-simple text-orange-500' })]
        };
        return [...settingsData.value, plotTree, analysisTree];
    });

    function findNodeById(nodeId: string) {
        return _findNodeRecursive(relatedData.value, nodeId);
    }

    function fetchRelatedData(settings: RelatedTree[], plot: RelatedTree[], analysis: RelatedTree[]) {
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            result.node.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== result.node.title) {
                result.node.title = newTitle;
            }
        }
    }

    function addRelatedNode(parentId: string, type: 'group' | 'item'): RelatedTree | null {
        const result = findNodeById(parentId);
        if (!result?.node) return null;

        const parentNode = result.node;
        if (!parentNode.children) parentNode.children = [];

        const itemTypePrefix = parentNode.id.replace(/s$/, '');
        const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;

        const newNode: RelatedTree = {
            id: `${type}-${Date.now()}`,
            title: type === 'group' ? '新建分组' : '新建条目',
            type: newNodeType,
            icon: getIconByNodeType(newNodeType),
            content: type === 'item' ? `<h1>新建条目</h1>` : undefined,
            children: type === 'group' ? [] : undefined,
        };
        parentNode.children.push(newNode);
        return newNode;
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis'): RelatedTree {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode: RelatedTree = {
            id: `custom-${target}-${Date.now()}`,
            title: '新建自定义条目',
            type: `${target}_item`,
            icon: getIconByNodeType(`${target}_item`),
            content: '<h1>新建自定义条目</h1>',
        };
        dataRef.value.unshift(newNode);
        return newNode;
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        if (!newTitle.trim()) return;

        const result = findNodeById(nodeId);
        if (result?.node) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;
            if (result.node.content?.includes('<h1>')) {
                result.node.content = result.node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            }
        }
    }

    function deleteRelatedNode(nodeId: string) {
        const nodeToDelete = findNodeById(nodeId)?.node;
        if (!nodeToDelete) return;
        if (!window.confirm(`您确定要删除 "${nodeToDelete.title}" 吗？此操作无法撤销。`)) return;

        const _findAndRemove = (nodes: RelatedTree[]): boolean => {
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].id === nodeId) {
                    nodes.splice(i, 1);
                    return true;
                }
                if (nodes[i].children && _findAndRemove(nodes[i].children!)) {
                    return true;
                }
            }
            return false;
        }
        _findAndRemove(settingsData.value);
    }

    function deleteCustomRelatedNode(nodeId: string) {
        const sources = [plotCustomData, analysisCustomData];
        for (const source of sources) {
            const index = source.value.findIndex(item => item.id === nodeId);
            if (index !== -1) {
                if (!window.confirm(`您确定要删除 "${source.value[index].title}" 吗？`)) return;
                source.value.splice(index, 1);
                break;
            }
        }
    }

    return {
        relatedData,
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        addRelatedNode,
        addCustomRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        deleteCustomRelatedNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

import { defineStore } from 'pinia';
import { ref, reactive } from 'vue';
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { getIconByNodeType } from '../utils/iconUtils';
import type { SearchResult, ContextItem, RelatedTree } from '../types';

type AnyItem = RelatedTree | ReturnType<typeof useDirectoryStore>['directoryData'][0]['chapters'][0] | ReturnType<typeof useNotesStore>['notes'][0];

export const useUIStore = defineStore('novel-ui', () => {
    const editingNodeId = ref<string | null>(null);
    const searchResults = ref<SearchResult[]>([]);

    const uiState = reactive({
        expandedNodeIds: new Set<string>(),
        expandedRelatedNodeIds: new Set<string>(),
        needsPreview: false,
        customContextContent: '',
        dynamicContextSettings: { prevChapters: 3, nextChapters: 2 },
        isRagEnabled: true,
        selectedContextItems: [] as ContextItem[],
    });

    function setEditingNodeId(id: string | null) {
        editingNodeId.value = id;
    }

    function toggleNodeExpansion(nodeId: string) {
        if (uiState.expandedNodeIds.has(nodeId)) {
            uiState.expandedNodeIds.delete(nodeId);
        } else {
            uiState.expandedNodeIds.add(nodeId);
        }
    }

    function toggleRelatedNodeExpansion(nodeId: string) {
        if (uiState.expandedRelatedNodeIds.has(nodeId)) {
            uiState.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.expandedRelatedNodeIds.add(nodeId);
        }
    }

    function addFixedContextItem(item: ContextItem) {
        if (!uiState.selectedContextItems.some(i => i.id === item.id)) {
            uiState.selectedContextItems.push({
                ...item,
                wordCount: item.content.length
            });
        }
    }

    function removeFixedContextItem(index: number) {
        uiState.selectedContextItems.splice(index, 1);
    }

    function searchAllDocuments(query: string) {
        searchResults.value = [];
        if (!query || query.trim().length < 1) return;

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: AnyItem) => {
            if (!('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';

            if (textContent.toLowerCase().includes(lowerCaseQuery)) {
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;
                const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
                let match;
                while ((match = regex.exec(textContent)) !== null) {
                    if (result.matches.length >= 5) break;
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    result.matches.push({ context: `...${context}...` });
                }
            }
        };

        const directoryStore = useDirectoryStore();
        directoryStore.directoryData.forEach(vol => vol.chapters.forEach(processItem));

        const relatedContentStore = useRelatedContentStore();
        const flattenRelated = (nodes: RelatedTree[]) => {
            nodes.forEach(node => {
                processItem(node);
                if (node.children) flattenRelated(node.children);
            });
        };
        flattenRelated(relatedContentStore.relatedData);

        const notesStore = useNotesStore();
        notesStore.notes.forEach(processItem);

        searchResults.value = Array.from(resultsMap.values());
    }

    function clearSearchResults() {
        searchResults.value = [];
    }

    return {
        editingNodeId,
        searchResults,
        uiState,
        setEditingNodeId,
        toggleNodeExpansion,
        toggleRelatedNodeExpansion,
        addFixedContextItem,
        removeFixedContextItem,
        searchAllDocuments,
        clearSearchResults
    };
});

// =
// 文件: ..\src\novel\editor\types.ts
//

// --- 基本内容结构 ---

export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    content: string;
    chapters: Chapter[];
}

export interface Chapter {
    id: string;
    type: 'chapter';
    title: string;
    wordCount: number;
    content: string;
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

export interface RelatedTree {
    id: string;
    type: string;
    title: string;
    icon: string;
    content?: string;
    children?: RelatedTree[];
    originalData?: any;
}

export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    content: string;
    timestamp: string;
}

// --- 小说元数据与角色 ---

export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string;
    notes?: string;
    status?: 'editing' | 'completed' | 'draft';
}

export interface NovelTag {
    text: string;
    class: string;
}

export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}


// --- AI 相关 ---

export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'applied';

export interface AITask {
    id: string;
    title: string;
    type: '润色' | '续写' | '分析';
    targetItemId: string;
    status: AITaskStatus;
    originalContent: string;
    generatedContent: string;
    error?: string;
    createdAt: Date;
}

// --- 聊天相关 ---

export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// --- 搜索与UI ---

export interface SearchResult {
    id: string;
    title: string;
    icon: string;
    matches: { context: string }[];
}

// --- 上下文预览相关 ---
export interface ContextItem {
    id: string;
    group: string;
    title: string;
    description: string;
    content: string;
    wordCount?: number;
}

export interface PreviewTask {
    type: '润色' | '续写' | '分析';
    targetItemId: string;
    title: string;
}

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

const ICON_MAP: Record<string, string> = {
    'volume': 'fa-solid fa-layer-group text-purple-500',
    'chapter': 'fa-solid fa-file-lines text-blue-600',
    'settings': 'fa-solid fa-book-journal-whills',
    'group': 'fa-solid fa-folder text-yellow-600',
    'character_item': 'fa-regular fa-user',
    'worldview_item': 'fa-solid fa-book-atlas',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-box-archive',
    'plot': 'fa-solid fa-feather-pointed',
    'plot_volume': 'fa-solid fa-book-bible text-rose-500',
    'plot_chapter': 'fa-solid fa-scroll text-rose-500',
    'plot_item': 'fa-solid fa-lightbulb text-rose-500',
    'analysis': 'fa-solid fa-magnifying-glass-chart',
    'analysis_volume': 'fa-solid fa-chart-pie text-orange-500',
    'analysis_chapter': 'fa-solid fa-chart-simple text-orange-500',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus text-orange-500',
    'note': 'fa-solid fa-note-sticky text-yellow-500',
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

export function getIconByNodeType(type: string): string {
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }
    const normalizedType = type.replace(/s_item$/, '_item');
    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\editor\views\EditorWorkspaceView.vue
//

<template>
  <div class="editor-workspace-container">
    <CoreLayout v-if="kernel" :kernel="kernel">
      <template #activity-bar>
        <ActivityBar />
      </template>
      <template #sidebar>
        <SidebarPanel />
      </template>
      <template #status-bar>
        <StatusBar />
      </template>
      <template #global>
        <NotificationCenter />
        <CommandPalette />
        <ContextMenu />
        <ContextPreviewModal />
        <ManageMenu />
      </template>
    </CoreLayout>
  </div>
</template>
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { EditorKernel } from '@core/services/EditorKernel';
import { viewRegistry } from '@core/common/services/ViewRegistry';
import { novelItemProvider } from '../novel.provider';
import { NovelModule } from '../novel.module';
import { useEditorStore } from '../stores/editorStore';

// Core Components
import CoreLayout from '@core/layout/components/CoreLayout.vue';
import NotificationCenter from '@core/layout/components/NotificationCenter.vue';
import CommandPalette from '@core/palette/components/CommandPalette.vue';
import ContextMenu from '@core/panes/components/ContextMenu.vue';

// Novel Specific Components
import ActivityBar from '../components/layout/ActivityBar.vue';
import SidebarPanel from '../components/sidebar/SidebarPanel.vue';
import StatusBar from '../components/layout/StatusBar.vue';
import ContextPreviewModal from '../components/modals/ContextPreviewModal.vue';
import ManageMenu from '../components/layout/ManageMenu.vue';

const kernel = ref<EditorKernel | null>(null);
const editorStore = useEditorStore();

onMounted(() => {
// 1. 初始化内核，并注入 Novel 模块的数据提供者
  const editorKernel = new EditorKernel(novelItemProvider);

// 2. 安装 Novel 模块，注册所有视图和命令
  new NovelModule().install(viewRegistry);

// 3. 启动内核 (将加载持久化的工作区状态等)
  editorKernel.startup();

// 4. 初始化 Novel 模块的业务数据 (模拟加载)
  editorStore.initialize();

  kernel.value = editorKernel;
});

onUnmounted(() => {
  kernel.value?.shutdown();
});
</script>
<style scoped>
.editor-workspace-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background-color: #F9FAFB;
}
</style>

// =
// 文件: ..\src\novel\editor\views\NovelEditorPane.vue
//

<template>
  <div class="novel-editor-pane-container">
    <!-- Level 1: Breadcrumbs and Pane Actions (Replicates old EditorInstance top bar) -->
    <div class="top-header-bar">
      <BreadcrumbsBar :active-tab="tab" :is-active="isActivePane" />
      <PaneActions :pane-id="paneId" :is-active="isActivePane" />
    </div>

    <!-- Level 2: Content Area with Editor and Floating Toolbar -->
    <div class="content-area-wrapper" ref="wrapperRef" @contextmenu.prevent="showContextMenu">
      <FloatingToolbar ref="floatingToolbarRef" />
      <div class="editor-content-wrapper" ref="editorContentRef">
        <TiptapEditor
            :key="tab.id"
            v-model="editableContent"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, computed, onMounted, onBeforeUnmount, type PropType } from 'vue';
import type { CoreItem, Tab } from '@core/types';
import { useEditableView } from '@core/editor/composables/useEditableView';
import { contextMenuService } from '@core/panes/service/ContextMenuService';
import { usePaneStore } from '@core/panes/stores/paneStore';

import TiptapEditor from '../components/content/TiptapEditor.vue';
import FloatingToolbar from '../components/content/FloatingToolbar.vue';
import BreadcrumbsBar from '../components/layout/BreadcrumbsBar.vue';
import PaneActions from '../components/layout/PaneActions.vue';

const props = defineProps({
  item: { type: Object as PropType<CoreItem>, required: true },
  tab: { type: Object as PropType<Tab>, required: true },
  // pane and isActivePane are not directly passed from core, but we can get them.
});

const paneStore = usePaneStore();
const paneId = computed(() => paneStore.findLeafContainingTab(props.tab.id)?.id ?? '');
const isActivePane = computed(() => paneStore.activePaneId === paneId.value);


const editableContent = ref(props.item.metadata.content || '');
useEditableView({
  tab: ref(props.tab),
  coreItem: ref(props.item),
  content: editableContent,
});


const wrapperRef = ref<HTMLElement | null>(null);
const editorContentRef = ref<HTMLElement | null>(null);
const floatingToolbarRef = ref<InstanceType<typeof FloatingToolbar> | null>(null);

const showContextMenu = (event: MouseEvent) => {
  contextMenuService.show(event, 'novel-editor-content', { itemId: props.item.id });
};

const handleSelectionChange = () => {
  if (!isActivePane.value || !floatingToolbarRef.value || !wrapperRef.value || !editorContentRef.value) {
    floatingToolbarRef.value?.hide();
    return;
  }
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed || !editorContentRef.value.contains(selection.getRangeAt(0).commonAncestorContainer)) {
    floatingToolbarRef.value.hide();
    return;
  }
  floatingToolbarRef.value.show(selection.getRangeAt(0).getBoundingClientRect(), wrapperRef.value.getBoundingClientRect());
};

const handleClickOutside = (event: MouseEvent) => {
  const target = event.target as HTMLElement;
  if (floatingToolbarRef.value && !target.closest('.floating-toolbar')) {
    floatingToolbarRef.value.hide();
  }
};

onMounted(() => {
  document.addEventListener('selectionchange', handleSelectionChange);
  document.addEventListener('click', handleClickOutside, true);
});

onBeforeUnmount(() => {
  document.removeEventListener('selectionchange', handleSelectionChange);
  document.removeEventListener('click', handleClickOutside, true);
});
</script>

<style scoped>
.novel-editor-pane-container { display: flex; flex-direction: column; height: 100%; overflow: hidden; }
.top-header-bar { display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; background-color: #FFFFFF; border-bottom: 1px solid #E5E7EB; }
.content-area-wrapper { flex-grow: 1; overflow-y: auto; position: relative; }
.editor-content-wrapper { max-width: 42rem; margin: 2rem auto; }
</style>

// =
// 文件: ..\src\core\common\components\ErrorDisplay.vue
//

<!-- 文件: src/core/components/ErrorDisplay.vue -->
<template>
  <div class="error-display-container">
    <i class="fa-solid fa-circle-exclamation error-icon"></i>
    <h3 class="error-title">Failed to Load Content</h3>
    <p class="error-message">{{ message }}</p>
    <p class="error-suggestion">
      You can try to <a href="#" @click.prevent="reload">reload</a> the item or close this tab.
    </p>
  </div>
</template>

<script setup lang="ts">
defineProps({
  message: {
    type: String,
    required: true,
  },
});

const emit = defineEmits(['reload']);

const reload = () => {
  emit('reload');
};
</script>

<style scoped>
.error-display-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 2rem;
  text-align: center;
  user-select: none;
  background-color: #FFFFFF;
}
.error-icon {
  font-size: 3rem;
  color: #F87171;
}
.error-title {
  font-size: 1.25rem;
  font-weight: 500;
  color: #4B5563;
  margin-top: 1.5rem;
}
.error-message {
  color: #6B7280;
  margin-top: 0.5rem;
  max-width: 500px;
}
.error-suggestion {
  color: #9CA3AF;
  margin-top: 1.5rem;
  font-size: 0.875rem;
}
.error-suggestion a {
  color: #3B82F6;
  text-decoration: none;
}
.error-suggestion a:hover {
  text-decoration: underline;
}
</style>

// =
// 文件: ..\src\core\common\components\WelcomeScreen.vue
//

<template>
  <div class="welcome-screen">
    <i class="fa-solid fa-feather-pointed text-6xl text-gray-300"></i>
    <h1 class="text-2xl font-medium text-gray-600 mt-6">星尘编辑器</h1>
    <p class="text-gray-500 mt-2">从左侧面板选择一个文件开始创作。</p>
  </div>
</template>
<style scoped>
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
  background-color: #FFFFFF;
}
</style>

// =
// 文件: ..\src\core\common\composables\useResizable.ts
//

// 文件: src/core/composables/useResizable.ts
// 描述: 一个可复用的 Vue Composable，用于处理元素拖拽调整大小的逻辑。

import { onUnmounted } from 'vue';

interface ResizableOptions {
    onResize: (delta: { dx: number; dy: number }) => void;
    onResizeEnd?: () => void;
    cursor?: 'col-resize' | 'row-resize';
}

export function useResizable(options: ResizableOptions) {
    const { onResize, onResizeEnd, cursor = 'col-resize' } = options;
    let startX = 0;
    let startY = 0;

    const handleMouseMove = (e: MouseEvent) => {
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        onResize({ dx, dy });
    };

    const handleMouseUp = () => {
        document.body.style.cursor = '';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        onResizeEnd?.();
    };

    const startResize = (event: MouseEvent) => {
        event.preventDefault();
        startX = event.clientX;
        startY = event.clientY;

        document.body.style.cursor = cursor;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    };

    onUnmounted(() => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    });

    return {
        startResize,
    };
}

// =
// 文件: ..\src\core\common\services\ConfigService.ts
//

class ConfigService {
    private config: Map<string, any> = new Map();

    /**
     * 设置一个配置项。
     * 应用层在初始化时调用此方法来注入自定义配置。
     * @param key - 配置项的键 (e.g., 'pane.minWidth')。
     * @param value - 配置项的值。
     */
    public set(key: string, value: any): void {
        this.config.set(key, value);
    }

    /**
     * 获取一个配置项。
     * 如果配置未被设置，则返回提供的默认值。
     * @param key - 配置项的键。
     * @param defaultValue - 当找不到键时返回的默认值。
     * @returns 配置项的值或默认值。
     */
    public get<T>(key: string, defaultValue: T): T {
        if (this.config.has(key)) {
            return this.config.get(key) as T;
        }
        return defaultValue;
    }
}

// 导出一个单例，确保整个应用共享同一个配置服务。
export const configService = new ConfigService();

// =
// 文件: ..\src\core\common\services\ContextService.ts
//



import { reactive } from 'vue';

type ContextValue = boolean | string | number;

class ContextService {
    private contextState: Map<string, ContextValue> = reactive(new Map());

    constructor() {
        this.contextState.set('alwaysTrue', true); // A default context for commands without a 'when' clause
    }

    /**
     * 设置一个上下文键的值。
     * @param key - 上下文键 (e.g., 'editorFocus', 'isReadOnly').
     * @param value - 上下文的值.
     */
    public set(key: string, value: ContextValue): void {
        if (this.contextState.get(key) !== value) {
            this.contextState.set(key, value);
        }
    }

    /**
     * 获取一个上下文键的值。
     * @param key - 上下文键。
     * @returns The value of the context key, or undefined if not set.
     */
    public get(key: string): ContextValue | undefined {
        return this.contextState.get(key);
    }

    /**
     * 检查一个基于字符串的 'when' 表达式是否为真。
     * 目前仅支持 '&&', '||', '!', '==', '!=' 和键名。
     * @param when - The when clause string, e.g., "editorFocus && !isReadOnly".
     * @returns True if the expression evaluates to true, false otherwise.
     */
    public check(when: string): boolean {
        try {
            const keys = Array.from(this.contextState.keys());
            // This is a safer alternative to eval(). It creates a function where
            // context keys are arguments, preventing access to the global scope.
            const func = new Function(...keys, `return !!(${when});`);
            const values = keys.map(key => this.contextState.get(key));
            return func(...values);
        } catch (error) {
            console.error(`[ContextService] Error evaluating 'when' clause: "${when}"`, error);
            return false;
        }
    }
}

export const contextService = new ContextService();

// =
// 文件: ..\src\core\common\services\EventBusService.ts
//

// 文件: src/core/services/EventBusService.ts
// 描述: 一个轻量级的全局事件总线，用于实现模块间的解耦通信。

type EventHandler = (payload?: any) => void;

class EventBusService {
    private events: Map<string, EventHandler[]> = new Map();

    /**
     * 订阅一个事件。
     * @param eventName - 事件名称 (e.g., 'core:tab.opened')。
     * @param handler - 事件处理函数。
     */
    public on(eventName: string, handler: EventHandler): void {
        if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
        }
        this.events.get(eventName)!.push(handler);
    }

    /**
     * 取消订阅一个事件。
     * @param eventName - 事件名称。
     * @param handler - 要移除的事件处理函数。
     */
    public off(eventName: string, handler: EventHandler): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            const index = handlers.indexOf(handler);
            if (index > -1) {
                handlers.splice(index, 1);
            }
        }
    }

    /**
     * 触发一个事件，通知所有订阅者。
     * @param eventName - 事件名称。
     * @param payload - （可选）随事件传递的数据。
     */
    public emit(eventName: string, payload?: any): void {
        const handlers = this.events.get(eventName);
        if (handlers) {
            // 创建副本以防在处理过程中有订阅/取消订阅操作
            [...handlers].forEach(handler => handler(payload));
        }
    }
}

// 导出一个单例，确保整个应用共享同一个事件总线。
export const eventBus = new EventBusService();

// =
// 文件: ..\src\core\common\services\KeybindingService.ts
//



import { commandService } from '../../services/CommandService.ts';

interface Keybinding {
    key: string;
    commandId: string;
    when?: () => boolean;
}

class KeybindingService {
    private keybindings: Map<string, Keybinding> = new Map();
    // [FIX] Store the bound event handler to ensure it can be removed.
    private readonly boundHandleKeyDown: (event: KeyboardEvent) => void;

    constructor() {
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    }

    public initialize(): void {
        window.addEventListener('keydown', this.boundHandleKeyDown);
    }

    public destroy(): void {
        window.removeEventListener('keydown', this.boundHandleKeyDown);
    }

    public register(keybinding: Keybinding): void {
        const key = this.normalizeKey(keybinding.key);
        this.keybindings.set(key, keybinding);
    }

    private handleKeyDown(event: KeyboardEvent): void {
        const key = this.eventToKey(event);
        const binding = this.keybindings.get(key);

        if (binding) {
            const isKeybindingConditionMet = !binding.when || binding.when();
            const isCommandConditionMet = commandService.canExecute(binding.commandId);

            if (isKeybindingConditionMet && isCommandConditionMet) {
                event.preventDefault();
                event.stopPropagation();
                commandService.execute(binding.commandId);
            }
        }
    }

    private normalizeKey(key: string): string {
        const parts = key.toLowerCase().split('+').map(part => part.trim());
        const modifiers = parts.filter(p => ['ctrl', 'shift', 'alt', 'meta'].includes(p)).sort();
        const mainKey = parts.find(p => !['ctrl', 'shift', 'alt', 'meta'].includes(p));
        return [...modifiers, mainKey].join('+');
    }

    private eventToKey(event: KeyboardEvent): string {
        const parts: string[] = [];
        if (event.ctrlKey) parts.push('ctrl');
        if (event.shiftKey) parts.push('shift');
        if (event.altKey) parts.push('alt');
        if (event.metaKey) parts.push('meta');

        const key = event.key.toLowerCase();
        if (!['control', 'shift', 'alt', 'meta'].includes(key)) {
            parts.push(key);
        }

        return this.normalizeKey(parts.join('+'));
    }
}

export const keybindingService = new KeybindingService();

// =
// 文件: ..\src\core\common\services\UIService.ts
//

// 文件: src/core/services/UIService.ts
// 描述: 提供与用户界面交互的抽象服务，将核心逻辑与具体UI实现解耦。

interface ConfirmationOptions {
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
}

class UIService {
    private confirmHandler: (options: ConfirmationOptions) => Promise<boolean> = async (options) => {
        const fullMessage = `${options.title}\n\n${options.message}`;
        return window.confirm(fullMessage);
    };

    /**
     * 请求用户确认。这会显示一个对话框并等待用户响应。
     * @param options - 配置对话框的内容。
     * @returns 一个解析为布尔值的 Promise，true 表示用户确认，false 表示取消。
     */
    public requestConfirmation(options: ConfirmationOptions): Promise<boolean> {
        return this.confirmHandler(options);
    }

    /**
     * 允许UI层（如Vue组件）注册一个自定义的确认对话框处理器。
     * @param handler - 一个接收选项并返回Promise<boolean>的函数。
     */
    public registerConfirmHandler(handler: (options: ConfirmationOptions) => Promise<boolean>): void {
        this.confirmHandler = handler;
    }
}

export const uiService = new UIService();

// =
// 文件: ..\src\core\common\services\ViewRegistry.ts
//

// 文件: src/core/services/ViewRegistry.ts
// 描述: 视图注册表服务，负责管理 "viewType" 字符串到 Vue 组件的映射。

import type { Component } from 'vue';

class ViewRegistry {
    private views: Map<string, Component> = new Map();

    /**
     * 注册一个视图类型及其对应的Vue组件。
     * 应用层在启动时调用此方法，告诉内核如何渲染特定类型的内容。
     * @param viewType - 视图的唯一标识符字符串 (e.g., 'novel-chapter-editor')。
     * @param component - 要渲染的Vue组件。
     */
    public register(viewType: string, component: Component): void {
        if (this.views.has(viewType)) {
            console.warn(`[ViewRegistry] View type "${viewType}" is already registered. Overwriting.`);
        }
        this.views.set(viewType, component);
    }

    /**
     * 根据视图类型解析并返回对应的Vue组件。
     * PaneInstance组件会调用此方法来动态渲染内容。
     * @param viewType - 视图的唯一标识符字符串。
     * @returns 如果找到，则返回Vue组件；否则返回null。
     */
    public resolve(viewType: string): Component | null {
        if (!this.views.has(viewType)) {
            console.error(`[ViewRegistry] No view component registered for type "${viewType}".`);
            return null;
        }
        return this.views.get(viewType) || null;
    }
}

// 导出一个单例，确保整个应用共享同一个视图注册表。
export const viewRegistry = new ViewRegistry();

// =
// 文件: ..\src\core\common\types\command.ts
//

export interface CommandContext {
    [key: string]: any;
}

export interface Command {
    id: string;
    label: string | ((context: CommandContext) => string);
    icon?: string;
    when?: ((context: CommandContext) => boolean) | string;
    execute: (context: CommandContext) => void;
}

export interface ContextMenuItem {
    commandId: string;
    context?: CommandContext;
    isDivider?: boolean;
}

export interface ProcessedMenuItem {
    id: string;
    isDivider: boolean;
    isDisabled: boolean;
    label: string;
    icon?: string;
    command: Command;
    context?: CommandContext;
}

// =
// 文件: ..\src\core\common\types\domain.ts
//

export interface CoreItem {
    id: string;
    title: string;
    icon: string;
    viewType: string;
    metadata: Record<string, any>;
}

export interface Tab {
    id: string;
    itemId: string;
    title: string;
    icon: string;
    isDirty: boolean;
}

// =
// 文件: ..\src\core\common\types\providers.ts
//



import type { CoreItem } from '../../types.ts';

/**
 * 数据提供者接口 (ItemProvider Interface)。
 * 内核依赖此接口来获取和更新数据。
 * 应用层必须提供一个实现了此接口的对象，并将其注入到内核中。
 */
export interface ItemProvider {
    /**
     * 根据ID异步获取一个项目。
     * @param id - 要获取的项目的唯一ID。
     * @returns 返回一个Promise，解析为CoreItem对象或在找不到时解析为null。
     */
    getItem(id: string): Promise<CoreItem | null>;

    /**
     * 根据ID和新内容更新一个项目。
     * @param id - 要更新的项目的唯一ID。
     * @param content - 项目的新内容。
     * @returns 返回一个Promise，在更新完成后解析。可用于处理保存失败的情况。
     */
    updateItem(id: string, content: string): Promise<void>;
}

// =
// 文件: ..\src\core\constants.ts
//

export const CoreEvent = {
    STATE_CHANGED: 'core:state-changed',
    PANE_INITIALIZED: 'core:pane.initialized',
    PANE_ACTIVATED: 'core:pane.activated',
    PANE_SPLITTED: 'core:pane.splitted',
    PANE_CLOSED: 'core:pane.closed',
    TAB_OPENED: 'core:tab.opened',
    TAB_CLOSED: 'core:tab.closed',
    TAB_ACTIVATED: 'core:tab.activated',
    TAB_STATE_CHANGED: 'core:tab.stateChanged',
} as const;

export const CoreContext = {
    PANE_IS_SPLIT: 'pane.isSplit',
} as const;

export const CoreCommand = {
    PANE_SPLIT_HORIZONTAL: 'core.pane.split-horizontal',
    PANE_SPLIT_VERTICAL: 'core.pane.split-vertical',
    PANE_CLOSE: 'core.pane.close',
    SAVE_TAB: 'core.saveTab',
    COMMAND_PALETTE_SHOW: 'core.commandPalette.show',
} as const;

// =
// 文件: ..\src\core\editor\composables\useEditableView.ts
//



import { onMounted, onUnmounted, watch, ref, computed, type Ref } from 'vue';
import { activeEditorService } from '@core/tabs/service/ActiveEditorService.ts';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';
import { useNotificationStore } from '@core/layout/stores/notificationStore.ts';
import type { CoreItem, Tab } from '@core/types.ts';

interface UseEditableViewOptions {
    tab: Ref<Tab>;
    coreItem: Ref<CoreItem | null>;
    content: Ref<string>;
}

export function useEditableView({ tab, coreItem, content }: UseEditableViewOptions) {
    const tabStore = useTabStore();
    const notificationStore = useNotificationStore();
    const initialContent = ref('');

    const isDirty = computed(() => initialContent.value !== content.value);

    const initializeContent = () => {
        const newInitialContent = coreItem.value?.metadata?.content || '';
        initialContent.value = newInitialContent;
        if (content.value !== newInitialContent) {
            content.value = newInitialContent;
        }
    };

    onMounted(() => {
        initializeContent();

        activeEditorService.register(tab.value.id, {
            getContent: () => content.value,
            setContent: (newContent: string) => {
                content.value = newContent;
                initialContent.value = newContent;
            },
        });
    });

    onUnmounted(() => {
        activeEditorService.unregister(tab.value.id);
    });

    watch(isDirty, (newValue) => {
        tabStore.updateTabState(tab.value.id, { isDirty: newValue });
    });

    watch(() => coreItem.value?.metadata?.content, (newContent) => {
        if (newContent !== undefined && content.value !== newContent) {
            if (isDirty.value) {
                notificationStore.add(
                    `'${tab.value.title}' has been modified on disk. Your version has unsaved changes.`,
                    'warning',
                    0
                );
            } else {
                initializeContent();
            }
        }
    });

    return {
        isDirty,
    };
}

// =
// 文件: ..\src\core\layout\components\CoreLayout.vue
//

<template>
  <div class="core-layout-container">
    <div class="workspace-area">
      <div class="activity-bar-area">
        <slot name="activity-bar"></slot>
      </div>
      <div v-if="isSidebarVisible" class="sidebar-area" :style="{ width: `${sidebarWidth}px` }">
        <slot name="sidebar">
          <SidebarPanel />
        </slot>
      </div>
      <div v-if="isSidebarVisible" class="sidebar-resizer" @mousedown="startResizeWrapper"></div>
      <div class="main-content-area">
        <MainPane />
      </div>
    </div>

    <!-- Status bar at the bottom -->
    <div class="status-bar-area">
      <slot name="status-bar"></slot>
    </div>

    <div class="global-components-area">
      <slot name="global">
        <NotificationCenter />
        <CommandPalette />
        <ContextMenu />
      </slot>
    </div>
  </div>
</template>
<script setup lang="ts">
import { onMounted, onUnmounted } from 'vue';
import { useLayoutStore } from '@core/layout/stores/layoutStore.ts';
import { storeToRefs } from 'pinia';
import type { EditorKernel } from '@core/services/EditorKernel.ts';
import { useResizable } from '@core/common/composables/useResizable.ts';

import MainPane from '../../panes/components/MainPane.vue';
import SidebarPanel from './SidebarPanel.vue';
import NotificationCenter from './NotificationCenter.vue';
import CommandPalette from '../../palette/components/CommandPalette.vue';
import ContextMenu from '../../panes/components/ContextMenu.vue';

const props = defineProps<{
  kernel: EditorKernel;
}>();

const layoutStore = useLayoutStore();
const { isSidebarVisible, sidebarWidth } = storeToRefs(layoutStore);

onMounted(() => {
  props.kernel.startup();
});

onUnmounted(() => {
  props.kernel.shutdown();
});

let initialWidth = 0;
const { startResize } = useResizable({
  onResize: ({ dx }) => {
    layoutStore.setSidebarWidth(initialWidth + dx);
  },
});

const startResizeWrapper = (event: MouseEvent) => {
  initialWidth = sidebarWidth.value;
  startResize(event);
};
</script>
<style scoped>
.core-layout-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: #FFFFFF;
}

.workspace-area {
  flex-grow: 1;
  display: flex;
  flex-direction: row;
  min-height: 0;
}

.activity-bar-area, .sidebar-area {
  flex-shrink: 0;
  height: 100%;
}

.activity-bar-area {
  z-index: 20;
}

.sidebar-area {
  z-index: 10;
  border-right: 1px solid #E5E7EB;
}

.sidebar-resizer {
  width: 5px;
  background-color: transparent;
  cursor: col-resize;
  flex-shrink: 0;
  position: relative;
  z-index: 15;
}
.sidebar-resizer:hover {
  background-color: #3B82F6;
}

.main-content-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  position: relative;
}

.status-bar-area {
  position: relative;
  z-index: 20;
  flex-shrink: 0;
  height: 28px;
  border-top: 1px solid #E5E7EB;
}

.global-components-area > :deep(*) {
  pointer-events: all;
}
.global-components-area {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 9999;
  pointer-events: none;
}
</style>

// =
// 文件: ..\src\core\layout\components\NotificationCenter.vue
//

<template>
  <div class="notification-center">
    <transition-group name="notification-fade" tag="div">
      <div
          v-for="notification in notifications"
          :key="notification.id"
          :class="['notification-toast', `notification-${notification.type}`]"
          @click="notificationStore.remove(notification.id)"
      >
        <span class="message">{{ notification.message }}</span>
      </div>
    </transition-group>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useNotificationStore } from '@core/layout/stores/notificationStore.ts';

const notificationStore = useNotificationStore();
const notifications = computed(() => notificationStore.notifications);
</script>

<style scoped>
.notification-center {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.5rem;
  pointer-events: all; /* Re-enable pointer events for toasts */
}
.notification-toast {
  padding: 0.75rem 1.25rem;
  border-radius: 0.5rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  cursor: pointer;
  color: white;
  font-weight: 500;
  transition: all 0.3s ease;
}
.notification-info { background-color: #3B82F6; }
.notification-success { background-color: #16A34A; }
.notification-warning { background-color: #F59E0B; }
.notification-error { background-color: #DC2626; }

.notification-fade-enter-active,
.notification-fade-leave-active {
  transition: opacity 0.5s, transform 0.5s;
}
.notification-fade-enter-from,
.notification-fade-leave-to {
  opacity: 0;
  transform: translateX(30px);
}
</style>

// =
// 文件: ..\src\core\layout\components\SidebarPanel.vue
//


<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <!-- The title can be passed down via a slot or a prop -->
      <slot name="header">
        <h3 class="title">Sidebar</h3>
      </slot>
    </div>
    <div class="content">
      <slot>
        <!-- Default content if no content is provided by the app -->
        <div class="p-4 text-sm text-gray-500">
          This is the default sidebar content.
        </div>
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}
.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F0F0F0;
  flex-shrink: 0;
}
.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}
.content {
  flex-grow: 1;
  position: relative;
  overflow: auto;
}
</style>

// =
// 文件: ..\src\core\layout\stores\layoutStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { configService } from '@core/common/services/ConfigService.ts';

export const useLayoutStore = defineStore('core-layout', () => {
    const isSidebarVisible = ref(true);
    const sidebarWidth = ref(configService.get('layout.sidebar.defaultWidth', 320));

    function toggleSidebar() {
        isSidebarVisible.value = !isSidebarVisible.value;
    }

    function setSidebarWidth(width: number) {
        const min = configService.get('layout.sidebar.minWidth', 240);
        const max = configService.get('layout.sidebar.maxWidth', 600);
        const newWidth = Math.max(min, Math.min(width, max));
        if (sidebarWidth.value !== newWidth) {
            sidebarWidth.value = newWidth;
        }
    }

    function dehydrate() {
        return {
            isSidebarVisible: isSidebarVisible.value,
            sidebarWidth: sidebarWidth.value,
        };
    }

    function hydrate(state: { isSidebarVisible?: boolean; sidebarWidth?: number; }) {
        if (typeof state.isSidebarVisible === 'boolean') {
            isSidebarVisible.value = state.isSidebarVisible;
        }
        if (typeof state.sidebarWidth === 'number') {
            setSidebarWidth(state.sidebarWidth);
        }
    }

    return {
        isSidebarVisible,
        sidebarWidth,
        toggleSidebar,
        setSidebarWidth,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\layout\stores\notificationStore.ts
//

// 文件: src/core/stores/notificationStore.ts
// 描述: 管理全局通知（Toast）的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';

export type NotificationType = 'info' | 'success' | 'warning' | 'error';

export interface Notification {
    id: number;
    message: string;
    type: NotificationType;
    duration?: number;
}

let nextId = 0;

export const useNotificationStore = defineStore('core-notification', () => {
    const notifications = ref<Notification[]>([]);

    /**
     * 添加一条新通知。
     * @param message - 通知内容。
     * @param type - 通知类型。
     * @param duration - （可选）显示时长（毫秒）。默认为3000ms。如果提供一个小于或等于0的值，通知将不会自动关闭，需要用户手动关闭。
     */
    function add(message: string, type: NotificationType = 'info', duration: number = 3000) {
        const id = nextId++;
        notifications.value.push({ id, message, type, duration });

        if (duration > 0) {
            setTimeout(() => {
                remove(id);
            }, duration);
        }
    }

    /**
     * 移除一条通知。
     * @param id - 要移除的通知的ID。
     */
    function remove(id: number) {
        const index = notifications.value.findIndex(n => n.id === id);
        if (index !== -1) {
            notifications.value.splice(index, 1);
        }
    }

    return {
        notifications,
        add,
        remove,
    };
});

// =
// 文件: ..\src\core\palette\components\CommandPalette.vue
//

<template>
  <div v-if="isVisible" class="palette-overlay" @click="store.hide">
    <div class="palette-container" @click.stop>
      <div class="search-wrapper">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            ref="searchInput"
            v-model="searchQuery"
            type="text"
            placeholder="Type a command"
            class="search-input"
            @keydown.down.prevent="store.navigate(1)"
            @keydown.up.prevent="store.navigate(-1)"
            @keydown.enter.prevent="commandPaletteService.executeSelected()"
        />
      </div>
      <ul class="results-list">
        <li
            v-for="(command, index) in filteredCommands"
            :key="command.id"
            :class="{ 'selected': index === selectedIndex }"
            @click="commandPaletteService.executeCommand(command.id)"
            @mouseenter="store.setSelectedIndex(index)"
        >
          <i v-if="command.icon" :class="[command.icon, 'command-icon']"></i>
          <span>{{ command.label }}</span>
        </li>
        <li v-if="filteredCommands.length === 0" class="no-results">
          No matching commands
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, nextTick, onMounted, onUnmounted } from 'vue';
import { useCommandPaletteStore } from '@core/palette/stores/commandPaletteStore.ts';
import { commandPaletteService } from '@core/palette/services/CommandPaletteService.ts';
import { storeToRefs } from 'pinia';

const store = useCommandPaletteStore();
const { isVisible, searchQuery, filteredCommands, selectedIndex } = storeToRefs(store);

const searchInput = ref<HTMLInputElement | null>(null);

watch(isVisible, (newValue) => {
  if (newValue) {
    nextTick(() => {
      searchInput.value?.focus();
    });
  }
});

const handleGlobalKey = (e: KeyboardEvent) => {
  if (e.key === 'Escape' && isVisible.value) {
    store.hide();
  }
}

onMounted(() => window.addEventListener('keydown', handleGlobalKey));
onUnmounted(() => window.removeEventListener('keydown', handleGlobalKey));
</script>

<style scoped>
.palette-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  display: flex;
  justify-content: center;
  padding-top: 15vh;
}
.palette-container {
  width: 100%;
  max-width: 600px;
  background-color: white;
  border-radius: 0.75rem;
  box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: min-content;
  max-height: 70vh;
}
.search-wrapper {
  position: relative;
  border-bottom: 1px solid #e5e7eb;
  padding: 0.75rem;
}
.search-icon {
  position: absolute;
  left: 1.5rem;
  top: 50%;
  transform: translateY(-50%);
  color: #9ca3af;
}
.search-input {
  width: 100%;
  font-size: 1rem;
  padding: 0.75rem 1rem 0.75rem 2.5rem;
  border: none;
  outline: none;
  background: transparent;
}
.results-list {
  overflow-y: auto;
  padding: 0.5rem;
}
.results-list li {
  padding: 0.75rem 1rem;
  border-radius: 0.375rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}
.results-list li.selected {
  background-color: #3B82F6;
  color: white;
}
.no-results {
  color: #9ca3af;
  text-align: center;
  padding: 2rem;
  cursor: default;
}
</style>

// =
// 文件: ..\src\core\palette\features\palette.commands.ts
//

import type { CommandService } from '@core/services/CommandService.ts';
import { commandPaletteService } from '@core/palette/services/CommandPaletteService.ts';
import { CoreCommand } from '@core/constants.ts';

export function registerPaletteCommands(commandService: CommandService) {
    commandService.register({
        id: CoreCommand.COMMAND_PALETTE_SHOW,
        label: 'View: Show Command Palette',
        execute: () => {
            commandPaletteService.show();
        },
    });
}

// =
// 文件: ..\src\core\palette\features\palette.keybindings.ts
//

import type { KeybindingService } from '@core/common/services/KeybindingService.ts';
import { CoreCommand } from '@core/constants.ts';

export function registerPaletteKeybindings(keybindingService: KeybindingService) {
    keybindingService.register({
        key: 'ctrl+shift+p',
        commandId: CoreCommand.COMMAND_PALETTE_SHOW,
    });
}

// =
// 文件: ..\src\core\palette\features\palette.module.ts
//

import { commandService } from "@core/services/CommandService.ts";
import { keybindingService } from "@core/common/services/KeybindingService.ts";
import { registerPaletteCommands } from "./palette.commands.ts";
import { registerPaletteKeybindings } from "./palette.keybindings.ts";

export class CommandPaletteModule {
    public install(): void {
        registerPaletteCommands(commandService);
        registerPaletteKeybindings(keybindingService);
    }
}

// =
// 文件: ..\src\core\palette\services\CommandPaletteService.ts
//

import { useCommandPaletteStore, type PaletteCommand } from '@core/palette/stores/commandPaletteStore.ts';
import { commandService } from '@core/services/CommandService.ts';

class CommandPaletteService {
    public show(): void {
        const commandPaletteStore = useCommandPaletteStore();

        const availableCommands: PaletteCommand[] = [];
        for (const command of commandService.getAllCommands()) {
            if (commandService.canExecute(command.id)) {
                const label = typeof command.label === 'function' ? command.label({}) : command.label;
                availableCommands.push({
                    id: command.id,
                    label: label,
                    icon: command.icon
                });
            }
        }

        commandPaletteStore._setCommands(availableCommands);
        commandPaletteStore.show();
    }

    public executeSelected(): void {
        const store = useCommandPaletteStore();
        const command = store.filteredCommands[store.selectedIndex];
        if (command) {
            this.executeCommand(command.id);
        }
    }

    public executeCommand(commandId: string): void {
        const store = useCommandPaletteStore();
        commandService.execute(commandId);
        store.hide();
    }
}

export const commandPaletteService = new CommandPaletteService();

// =
// 文件: ..\src\core\palette\stores\commandPaletteStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export interface PaletteCommand {
    id: string;
    label: string;
    icon?: string;
}

export const useCommandPaletteStore = defineStore('core-command-palette', () => {
    const isVisible = ref(false);
    const searchQuery = ref('');
    const allCommands = ref<PaletteCommand[]>([]);
    const selectedIndex = ref(0);

    const filteredCommands = computed(() => {
        if (!searchQuery.value) {
            return allCommands.value;
        }
        const query = searchQuery.value.toLowerCase();
        return allCommands.value.filter(cmd =>
            cmd.label.toLowerCase().includes(query)
        );
    });

    function show() {
        isVisible.value = true;
    }

    function hide() {
        isVisible.value = false;
        searchQuery.value = '';
        allCommands.value = [];
    }

    function _setCommands(commands: PaletteCommand[]) {
        allCommands.value = commands;
        setSelectedIndex(0);
        searchQuery.value = '';
    }

    function setSelectedIndex(index: number) {
        if (index >= 0 && index < filteredCommands.value.length) {
            selectedIndex.value = index;
        }
    }

    function navigate(direction: 1 | -1) {
        const newIndex = selectedIndex.value + direction;
        setSelectedIndex(newIndex);
    }

    return {
        isVisible,
        searchQuery,
        selectedIndex,
        filteredCommands,
        allCommands,
        show,
        hide,
        _setCommands,
        navigate,
        setSelectedIndex,
    };
});

// =
// 文件: ..\src\core\panes\components\ContextMenu.vue
//

<template>
  <div
      v-if="isVisible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
      @contextmenu.prevent
  >
    <ul class="menu-list">
      <template v-for="item in items" :key="item.id">
        <li v-if="item.isDivider" class="menu-divider"></li>
        <li
            v-else
            :class="['menu-item', { 'disabled': item.isDisabled }]"
            @click.prevent="contextMenuService.execute(item)"
        >
          <i v-if="item.icon" :class="[item.icon, 'menu-icon']"></i>
          <span>{{ item.label }}</span>
        </li>
      </template>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { onMounted, onBeforeUnmount } from 'vue';
import { storeToRefs } from 'pinia';
import { useContextMenuStore } from '@core/panes/stores/contextMenuStore.ts';
import { contextMenuService } from '@core/panes/service/ContextMenuService.ts';

const contextMenuStore = useContextMenuStore();
const { isVisible, position, items } = storeToRefs(contextMenuStore);

const handleClickOutside = () => contextMenuStore.hideMenu();

onMounted(() => window.addEventListener('click', handleClickOutside));
onBeforeUnmount(() => window.removeEventListener('click', handleClickOutside));
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
.menu-list { list-style: none; padding: 0; margin: 0; }
.menu-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  color: #374151;
  cursor: pointer;
  user-select: none;
}
.menu-item:not(.disabled):hover { background-color: #f3f4f6; }
.menu-item.disabled { color: #9ca3af; cursor: not-allowed; }
.menu-icon { width: 1rem; text-align: center; color: #6B7280; }
.menu-item:not(.disabled):hover .menu-icon { color: #374151; }
.menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\core\panes\components\MainPane.vue
//

<template>
  <div class="main-pane-container">
    <PaneNodeRenderer v-if="root" :node="root" />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import PaneNodeRenderer from './PaneNodeRenderer.vue';

const paneStore = usePaneStore();
const root = computed(() => paneStore.root);
</script>

<style scoped>
.main-pane-container {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  background-color: #F3F4F6;
}
</style>

// =
// 文件: ..\src\core\panes\components\PaneInstance.vue
//

<template>
  <div class="pane-instance-container" @click="paneManagementService.setActivePane(pane.id)">
    <TabBar :tabs="tabsForPane" :active-tab-id="pane.activeTabId" :pane-id="pane.id" :is-active-pane="isActive" />
    <div class="content-area">
      <div v-if="isLoading" class="loading-screen">
        <p>Loading...</p>
      </div>
      <ErrorDisplay
          v-else-if="loadingError"
          :message="loadingError"
          @reload="reloadContent"
      />
      <template v-else-if="activeCoreItem && activeTab">
        <component
            :is="resolvedView"
            :key="activeTab.id"
            :tab="activeTab"
            :item="activeCoreItem"
        />
      </template>
      <WelcomeScreen v-else />
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, toRef, type PropType } from 'vue';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';
import { usePaneContent } from '@core/panes/composables/usePaneContent.ts';
import { paneManagementService } from '@core/panes/service/PaneManagementService.ts';
import type { LeafPaneNode, Tab } from '@core/types.ts';
import TabBar from '../../tabs/components/TabBar.vue';
import WelcomeScreen from '../../common/components/WelcomeScreen.vue';
import ErrorDisplay from '../../common/components/ErrorDisplay.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<LeafPaneNode>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  },
});

const tabStore = useTabStore();

const {
  activeTab,
  activeCoreItem,
  isLoading,
  loadingError,
  resolvedView,
  reloadContent,
} = usePaneContent(toRef(props, 'pane'));

const tabsForPane = computed((): Tab[] => {
  return tabStore.getTabsForPane(props.pane.id);
});
</script>
<style scoped>
.pane-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  border-left: 1px solid #E5E7EB;
  flex: 1;
  min-width: 0;
}
.pane-instance-container:first-child {
  border-left: none;
}
.content-area {
  flex-grow: 1;
  overflow: auto;
  position: relative;
}
.loading-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #9CA3AF;
  user-select: none;
}
</style>

// =
// 文件: ..\src\core\panes\components\PaneNodeRenderer.vue
//

<template>
  <template v-if="node">
    <PaneInstance
        v-if="node.type === 'leaf'"
        :pane="node"
        :is-active="node.id === paneStore.activePaneId"
        class="pane-instance"
    />
    <div
        v-else-if="node.type === 'split'"
        class="split-pane-container"
        :style="{ flexDirection: node.direction === 'horizontal' ? 'row' : 'column' }"
    >
      <template v-for="(child, index) in node.children" :key="child.id">
        <PaneNodeRenderer
            :node="child"
            :style="{ flexBasis: `${node.sizes[index]}%` }"
            class="pane-node-renderer"
        />
        <div
            v-if="index < node.children.length - 1"
            class="pane-resizer"
            :class="node.direction"
            @mousedown.prevent="startResize($event, index)"
        ></div>
      </template>
    </div>
  </template>
</template>

<script setup lang="ts">
import { type PropType, toRef } from 'vue';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { usePaneResizer } from '@core/panes/composables/usePaneResizer.ts';
import type { PaneNode } from '@core/types.ts';
import PaneInstance from './PaneInstance.vue';

const props = defineProps({
  node: {
    type: Object as PropType<PaneNode>,
    required: true,
  },
});

const paneStore = usePaneStore();

const { startResize } = usePaneResizer(
    toRef(props, 'node')
);

</script>

<style scoped>
.split-pane-container {
  display: flex;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.pane-node-renderer {
  min-width: 0;
  min-height: 0;
  overflow: hidden;
}
.pane-resizer {
  flex-shrink: 0;
  background-color: transparent;
  transition: background-color 0.2s ease;
  z-index: 5;
  position: relative;
}
.pane-resizer.horizontal {
  width: 5px;
  cursor: col-resize;
}
.pane-resizer.vertical {
  height: 5px;
  cursor: row-resize;
}
.pane-resizer:hover {
  background-color: #3B82F6;
}
.pane-resizer.horizontal::before {
  content: ''; position: absolute; left: 2px; top: 0; width: 1px;
  height: 100%; background-color: #E5E7EB;
}
.pane-resizer.vertical::before {
  content: ''; position: absolute; top: 2px; left: 0; height: 1px;
  width: 100%; background-color: #E5E7EB;
}
.pane-resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\core\panes\composables\usePaneContent.ts
//


import { ref, computed, watch, type Ref } from 'vue';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';
import { viewRegistry } from '@core/common/services/ViewRegistry.ts';
import { tabManagementService } from '@core/tabs/service/TabManagementService.ts';
import type { LeafPaneNode, CoreItem, Tab } from '@core/types.ts';

export function usePaneContent(pane: Ref<LeafPaneNode>) {
    const tabStore = useTabStore();

    const activeCoreItem = ref<CoreItem | null>(null);
    const isLoading = ref(false);
    const loadingError = ref<string | null>(null);

    const activeTab = computed((): Tab | undefined => {
        return pane.value.activeTabId ? tabStore.getTabById(pane.value.activeTabId) : undefined;
    });

    const resolvedView = computed(() => {
        if (activeCoreItem.value?.viewType) {
            return viewRegistry.resolve(activeCoreItem.value.viewType);
        }
        return null;
    });

    const loadContentForTab = async (tabId: string | null) => {
        if (!tabId) {
            activeCoreItem.value = null;
            isLoading.value = false;
            loadingError.value = null;
            return;
        }

        isLoading.value = true;
        loadingError.value = null;
        activeCoreItem.value = null;

        try {
            const item = await tabManagementService.loadCoreItemForTab(tabId);
            if (pane.value.activeTabId === tabId) {
                activeCoreItem.value = item;
                if (!item) {
                    loadingError.value = "The associated item could not be found. It might have been deleted.";
                }
            }
        } catch (error: any) {
            console.error(`Failed to load content for tab ${tabId}`, error);
            if (pane.value.activeTabId === tabId) {
                loadingError.value = error.message || 'An unknown error occurred.';
            }
        } finally {
            if (pane.value.activeTabId === tabId) {
                isLoading.value = false;
            }
        }
    };

    const reloadContent = () => {
        loadContentForTab(pane.value.activeTabId);
    };

    watch(
        () => pane.value.activeTabId,
        (newTabId) => {
            loadContentForTab(newTabId);
        },
        { immediate: true }
    );

    return {
        activeTab,
        activeCoreItem,
        isLoading,
        loadingError,
        resolvedView,
        reloadContent,
    };
}

// =
// 文件: ..\src\core\panes\composables\usePaneResizer.ts
//

import { type Ref } from 'vue';
import { useResizable } from '@core/common/composables/useResizable.ts';
import { paneManagementService } from '@core/panes/service/PaneManagementService.ts';
import { configService } from '@core/common/services/ConfigService.ts';
import type { SplitPaneNode, PaneNode } from '@core/types.ts';

export function usePaneResizer(nodeRef: Ref<PaneNode | undefined>) {

    let initialSizes: number[] = [];
    let totalSize = 0;
    let activeIndex = 0;
    let container: HTMLElement | null = null;
    let firstElement: HTMLElement | null = null;
    let secondElement: HTMLElement | null = null;

    const { startResize: start } = useResizable({
        cursor: (nodeRef.value as SplitPaneNode)?.direction === 'horizontal' ? 'col-resize' : 'row-resize',
        onResize: ({ dx, dy }) => {
            const node = nodeRef.value;
            if (!node || node.type !== 'split') return;

            const delta = node.direction === 'horizontal' ? dx : dy;
            const deltaPercent = (delta / totalSize) * 100;

            const newSizes = [...initialSizes];
            newSizes[activeIndex] += deltaPercent;
            newSizes[activeIndex + 1] -= deltaPercent;

            const minSize = configService.get('pane.resizer.minSize', 10);
            if (newSizes[activeIndex] < minSize || newSizes[activeIndex + 1] < minSize) {
                return;
            }

            paneManagementService.updatePaneNodeSize(node.id, newSizes);
        }
    });

    const startResize = (event: MouseEvent, index: number) => {
        const node = nodeRef.value;
        if (!node || node.type !== 'split') return;

        container = (event.currentTarget as HTMLElement).parentElement;
        if (!container) return;

        firstElement = container.children[index * 2] as HTMLElement;
        secondElement = container.children[index * 2 + 2] as HTMLElement;
        if (!firstElement || !secondElement) return;

        activeIndex = index;
        initialSizes = [...node.sizes];
        totalSize = node.direction === 'horizontal'
            ? firstElement.offsetWidth + secondElement.offsetWidth
            : firstElement.offsetHeight + secondElement.offsetHeight;

        start(event);
    };

    return {
        startResize,
    };
}

// =
// 文件: ..\src\core\panes\features\pane.commands.ts
//

import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { tabManagementService } from '@core/tabs/service/TabManagementService.ts';
import { paneManagementService } from '@core/panes/service/PaneManagementService.ts';
import type { CommandService } from '@core/services/CommandService.ts';
import { CoreCommand, CoreContext } from '@core/constants.ts';

export function registerPaneCommands(commandService: CommandService) {
    const paneStore = usePaneStore();

    commandService.register({
        id: CoreCommand.PANE_SPLIT_HORIZONTAL,
        label: 'Pane: Split Horizontal',
        icon: 'fa-solid fa-columns',
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (paneId) paneManagementService.splitPane(paneId, 'horizontal');
        },
    });

    commandService.register({
        id: CoreCommand.PANE_SPLIT_VERTICAL,
        label: 'Pane: Split Vertical',
        icon: 'fa-solid fa-grip-lines',
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (paneId) paneManagementService.splitPane(paneId, 'vertical');
        },
    });

    commandService.register({
        id: CoreCommand.PANE_CLOSE,
        label: 'Pane: Close Pane',
        icon: 'fa-solid fa-xmark',
        when: CoreContext.PANE_IS_SPLIT,
        execute: (context) => {
            const paneId = context?.paneId || paneStore.activePaneId;
            if (!paneId) return;

            const orphanedTabIds = paneManagementService.closePane(paneId);

            if (orphanedTabIds && orphanedTabIds.length > 0) {
                const targetPaneId = paneStore.activePaneId;
                if (targetPaneId) {
                    orphanedTabIds.forEach(tabId => {
                        paneManagementService.addTabToPane(tabId, targetPaneId);
                    });
                    paneManagementService.setActiveTab(targetPaneId, orphanedTabIds[0]);
                } else {
                    // Edge case: No panes left. Close the tabs.
                    orphanedTabIds.forEach(tabId => tabManagementService.closeTab(tabId));
                }
            }
        },
    });
}

// =
// 文件: ..\src\core\panes\features\pane.contexts.ts
//

import { watch } from 'vue';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { contextService } from '@core/common/services/ContextService.ts';
import { CoreContext } from '@core/constants.ts';

export function initializePaneContexts() {
    const paneStore = usePaneStore();

    const updateContext = () => {
        const isSplit = (paneStore.root?.type ?? 'leaf') === 'split';
        contextService.set(CoreContext.PANE_IS_SPLIT, isSplit);
    };

    watch(() => paneStore.root, updateContext, { immediate: true, deep: true });
}

// =
// 文件: ..\src\core\panes\features\pane.module.ts
//

import { commandService } from "@core/services/CommandService.ts";
import { registerPaneCommands } from "./pane.commands.ts";
import { initializePaneContexts } from "./pane.contexts.ts";

export class PaneManagementModule {
    public install(): void {
        registerPaneCommands(commandService);
        initializePaneContexts();
    }
}

// =
// 文件: ..\src\core\panes\service\ContextMenuService.ts
//

import type { ContextMenuItem, CommandContext, Command, ProcessedMenuItem } from '@core/types.ts';
import { useContextMenuStore } from '@core/panes/stores/contextMenuStore.ts';
import { commandService } from '../../services/CommandService.ts';

type ContextMenuProvider = (context: CommandContext) => ContextMenuItem[];

class ContextMenuService {
    private providers: Map<string, ContextMenuProvider[]> = new Map();

    public registerProvider(contextType: string, provider: ContextMenuProvider): void {
        if (!this.providers.has(contextType)) {
            this.providers.set(contextType, []);
        }
        this.providers.get(contextType)!.push(provider);
    }

    private getItemsForContext(contextType: string, context: CommandContext): ContextMenuItem[] {
        const providers = this.providers.get(contextType) || [];
        let allItems: ContextMenuItem[] = [];

        providers.forEach((provider, index) => {
            const items = provider(context);
            if (items.length > 0) {
                if (index > 0 && allItems.length > 0 && !allItems[allItems.length - 1].isDivider) {
                    allItems.push({ commandId: `divider-${index}`, isDivider: true });
                }
                allItems = allItems.concat(items);
            }
        });

        return allItems;
    }

    public show(event: MouseEvent, contextType: string, context: CommandContext): void {
        event.preventDefault();
        event.stopPropagation();

        const contextMenuStore = useContextMenuStore();
        const rawItems = this.getItemsForContext(contextType, context);

        if (rawItems.length === 0) {
            contextMenuStore.hideMenu();
            return;
        }

        const processedItems = this.processItems(rawItems);

        if (processedItems.length > 0) {
            contextMenuStore.showMenu(event, processedItems);
        } else {
            contextMenuStore.hideMenu();
        }
    }

    public execute(item: ProcessedMenuItem): void {
        if (!item.isDisabled) {
            commandService.execute(item.command.id, item.context);
            useContextMenuStore().hideMenu();
        }
    }

    private processItems(items: ContextMenuItem[]): ProcessedMenuItem[] {
        return items.map((item, index) => {
            if (item.isDivider) {
                return { id: `d-${index}`, isDivider: true, isDisabled: true, label: '', command: {} as Command, context: undefined };
            }
            const command = commandService.find(item.commandId);
            const isDisabled = !command || !commandService.canExecute(item.commandId, item.context);
            const label = command
                ? (typeof command.label === 'function' ? command.label({ ...item.context }) : command.label)
                : 'Unknown Command';

            return {
                id: `${item.commandId}-${index}`,
                isDivider: false,
                isDisabled,
                label,
                icon: command?.icon,
                command: command!,
                context: item.context,
            };
        });
    }
}

export const contextMenuService = new ContextMenuService();

// =
// 文件: ..\src\core\panes\service\PaneManagementService.ts
//

import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { useNotificationStore } from '@core/layout/stores/notificationStore.ts';
import { paneTreeService } from '@core/panes/service/PaneTreeService.ts';
import { eventBus } from '@core/common/services/EventBusService.ts';
import type { PaneNode } from '@core/types.ts';
import { CoreEvent } from '@core/constants.ts';

class PaneManagementService {
    public initializePanes() {
        const paneStore = usePaneStore();
        if (!paneStore.root) {
            const initialPaneId = `pane-${Date.now()}`;
            const initialRoot: PaneNode = { id: initialPaneId, type: 'leaf', tabIds: [], activeTabId: null };
            paneStore._setRoot(initialRoot);
            this.setActivePane(initialPaneId);
            eventBus.emit(CoreEvent.PANE_INITIALIZED, { initialPaneId });
        }
    }

    public setActivePane(paneId: string | null) {
        const paneStore = usePaneStore();
        if (paneId && paneStore.activePaneId !== paneId) {
            paneStore._setActivePaneId(paneId);
            eventBus.emit(CoreEvent.PANE_ACTIVATED, { paneId });
        }
    }

    public setActiveTab(paneId: string, tabId: string | null) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.findNodeAndParent(paneStore.root, paneId);
        if (result && result.node.type === 'leaf' && result.node.activeTabId !== tabId) {
            result.node.activeTabId = tabId;
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public addTabToPane(tabId: string, paneId: string) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.findNodeAndParent(paneStore.root, paneId);
        if (result && result.node.type === 'leaf' && !result.node.tabIds.includes(tabId)) {
            result.node.tabIds.push(tabId);
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public removeTabFromPane(tabId: string) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const leaf = paneStore.findLeafContainingTab(tabId);
        if (leaf) {
            const index = leaf.tabIds.indexOf(tabId);
            if (index > -1) {
                leaf.tabIds.splice(index, 1);
                if (leaf.activeTabId === tabId) {
                    const newActiveIndex = Math.max(0, index - 1);
                    leaf.activeTabId = leaf.tabIds[newActiveIndex] || null;
                }
                eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
            }
        }
    }

    public updatePaneNodeSize(splitNodeId: string, newSizes: number[]) {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const findResult = paneTreeService.findNodeAndParent(paneStore.root, splitNodeId);
        if (findResult && findResult.node.type === 'split') {
            findResult.node.sizes = newSizes;
            eventBus.emit(CoreEvent.STATE_CHANGED, { store: 'pane' });
        }
    }

    public splitPane(sourcePaneId: string, direction: 'horizontal' | 'vertical' = 'horizontal') {
        const paneStore = usePaneStore();
        if (!paneStore.root) return;
        const result = paneTreeService.splitPane(paneStore.root, sourcePaneId, direction);
        if (result) {
            paneStore._setRoot(result.newRoot);
            this.setActivePane(result.newPaneId);
            eventBus.emit(CoreEvent.PANE_SPLITTED, { sourcePaneId, newPaneId: result.newPaneId });
        }
    }

    public closePane(paneId: string): string[] | null {
        const paneStore = usePaneStore();
        if (!paneStore.root) return null;
        const result = paneTreeService.closePane(paneStore.root, paneId);
        if (result) {
            paneStore._setRoot(result.newRoot);
            if (paneStore.activePaneId === paneId) {
                const firstLeaf = paneTreeService.findLeaf(paneStore.root);
                this.setActivePane(firstLeaf ? firstLeaf.id : null);
            }
            eventBus.emit(CoreEvent.PANE_CLOSED, { closedPaneId: paneId });
            return result.closedPane.tabIds;
        } else {
            useNotificationStore().add('Cannot close the last pane.', 'warning');
            return null;
        }
    }
}

export const paneManagementService = new PaneManagementService();

// =
// 文件: ..\src\core\panes\service\PaneTreeService.ts
//

// 文件: src/core/panes/service/PaneTreeService.ts
// ---------------------------------------------
// 描述: 提供操作和查询窗格树（PaneNode）的底层静态方法。此版本修复了 closePane 方法中的一个布局尺寸计算 Bug。

import type { PaneNode, LeafPaneNode, SplitPaneNode } from '@core/panes/types/pane.ts';

class PaneTreeService {

    public findNodeAndParent(
        startNode: PaneNode,
        id: string,
        parent: SplitPaneNode | null = null
    ): { node: PaneNode; parent: SplitPaneNode | null } | null {
        if (startNode.id === id) return { node: startNode, parent };
        if (startNode.type === 'split') {
            for (const child of startNode.children) {
                const found = this.findNodeAndParent(child, id, startNode);
                if (found) return found;
            }
        }
        return null;
    }

    public findLeaf(node: PaneNode): LeafPaneNode | null {
        if (node.type === 'leaf') return node;
        for(const child of node.children) {
            const leaf = this.findLeaf(child);
            if (leaf) return leaf;
        }
        return null;
    }

    public findLeafContainingTab(node: PaneNode, tabId: string): LeafPaneNode | null {
        if (node.type === 'leaf') {
            return node.tabIds.includes(tabId) ? node : null;
        }
        for (const child of node.children) {
            const found = this.findLeafContainingTab(child, tabId);
            if (found) return found;
        }
        return null;
    }

    public splitPane(
        root: PaneNode,
        sourcePaneId: string,
        direction: 'horizontal' | 'vertical'
    ): { newRoot: PaneNode; newPaneId: string } | null {
        const findResult = this.findNodeAndParent(root, sourcePaneId);
        if (!findResult || findResult.node.type !== 'leaf') return null;

        const { node: sourceNode, parent: parentNode } = findResult;

        const newLeaf: LeafPaneNode = { id: `pane-${Date.now()}`, type: 'leaf', tabIds: [], activeTabId: null };
        const newSplit: SplitPaneNode = {
            id: `split-${Date.now()}`,
            type: 'split',
            direction,
            children: [sourceNode, newLeaf],
            sizes: [50, 50]
        };

        if (parentNode) {
            const index = parentNode.children.findIndex(c => c.id === sourceNode.id);
            parentNode.children.splice(index, 1, newSplit);
            return { newRoot: { ...root }, newPaneId: newLeaf.id };
        } else {
            return { newRoot: newSplit, newPaneId: newLeaf.id };
        }
    }

    public closePane(
        root: PaneNode,
        paneId: string
    ): { newRoot: PaneNode, closedPane: LeafPaneNode } | null {
        if (root.type === 'leaf') return null; // Cannot close the root pane if it's the only one

        const findResult = this.findNodeAndParent(root, paneId);
        if (!findResult || findResult.node.type !== 'leaf' || !findResult.parent) return null;

        const { node: closedPane, parent } = findResult;
        const siblingIndex = parent.children.findIndex(c => c.id === paneId);

        const sizeToDistribute = parent.sizes[siblingIndex];
        parent.children.splice(siblingIndex, 1);
        parent.sizes.splice(siblingIndex, 1);
        parent.sizes[siblingIndex > 0 ? siblingIndex - 1 : 0] += sizeToDistribute;

        if (parent.children.length === 1) {
            const remainingChild = parent.children[0];
            const grandparentResult = this.findNodeAndParent(root, parent.id);
            if (grandparentResult && grandparentResult.parent) {
                const grandparent = grandparentResult.parent;
                const parentIndex = grandparent.children.findIndex(p => p.id === parent.id);
                grandparent.children[parentIndex] = remainingChild;

            } else {
                root = remainingChild;
            }
        }

        return { newRoot: { ...root }, closedPane };
    }
}

export const paneTreeService = new PaneTreeService();

// =
// 文件: ..\src\core\panes\stores\contextMenuStore.ts
//

// 文件: src/core/stores/contextMenuStore.ts
// 描述: 一个新的 Pinia Store，用于管理全局右键菜单的状态。

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { ContextMenuItem } from '@core/types.ts';

export const useContextMenuStore = defineStore('core-context-menu', () => {
    const isVisible = ref(false);
    const position = ref({ x: 0, y: 0 });
    const items = ref<ContextMenuItem[]>([]);

    function showMenu(event: MouseEvent, menuItems: ContextMenuItem[]) {
        isVisible.value = true;
        position.value = { x: event.clientX, y: event.clientY };
        items.value = menuItems;
    }

    function hideMenu() {
        isVisible.value = false;
        items.value = [];
    }

    return {
        isVisible,
        position,
        items,
        showMenu,
        hideMenu,
    };
});

// =
// 文件: ..\src\core\panes\stores\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { PaneNode, LeafPaneNode } from '@core/types.ts';
import { paneTreeService } from '@core/panes/service/PaneTreeService.ts';
import { paneManagementService } from '@core/panes/service/PaneManagementService.ts';

export const usePaneStore = defineStore('core-pane', () => {
    const root = ref<PaneNode | null>(null);
    const activePaneId = ref<string | null>(null);

    const activePane = computed((): LeafPaneNode | null => {
        if (!activePaneId.value || !root.value) return null;
        const result = paneTreeService.findNodeAndParent(root.value, activePaneId.value);
        return result && result.node.type === 'leaf' ? result.node : null;
    });

    const findLeafContainingTab = (tabId: string): LeafPaneNode | null => {
        if (!root.value) return null;
        return paneTreeService.findLeafContainingTab(root.value, tabId);
    };

    function _setRoot(newRoot: PaneNode) {
        root.value = newRoot;
    }

    function _setActivePaneId(paneId: string | null) {
        activePaneId.value = paneId;
    }

    function dehydrate() {
        return {
            root: root.value,
            activePaneId: activePaneId.value,
        };
    }

    function hydrate(state: { root: PaneNode, activePaneId: string | null }) {
        if (state.root && state.activePaneId) {
            root.value = state.root;
            activePaneId.value = state.activePaneId;
        }
    }

    function initializePanes() {
        paneManagementService.initializePanes();
    }

    return {
        root,
        activePaneId,
        activePane,
        findLeafContainingTab,
        _setRoot,
        _setActivePaneId,
        initializePanes,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\panes\types\pane.ts
//

// 文件: src/core/types/pane.ts

// 定义叶子节点，即实际的窗格
export interface LeafPaneNode {
    id: string;
    type: 'leaf';
    tabIds: string[];
    activeTabId: string | null;
}

// 定义分割节点，用于布局
export interface SplitPaneNode {
    id:string;
    type: 'split';
    direction: 'horizontal' | 'vertical';
    children: PaneNode[];
    sizes: number[]; // 存储每个子节点的尺寸比例
}

// PaneNode 是一个联合类型，可以是叶子节点或分割节点
export type PaneNode = LeafPaneNode | SplitPaneNode;

// =
// 文件: ..\src\core\services\CommandService.ts
//

import type { Command, CommandContext } from '@core/types.ts';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { contextService } from '../common/services/ContextService.ts';

export class CommandService {
    private commands: Map<string, Command> = new Map();

    public register(command: Command): void {
        if (this.commands.has(command.id)) {
            console.warn(`[CommandService] Command "${command.id}" is already registered. Overwriting.`);
        }
        this.commands.set(command.id, command);
    }

    public find(commandId: string): Command | undefined {
        return this.commands.get(commandId);
    }

    private getGlobalContext(): CommandContext {
        const paneStore = usePaneStore();
        return {
            activePaneId: paneStore.activePaneId,
            activeTabId: paneStore.activePane?.activeTabId,
        };
    }

    public canExecute(commandId: string, specificContext?: CommandContext): boolean {
        const command = this.find(commandId);
        if (!command) return false;

        const context = { ...this.getGlobalContext(), ...specificContext };

        if (typeof command.when === 'string') {
            return contextService.check(command.when);
        }
        if (typeof command.when === 'function') {
            return command.when(context);
        }

        return true;
    }

    public execute(commandId: string, specificContext?: CommandContext): void {
        if (!this.canExecute(commandId, specificContext)) {
            console.warn(`[CommandService] Execution of command "${commandId}" was prevented by its 'when' condition.`);
            return;
        }

        const command = this.find(commandId);
        if (!command) {
            console.error(`[CommandService] Command "${commandId}" not found.`);
            return;
        }

        const context = { ...this.getGlobalContext(), ...specificContext };
        command.execute(context);
    }

    public *getAllCommands() {
        for (const command of this.commands.values()) {
            yield command;
        }
    }
}

export const commandService = new CommandService();

// =
// 文件: ..\src\core\services\EditorKernel.ts
//

import type { ItemProvider } from '@core/common/types/providers.ts';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { keybindingService } from '../common/services/KeybindingService.ts';
import { workspaceService } from './WorkspaceService';
import { tabManagementService } from '../tabs/service/TabManagementService.ts';
import { PaneManagementModule } from '../panes/features/pane.module.ts';
import { FileOperationsModule } from '../tabs/features/file.module.ts';
import { CommandPaletteModule } from '../palette/features/palette.module.ts';

export class EditorKernel {
    private itemProvider: ItemProvider;

    constructor(provider: ItemProvider) {
        this.itemProvider = provider;
    }

    public async startup(): Promise<void> {
        console.log('[EditorKernel] Starting up...');

        this.setupServices();
        this.registerCoreModules();

        keybindingService.initialize();
        workspaceService.initialize();
        workspaceService.loadAndHydrateStores();
        usePaneStore().initializePanes();

        console.log('[EditorKernel] Startup complete.');
    }

    public shutdown(): void {
        keybindingService.destroy();
        workspaceService.destroy();
        console.log('[EditorKernel] Shutdown complete.');
    }

    private setupServices(): void {
        tabManagementService.setItemProvider(this.itemProvider);
    }

    private registerCoreModules(): void {
        new PaneManagementModule().install();
        new FileOperationsModule().install(this.itemProvider);
        new CommandPaletteModule().install();
    }
}

// =
// 文件: ..\src\core\services\WorkspaceService.ts
//

import { useLayoutStore } from '@core/layout/stores/layoutStore.ts';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';

const WORKSPACE_STORAGE_KEY = 'editorCoreWorkspaceState';
const WORKSPACE_STATE_VERSION = 'v2.1';

type Unsubscribe = () => void;

class WorkspaceService {
    private debouncedPersistState: () => void;
    private subscriptions: Unsubscribe[] = [];

    constructor() {
        this.debouncedPersistState = this.debounce(this.persistState.bind(this), 500);
    }

    public initialize() {
        const layoutStore = useLayoutStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        // Subscribe to each store and save the unsubscribe function
        this.subscriptions.push(layoutStore.$subscribe(this.debouncedPersistState));
        this.subscriptions.push(paneStore.$subscribe(this.debouncedPersistState));
        this.subscriptions.push(tabStore.$subscribe(this.debouncedPersistState));

        console.log('[WorkspaceService] Initialized and subscribed to stores.');
    }

    public destroy() {
        // Unsubscribe from all stores to prevent memory leaks
        this.subscriptions.forEach(unsubscribe => unsubscribe());
        this.subscriptions = [];
        console.log('[WorkspaceService] Destroyed store subscriptions.');
    }

    private getStoresState() {
        const layoutStore = useLayoutStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        return {
            version: WORKSPACE_STATE_VERSION,
            state: {
                layout: layoutStore.dehydrate(),
                paneLayout: paneStore.dehydrate(),
                tabs: tabStore.dehydrate(),
            }
        };
    }

    private persistState(): void {
        try {
            const statePayload = this.getStoresState();
            const stateJSON = JSON.stringify(statePayload);
            localStorage.setItem(WORKSPACE_STORAGE_KEY, stateJSON);
        } catch (error) {
            console.error('[WorkspaceService] Failed to persist state:', error);
        }
    }

    public loadAndHydrateStores(): void {
        const savedStateJSON = localStorage.getItem(WORKSPACE_STORAGE_KEY);
        if (!savedStateJSON) {
            console.log('[WorkspaceService] No saved workspace state found.');
            return;
        }

        try {
            const savedPayload = JSON.parse(savedStateJSON);

            if (savedPayload.version !== WORKSPACE_STATE_VERSION) {
                console.warn(
                    `[WorkspaceService] Mismatch in workspace state version. Expected '${WORKSPACE_STATE_VERSION}', found '${savedPayload.version}'. Discarding saved state.`
                );
                localStorage.removeItem(WORKSPACE_STORAGE_KEY);
                return;
            }

            const savedState = savedPayload.state;
            const layoutStore = useLayoutStore();
            const paneStore = usePaneStore();
            const tabStore = useTabStore();

            if (savedState.layout) {
                layoutStore.hydrate(savedState.layout);
            }
            if (savedState.paneLayout) {
                paneStore.hydrate(savedState.paneLayout);
            }
            if (savedState.tabs) {
                tabStore.hydrate(savedState.tabs);
            }
            console.log('[WorkspaceService] Stores hydrated from saved state.');
        } catch (error) {
            console.error('[WorkspaceService] Failed to hydrate stores:', error);
            localStorage.removeItem(WORKSPACE_STORAGE_KEY);
        }
    }

    private debounce<T extends (...args: any[]) => any>(func: T, delay: number): () => void {
        let timeoutId: number | undefined;
        return () => {
            clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => func(), delay);
        };
    }
}

export const workspaceService = new WorkspaceService();

// =
// 文件: ..\src\core\tabs\components\TabBar.vue
//

<template>
  <div class="tab-bar-container">
    <div
        v-for="tab in tabs"
        :key="tab.id"
        class="tab-item"
        :class="{ 'active': tab.id === activeTabId, 'inactive-pane-tab': !isActivePane }"
        @click.stop="tabManagementService.activateTab(tab.id)"
    >
      <i :class="[tab.icon, 'tab-icon']"></i>
      <span class="tab-title">{{ tab.title }}</span>
      <div
          class="close-icon-wrapper"
          @click.stop="tabManagementService.closeTab(tab.id)"
      >
        <div v-if="tab.isDirty" class="dirty-indicator"></div>
        <i v-else class="fa-solid fa-times close-icon"></i>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { PropType } from 'vue';
import { tabManagementService } from '@core/tabs/service/TabManagementService.ts';
import type { Tab } from '@core/types.ts';
defineProps({
  tabs: { type: Array as PropType<Tab[]>, required: true },
  activeTabId: { type: String as PropType<string | null>, required: true },
  paneId: { type: String, required: true },
  isActivePane: { type: Boolean, required: true },
});
</script>
<style scoped>
.tab-bar-container {
  display: flex;
  flex-shrink: 0;
  overflow-x: auto;
  min-width: 0;
  border-bottom: 1px solid #E5E7EB;
  padding: 0.5rem 0.5rem 0;
}
.tab-bar-container::-webkit-scrollbar {
  display: none;
}
.tab-bar-container {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.tab-item {
  display: flex;
  align-items: center;
  padding: 0.5rem 0.75rem;
  font-size: 0.875rem;
  color: #6B7280;
  cursor: pointer;
  position: relative;
  border: 1px solid transparent;
  border-bottom: none;
  border-top-left-radius: 0.375rem;
  border-top-right-radius: 0.375rem;
  background-color: #F3F4F6;
  white-space: nowrap;
  transition: background-color 0.2s, color 0.2s;
  flex-shrink: 0;
}

.tab-item:not(:first-child) {
  margin-left: 2px;
}

.tab-item:hover {
  background-color: #E5E7EB;
}

.tab-item.active {
  background-color: #FFFFFF;
  color: #1F2937;
  border-color: #E5E7EB;
  z-index: 2;
  margin-bottom: -1px; /* Overlaps the container's bottom border */
}

.inactive-pane-tab:not(.active) {
  background-color: #F9FAFB;
  color: #9CA3AF;
}
.inactive-pane-tab.active {
  background-color: #FFFFFF;
  color: #6B7280;
}

.tab-icon {
  margin-right: 0.5rem;
  width: 1rem;
}

.tab-item.active .tab-icon {
  color: #3B82F6;
}
.inactive-pane-tab.active .tab-icon {
  color: inherit;
}

.tab-title {
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.close-icon-wrapper {
  margin-left: 0.75rem;
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 9999px;
  flex-shrink: 0;
}

.close-icon {
  font-size: 0.8rem;
  color: #9CA3AF;
  padding: 0.25rem;
  border-radius: 9999px;
  transition: all 0.2s;
}
.tab-item:hover .close-icon {
  color: #4B5563;
}
.close-icon:hover {
  background-color: #E5E7EB;
}

.dirty-indicator {
  width: 0.6rem;
  height: 0.6rem;
  background-color: #6B7280;
  border-radius: 9999px;
  transition: all 0.2s;
}
.tab-item:hover .dirty-indicator {
  background-color: transparent;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%236B7280'%3E%3Cpath d='M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 0 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z'/%3E%3C/svg%3E");
  background-size: 100% 100%;
  width: 1rem;
  height: 1rem;
}
</style>

// =
// 文件: ..\src\core\tabs\features\file.commands.ts
//

import type { CommandService } from '@core/services/CommandService.ts';
import type { ItemProvider } from '@core/types.ts';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';
import { useNotificationStore } from '@core/layout/stores/notificationStore.ts';
import { activeEditorService } from '@core/tabs/service/ActiveEditorService.ts';
import { CoreCommand } from '@core/constants.ts';

export function registerFileCommands(commandService: CommandService, itemProvider: ItemProvider) {
    const tabStore = useTabStore();
    const paneStore = usePaneStore();
    const notificationStore = useNotificationStore();

    commandService.register({
        id: CoreCommand.SAVE_TAB,
        label: 'File: Save',
        icon: 'fa-solid fa-save',
        when: (context) => {
            const tabId = context?.tabId || paneStore.activePane?.activeTabId;
            if (!tabId) return false;
            const tab = tabStore.getTabById(tabId);
            return tab?.isDirty || false;
        },
        execute: async (context) => {
            const tabId = context?.tabId || paneStore.activePane?.activeTabId;
            if (!tabId) return;

            const tab = tabStore.getTabById(tabId);
            if (!tab || !tab.isDirty) return;

            const content = activeEditorService.getContent(tabId);
            if (content === null) return;

            try {
                await itemProvider.updateItem(tab.itemId, content);
                activeEditorService.setContent(tabId, content);
                notificationStore.add(`'${tab.title}' saved.`, 'success', 2000);
            } catch (error) {
                console.error(`Failed to save item ${tab.itemId}`, error);
                notificationStore.add(`Error saving '${tab.title}'.`, 'error');
            }
        },
    });
}

// =
// 文件: ..\src\core\tabs\features\file.keybindings.ts
//

import type { KeybindingService } from '@core/common/services/KeybindingService.ts';
import { CoreCommand } from '@core/constants.ts';

export function registerFileKeybindings(keybindingService: KeybindingService) {
    keybindingService.register({
        key: 'ctrl+s',
        commandId: CoreCommand.SAVE_TAB,
    });
}

// =
// 文件: ..\src\core\tabs\features\file.module.ts
//

import { commandService } from "@core/services/CommandService.ts";
import { keybindingService } from "@core/common/services/KeybindingService.ts";
import type { ItemProvider } from "@core/types.ts";
import { registerFileCommands } from "./file.commands.ts";
import { registerFileKeybindings } from "./file.keybindings.ts";

export class FileOperationsModule {
    public install(itemProvider: ItemProvider): void {
        registerFileCommands(commandService, itemProvider);
        registerFileKeybindings(keybindingService);
    }
}

// =
// 文件: ..\src\core\tabs\service\ActiveEditorService.ts
//

// 文件: src/core/services/ActiveEditorService.ts

interface EditorAPI {
    getContent: () => string;
    setContent: (newContent: string) => void;
}

class ActiveEditorService {
    // The key is now the unique Tab ID, not the Item ID.
    private activeEditors: Map<string, EditorAPI> = new Map();

    public register(tabId: string, api: EditorAPI): void {
        this.activeEditors.set(tabId, api);
    }

    public unregister(tabId: string): void {
        this.activeEditors.delete(tabId);
    }

    public getContent(tabId: string): string | null {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.getContent === 'function') {
            return editor.getContent();
        }
        return null;
    }

    public setContent(tabId: string, newContent: string): boolean {
        const editor = this.activeEditors.get(tabId);
        if (editor && typeof editor.setContent === 'function') {
            editor.setContent(newContent);
            return true;
        }
        return false;
    }
}

export const activeEditorService = new ActiveEditorService();

// =
// 文件: ..\src\core\tabs\service\TabManagementService.ts
//


import { nextTick } from 'vue';
import { useTabStore } from '@core/tabs/stores/tabStore.ts';
import { usePaneStore } from '@core/panes/stores/paneStore.ts';
import { useNotificationStore } from '@core/layout/stores/notificationStore.ts';
import { commandService } from '@core/services/CommandService.ts';
import { uiService } from '@core/common/services/UIService.ts';
import { eventBus } from '@core/common/services/EventBusService.ts';
import { paneManagementService } from '@core/panes/service/PaneManagementService.ts';
import { CoreEvent, CoreCommand } from '@core/constants.ts';
import type { ItemProvider, CoreItem, Tab } from '@core/types.ts';

class TabManagementService {
    private itemProvider: ItemProvider | null = null;
    // [FIX] A map to track items currently being opened to prevent race conditions.
    private openingPromises: Map<string, Promise<void>> = new Map();

    public setItemProvider(provider: ItemProvider) {
        this.itemProvider = provider;
    }

    public async openTab(itemId: string, targetPaneId?: string) {
        // [FIX] If the item is already being opened, wait for the existing promise to resolve.
        if (this.openingPromises.has(itemId)) {
            return this.openingPromises.get(itemId);
        }

        const tabStore = useTabStore();
        const existingTab = tabStore.findTabByItemId(itemId);
        if (existingTab) {
            this.activateTab(existingTab.id);
            return;
        }

        const promise = this._doOpenTab(itemId, targetPaneId);
        this.openingPromises.set(itemId, promise);

        try {
            await promise;
        } finally {
            this.openingPromises.delete(itemId);
        }
    }

    private async _doOpenTab(itemId: string, targetPaneId?: string) {
        const tabStore = useTabStore();
        const paneStore = usePaneStore();
        const notificationStore = useNotificationStore();

        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) {
            notificationStore.add('No active pane to open the tab in.', 'error');
            return;
        }

        if (!this.itemProvider) throw new Error('[TabManagementService] ItemProvider has not been set.');

        const item = await this.itemProvider.getItem(itemId);
        if (!item) {
            notificationStore.add(`Failed to open: Item "${itemId}" not found.`, 'error');
            return;
        }

        const newTab: Tab = {
            id: `tab-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            itemId: item.id,
            title: item.title,
            icon: item.icon,
            isDirty: false,
        };

        tabStore._addTab(newTab);
        paneManagementService.addTabToPane(newTab.id, paneId);
        this.activateTab(newTab.id);
        eventBus.emit(CoreEvent.TAB_OPENED, { tab: newTab, paneId });
    }

    public async closeTab(tabId: string) {
        const tabStore = useTabStore();
        const notificationStore = useNotificationStore();
        const tabToClose = tabStore.getTabById(tabId);

        if (!tabToClose) return;

        if (tabToClose.isDirty) {
            const userChoice = await uiService.requestConfirmation({
                title: 'Unsaved Changes',
                message: `Do you want to save the changes for '${tabToClose.title}'?`,
                confirmText: 'Save',
                cancelText: "Don't Save",
            });

            if (userChoice) {
                await commandService.execute(CoreCommand.SAVE_TAB, { tabId });
                await nextTick();

                const potentiallyUpdatedTab = tabStore.getTabById(tabId);
                if (potentiallyUpdatedTab && !potentiallyUpdatedTab.isDirty) {
                    this._forceCloseTab(tabId);
                } else {
                    notificationStore.add(`Failed to save '${tabToClose.title}'. Close aborted.`, 'error');
                }
            } else {
                this._forceCloseTab(tabId);
            }
        } else {
            this._forceCloseTab(tabId);
        }
    }

    public activateTab(tabId: string) {
        const paneStore = usePaneStore();
        const paneId = paneStore.findLeafContainingTab(tabId)?.id;
        if (!paneId) return;

        paneManagementService.setActivePane(paneId);
        paneManagementService.setActiveTab(paneId, tabId);
        eventBus.emit(CoreEvent.TAB_ACTIVATED, { tabId, paneId });
    }

    public async loadCoreItemForTab(tabId: string): Promise<CoreItem | null> {
        const tabStore = useTabStore();
        const notificationStore = useNotificationStore();

        if (!this.itemProvider) {
            console.error('[TabManagementService] ItemProvider not set.');
            return null;
        }
        const tab = tabStore.getTabById(tabId);
        if (!tab) return null;

        try {
            const item = await this.itemProvider.getItem(tab.itemId);
            if (!item) {
                notificationStore.add(`Item for tab '${tab.title}' not found. It may have been deleted.`, 'error');
                await this.closeTab(tabId);
            }
            return item;
        } catch (error) {
            console.error(`Error loading item ${tab.itemId}`, error);
            notificationStore.add(`An error occurred while loading '${tab.title}'.`, 'error');
            await this.closeTab(tabId);
            return null;
        }
    }

    private _forceCloseTab(tabId: string) {
        const tabStore = useTabStore();
        const closedTab = tabStore.getTabById(tabId);
        if (!closedTab) return;

        paneManagementService.removeTabFromPane(tabId);
        tabStore._removeTab(tabId);

        eventBus.emit(CoreEvent.TAB_CLOSED, { tab: closedTab });
    }
}

export const tabManagementService = new TabManagementService();

// =
// 文件: ..\src\core\tabs\stores\tabStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { usePaneStore } from '../../panes/stores/paneStore.ts';
import { paneTreeService } from '@core/panes/service/PaneTreeService.ts';
import type { Tab } from '@core/types.ts';
import { eventBus } from '@core/common/services/EventBusService.ts';
import { CoreEvent } from '@core/constants.ts';

export const useTabStore = defineStore('core-tab', () => {
    const tabsById = ref<Map<string, Tab>>(new Map());

    const getTabById = (tabId: string): Tab | undefined => tabsById.value.get(tabId);

    const findTabByItemId = (itemId: string): Tab | undefined => {
        for (const tab of tabsById.value.values()) {
            if (tab.itemId === itemId) {
                return tab;
            }
        }
        return undefined;
    };

    const getTabsForPane = (paneId: string): Tab[] => {
        const paneStore = usePaneStore();
        const pane = paneStore.root ? paneTreeService.findNodeAndParent(paneStore.root, paneId)?.node : undefined;
        if (!pane || pane.type !== 'leaf') return [];
        return pane.tabIds.map(id => getTabById(id)).filter((t): t is Tab => !!t);
    };

    function _addTab(tab: Tab) {
        tabsById.value.set(tab.id, tab);
    }

    function _removeTab(tabId: string) {
        tabsById.value.delete(tabId);
    }

    function updateTabState(tabId: string, state: Partial<Pick<Tab, 'isDirty' | 'title' | 'icon'>>) {
        const tab = getTabById(tabId);
        if (tab) {
            Object.assign(tab, state);
            // This event is for UI reactivity (e.g., command enablement), not persistence. Keep it.
            eventBus.emit(CoreEvent.TAB_STATE_CHANGED, { tabId, newState: state });
        }
    }

    function dehydrate() {
        return {
            tabs: Array.from(tabsById.value.entries()),
        };
    }

    function hydrate(state: { tabs: [string, Tab][] }) {
        if (state.tabs) {
            tabsById.value = new Map(state.tabs);
        }
    }

    return {
        getTabById,
        getTabsForPane,
        findTabByItemId,
        updateTabState,
        _addTab,
        _removeTab,
        hydrate,
        dehydrate,
    };
});

// =
// 文件: ..\src\core\types.ts
//

export * from './panes/types/pane.ts';
export * from './common/types/domain.ts';
export * from './common/types/command.ts';
export * from './common/types/providers.ts';

