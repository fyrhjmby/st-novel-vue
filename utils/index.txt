// == 扫描摘要 ==
//
// 跳过的目录 (共 1 个):
//   - ..\src\novel\editor\components\system\settings
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\editor\api\apiManagementApi.ts
//

import { fetchApiKeys as globalFetchApiKeys } from '@/api/apiManagementApi';
import type { ApiKey } from '@/types/apiManagement';

export const fetchApiKeys = (): Promise<ApiKey[]> => {
    return globalFetchApiKeys();
};

// =
// 文件: ..\src\novel\editor\api\chatApi.ts
//

import * as editorApi from '@/api/novel/editorApi';
import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes.ts';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';

export const fetchConversations = (): Promise<Conversation[]> => {
    return editorApi.fetchConversations();
};

export const createConversation = (): Promise<Conversation> => {
    return editorApi.createConversation();
};

export const sendMessage = (conversationId: string, userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> => {
    return editorApi.sendMessage(conversationId, userInput);
};

export const streamAITask = (
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: {
        onChunk: (chunk: string) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    return editorApi.streamAITask(prompt, config, taskType, sourceItemTitle, callbacks);
};

// =
// 文件: ..\src\novel\editor\api\metadataApi.ts
//

import {
    getNovelMetadata as globalGetNovelMetadata,
    updateNovelMetadata as globalUpdateNovelMetadata,
} from '@/api/novel/metadataApi';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * [Proxy] 根据小说ID获取元数据
 */
export const getNovelMetadata = (novelId: string): Promise<NovelMetadata> => {
    return globalGetNovelMetadata(novelId);
};

/**
 * [Proxy] 更新小说元数据
 */
export const updateNovelMetadata = (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    return globalUpdateNovelMetadata(novelId, metadata);
};

// =
// 文件: ..\src\novel\editor\api\projectApi.ts
//

import * as projectApi from '@/api/novel/projectApi';
import type { NovelProject } from '@/novel/editor/types/project';

/**
 * [Proxy] 根据ID获取完整的小说项目数据
 */
export const getNovelProject = (novelId: string): Promise<NovelProject> => {
    return projectApi.getNovelProject(novelId);
};

/**
 * [Proxy] 获取所有小说项目，用于参考书选择等场景
 */
export const fetchAllNovelProjects = (): Promise<NovelProject[]> => {
    return projectApi.fetchAllNovelProjects();
};

/**
 * [Proxy] 更新一个小说项目的内容结构
 */
export const updateNovelProjectContent = (novelId: string, projectData: Omit<NovelProject, 'metadata'>): Promise<NovelProject> => {
    return projectApi.updateNovelProjectContent(novelId, projectData);
};

// =
// 文件: ..\src\novel\editor\components\ai\AIDiffPreview.vue
//

import type { PropType } from 'vue';
import type { AITask } from '@/novel/editor/types';

defineProps({
  previewTask: {
    type: Object as PropType<AITask | null>,
    default: null,
  }
});

defineEmits<{
  (e: 'apply-changes', taskId: string): void;
}>();

// =
// 文件: ..\src\novel\editor\components\ai\AITaskItem.vue
//

import type { PropType } from 'vue';
import type { AITask, AITaskStatus } from '@/novel/editor/types';

const props = defineProps({
  task: {
    type: Object as PropType<AITask>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
  (e: 'retry-task', taskId: string): void;
}>();

const getStatusText = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: '等待中',
    processing: '进行中...',
    completed: '待应用',
    failed: '失败',
    applied: '已应用'
  };
  return map[status];
};

const getStatusIcon = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: 'fa-solid fa-hourglass-half',
    processing: 'fa-solid fa-spinner fa-spin',
    completed: 'fa-solid fa-check-circle',
    failed: 'fa-solid fa-times-circle',
    applied: 'fa-solid fa-check-double'
  };
  return map[status];
}

const isClickable = (status: AITaskStatus): boolean => {
  return ['completed', 'processing', 'applied', 'failed'].includes(status);
};

const handleTaskClick = () => {
  if (isClickable(props.task.status)) {
    emit('select-task', props.task);
  }
};

// =
// 文件: ..\src\novel\editor\components\ai\AITaskPanel.vue
//

import { ref, computed } from 'vue';
import AITaskQueue from './AITaskQueue.vue';
import AIDiffPreview from './AIDiffPreview.vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';

const selectedTaskId = ref<string | null>(null);
const aiTaskStore = useAITaskStore();

const selectedTask = computed((): AITask | null => {
  if (!selectedTaskId.value) return null;
  return aiTaskStore.tasks.find(t => t.id === selectedTaskId.value) ?? null;
});

const handleSelectTask = (task: AITask) => {
  selectedTaskId.value = task.id;
};

const handleApplyChanges = (taskId: string) => {
  aiTaskStore.applyChanges(taskId);

  // If the applied task was the one being previewed, clear the preview.
  if (selectedTaskId.value === taskId) {
    selectedTaskId.value = null;
  }
};

// =
// 文件: ..\src\novel\editor\components\ai\AITaskQueue.vue
//

import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';
import AITaskItem from './AITaskItem.vue';

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
}>();

const aiTaskStore = useAITaskStore();
const tasks = computed(() => aiTaskStore.tasks);
const activeTasksCount = computed(() => aiTaskStore.activeTasksCount);

const handleTaskClick = (task: AITask) => {
  emit('select-task', task);
};

const handleRetry = (taskId: string) => {
  aiTaskStore.retryTask(taskId);
};

const handleApplyChanges = (taskId: string) => {
  emit('apply-changes', taskId);
}

// =
// 文件: ..\src\novel\editor\components\ai\chat\AIChatView.vue
//

import { onMounted } from 'vue';
import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';
import { storeToRefs } from 'pinia';
import ConversationList from './ConversationList.vue';
import ChatMessageHistory from './ChatMessageHistory.vue';
import ChatInputArea from './ChatInputArea.vue';
import ChatHeader from './ChatHeader.vue';

const chatStore = useChatStore();
const { activeConversation, currentModel, isReceiving } = storeToRefs(chatStore);

onMounted(() => {
  chatStore.fetchConversations();
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatHeader.vue
//

import type { PropType } from 'vue';
import type { Conversation, AIModel } from '@/novel/editor/types/chatTypes';

defineProps({
  activeConversation: {
    type: Object as PropType<Conversation>,
    required: true,
  },
  currentModel: {
    type: Object as PropType<AIModel>,
    required: true,
  },
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatInputArea.vue
//

import { ref, watch } from 'vue';
import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';
import { storeToRefs } from 'pinia';

const chatStore = useChatStore();
const { messageInput, isReceiving, currentTokenCount } = storeToRefs(chatStore);

const textareaRef = ref<HTMLTextAreaElement | null>(null);

const sendMessage = () => {
  chatStore.sendMessage();
};

// 自动调整 textarea 高度
watch(messageInput, (newValue) => {
  const el = textareaRef.value;
  if (el) {
    el.style.height = 'auto';
    el.style.height = `${el.scrollHeight}px`;
  }
  // 清空后恢复原始高度
  if (newValue === '') {
    el.style.height = 'auto';
  }
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatMessageHistory.vue
//

import { ref, watch, nextTick, type PropType } from 'vue';
import type { Conversation } from '@/novel/editor/types/chatTypes';

const props = defineProps({
  conversation: {
    type: Object as PropType<Conversation | null>,
    required: true,
  },
  isReceiving: {
    type: Boolean,
    required: true,
  },
});

const chatHistoryContainer = ref<HTMLElement | null>(null);

const scrollToBottom = () => {
  nextTick(() => {
    if (chatHistoryContainer.value) {
      chatHistoryContainer.value.scrollTop = chatHistoryContainer.value.scrollHeight;
    }
  });
};

watch(() => props.conversation?.messages, () => {
  scrollToBottom();
}, { deep: true, flush: 'post' });

watch(() => props.isReceiving, (newValue) => {
  if (newValue) {
    scrollToBottom();
  }
}, { flush: 'post' });

// =
// 文件: ..\src\novel\editor\components\ai\chat\ConversationList.vue
//

import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';

const chatStore = useChatStore();

// =
// 文件: ..\src\novel\editor\components\ai\chat\chatData.ts
//

import type { Conversation } from '@novel/editor/types/chatTypes.ts';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\components\content\EditorContextMenu.vue
//

import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ x: 0, y: 0 });

const show = (event: MouseEvent, container: HTMLElement | null) => {
  const containerRect = container?.getBoundingClientRect() || { top: 0, left: 0 };
  visible.value = true;
  position.value.x = event.clientX - containerRect.left;
  position.value.y = event.clientY - containerRect.top;
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type']) => {
  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\content\EditorInstance.vue
//

import { computed, ref, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { EditorPane } from '@novel/editor/stores/editor-state/paneStore';
import PaneActions from '../layout/PaneActions.vue';
import BreadcrumbsBar from '../layout/BreadcrumbsBar.vue';
import PaneContentDispatcher from './PaneContentDispatcher.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<EditorPane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  }
});

const editorStore = useEditorStore();
const dispatcherRef = ref<InstanceType<typeof PaneContentDispatcher> | null>(null);

const openTabs = computed(() => editorStore.getTabsForPane(props.pane.id));
const activeTab = computed(() => editorStore.getActiveTabForPane(props.pane.id));

const activeTabContent = computed({
  get: () => {
    const item = activeTab.value?.item;
    if (item && 'content' in item && typeof item.content === 'string') {
      return item.content;
    }
    return '';
  },
  set: (newContent: string) => {
    const item = activeTab.value?.item;
    if (activeTab.value && item && 'content' in item && props.isActive) {
      editorStore.updateItemContentById(activeTab.value.id, newContent);
    }
  }
});

const setActivePane = () => {
  editorStore.setActivePane(props.pane.id)
};

const showEditorContextMenu = (event: MouseEvent) => {
  dispatcherRef.value?.showContextMenu(event, dispatcherRef.value.$el);
};

// =
// 文件: ..\src\novel\editor\components\content\FloatingToolbar.vue
//

import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ top: 0, left: 0 });

const show = (rect: DOMRect, wrapperRect: DOMRect) => {
  visible.value = true;
  position.value = {
    top: rect.top - wrapperRect.top - 48,
    left: rect.left - wrapperRect.left + rect.width / 2 - 60,
  };
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type'], event: MouseEvent) => {
  event.preventDefault();

  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\content\MainPane.vue
//

import { computed, ref, watch, nextTick } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import EditorInstance from './EditorInstance.vue';

const editorStore = useEditorStore();
const panes = computed(() => editorStore.panes);
const containerRef = ref<HTMLElement | null>(null);

watch(() => panes.value.length, (newLength, oldLength) => {
  if (newLength < oldLength) {
    nextTick(() => {
      if (!containerRef.value) return;
      const remainingPanes = containerRef.value.querySelectorAll('.pane-instance') as NodeListOf<HTMLElement>;
      remainingPanes.forEach(el => {
        el.style.flex = '';
      });
    });
  }
});

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    const minWidth = 200;
    if (newLeftWidth < minWidth) {
      newLeftWidth = minWidth;
    }
    if (totalWidth - newLeftWidth < minWidth) {
      newLeftWidth = totalWidth - minWidth;
    }

    const newLeftBasis = (newLeftWidth / totalWidth) * 100;
    const newRightBasis = 100 - newLeftBasis;

    leftPane.style.flex = `0 0 ${newLeftBasis}%`;
    rightPane.style.flex = `0 0 ${newRightBasis}%`;
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = 'none';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

// =
// 文件: ..\src\novel\editor\components\content\PaneContentDispatcher.vue
//

import { computed, ref, onMounted, onBeforeUnmount, shallowRef, type PropType } from 'vue';
import type { TabInfo, SystemViewInfo } from '@/novel/editor/types';
import TiptapEditor from './TiptapEditor.vue';
import FloatingToolbar from './FloatingToolbar.vue';
import EditorContextMenu from './EditorContextMenu.vue';
import SearchView from '@novel/editor/views/SearchView.vue';
import AIChatView from '@novel/editor/components/ai/chat/AIChatView.vue';
import AITaskPanel from '@/novel/editor/components/ai/AITaskPanel.vue';
import EditorSettings from '@/novel/editor/components/system/settings/EditorSettings.vue';
import ContextSettings from '@/novel/editor/components/system/settings/ContextSettings.vue';
import TaskSettings from '@/novel/editor/components/system/settings/TaskSettings.vue';
import AIConfigSettings from '@/novel/editor/components/system/settings/AIConfigSettings.vue';
import NovelSettings from '@/novel/editor/components/system/settings/NovelSettings.vue';
import ThemeSettings from '@/novel/editor/components/system/settings/ThemeSettings.vue';
import HistoryPanel from '@/novel/editor/components/system/HistoryPanel.vue';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    default: null
  },
  modelValue: {
    type: String,
    default: ''
  },
  isActivePane: {
    type: Boolean,
    required: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>();

const systemViewMap = shallowRef({
  SearchView,
  AIChatView,
  AITaskPanel,
  EditorSettings,
  ContextSettings,
  TaskSettings,
  AIConfigSettings,
  NovelSettings,
  ThemeSettings,
  HistoryPanel,
});

const systemViewComponent = computed(() => {
  const item = props.activeTab?.item;
  if (item?.type === 'system') {
    const componentName = item.component;
    return systemViewMap.value[componentName] || null;
  }
  return null;
});

const isCurrentTabReadOnly = computed(() => {
  const item = props.activeTab?.item;
  if (item && 'isReadOnly' in item) {
    return item.isReadOnly === true;
  }
  return false;
});

const wrapperRef = ref<HTMLElement | null>(null);
const editorContentRef = ref<HTMLElement | null>(null);
const floatingToolbarRef = ref<InstanceType<typeof FloatingToolbar> | null>(null);
const editorContextMenuRef = ref<InstanceType<typeof EditorContextMenu> | null>(null);

const showContextMenu = (event: MouseEvent, container: HTMLElement | null) => {
  editorContextMenuRef.value?.show(event, container);
};

const handleSelectionChange = () => {
  if (!props.isActivePane || !floatingToolbarRef.value || !wrapperRef.value || !editorContentRef.value) return;

  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed || !editorContentRef.value.contains(selection.getRangeAt(0).commonAncestorContainer)) {
    floatingToolbarRef.value.hide();
    return;
  }
  floatingToolbarRef.value.show(selection.getRangeAt(0).getBoundingClientRect(), wrapperRef.value.getBoundingClientRect());
  editorContextMenuRef.value?.hide();
};

const handleScroll = () => {
  floatingToolbarRef.value?.hide();
  editorContextMenuRef.value?.hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (!wrapperRef.value?.contains(event.target as Node)) return;
  const target = event.target as HTMLElement;
  if (!target.closest('.context-menu') && !target.closest('.floating-toolbar')) {
    editorContextMenuRef.value?.hide();
    floatingToolbarRef.value?.hide();
  }
};

onMounted(() => {
  document.addEventListener('selectionchange', handleSelectionChange);
  document.addEventListener('click', handleClickOutside, true);
});

onBeforeUnmount(() => {
  document.removeEventListener('selectionchange', handleSelectionChange);
  document.removeEventListener('click', handleClickOutside, true);
});

defineExpose({
  showContextMenu
});

// =
// 文件: ..\src\novel\editor\components\content\TiptapEditor.vue
//

import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { watch, onBeforeUnmount } from 'vue'

const props = defineProps({
  modelValue: {
    type: String,
    required: true,
  },
  isEditable: {
    type: Boolean,
    default: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>()

const editor = useEditor({
  content: props.modelValue,
  editable: props.isEditable,
  extensions: [
    StarterKit.configure({
      heading: { levels: [1, 2, 3] },
    }),
  ],
  onUpdate: () => {
    if (editor.value?.isEditable) {
      emit('update:modelValue', editor.value?.getHTML() || '')
    }
  },
  editorProps: {
    attributes: {
      class: 'prose-mirror-focus',
    },
  },
})

watch(() => props.modelValue, (newValue) => {
  const isSame = editor.value?.getHTML() === newValue
  if (isSame) {
    return
  }
  editor.value?.commands.setContent(newValue, false)
})

watch(() => props.isEditable, (value) => {
  editor.value?.setEditable(value);
});

onBeforeUnmount(() => {
  editor.value?.destroy()
})

// =
// 文件: ..\src\novel\editor\components\layout\ActivityBar.vue
//

import { ref } from 'vue';

type TabId = 'directory' | 'related' | 'notes' | 'references';
type ActionId = 'system:search' | 'system:ai_chat';

interface Tab {
  id: TabId;
  title: string;
  icon: string;
}

interface ActionButton {
  id: ActionId;
  title: string;
  icon: string;
}

defineProps<{
  activeTabId: string | null;
  isSidebarVisible: boolean;
}>();

defineEmits<{
  (e: 'select-tab', id: TabId): void;
  (e: 'trigger-action', id: ActionId): void;
  (e: 'show-manage-menu', event: MouseEvent): void;
}>();

const mainTabs = ref<Tab[]>([
  { id: 'directory', title: '目录', icon: 'fa-solid fa-list-ul' },
  { id: 'related', title: '相关', icon: 'fa-solid fa-sitemap' },
  { id: 'notes', title: '笔记', icon: 'fa-solid fa-book-medical' },
  { id: 'references', title: '参考书', icon: 'fa-solid fa-book-bookmark' },
]);

const actionButtons = ref<ActionButton[]>([
  { id: 'system:search', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
  { id: 'system:ai_chat', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
])

// =
// 文件: ..\src\novel\editor\components\layout\BreadcrumbsBar.vue
//

import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';

const props = defineProps<{
  paneId: string;
  isActive: boolean;
}>();

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();

const activeTab = computed(() => editorStore.getActiveTabForPane(props.paneId));

const volumeTitle = computed(() => {
  if (!activeTab.value || activeTab.value.item.type !== 'chapter') {
    return '根目录';
  }
  const chapterId = activeTab.value.id;
  const volume = directoryStore.directoryData.find(v =>
      v.chapters.some(c => c.id === chapterId)
  );
  return volume ? volume.title : '未知卷';
});

// =
// 文件: ..\src\novel\editor\components\layout\ManageMenu.vue
//

import { ref, computed, onMounted, onBeforeUnmount } from 'vue';

const emit = defineEmits<{
  (e: 'select-action', actionId: string): void;
}>();

const visible = ref(false);
const position = ref({ bottom: 0, left: 0 });
const menuRef = ref<HTMLElement | null>(null);

const menuItems = ref([
  { id: 'command_palette', label: '命令面板...', shortcut: 'Ctrl+Shift+P' },
  { isDivider: true },
  { id: 'system:settings_novel', label: '小说设置', shortcut: '' },
  { id: 'system:settings_context', label: '上下文管理', shortcut: '' },
  { id: 'system:settings_ai_config', label: 'AI 任务配置', shortcut: '' },
  { isDivider: true },
  { id: 'system:settings_editor', label: '编辑器设置', shortcut: '' },
  { id: 'system:settings_tasks', label: '任务管理', shortcut: '' },
  { id: 'system:settings_theme', label: '主题设置' },
  { isDivider: true },
  { id: 'keyboard_shortcuts', label: '键盘快捷方式', shortcut: 'Ctrl+K Ctrl+S' },
  { isDivider: true },
  { id: 'check_for_updates', label: '检查更新...' },
]);

const menuStyle = computed(() => ({
  bottom: `${position.value.bottom}px`,
  left: `${position.value.left}px`,
}));

const show = (buttonElement: HTMLElement) => {
  const rect = buttonElement.getBoundingClientRect();
  position.value.bottom = window.innerHeight - rect.top + 8; // 8px spacing
  position.value.left = rect.left;
  visible.value = true;
};

const hide = () => {
  visible.value = false;
};

const selectItem = (actionId: string) => {
  emit('select-action', actionId);
  hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (menuRef.value && !menuRef.value.contains(event.target as Node)) {
    hide();
  }
};

onMounted(() => {
  window.addEventListener('click', handleClickOutside);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', handleClickOutside);
});

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\layout\PaneActions.vue
//

import { useEditorStore } from '@/novel/editor/stores/editorStore';

const props = defineProps<{
  paneId: string;
  isActive: boolean;
}>();

const editorStore = useEditorStore();

const handleSplitPane = () => {
  editorStore.splitPane(props.paneId);
}

const handleShowHistory = () => {
  editorStore.toggleHistoryPanel(props.paneId);
};

const handleShowReader = () => {
  editorStore.openReaderView();
};

// =
// 文件: ..\src\novel\editor\components\layout\StatusBar.vue
//

import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { Chapter } from '@/novel/editor/types';

const editorStore = useEditorStore();

const activeItem = computed(() => editorStore.activeTab?.item);

const wordCount = computed(() => {
  if (activeItem.value && activeItem.value.type === 'chapter') {
    return (activeItem.value as Chapter).wordCount || 0;
  }
  return 0;
});

const readingTime = computed(() => {
  if (!wordCount.value) return 0;
  const time = Math.ceil(wordCount.value / 400);
  return time > 0 ? time : 1;
});

// =
// 文件: ..\src\novel\editor\components\modals\ContextPreviewModal.vue
//

import { ref, computed, watch } from 'vue';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { ContextBuildResult } from '@/novel/editor/types';

type PanelId = 'fixed' | 'dynamic' | 'reference' | 'rag' | 'prompt';

const store = useContextPreviewStore();
const expandedPanelIds = ref(new Set<PanelId>());

const panels = ref([
  { id: 'fixed', name: '固定上下文', statKey: 'fixedCharCount' },
  { id: 'dynamic', name: '动态上下文', statKey: 'dynamicCharCount' },
  { id: 'reference', name: '参考书籍上下文', statKey: 'referenceCharCount' },
  { id: 'rag', name: 'RAG检索', statKey: 'ragCharCount' },
  { id: 'prompt', name: '最终提示词', statKey: 'promptCharCount' },
] as const);

watch(() => store.previewContent, (newContent) => {
  if (newContent) {
    // Default expand panels with content.
    expandedPanelIds.value.clear();
    if (newContent.fixed) expandedPanelIds.value.add('fixed');
    if (newContent.dynamic) expandedPanelIds.value.add('dynamic');
    if (newContent.reference) expandedPanelIds.value.add('reference');
    expandedPanelIds.value.add('prompt'); // Always expand prompt
  }
}, { immediate: true });


const toggleExpansion = (panelId: PanelId) => {
  if (expandedPanelIds.value.has(panelId)) {
    expandedPanelIds.value.delete(panelId);
  } else {
    expandedPanelIds.value.add(panelId);
  }
};

const formatCharCount = (count: number | undefined) => {
  if(count === undefined) return 0;
  if (count > 1000) return `${(count / 1000).toFixed(1)}k`;
  return count;
};

const totalCharCount = computed(() => {
  if (!store.previewContent?.stats) return '0';
  const { fixedCharCount, dynamicCharCount, referenceCharCount, ragCharCount } = store.previewContent.stats;
  const total = (fixedCharCount || 0) + (dynamicCharCount || 0) + (referenceCharCount || 0) + (ragCharCount || 0);
  return formatCharCount(total);
});

const emptyStateHtml = (contextType: string) => {
  return `<p class="text-gray-400 italic p-4">未配置或未找到${contextType}内容。</p>`;
};

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryContextMenu.vue
//

// ..\src\novel\editor\components\sidebar\DirectoryContextMenu.vue
import { ref, computed, onMounted, onBeforeUnmount, defineAsyncComponent, shallowRef } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { AITask } from '@/novel/editor/types';

// --- 组件映射 ---
const menuComponentMap = shallowRef({
  'volume': defineAsyncComponent(() => import('./context-menus/VolumeMenu.vue')),
  'chapter': defineAsyncComponent(() => import('./context-menus/ChapterMenu.vue')),
  'group': defineAsyncComponent(() => import('./context-menus/GroupMenu.vue')),
  'item': defineAsyncComponent(() => import('./context-menus/ItemMenu.vue')),
  'root': defineAsyncComponent(() => import('./context-menus/RootMenu.vue')),
  'others': defineAsyncComponent(() => import('./context-menus/OthersMenu.vue')),
  'others_item': defineAsyncComponent(() => import('./context-menus/OthersItemMenu.vue')),
  'custom_related': defineAsyncComponent(() => import('./context-menus/CustomRelatedMenu.vue')),
  'note': defineAsyncComponent(() => import('./context-menus/NoteMenu.vue')),
  'setting_root': defineAsyncComponent(() => import('./context-menus/SettingsRootMenu.vue')),
  'prompt_group': defineAsyncComponent(() => import('./context-menus/PromptGroupMenu.vue')),
  'prompt_item': defineAsyncComponent(() => import('./context-menus/PromptItemMenu.vue')),
});

// --- State and Props ---
const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const node = ref<TreeNode | null>(null);

// --- Stores and Composables ---
const { executeAITask } = useAITaskExecutor();
const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const relatedContentStore = useRelatedContentStore();
const notesStore = useNotesStore();
const promptTemplateStore = usePromptTemplateStore();

// --- Computed ---
const menuComponent = computed(() => {
  if (!node.value) return null;
  const { type, id } = node.value;

  // 检查是否为提示词相关节点
  if (type === 'prompt_group' || type === 'prompt_item') {
    return menuComponentMap.value[type];
  }

  // Handle custom item types first by ID prefix
  if (id.startsWith('custom-others-')) {
    return menuComponentMap.value['others_item'];
  }
  if (id.startsWith('custom-') && !id.startsWith('custom-others-')) {
    return menuComponentMap.value['custom_related'];
  }

  // Handle root nodes by ID
  if (type === 'root') {
    if (id === 'setting') {
      return menuComponentMap.value['setting_root'];
    }
    if (id === 'plot' || id === 'analysis') {
      return menuComponentMap.value['root'];
    }
    if (id === 'others') {
      return menuComponentMap.value['others'];
    }
    return null;
  }

  // Handle specific node types by their 'type' property
  if (type in menuComponentMap.value) {
    return menuComponentMap.value[type];
  }

  // Fallback for settings items (e.g., character_item)
  if (type.endsWith('_item')) {
    return menuComponentMap.value['item'];
  }

  return null;
});

// --- Core Logic ---
const show = (event: MouseEvent, targetNode: TreeNode) => {
  if (targetNode.isOverview) return;
  if(targetNode.isReadOnly && targetNode.type !== 'prompt_group') return;
  // Disable context menu for all reference-related nodes
  if (targetNode.type.startsWith('reference_')) return;

  node.value = targetNode;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  node.value = null;
};

// --- Event Handlers ---
const handleAIAction = (taskType: AITask['type'], sourceNode: TreeNode, isBatch = false) => {
  hide();
  if (isBatch && sourceNode.type === 'volume' && 'originalData' in sourceNode && sourceNode.originalData.type === 'volume') {
    const aiTaskStore = (async () => (await import('@novel/editor/stores/ai/aiTaskStore.ts')).useAITaskStore())();
    aiTaskStore.then(store => store.startBatchTaskForVolume(taskType, sourceNode.originalData));
  } else {
    executeAITask(taskType, { id: sourceNode.id, title: sourceNode.title });
  }
};

const handleAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newChapter': directoryStore.addChapterToVolume(nodeId); break;
    case 'newVolume': directoryStore.addNewVolume(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': directoryStore.deleteNode(nodeId); break;
  }
};

const handleSettingsAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newGroup': relatedContentStore.addRelatedNode(nodeId, 'group'); break;
    case 'newItem': relatedContentStore.addRelatedNode(nodeId, 'item'); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteRelatedNode(nodeId); break;
  }
};

const handleCustomRelatedAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  const target = payload?.target as 'plot' | 'analysis' | undefined;

  switch(action) {
    case 'newItem':
      if (target) {
        relatedContentStore.addCustomRelatedNode(target);
      }
      break;
    case 'rename':
      editorStore.setEditingNodeId(nodeId);
      break;
    case 'delete':
      relatedContentStore.deleteCustomRelatedNode(nodeId);
      break;
  }
};

const handleOthersAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch(action) {
    case 'newItem': relatedContentStore.addCustomOthersNode(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteCustomOthersNode(nodeId); break;
  }
};

const handleNoteAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': notesStore.deleteNote(nodeId); break;
  }
};

const handlePromptAction = (action: string, payload: any) => {
  hide();
  const uiStore = useUIStore();

  switch(action) {
    case 'newPrompt':
      const newNode = promptTemplateStore.addPrompt(payload.groupId, '新建提示词', '在这里输入你的提示词模板...');
      if (newNode) {
        uiStore.ensureRelatedNodeIsExpanded(payload.groupId);
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
      }
      break;
    case 'renamePrompt':
      editorStore.setEditingNodeId(payload.promptId);
      break;
    case 'deletePrompt':
      if (confirm('确定要删除这个提示词模板吗？')) {
        if (promptTemplateStore.deletePrompt(payload.promptId)) {
          editorStore.closeTab(payload.promptId);
        }
      }
      break;
  }
}

// --- Lifecycle ---
onMounted(() => {
  window.addEventListener('click', hide);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', hide);
});

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryTab.vue
//

import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import type { TreeNode, VolumeNode, ChapterNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const directoryTree = computed((): VolumeNode[] => {
  return directoryStore.directoryData.map(volume => ({
    id: volume.id,
    title: volume.title,
    icon: getIconByNodeType(volume.type),
    type: 'volume',
    content: volume.content,
    originalData: volume,
    children: volume.chapters.map(chapter => ({
      id: chapter.id,
      title: chapter.title,
      icon: getIconByNodeType(chapter.type),
      type: 'chapter',
      status: chapter.status,
      content: chapter.content,
      originalData: chapter,
    })),
  }));
});

const handleSelectNode = (node: TreeNode) => {
  if (node.type === 'chapter' || node.type === 'volume') {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    uiStore.toggleNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id:string) => {
  uiStore.toggleNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleAddNewVolume = () => {
  directoryStore.addNewVolume();
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  directoryStore.renameNode(payload.nodeId, payload.newTitle);
  handleCancelRename();
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\NotesTab.vue
//

import { ref, computed, watch, nextTick, onBeforeUpdate } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { NoteItem } from '@/novel/editor/types';
import type { TreeNode } from './TreeView.vue';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const notesStore = useNotesStore();
const uiStore = useUIStore();
const quickAddValue = ref('');
const renameInputs = ref<HTMLInputElement[]>([]);

const editingNodeId = computed(() => uiStore.editingNodeId);
const activeTabId = computed(() => editorStore.activeTabId);


watch(editingNodeId, (newId) => {
  if (newId && newId.startsWith('note-')) {
    nextTick(() => {
      const noteIndex = notesStore.notes.findIndex(n => n.id === newId);
      if (noteIndex !== -1 && renameInputs.value[noteIndex]) {
        renameInputs.value[noteIndex].focus();
        renameInputs.value[noteIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const handleAddNewNote = () => {
  notesStore.addNote('新建笔记');
};

const handleQuickAdd = () => {
  const value = quickAddValue.value.trim();
  if (!value) return;
  notesStore.addNote(value);
  quickAddValue.value = '';
};

const handleContextMenu = (note: NoteItem, event: MouseEvent) => {
  const nodePayload: TreeNode = {
    id: note.id,
    title: note.title,
    type: note.type,
    icon: getIconByNodeType(note.type),
    originalData: note
  };
  emit('show-context-menu', { node: nodePayload, event });
}

const handleCommitRename = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value.trim();
  if(newTitle) {
    notesStore.renameNote(nodeId, newTitle);
  }
  handleCancelRename();
};

const handleCancelRename = () => {
  uiStore.setEditingNodeId(null);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\ReferencesTab.vue
//

import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const referenceStore = useReferenceStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const referenceTree = computed((): TreeNode[] => {
  return referenceStore.referenceData;
});

const handleSelectNode = (node: TreeNode) => {
  // If the node has children, it's a container node, so we toggle its expansion.
  if (node.children && node.children.length > 0) {
    uiStore.toggleReferenceNodeExpansion(node.id);
  }
  // If the node has content, it's a leaf node that can be opened.
  else if (node.hasOwnProperty('content')) {
    editorStore.openTab(node.id);
  }
};

const handleToggleExpansion = (id:string) => {
  uiStore.toggleReferenceNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\RelatedTab.vue
//

import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const relatedContentStore = useRelatedContentStore();
const promptTemplateStore = usePromptTemplateStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const relatedTree = computed((): TreeNode[] => {
  return relatedContentStore.relatedData;
});

const handleSelectNode = (node: TreeNode) => {
  if ('content' in node && node.content !== undefined) {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    uiStore.toggleRelatedNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id: string) => {
  uiStore.toggleRelatedNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  if (payload.newTitle.trim()) {
    if (payload.nodeId.startsWith('custom-others-')) {
      relatedContentStore.renameCustomOthersNode(payload.nodeId, payload.newTitle);
    } else if (payload.nodeId.startsWith('custom-')) {
      relatedContentStore.renameCustomRelatedNode(payload.nodeId, payload.newTitle);
    } else if (payload.nodeId.startsWith('prompt-')) {
      // ** FIX: Call the correct store for renaming prompts **
      promptTemplateStore.renamePrompt(payload.nodeId, payload.newTitle);
    }
    else {
      relatedContentStore.renameRelatedNode(payload.nodeId, payload.newTitle);
    }
  }
  editorStore.setEditingNodeId(null);
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};

const handleAddNewCustomPlot = () => {
  relatedContentStore.addCustomRelatedNode('plot');
};

const handleAddNewCustomAnalysis = () => {
  relatedContentStore.addCustomRelatedNode('analysis');
};

const handleAddNewCustomOthers = () => {
  relatedContentStore.addCustomOthersNode();
};

// =
// 文件: ..\src\novel\editor\components\sidebar\SidebarPanel.vue
//

import { ref, computed, defineAsyncComponent } from 'vue';
import DirectoryContextMenu from './DirectoryContextMenu.vue';
import type { TreeNode } from './TreeView.vue';

type TabId = 'directory' | 'related' | 'notes' | 'references';

const props = defineProps<{
  activeTabId: TabId | null;
}>();

const directoryContextMenuRef = ref<InstanceType<typeof DirectoryContextMenu> | null>(null);

const titles: Record<TabId, string> = {
  directory: '目录大纲',
  related: '相关内容',
  notes: '章节笔记',
  references: '参考书目',
};

const tabComponents: Record<TabId, any> = {
  directory: defineAsyncComponent(() => import('./DirectoryTab.vue')),
  related: defineAsyncComponent(() => import('./RelatedTab.vue')),
  notes: defineAsyncComponent(() => import('./NotesTab.vue')),
  references: defineAsyncComponent(() => import('./ReferencesTab.vue')),
};

const activeTabComponent = computed(() => {
  if (!props.activeTabId) return null;
  return tabComponents[props.activeTabId] || null;
});

const activeTitle = computed(() => {
  if (!props.activeTabId) return '';
  return titles[props.activeTabId] || '';
});

const showDirectoryContextMenu = (payload: { node: TreeNode, event: MouseEvent }) => {
  directoryContextMenuRef.value?.show(payload.event, payload.node);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\TreeView.vue
//

import { ref, watch, nextTick } from 'vue';
import type { PropType } from 'vue';
import type { TreeNode } from '@novel/editor/types';

// --- Props & Emits ---
const props = defineProps({
  nodes: {
    type: Array as PropType<TreeNode[]>,
    required: true,
  },
  activeNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
  expandedNodeIds: {
    type: Set as PropType<Set<string>>,
    required: true,
  },
  editingNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
});

const emit = defineEmits<{
  (e: 'select-node', node: TreeNode): void;
  (e: 'toggle-expansion', id: string): void;
  (e: 'context-menu', payload: { node: TreeNode, event: MouseEvent }): void;
  (e: 'commit-rename', payload: { nodeId: string, newTitle: string, nodeType: string }): void;
  (e: 'cancel-rename'): void;
}>();

const renameInput = ref<HTMLInputElement[] | null>(null);

watch(() => props.editingNodeId, (newId, oldId) => {
  if (newId && newId !== oldId) {
    nextTick(() => {
      if (renameInput.value && renameInput.value.length > 0) {
        renameInput.value[0].focus();
        renameInput.value[0].select();
      }
    });
  }
});

const handleNodeClick = (node: TreeNode) => {
  if (props.editingNodeId === node.id) return;
  // Always emit the select-node event and let the parent decide the action.
  emit('select-node', node);
};

const handleRenameCommit = (event: Event, node: TreeNode) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value;
  emit('commit-rename', { nodeId: node.id, newTitle, nodeType: node.type });
};

const handleRenameCancel = () => {
  emit('cancel-rename');
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ChapterMenu.vue
//

import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch?: boolean): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\CustomRelatedMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\GroupMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\NoteMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'note-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptGroupMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'prompt-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'prompt-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\RootMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\SettingsRootMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\VolumeMenu.vue
//

import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch: boolean): void;
}>();

// =
// 文件: ..\src\novel\editor\components\system\HistoryPanel.vue
//

import { computed, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { TabInfo, EditorItem } from '@/novel/editor/types';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    required: true,
  },
});

const editorStore = useEditorStore();

const targetDocumentId = computed(() => {
  if (!props.activeTab) return null;
  const parts = props.activeTab.id.split(':');
  return parts.length === 3 ? parts[2] : null;
});

const targetDocument = computed((): EditorItem | null => {
  if (!targetDocumentId.value) return null;
  return editorStore.findItemById(targetDocumentId.value).node;
});

const headerTitle = computed(() => {
  if (!targetDocument.value) return '版本对比';
  return `《${targetDocument.value.title}》版本对比`;
});

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings, ReferenceContextSettings, TreeNode } from '@/novel/editor/types';

const stripHtml = (html: string): string => {
    // 使用正则表达式替换，避免依赖DOM环境
    if (!html) return '';
    return html.replace(/<[^>]*>?/gm, '');
};

const _findDerivedItemsRecursive = (nodes: TreeNode[], sourceId: string): TreeNode[] => {
    let results: TreeNode[] = [];
    for (const node of nodes) {
        if (node.originalData?.sourceId === sourceId) {
            results.push(node);
        }
        if (node.children) {
            results = [...results, ..._findDerivedItemsRecursive(node.children, sourceId)];
        }
    }
    return results;
}

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const referenceStore = useReferenceStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const _buildReferenceContextHtmlByIndex = (sourceNode: Chapter | Volume, vIndex: number, cIndex: number | null, settings: ReferenceContextSettings): string => {
        // BUG: This index-based matching is fragile and likely to produce incorrect context.
        // It assumes the reference book has the exact same structure.
        // This should be replaced with a more robust matching logic (e.g., title similarity)
        // or a user-driven manual mapping feature.
        // For now, returning an empty string to prevent context pollution.
        if (true) { // Temporarily disabling this feature
            return '<!-- Reference context matching is disabled due to known bugs. -->';
        }

        if (!referenceStore.referenceData.length || vIndex < 0) return '';

        let referenceContextHtml = '';

        for (const refBook of referenceStore.referenceData) {
            const directoryRoot = refBook.children?.find(c => c.id.startsWith('ref-dir-'));
            if (!directoryRoot) continue;

            const refVolumeNode = directoryRoot.children?.[vIndex];
            if (!refVolumeNode) continue;

            let matchingNode: TreeNode | null = null;
            let matchingParent: TreeNode | null = null;

            if (sourceNode.type === 'volume') {
                matchingNode = refVolumeNode;
            } else if (sourceNode.type === 'chapter' && cIndex !== null && cIndex >= 0) {
                matchingNode = refVolumeNode.children?.[cIndex] ?? null;
                matchingParent = refVolumeNode;
            }

            if (matchingNode) {
                referenceContextHtml += `<hr><h3>参考书籍《${refBook.title}》中的匹配内容: ${matchingNode.title}</h3>`;

                if (settings.includeContent && 'content' in matchingNode && matchingNode.content) {
                    referenceContextHtml += `<h4>正文</h4>${matchingNode.content}`;
                }

                if (settings.includeVolumeInfo && matchingParent && matchingParent.type.endsWith('volume') && 'content' in matchingParent && matchingParent.content) {
                    referenceContextHtml += `<h4>所属卷信息</h4>${matchingParent.content}`;
                }

                if (settings.includePlot) {
                    const plotRoot = refBook.children?.find(c => c.id.startsWith('ref-plot-'));
                    if (plotRoot) {
                        const plotItems = _findDerivedItemsRecursive(plotRoot.children || [], matchingNode.id);
                        if (plotItems.length > 0) {
                            referenceContextHtml += `<h4>相关剧情</h4>` + plotItems.map(p => 'content' in p ? p.content : '').join('<hr>');
                        }
                    }
                }
                if (settings.includeAnalysis) {
                    const analysisRoot = refBook.children?.find(c => c.id.startsWith('ref-analysis-'));
                    if (analysisRoot) {
                        const analysisItems = _findDerivedItemsRecursive(analysisRoot.children || [], matchingNode.id);
                        if (analysisItems.length > 0) {
                            referenceContextHtml += `<h4>相关分析</h4>` + analysisItems.map(a => 'content' in a ? a.content : '').join('<hr>');
                        }
                    }
                }
            }
        }
        return referenceContextHtml;
    }

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        let referenceContextHtml = '';
        if ((sourceNode.type === 'chapter' && sourceParent) || sourceNode.type === 'volume') {
            const vIndex = directoryStore.directoryData.findIndex(v => v.id === (sourceParent?.id || sourceNode.id));
            const cIndex = sourceNode.type === 'chapter' && sourceParent ? sourceParent.chapters.findIndex(c => c.id === sourceNode.id) : null;
            referenceContextHtml = _buildReferenceContextHtmlByIndex(sourceNode, vIndex, cIndex, contextSettingsStore.referenceContextSettings);
        }
        const referenceContextText = stripHtml(referenceContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            // 使用正则表达式从<pre>标签中提取模板，更安全
            const match = promptNode.content.match(/<pre[^>]*>([\s\S]*)<\/pre>/);
            const template = match ? match[1] : selectedPromptTemplate;
            selectedPromptTemplate = template.replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# 参考书籍上下文
${referenceContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            reference: referenceContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                referenceCharCount: referenceContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\layouts\NovelEditorLayout.vue
//

import '@/novel/assets/styles/main.css';
import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ContextPreviewModal from '@/novel/editor/components/modals/ContextPreviewModal.vue';
import ReaderModeOverlay from '@novel/editor/views/ReaderModeOverlay.vue';
import {useAuthStore} from "@auth/store/auth.store.ts";
const authStore = useAuthStore();
const editorStore = useEditorStore();
const uiStore = useUIStore();
const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\services\ai\AITaskExecutionService.ts
//


import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore';
import { useUIStore } from '@novel/editor/stores/uiStore';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder';
import { streamAITask } from '@novel/editor/services/ai/aiService.ts';
import type { AITask } from '@/novel/editor/types';

const { buildContextForTask } = useContextBuilder();

function executeTaskAndStream(task: AITask) {
    const aiTaskStore = useAITaskStore();

    aiTaskStore.updateTaskStatus(task.id, 'processing');

    // 如果任务没有最终提示词，立即构建它
    if (!task.finalPrompt) {
        const contextResult = buildContextForTask(task);
        if (!contextResult || !contextResult.prompt) {
            aiTaskStore.updateTaskError(task.id, '上下文构建失败，无法生成最终提示词。');
            processQueue(); // 继续处理下一个任务
            return;
        }
        task.finalPrompt = contextResult.prompt;
    }

    const promptToUse = task.finalPrompt;

    streamAITask(promptToUse, task.aiConfig, task.type, task.sourceItemTitle, {
        onChunk: (chunk) => {
            aiTaskStore.appendGeneratedContent(task.id, chunk);
        },
        onComplete: () => {
            aiTaskStore.completeTask(task.id);
            processQueue(); // 完成后处理下一个
        },
        onError: (error) => {
            aiTaskStore.updateTaskError(task.id, error);
            processQueue(); // 出错后也处理下一个
        }
    });
}

/**
 * 处理任务队列。检查当前正在执行的任务数是否达到并发上限，
 * 如果没有，则从等待队列中取出任务开始执行。
 */
export function processQueue() {
    const uiStore = useUIStore();
    const aiTaskStore = useAITaskStore();

    const limit = uiStore.uiState.concurrentTaskLimit;
    const processingCount = aiTaskStore.tasks.filter(t => t.status === 'processing').length;

    if (processingCount >= limit) {
        return;
    }

    const canStartCount = limit - processingCount;
    const pendingTasks = aiTaskStore.tasks.filter(t => t.status === 'pending');

    const tasksToStart = pendingTasks.slice(0, canStartCount);

    for (const task of tasksToStart) {
        executeTaskAndStream(task);
    }
}

// =
// 文件: ..\src\novel\editor\services\ai\AITaskFactory.ts
//

import { useEditorStore } from '@novel/editor/stores/editorStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import type { AITask, AITaskType } from '@/novel/editor/types';

/**
 * 创建一个新的AI任务对象。
 * @param taskType AI任务的类型。
 * @param sourceItemId 源文档的ID。
 * @param finalPrompt 可选的，预先构建好的最终提示词。
 * @returns 一个结构完整的AITask对象，如果源项目无效则返回null。
 */
export async function createTask(taskType: AITaskType, sourceItemId: string, finalPrompt?: string): Promise<AITask | null> {
    const editorStore = useEditorStore();
    const aiConfigStore = useAIConfigStore();

    const { node: sourceItem } = editorStore.findItemById(sourceItemId);
    if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
        console.error("AI Task Factory Error: Source item not found or has no content.", sourceItemId);
        return null;
    }

    // --- 核心Bug修复：版本控制 ---
    // 为源对象打上一个时间戳作为版本号
    // 如果已有，则更新它
    (sourceItem as any)._lastModified = Date.now();
    const sourceItemVersion = (sourceItem as any)._lastModified;
    // --- 核心Bug修复结束 ---

    const taskConfigSettings = aiConfigStore.taskConfigs[taskType];
    const baseAIProviderConfig = aiConfigStore.availableAIProviders.find(p => p.id === taskConfigSettings.selectedAIProviderId);

    if (!baseAIProviderConfig) {
        console.error("AI Task Factory Error: Selected AI Provider Config not found.", taskConfigSettings.selectedAIProviderId);
        alert(`未找到ID为 "${taskConfigSettings.selectedAIProviderId}" 的AI配置，请在设置中检查。`);
        return null;
    }

    const finalAIConfig = {
        ...baseAIProviderConfig,
        temperature: taskConfigSettings.temperature,
    };

    // 对于所有任务，目标ID最初都指向源ID。
    // 应用时，将根据任务类型决定是修改此ID的项，还是基于此ID创建新项。
    const targetItemId = sourceItemId;
    const taskTitle = `${taskType}《${sourceItem.title}》`;

    const newTask: AITask = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title: taskTitle,
        type: taskType,
        sourceItemId: sourceItemId,
        targetItemId: targetItemId,
        sourceItemTitle: sourceItem.title,
        sourceItemContent: sourceItem.content,
        sourceItemVersion: sourceItemVersion, // 存储版本快照
        status: 'pending',
        generatedContent: '',
        finalPrompt: finalPrompt,
        createdAt: new Date(),
        aiConfig: finalAIConfig,
    };

    return newTask;
}

// =
// 文件: ..\src\novel\editor\services\ai\aiService.ts
//

import { fetchApiKeys } from '../../api/apiManagementApi.ts';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';
import { streamAITask as streamAITaskFromApi } from '@novel/editor/api/chatApi';

interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 从系统设置中获取所有已启用的、可供编辑器使用的AI配置。
 * @returns 返回一个符合编辑器AIProviderConfig格式的数组。
 */
export async function fetchAvailableAIProviders(): Promise<AIProviderConfig[]> {
    try {
        const allKeys = await fetchApiKeys();
        const enabledKeys = allKeys.filter(key => key.status === '启用');

        return enabledKeys.map(key => ({
            id: key.id.toString(), // 将数字ID转换为字符串以匹配接口
            name: key.name,
            model: key.model,
            temperature: key.temperature,
            maxTokens: key.maxTokens,
            description: key.description,
        }));
    } catch (error) {
        console.error("Failed to fetch available AI providers from API layer:", error);
        return [];
    }
}

/**
 * 通过API层执行一个流式AI任务。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param taskType - 任务的类型 ('润色', '续写' 等).
 * @param sourceItemTitle - 任务源文档的标题.
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: StreamCallbacks
): void {
    console.log(`[AI Service] Delegating task to API layer. Type: ${taskType}, Title: ${sourceItemTitle}`);
    streamAITaskFromApi(prompt, config, taskType, sourceItemTitle, callbacks);
}

// =
// 文件: ..\src\novel\editor\services\ai\chatService.ts
//

import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes.ts';
import * as chatApi from '@/novel/editor/api/chatApi';

/**
 * 从API获取所有聊天对话。
 * @returns 对话列表。
 */
export async function getConversations(): Promise<Conversation[]> {
    return await chatApi.fetchConversations();
}

/**
 * 通过API创建一个新的、空的对话对象。
 * @returns 一个新的 Conversation 对象。
 */
export async function createConversation(): Promise<Conversation> {
    return await chatApi.createConversation();
}

/**
 * 发送一条消息到API并接收AI的回复。
 * @param conversationId - 当前对话的ID
 * @param userInput - 用户输入的文本。
 * @returns 一个包含用户消息和AI回复消息的对象。
 */
export async function sendMessage(conversationId: string, userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> {
    return await chatApi.sendMessage(conversationId, userInput);
}

// =
// 文件: ..\src\novel\editor\services\directoryService.ts
//

// src/novel/editor/services/directoryService.ts
import type { Volume, Chapter } from '@/novel/editor/types';

type DirectoryNode = Volume | Chapter;

function _findNodeRecursive(nodes: DirectoryNode[], nodeId: string): { node: DirectoryNode; parent: Volume | null; siblings: DirectoryNode[] } | null {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null, siblings: nodes };
        }
        if (node.type === 'volume' && node.chapters) {
            const chapterResult = node.chapters.find(c => c.id === nodeId);
            if (chapterResult) {
                return { node: chapterResult, parent: node, siblings: node.chapters };
            }
        }
    }
    return null;
}

export function findNodeById(nodes: Volume[], nodeId: string) {
    return _findNodeRecursive(nodes, nodeId);
}

export function createVolume(): Volume {
    return {
        id: `vol-${Date.now()}`,
        type: 'volume',
        title: '新建卷',
        content: `<h1>新建卷</h1>`,
        chapters: [],
    };
}

export function createChapter(): Chapter {
    return {
        id: `ch-${Date.now()}`,
        type: 'chapter',
        title: '新建章节',
        wordCount: 0,
        content: '<h1>新建章节</h1>',
        status: 'editing'
    };
}

export function updateNodeContent(node: Volume | Chapter, content: string) {
    node.content = content;
    (node as any)._lastModified = Date.now(); // Update version timestamp

    if (node.type === 'chapter') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        node.wordCount = tempDiv.textContent?.trim().length || 0;
    }

    const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
    const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
    if (newTitle && newTitle !== node.title) {
        node.title = newTitle;
    }
}

export function appendChapterContent(chapter: Chapter, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    chapter.content += htmlToAppend;
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = chapter.content;
    chapter.wordCount = tempDiv.textContent?.trim().length || 0;
    (chapter as any)._lastModified = Date.now(); // Update version timestamp
}

export function renameNode(node: DirectoryNode, newTitle: string) {
    if (!newTitle.trim()) {
        return;
    }
    const trimmedTitle = newTitle.trim();
    node.title = trimmedTitle;
    if (node.content) {
        if (node.content.includes('<h1>')) {
            node.content = node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        } else {
            node.content = `<h1>${trimmedTitle}</h1>` + node.content;
        }
    }
    (node as any)._lastModified = Date.now(); // Update version timestamp on rename
}

export function deleteNode(nodes: Volume[], nodeId: string): boolean {
    const result = findNodeById(nodes, nodeId);
    if (!result) return false;

    if (result.parent && result.node.type === 'chapter') {
        const index = result.parent.chapters.findIndex(c => c.id === nodeId);
        if (index > -1) {
            result.parent.chapters.splice(index, 1);
            return true;
        }
    } else if (!result.parent && result.node.type === 'volume') {
        const index = nodes.findIndex(v => v.id === nodeId);
        if (index > -1) {
            nodes.splice(index, 1);
            return true;
        }
    }
    return false;
}

// =
// 文件: ..\src\novel\editor\services\noteService.ts
//

import type { NoteItem } from '@/novel/editor/types';

class NoteService {

    /**
     * 创建一个新的笔记对象
     * @param title - 笔记的初始标题
     * @param content - 笔记的初始内容（纯文本）
     * @returns 一个完整的 NoteItem 对象
     */
    public createNote(title: string, content: string = ''): NoteItem {
        return {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
    }

    /**
     * 根据新的HTML内容更新笔记对象，并同步标题
     * @param note - 要更新的原始笔记对象
     * @param newContent - 新的HTML内容
     * @returns 一个被更新后的新笔记对象副本
     */
    public updateNoteWithNewContent(note: NoteItem, newContent: string): NoteItem {
        const updatedNote = { ...note, content: newContent };

        const h1Match = newContent.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;

        if (newTitle) {
            updatedNote.title = newTitle;
        }

        return updatedNote;
    }

    /**
     * 将文本内容附加到现有笔记内容的末尾
     * @param originalContent - 原始HTML内容
     * @param contentToAppend - 要附加的纯文本内容
     * @param isAutoApplied - 是否为AI自动应用，若是则添加一个标记
     * @returns 附加了新内容的完整HTML字符串
     */
    public appendContentToNote(originalContent: string, contentToAppend: string, isAutoApplied: boolean): string {
        const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
        let htmlToAppend = paragraphs;
        if (isAutoApplied) {
            htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
        }
        return (originalContent || "") + htmlToAppend;
    }

    /**
     * 根据新标题更新笔记对象，并同步内容中的<h1>标签
     * @param note - 要更新的原始笔记对象
     * @param newTitle - 新的标题
     * @returns 一个被更新后的新笔记对象副本
     */
    public renameNote(note: NoteItem, newTitle: string): NoteItem {
        const updatedNote = { ...note, title: newTitle };
        if (updatedNote.content.includes('<h1>')) {
            updatedNote.content = updatedNote.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
        } else {
            updatedNote.content = `<h1>${newTitle}</h1>` + updatedNote.content;
        }
        return updatedNote;
    }
}

export const noteService = new NoteService();

// =
// 文件: ..\src\novel\editor\services\novelLoaderService.ts
//

import { getNovelProject, updateNovelProjectContent } from '../api/projectApi';
import { useMetadataStore } from '@/novel/editor/stores/editor-state/metadataStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useNovelSettingsStore } from '@/novel/editor/stores/novelSettingsStore';
import { useAIConfigStore } from '@/novel/editor/stores/ai/aiConfigStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { usePaneStore } from '@/novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@/novel/editor/stores/editor-state/tabStore';
import type { NovelProject } from '../types/project';

class NovelLoaderService {
    private resetAllStores() {
        useMetadataStore().$reset();
        useDirectoryStore().$reset();
        useRelatedContentStore().$reset();
        useNotesStore().$reset();
        useReferenceStore().$reset();
        useDerivedContentStore().$reset();
        useNovelSettingsStore().$reset();
        useAIConfigStore().$reset();
        usePaneStore().$reset();
        useTabStore().$reset(); // Assuming tabs are managed inside panes or have their own reset
    }

    public async loadProjectIntoEditor(novelId: string): Promise<boolean> {
        // Temporary holders for fetched data
        let projectData: NovelProject | undefined;
        let referenceTree: any[] | undefined; // Adjust type as needed

        try {
            console.log(`[Service] Fetching data for novel: ${novelId}`);

            // 1. Fetch all data into temporary variables
            projectData = await getNovelProject(novelId);
            if (!projectData) {
                throw new Error(`Novel project with ID "${novelId}" not found.`);
            }

            // Assuming referenceStore.loadReferences internally fetches data
            // To make this transactional, the fetch needs to be extracted.
            // For now, we'll proceed assuming it can fail.
            const referenceStore = useReferenceStore();
            await referenceStore.loadReferences(projectData.metadata.referenceNovelIds);

            // 2. If all fetches are successful, commit to stores
            const metadataStore = useMetadataStore();
            const directoryStore = useDirectoryStore();
            const relatedContentStore = useRelatedContentStore();
            const notesStore = useNotesStore();
            const derivedContentStore = useDerivedContentStore();
            const novelSettingsStore = useNovelSettingsStore();
            const aiConfigStore = useAIConfigStore();
            const uiStore = useUIStore();
            const paneStore = usePaneStore();
            const tabStore = useTabStore();

            metadataStore._setCurrentNovelId(novelId);
            metadataStore._setNovelMetadata(projectData.metadata);

            await aiConfigStore.initializeProviders();
            directoryStore.fetchDirectoryData(projectData.directoryData);
            relatedContentStore.fetchRelatedData(
                projectData.settingsData,
                projectData.plotCustomData,
                projectData.analysisCustomData,
                projectData.othersCustomData
            );
            derivedContentStore.fetchDerivedData(
                projectData.derivedPlotData || [],
                projectData.derivedAnalysisData || []
            );
            notesStore.fetchNotes(projectData.noteData);

            await novelSettingsStore.loadSettingsData();

            paneStore.initializePanes();
            uiStore.uiState.expandedNodeIds.clear();
            uiStore.uiState.expandedRelatedNodeIds.clear();
            uiStore.uiState.expandedReferenceNodeIds.clear();

            if (projectData.directoryData.length > 0) {
                uiStore.ensureNodeIsExpanded(projectData.directoryData[0].id);
            }
            uiStore.ensureRelatedNodeIsExpanded('setting');
            uiStore.ensureRelatedNodeIsExpanded('characters');
            uiStore.ensureRelatedNodeIsExpanded('plot');
            uiStore.ensureRelatedNodeIsExpanded('analysis');
            uiStore.ensureRelatedNodeIsExpanded('others');
            if (projectData.metadata.referenceNovelIds.length > 0) {
                const firstRefBookId = `ref-book-${projectData.metadata.referenceNovelIds[0]}`;
                uiStore.ensureReferenceNodeIsExpanded(firstRefBookId);
            }

            const firstChapterId = projectData.directoryData[0]?.chapters[0]?.id;
            if (firstChapterId) {
                tabStore.openTab(firstChapterId);
            }

            return true;
        } catch (error) {
            console.error(`[Service] Failed to load project ${novelId}:`, error);
            // 3. On failure, reset all stores to ensure clean state
            this.resetAllStores();
            return false;
        }
    }

    public async saveCurrentProject(): Promise<boolean> {
        const metadataStore = useMetadataStore();
        const novelId = metadataStore.currentNovelId;

        if (!novelId) {
            console.error("[Service] Cannot save: No current novel loaded.");
            return false;
        }

        try {
            console.log(`[Service] Saving project content for: ${novelId}`);

            const directoryStore = useDirectoryStore();
            const relatedContentStore = useRelatedContentStore();
            const derivedContentStore = useDerivedContentStore();
            const notesStore = useNotesStore();

            const projectContentToSave: Omit<NovelProject, 'metadata'> = {
                directoryData: directoryStore.directoryData,
                settingsData: relatedContentStore.settingsData,
                plotCustomData: relatedContentStore.plotCustomData,
                analysisCustomData: relatedContentStore.analysisCustomData,
                othersCustomData: relatedContentStore.othersCustomData,
                derivedPlotData: derivedContentStore.plotItems,
                derivedAnalysisData: derivedContentStore.analysisItems,
                noteData: notesStore.notes,
            };
            await updateNovelProjectContent(novelId, projectContentToSave);

            await metadataStore.saveMetadata();

            console.log(`[Service] Project ${novelId} saved successfully.`);
            return true;
        } catch (error) {
            console.error(`[Service] Failed to save project ${novelId}:`, error);
            return false;
        }
    }
}

export const projectLoaderService = new NovelLoaderService();

// =
// 文件: ..\src\novel\editor\services\novelSettingsService.ts
//

import { fetchAllNovelProjects, getNovelProject } from '../api/projectApi';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

class NovelSettingsService {

    /**
     * 根据ID数组异步获取完整的小说项目对象列表。
     * @param novelIds - 要获取的小说ID数组。
     * @returns 完整的小说项目对象数组。
     */
    public async getReferencedNovels(novelIds: string[]): Promise<NovelProject[]> {
        if (!novelIds || novelIds.length === 0) return [];

        const projects = await Promise.all(
            novelIds.map(id => getNovelProject(id))
        );

        return projects.filter((p): p is NovelProject => p !== undefined);
    }

    /**
     * 异步获取可供添加为参考书的所有其他小说项目。
     * @param novelMetadata - 当前正在编辑的小说的元数据。
     * @returns 可用的参考小说项目数组。
     */
    public async getAvailableReferenceNovels(novelMetadata: NovelMetadata | null): Promise<NovelProject[]> {
        const allNovels = await fetchAllNovelProjects();
        if (!novelMetadata) return allNovels;

        const currentAndReferencedIds = new Set([
            ...novelMetadata.referenceNovelIds,
            novelMetadata.id
        ]);

        return allNovels.filter(novel => !currentAndReferencedIds.has(novel.metadata.id));
    }
}

export const novelSettingsService = new NovelSettingsService();

// =
// 文件: ..\src\novel\editor\services\promptService.ts
//

import type { TreeNode, AITaskType } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

class PromptService {

    public buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }
}

export const promptService = new PromptService();

// =
// 文件: ..\src\novel\editor\services\referenceService.ts
//

import type { TreeNode, ItemNode, PlotAnalysisItem, Volume, Chapter } from '@/novel/editor/types';
import type { NovelProject } from '@/novel/editor/types/project';
import { getNovelProject } from '../api/projectApi';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class ReferenceService {

    private makeNodesReadOnly(nodes: TreeNode[]): TreeNode[] {
        return nodes.map(node => {
            const newNode: TreeNode = { ...node, isReadOnly: true };
            if (newNode.children) {
                newNode.children = this.makeNodesReadOnly(newNode.children);
            }
            if (newNode.isOverview) {
                newNode.content = `<p class="overview-placeholder">参考书中所有内容均为只读。</p>`;
            }
            return newNode;
        });
    }

    private projectToTreeNode(project: NovelProject): TreeNode {
        const rootNode: TreeNode = {
            id: `ref-book-${project.metadata.id}`,
            type: 'reference_book',
            title: project.metadata.title,
            icon: getIconByNodeType('reference_book'),
            children: []
        };

        const directoryNode: TreeNode = {
            id: `ref-dir-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '目录',
            icon: 'fa-regular fa-folder-open',
            children: this.makeNodesReadOnly(project.directoryData.map((vol: Volume) => ({
                id: vol.id,
                title: vol.title,
                type: 'reference_volume',
                icon: getIconByNodeType('reference_volume'),
                content: vol.content,
                isReadOnly: true,
                children: vol.chapters.map((chap: Chapter) => ({
                    id: chap.id,
                    title: chap.title,
                    type: 'reference_chapter',
                    icon: getIconByNodeType('reference_chapter'),
                    content: chap.content,
                    isReadOnly: true
                }))
            })))
        };
        rootNode.children?.push(directoryNode);

        const buildRefDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[] | undefined, directory: Volume[]): TreeNode[] => {
            if (!dataArray || dataArray.length === 0) return [];

            return directory.map((volume: Volume) => {
                const derivedForVolume = dataArray
                    .filter((item: PlotAnalysisItem) => item.sourceId === volume.id)
                    .map((item: PlotAnalysisItem) => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        content: item.content,
                        originalData: item
                    }));

                const derivedForChapters = volume.chapters
                    .map((chapter: Chapter) => {
                        const itemsForChapter = dataArray.filter((item: PlotAnalysisItem) => item.sourceId === chapter.id);
                        if (itemsForChapter.length === 0) return null;

                        return {
                            id: `ref-derived-group-${type}-${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            children: itemsForChapter.map((item: PlotAnalysisItem) => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                content: item.content,
                                originalData: item
                            }))
                        };
                    })
                    .filter((c: TreeNode | null): c is TreeNode => c !== null);

                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `ref-derived-group-${type}-${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v: TreeNode | null): v is TreeNode => v !== null);
        };

        const plotTree = buildRefDerivedContentTree('plot', project.derivedPlotData, project.directoryData);
        const plotNode: TreeNode = {
            id: `ref-plot-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '剧情',
            icon: getIconByNodeType('plot'),
            children: this.makeNodesReadOnly([
                ...project.plotCustomData,
                ...plotTree
            ])
        };
        if (plotNode.children && plotNode.children.length > 0) {
            rootNode.children?.push(plotNode);
        }

        const analysisTree = buildRefDerivedContentTree('analysis', project.derivedAnalysisData, project.directoryData);
        const analysisNode: TreeNode = {
            id: `ref-analysis-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '分析',
            icon: getIconByNodeType('analysis'),
            children: this.makeNodesReadOnly([
                ...project.analysisCustomData,
                ...analysisTree
            ])
        };
        if (analysisNode.children && analysisNode.children.length > 0) {
            rootNode.children?.push(analysisNode);
        }

        const settingsRoot = project.settingsData.find(n => n.id === 'setting');
        if (settingsRoot && settingsRoot.children) {
            const settingsNode: TreeNode = {
                id: `ref-settings-${project.metadata.id}`,
                type: 'reference_content_item',
                title: settingsRoot.title,
                icon: getIconByNodeType('setting'),
                children: this.makeNodesReadOnly(settingsRoot.children)
            };
            rootNode.children?.push(settingsNode);
        }

        return rootNode;
    }

    public async buildReferenceTree(referenceNovelIds: string[]): Promise<TreeNode[]> {
        if (!referenceNovelIds || referenceNovelIds.length === 0) {
            return [];
        }

        const projects = await Promise.all(
            referenceNovelIds.map(id => getNovelProject(id))
        );

        const validProjects = projects.filter((p): p is NovelProject => p !== undefined);

        return validProjects.map(project => this.projectToTreeNode(project));
    }
}

export const referenceService = new ReferenceService();

// =
// 文件: ..\src\novel\editor\services\related\nodeOperationService.ts
//

// src/novel/editor/services/related/nodeOperationService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// Private helper function
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// Private helper function
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
};

export function findNodeById(nodeId: string, allDataSources: TreeNode[][]): { node: TreeNode; parent: TreeNode | null; } | null {
    for (const source of allDataSources) {
        const result = _findNodeInTreeRecursive(source, nodeId);
        if (result) return result;
    }
    return null;
}

export function createRelatedNode(parentNode: GroupNode, type: 'group' | 'item'): GroupNode | ItemNode {
    const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
    const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
    const newNodeIcon = getIconByNodeType(newNodeType);

    if (type === 'group') {
        const newNode: GroupNode = {
            id: `group-${Date.now()}`,
            title: '新建分组',
            type: 'group',
            icon: newNodeIcon,
            children: [],
        };
        return newNode;
    } else { // type === 'item'
        const newNode: ItemNode = {
            id: `item-${Date.now()}`,
            title: '新建条目',
            type: newNodeType as ItemNode['type'],
            icon: newNodeIcon,
            content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
        };
        return newNode;
    }
}

export function createCustomNode(type: 'plot' | 'analysis' | 'others'): ItemNode {
    const itemType = type === 'others' ? 'others_item' : `${type}_item`;
    const icon = getIconByNodeType(itemType);
    const title = type === 'others' ? '新建其他条目' : '新建自定义条目';

    const newNode: ItemNode = {
        id: `custom-${type}-${Date.now()}`,
        title: title,
        type: itemType as ItemNode['type'],
        icon: icon,
        content: `<h1>${title}</h1><p>请在此处填写内容...</p>`,
    };
    return newNode;
}

export function deleteNode(nodeId: string, allDataSources: TreeNode[][]): boolean {
    for (const source of allDataSources) {
        if (_findAndRemoveNodeInTree(source, nodeId)) {
            return true;
        }
    }
    return false;
}

export function renameNode(node: TreeNode, newTitle: string) {
    if (node && !node.isReadOnly && newTitle.trim()) {
        const trimmedTitle = newTitle.trim();
        node.title = trimmedTitle;
        if ('content' in node && node.content && node.content.includes('<h1>')) {
            (node as ItemNode).content = (node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        }
        (node as any)._lastModified = Date.now(); // Update version timestamp
    }
}

export function updateNodeContent(node: ItemNode, content: string) {
    node.content = content;
    (node as any)._lastModified = Date.now(); // Update version timestamp
    if (!node.isReadOnly) {
        const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
        if (newTitle && newTitle !== node.title) {
            node.title = newTitle;
        }
    }
}

export function appendNodeContent(node: ItemNode, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    if (!node.content) node.content = "";
    node.content += htmlToAppend;
    (node as any)._lastModified = Date.now(); // Update version timestamp
}

// =
// 文件: ..\src\novel\editor\services\related\overviewService.ts
//


import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
 * @param htmlContent - HTML 字符串
 * @returns 降级后的 HTML 字符串
 */
const demoteHeadings = (htmlContent: string): string => {
    if (typeof document === 'undefined') return htmlContent; // Guard for SSR
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
    headings.forEach(heading => {
        const level = parseInt(heading.tagName.charAt(1), 10);
        const newLevel = Math.min(6, level + 1); // 最多降到 h6
        const newHeading = document.createElement(`h${newLevel}`);
        newHeading.innerHTML = heading.innerHTML;
        for (const attr of heading.attributes) {
            newHeading.setAttribute(attr.name, attr.value);
        }
        heading.parentNode?.replaceChild(newHeading, heading);
    });
    return tempDiv.innerHTML;
};


/**
 * 更新单个分组节点下的总览内容。
 * @param groupNode - 包含总览节点的父分组节点。
 */
function updateOverviewContentForGroup(groupNode: GroupNode) {
    if (!groupNode.children) return;

    const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
    if (!overviewNode) return;

    const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

    const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

    overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
}

/**
 * 遍历整个设定树，更新所有找到的总览节点。
 * @param settingsData - 设定的树形数据 (可直接修改)
 */
export function updateAllOverviewContent(settingsData: TreeNode[]) {
    const findAndProcess = (nodes: TreeNode[]) => {
        for (const node of nodes) {
            if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                updateOverviewContentForGroup(node as GroupNode);
            }
            if (node.children) {
                findAndProcess(node.children);
            }
        }
    };
    findAndProcess(settingsData);
}

// =
// 文件: ..\src\novel\editor\services\related\treeBuilderService.ts
//

// src/novel/editor/services/related/treeBuilderService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode, Volume } from '@novel/editor/types';

function buildDerivedContentTree(
    type: 'plot' | 'analysis',
    dataArray: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    return directoryData.map(volume => {
        const derivedForVolume = dataArray
            .filter(item => item.sourceId === volume.id)
            .map(item => ({
                id: item.id,
                title: item.title,
                type: `${type}_item` as ItemNode['type'],
                icon: getIconByNodeType(`${type}_item`),
                originalData: item,
                content: item.content
            }));

        const derivedForChapters = volume.chapters
            .map(chapter => {
                const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                if (derivedForChapter.length === 0) return null;

                return {
                    id: `${type}_ch_group_${chapter.id}`,
                    title: chapter.title,
                    type: 'group',
                    icon: getIconByNodeType('chapter'),
                    isReadOnly: true,
                    children: derivedForChapter.map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }))
                };
            })
            .filter((c): c is TreeNode => c !== null);

        if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
            return null;
        }

        return {
            id: `${type}_vol_group_${volume.id}`,
            title: volume.title,
            type: 'group',
            icon: getIconByNodeType('volume'),
            isReadOnly: true,
            children: [
                ...derivedForVolume,
                ...derivedForChapters
            ]
        };
    }).filter((v): v is TreeNode => v !== null);
}

/**
 * 构建完整的 "相关内容" 侧边栏树。
 */
export function buildRelatedTree(
    settingsData: TreeNode[],
    plotCustomData: TreeNode[],
    analysisCustomData: TreeNode[],
    othersCustomData: TreeNode[],
    promptTree: TreeNode[],
    plotItems: PlotAnalysisItem[],
    analysisItems: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    const plotDerivedTree = buildDerivedContentTree('plot', plotItems, directoryData);
    const analysisDerivedTree = buildDerivedContentTree('analysis', analysisItems, directoryData);

    const plotTree: RootNode = {
        id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
        children: [
            ...plotCustomData,
            ...plotDerivedTree
        ]
    };

    const analysisTree: RootNode = {
        id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
        children: [
            ...analysisCustomData,
            ...analysisDerivedTree
        ]
    };

    const othersTree: RootNode = {
        id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
        children: [
            ...promptTree,
            ...othersCustomData
        ]
    };

    return [...settingsData, plotTree, analysisTree, othersTree];
}

// =
// 文件: ..\src\novel\editor\services\searchService.ts
//

import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class SearchService {
    private get directoryStore() { return useDirectoryStore(); }
    private get relatedContentStore() { return useRelatedContentStore(); }
    private get notesStore() { return useNotesStore(); }
    private get referenceStore() { return useReferenceStore(); }

    public search(query: string): SearchResult[] {
        if (!query || query.trim().length < 1) {
            return [];
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            // 1. 检查标题是否匹配
            const titleMatch = item.title.toLowerCase().includes(lowerCaseQuery);

            // 2. 检查内容是否匹配
            let contentMatches = false;
            const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
            let match;
            const matchesForThisItem: { context: string }[] = [];

            while ((match = regex.exec(textContent)) !== null) {
                contentMatches = true;
                if (matchesForThisItem.length < 5) { // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    matchesForThisItem.push({ context: `...${context}...` });
                } else {
                    break;
                }
            }

            // 如果标题或内容任一匹配，则加入结果列表
            if(titleMatch || contentMatches){
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;

                // 如果是因为内容匹配，添加匹配片段
                if(contentMatches){
                    result.matches.push(...matchesForThisItem);
                }
                // 如果只是标题匹配，可以添加一个特殊的 "match" 来注明
                else if (titleMatch) {
                    result.matches.push({ context: `<span class="italic text-gray-500">标题匹配</span>` });
                }
            }
        };

        // 遍历所有数据源
        this.directoryStore.directoryData.forEach(vol => {
            processItem(vol);
            vol.chapters.forEach(processItem);
        });

        const flattenAndProcess = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenAndProcess(node.children);
            });
        };

        flattenAndProcess(this.relatedContentStore.relatedData);
        flattenAndProcess(this.referenceStore.referenceData);

        this.notesStore.notes.forEach(processItem);

        return Array.from(resultsMap.values());
    }
}

export const searchService = new SearchService();

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { AITaskType, AIProviderConfig } from '@novel/editor/types';
import { fetchAvailableAIProviders } from '@novel/editor/services/ai/aiService.ts';

// 定义每种任务类型默认选中的提示词ID
const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

// 定义任务配置的接口
interface TaskConfig {
    selectedPromptId: string;
    selectedAIProviderId: string;
    temperature: number;
}

export const useAIConfigStore = defineStore('aiConfig', () => {
    // State: 外部AI配置列表
    const availableAIProviders = ref<AIProviderConfig[]>([]);

    // State: 每种任务类型的具体配置，现在包含温度
    const taskConfigs = ref<Record<AITaskType, TaskConfig>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'], selectedAIProviderId: '', temperature: 0.7 },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'], selectedAIProviderId: '', temperature: 0.8 },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'], selectedAIProviderId: '', temperature: 0.5 },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'], selectedAIProviderId: '', temperature: 0.9 },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'], selectedAIProviderId: '', temperature: 0.7 },
    });

    /**
     * 从系统设置中加载用户配置的 AI 提供商
     */
    async function initializeProviders() {
        if(availableAIProviders.value.length > 0) return;

        availableAIProviders.value = await fetchAvailableAIProviders();

        const firstAvailableProviderId = availableAIProviders.value[0]?.id || '';
        for (const taskType in taskConfigs.value) {
            const config = taskConfigs.value[taskType as AITaskType];
            const isCurrentProviderAvailable = availableAIProviders.value.some(p => p.id === config.selectedAIProviderId);
            if (!isCurrentProviderAvailable) {
                config.selectedAIProviderId = firstAvailableProviderId;
            }
        }
    }

    /**
     * 更新指定任务类型选择的提示词ID
     */
    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    /**
     * 更新指定任务类型选择的AI Provider ID
     */
    const setSelectedAIProviderId = (taskType: AITaskType, providerId: string) => {
        if (taskConfigs.value[taskType] && availableAIProviders.value.some(p => p.id === providerId)) {
            taskConfigs.value[taskType].selectedAIProviderId = providerId;
        }
    };

    /**
     * 更新指定任务类型的创作温度
     */
    const setTaskTemperature = (taskType: AITaskType, temperature: number) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].temperature = Number(temperature.toFixed(2));
        }
    }

    return {
        taskConfigs,
        availableAIProviders,
        initializeProviders,
        setSelectedPromptId,
        setSelectedAIProviderId,
        setTaskTemperature,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useEditorStore } from '../editorStore';
import { useUIStore } from '../uiStore';
import { useDerivedContentStore } from '../derivedContentStore';
import * as AITaskFactory from '@/novel/editor/services/ai/AITaskFactory';
import { processQueue } from '@/novel/editor/services/ai/AITaskExecutionService';
import type { AITask, Volume, AITaskType, AITaskStatus } from '@novel/editor/types';

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    // --- State Mutation Actions ---
    const updateTaskStatus = (taskId: string, status: AITaskStatus) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = status;
        }
    };

    const updateTaskError = (taskId: string, error: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = 'failed';
            task.error = error;
        }
    };

    const appendGeneratedContent = (taskId: string, chunk: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.generatedContent += chunk;
        }
    };

    // --- Complex Actions ---
    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const newTask = await AITaskFactory.createTask(taskType, sourceItemId, finalPrompt);
        if (!newTask) return;

        tasks.value.unshift(newTask);

        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }
        nextTick(processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const completeTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.status = 'completed';

            const strategy = uiStore.uiState.taskApplicationStrategy;
            if (strategy.mode === 'auto') {
                applyChanges(taskId, true);
            } else if (strategy.mode === 'delayed') {
                task.applyAt = Date.now() + strategy.delaySeconds * 1000;
                setTimeout(() => {
                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                    if (taskAfterDelay?.status === 'completed') {
                        applyChanges(taskId, true);
                    }
                }, strategy.delaySeconds * 1000);
            }
        }
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || (task.status !== 'completed' && task.status !== 'completed_with_conflict')) return;

        const { node: sourceItem } = editorStore.findItemById(task.targetItemId);
        if (!sourceItem) {
            task.status = 'failed';
            task.error = '目标文档不存在。';
            return;
        }

        // --- 核心Bug修复：版本冲突检查 ---
        const currentVersion = (sourceItem as any)._lastModified || 0;
        if (task.sourceItemVersion < currentVersion) {
            task.status = 'completed_with_conflict';
            task.error = `内容已被修改，AI结果无法自动应用。请手动处理。`;
            console.warn(`AI Task Conflict: Task for "${task.sourceItemTitle}" cannot be applied automatically. Task version: ${task.sourceItemVersion}, Current version: ${currentVersion}`);
            return;
        }
        // --- 核心Bug修复结束 ---

        if (task.type === '分析' || task.type === '剧情生成') {
            const newItem = derivedContentStore.createAndAddDerivedItem(
                sourceItem,
                task.type,
                task.generatedContent
            );
            if (newItem) {
                editorStore.openTab(newItem.id);
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && (task.status === 'failed' || task.status === 'completed_with_conflict')) {
            // Re-create the task to get fresh content and a new version stamp
            startTask(task.type, task.sourceItemId, task.finalPrompt);
            // Remove the old, failed task
            tasks.value = tasks.value.filter(t => t.id !== taskId);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => !['applied', 'failed', 'completed_with_conflict'].includes(t.status));
    };

    const clearAllTasks = () => {
        tasks.value = [];
    };

    return {
        tasks,
        activeTasksCount,
        startTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
        updateTaskStatus,
        updateTaskError,
        appendGeneratedContent,
        completeTask
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, AIModel } from '@novel/editor/types/chatTypes';
import * as chatService from '@/novel/editor/services/ai/chatService';

export const useChatStore = defineStore('editorChat', () => {
    // --- State ---
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);
    const isLoading = ref<boolean>(false);

    // --- Getters (Computed) ---
    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    // --- Actions ---
    const fetchConversations = async () => {
        isLoading.value = true;
        try {
            conversations.value = await chatService.getConversations();
            if (conversations.value.length > 0 && !activeConversationId.value) {
                activeConversationId.value = conversations.value[0].id;
            }
        } catch (error) {
            console.error("Failed to fetch conversations:", error);
            conversations.value = [];
        } finally {
            isLoading.value = false;
        }
    };

    const createNewConversation = async () => {
        try {
            const newConv = await chatService.createConversation();
            conversations.value.unshift(newConv);
            activeConversationId.value = newConv.id;
        } catch (error) {
            console.error("Failed to create new conversation:", error);
        }
    };

    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    const sendMessage = async () => {
        const userInput = messageInput.value.trim();
        if (!userInput || !activeConversation.value || isReceiving.value) {
            return;
        }

        const currentActiveConv = activeConversation.value;
        const conversationId = currentActiveConv.id;
        messageInput.value = '';
        isReceiving.value = true;

        try {
            const { userMessage, aiResponse } = await chatService.sendMessage(conversationId, userInput);
            if (activeConversation.value?.id === conversationId) {
                currentActiveConv.messages.push(userMessage);
                currentActiveConv.messages.push(aiResponse);
            }
        } catch (error) {
            console.error("Failed to send message:", error);
        } finally {
            isReceiving.value = false;
        }
    };

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        isLoading,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', reference: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, referenceCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings, ReferenceContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const referenceContextSettings = ref<ReferenceContextSettings>({
        includeContent: true,
        includeAnalysis: false,
        includePlot: false,
        includeVolumeInfo: false,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    const setReferenceContextSetting = (key: keyof ReferenceContextSettings, value: boolean) => {
        if (key in referenceContextSettings.value) {
            referenceContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        referenceContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
        setReferenceContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: src/novel/editor/stores/derivedContentStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);

    /**
     * 从项目数据中获取派生内容。
     * @param plotData - 项目中存储的剧情数据
     * @param analysisData - 项目中存储的分析数据
     */
    function fetchDerivedData(plotData: PlotAnalysisItem[], analysisData: PlotAnalysisItem[]) {
        plotItems.value = plotData;
        analysisItems.value = analysisData;
    }

    /**
     * 根据已完成的AI任务，创建并添加一个新的、内容完整的派生内容项。
     * @param sourceNode - 源节点对象 (章节或卷)
     * @param taskType - 任务类型 ('分析' 或 '剧情生成')
     * @param generatedContent - AI生成的原始文本内容
     * @returns 新创建的派生内容项
     */
    function createAndAddDerivedItem(sourceNode: EditorItem, taskType: AITaskType, generatedContent: string): PlotAnalysisItem | null {
        if (taskType !== '分析' && taskType !== '剧情生成') return null;
        if (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume') return null;

        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        const derivedType: PlotAnalysisItem['type'] = taskType === '分析' ? 'analysis' : 'plot';
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';
        const finalTitle = `《${titlePrefix}${sourceNode.title}》${taskType} - ${timestamp}`;

        const finalContent = formatContentForEditor(finalTitle, generatedContent);

        const newItem: PlotAnalysisItem = {
            id: `${derivedType}_${now.getTime()}`,
            type: derivedType,
            sourceId: sourceNode.id,
            title: finalTitle,
            content: finalContent
        };

        if (derivedType === 'analysis') {
            analysisItems.value.unshift(newItem);
        } else {
            plotItems.value.unshift(newItem);
        }

        return newItem;
    }

    /**
     * 根据ID从所有派生项中查找。
     * @param nodeId - 派生内容的ID
     */
    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    /**
     * 更新派生内容。
     * @param nodeId - 派生内容的ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            derivedItem.content = content;
        }
    }

    /**
     * (此函数不再用于派生内容，但为保持接口一致性而保留)
     * 向派生内容追加内容。
     * @param nodeId - 派生内容的ID
     * @param contentToAppend - 要追加的原始文本
     */
    function appendNodeContent(nodeId: string, contentToAppend: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            if (!derivedItem.content) derivedItem.content = "";
            derivedItem.content += paragraphs;
        }
    }

    /**
     * 删除与指定源ID关联的所有派生数据。
     * @param sourceId - 源的ID
     */
    function deleteDerivedDataForSource(sourceId: string) {
        plotItems.value = plotItems.value.filter(item => item.sourceId !== sourceId);
        analysisItems.value = analysisItems.value.filter(item => item.sourceId !== sourceId);
    }


    return {
        plotItems,
        analysisItems,
        fetchDerivedData,
        createAndAddDerivedItem,
        findItemById,
        updateNodeContent,
        appendNodeContent,
        deleteDerivedDataForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// src/novel/editor/stores/directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { useDerivedContentStore } from './derivedContentStore';
import * as directoryService from '@/novel/editor/services/directoryService';

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);

    const fetchDirectoryData = (data: Volume[]) => {
        directoryData.value = data;
    };

    const findNodeById = (nodeId: string) => {
        return directoryService.findNodeById(directoryData.value, nodeId);
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result && (result.node.type === 'chapter' || result.node.type === 'volume')) {
            directoryService.updateNodeContent(result.node, content);
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            directoryService.appendChapterContent(result.node, contentToAppend, isAutoApplied);
        }
    };

    const addNewVolume = () => {
        const uiStore = useUIStore();
        const editorStore = useEditorStore();
        const newVolume = directoryService.createVolume();
        directoryData.value.push(newVolume);

        editorStore.setEditingNodeId(newVolume.id);
        uiStore.ensureNodeIsExpanded(newVolume.id);
    };

    const addChapterToVolume = (volumeId: string) => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const editorStore = useEditorStore();
            const uiStore = useUIStore();
            const newChapter = directoryService.createChapter();
            volume.chapters.push(newChapter);

            uiStore.ensureNodeIsExpanded(volume.id);
            editorStore.openTab(newChapter.id);
            editorStore.setEditingNodeId(newChapter.id);
        }
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const result = findNodeById(nodeId);
        if (result?.node) {
            directoryService.renameNode(result.node, newTitle);
        }
    };

    const deleteNode = (nodeId: string) => {
        const result = findNodeById(nodeId);
        if (!result) return;

        // Coordination logic: Must happen before data is deleted
        const editorStore = useEditorStore();
        const derivedContentStore = useDerivedContentStore();

        if (result.node.type === 'chapter') {
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        } else if (result.node.type === 'volume') {
            result.node.chapters.forEach(chapter => {
                derivedContentStore.deleteDerivedDataForSource(chapter.id);
            });
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        }

        // Data manipulation logic
        const wasDeleted = directoryService.deleteNode(directoryData.value, nodeId);

        // UI update logic
        if (wasDeleted) {
            editorStore.closeTab(nodeId);
            if (editorStore.editingNodeId === nodeId) editorStore.setEditingNodeId(null);
        }
    };

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts
//

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        // 1. Check for System Views
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = parts.length > 2 && (parts[1] === 'history') ? parts.slice(0, 2).join(':') : id;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                if (parts.length > 2 && (parts[1] === 'history')) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                return { node: systemView, source: 'system' };
            }
        }

        // 2. Check for AI Derived Items
        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) {
            return { node: derivedItem as PlotAnalysisItem, source: 'derived' };
        }

        // 3. Check for Prompt Templates
        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) {
            return { node: promptItem, source: 'prompt' };
        }

        // 4. Check Directory
        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        // 5. Check Related Content (Settings & Custom Items)
        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        // 6. Check Notes
        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        // 7. Check Reference Books (New)
        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { projectLoaderService } from '@novel/editor/services/novelLoaderService.ts';
import type { NovelMetadata } from '@/novel/editor/types/project';
import { useReferenceStore } from '../referenceStore';
import { updateNovelMetadata } from '../../api/metadataApi';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);
    const currentNovelId = ref<string | null>(null);

    // --- Actions (Public API for components) ---

    async function fetchNovelData(novelId: string) {
        await projectLoaderService.loadProjectIntoEditor(novelId);
    }

    async function saveMetadata() {
        if (!currentNovelId.value || !novelMetadata.value) {
            console.error("保存失败：未加载小说。");
            alert('保存失败，请查看控制台获取更多信息。');
            return;
        }

        try {
            await updateNovelMetadata(currentNovelId.value, novelMetadata.value);
            alert('小说设置已保存！');
        } catch (error) {
            console.error("保存元数据失败:", error);
            alert('保存失败，请稍后重试。');
        }
    }

    // --- State Modifiers (Internal, called by services or other actions) ---

    function _setNovelMetadata(data: NovelMetadata) {
        novelMetadata.value = JSON.parse(JSON.stringify(data));
    }

    function _setCurrentNovelId(id: string) {
        currentNovelId.value = id;
    }

    function addReferenceNovel(novelIdToAdd: string) {
        if (!novelMetadata.value || novelMetadata.value.referenceNovelIds.includes(novelIdToAdd)) {
            return;
        }
        novelMetadata.value.referenceNovelIds.push(novelIdToAdd);
        const referenceStore = useReferenceStore();
        referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
    }

    function removeReferenceNovel(novelIdToRemove: string) {
        if (!novelMetadata.value) {
            return;
        }
        const index = novelMetadata.value.referenceNovelIds.indexOf(novelIdToRemove);
        if (index > -1) {
            novelMetadata.value.referenceNovelIds.splice(index, 1);
            const referenceStore = useReferenceStore();
            referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    return {
        // State
        novelMetadata,
        currentNovelId,
        // Actions
        fetchNovelData,
        addReferenceNovel,
        removeReferenceNovel,
        removeTag,
        addTag,
        saveMetadata,
        // Internal Setters
        _setNovelMetadata,
        _setCurrentNovelId,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\systemViewStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useEditorStore } from '../editorStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const editorStore = useEditorStore();
        const activeItem = editorStore.activeTab?.item;
        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\tabStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            if (node?.type === 'volume' || node?.type === 'group') {
                uiStore.toggleNodeExpansion(itemId);
            } else if (node) {
                uiStore.toggleRelatedNodeExpansion(itemId);
            }
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { usePaneStore, type EditorPane } from '@novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@novel/editor/stores/editor-state/tabStore';
import { useItemStore } from '@novel/editor/stores/editor-state/itemStore';
import { useSystemViewStore } from '@novel/editor/stores/editor-state/systemViewStore';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { useUIStore } from './uiStore';
import type { TabInfo, EditorItem } from '@/novel/editor/types';

export { EditorPane };

export const useEditorStore = defineStore('editor-facade', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    const splitPane = (sourcePaneId: string) => {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    };

    /**
     * 更新指定ID项目的内容，并自动更新其版本时间戳。
     * @param id - 项目的ID
     * @param content - 新的HTML内容
     */
    const updateItemContentById = (id: string, content: string) => {
        itemStore.updateItemContentById(id, content);
        const { node } = itemStore.findItemById(id);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    };

    /**
     * 向指定ID项目追加内容，并自动更新其版本时间戳。
     * @param itemId - 项目的ID
     * @param content - 要追加的HTML内容
     * @param auto - 是否为AI自动应用
     */
    const appendContentToItem = (itemId: string, content: string, auto: boolean) => {
        itemStore.appendContentToItem(itemId, content, auto);
        const { node } = itemStore.findItemById(itemId);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    };

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        splitPane,
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab: tabStore.openTab,
        closeTab: tabStore.closeTab,
        findItemById: itemStore.findItemById,
        updateItemContentById,
        appendContentToItem,
        toggleAIPanel: systemViewStore.toggleAIPanel,
        ensureAIPanelIsOpen: systemViewStore.ensureAIPanelIsOpen,
        toggleHistoryPanel: systemViewStore.toggleHistoryPanel,
        openReaderView: systemViewStore.openReaderView,
        fetchNovelData: metadataStore.fetchNovelData,
        getTabsForPane,
        getActiveTabForPane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { noteService } from '@/novel/editor/services/noteService';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);

    const fetchNotes = (data: NoteItem[]) => {
        notes.value = data;
    };

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);
        if (noteIndex === -1) return;

        const originalNote = notes.value[noteIndex];
        const updatedNote = noteService.updateNoteWithNewContent(originalNote, content);
        notes.value.splice(noteIndex, 1, updatedNote);
        (notes.value[noteIndex] as any)._lastModified = Date.now(); // Update version timestamp
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = noteService.appendContentToNote(note.content, contentToAppend, isAutoApplied);
            (note as any)._lastModified = Date.now(); // Update version timestamp
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const uiStore = useUIStore();
        const noteIndex = notes.value.findIndex(n => n.id === noteId);

        if (noteIndex !== -1 && newTitle.trim()) {
            const originalNote = notes.value[noteIndex];
            const trimmedTitle = newTitle.trim();
            const updatedNote = noteService.renameNote(originalNote, trimmedTitle);
            notes.value.splice(noteIndex, 1, updatedNote);
            (notes.value[noteIndex] as any)._lastModified = Date.now(); // Update version timestamp
        }
        uiStore.setEditingNodeId(null);
    };

    const addNote = (title: string, content: string = '') => {
        const editorStore = useEditorStore();
        const uiStore = useUIStore();

        const newNote = noteService.createNote(title, content);
        notes.value.unshift(newNote);

        editorStore.openTab(newNote.id);
        uiStore.setEditingNodeId(newNote.id);
    };

    const deleteNote = (noteId: string) => {
        const editorStore = useEditorStore();
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            notes.value.splice(index, 1);
            editorStore.closeTab(noteId);
        }
    };

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\novelSettingsStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { novelSettingsService } from '@/novel/editor/services/novelSettingsService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

export const useNovelSettingsStore = defineStore('novel-settings', () => {
    const metadataStore = useMetadataStore();

    const novelMetadata = ref<NovelMetadata | null>(null);
    const referencedNovels = ref<NovelProject[]>([]);
    const availableReferenceNovels = ref<NovelProject[]>([]);

    /**
     * Asynchronously loads and populates all data needed for the settings view.
     */
    async function loadSettingsData() {
        const meta = metadataStore.novelMetadata;
        novelMetadata.value = meta;
        if (meta) {
            referencedNovels.value = await novelSettingsService.getReferencedNovels(meta.referenceNovelIds);
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(meta);
        } else {
            referencedNovels.value = [];
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(null);
        }
    }

    const addReferenceNovel = async (novelId: string) => {
        if (!novelId) return;
        metadataStore.addReferenceNovel(novelId);
        await loadSettingsData();
    };

    const removeReferenceNovel = async (novelId: string) => {
        metadataStore.removeReferenceNovel(novelId);
        await loadSettingsData();
    };

    const addTag = () => {
        metadataStore.addTag();
    };

    const removeTag = (index: number) => {
        metadataStore.removeTag(index);
    };

    const saveMetadata = () => {
        metadataStore.saveMetadata();
    };

    const resetMetadata = async () => {
        if (metadataStore.currentNovelId) {
            await metadataStore.fetchNovelData(metadataStore.currentNovelId);
        }
    };

    return {
        novelMetadata,
        referencedNovels,
        availableReferenceNovels,
        loadSettingsData,
        addReferenceNovel,
        removeReferenceNovel,
        addTag,
        removeTag,
        saveMetadata,
        resetMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { promptService } from '@/novel/editor/services/promptService';
import { useAIConfigStore } from './ai/aiConfigStore';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    // State: Use a simple ref, not a computed property, for the main data tree.
    const promptTree = ref<TreeNode[]>([]);

    /**
     * Action to initialize the prompt tree if it's empty.
     * This should be called once when the editor loads.
     */
    function initialize() {
        if (promptTree.value.length === 0) {
            promptTree.value = promptService.buildInitialTree();
        }
    }

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = promptTree.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        if (!promptTree.value[0]?.children) return null;
        for (const group of promptTree.value[0].children) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPrompt(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = promptTree.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newNode: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newNode);
        return newNode;
    }

    function renamePrompt(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result && newTitle.trim()) {
            result.prompt.title = newTitle.trim();
        }
    }

    function deletePrompt(promptId: string): boolean {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            const index = group.children.findIndex(p => p.id === promptId);
            if (index > -1) {
                group.children.splice(index, 1);

                if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                    aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
                }
                return true;
            }
        }
        return false;
    }

    function updatePromptContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }

    return {
        promptTree,
        initialize,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPrompt,
        renamePrompt,
        deletePrompt,
        updatePromptContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { referenceService } from '@/novel/editor/services/referenceService';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const loadReferences = async (referenceNovelIds: string[]) => {
        referenceData.value = await referenceService.buildReferenceTree(referenceNovelIds);
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        loadReferences,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import * as nodeOperationService from '@/novel/editor/services/related/nodeOperationService';
import * as treeBuilderService from '@/novel/editor/services/related/treeBuilderService';
import { updateAllOverviewContent } from '@/novel/editor/services/related/overviewService';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode, ItemNode, GroupNode } from '@/novel/editor/types';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    // --- State ---
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<TreeNode[]>([]);
    const analysisCustomData = ref<TreeNode[]>([]);
    const othersCustomData = ref<TreeNode[]>([]);

    // --- Dependencies ---
    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    // --- Computed ---
    const relatedData = computed(() => {
        // Filter out derived items whose source has been deleted
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        const validPlotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        const validAnalysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        return treeBuilderService.buildRelatedTree(
            settingsData.value,
            plotCustomData.value,
            analysisCustomData.value,
            othersCustomData.value,
            promptTemplateStore.promptTree,
            validPlotItems,
            validAnalysisItems,
            directoryStore.directoryData
        );
    });

    const allDataSources = computed(() => [
        settingsData.value,
        plotCustomData.value,
        analysisCustomData.value,
        othersCustomData.value
    ]);

    // --- Watchers ---
    watch(settingsData, (newData) => {
        updateAllOverviewContent(newData);
    }, { deep: true });

    // --- Actions ---
    function fetchRelatedData(settings: any[], plot: any[], analysis: any[], others: any[]) {
        promptTemplateStore.initialize();
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
        othersCustomData.value = others;
    }

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        return nodeOperationService.findNodeById(nodeId, allDataSources.value);
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.updateNodeContent(result.node as ItemNode, content);
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.appendNodeContent(result.node as ItemNode, contentToAppend, isAutoApplied);
        }
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            nodeOperationService.renameNode(result.node, newTitle);
        }
    }

    // --- Action: Add ---
    function addRelatedNode(parentId: string, type: 'group' | 'item') {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return;

        const parentNode = result.node as GroupNode;
        const newNode = nodeOperationService.createRelatedNode(parentNode, type);
        parentNode.children.push(newNode);

        uiStore.ensureRelatedNodeIsExpanded(parentId);
        uiStore.setEditingNodeId(newNode.id);
        if (newNode.type.endsWith('_item')) {
            editorStore.openTab(newNode.id);
        }
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis') {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode = nodeOperationService.createCustomNode(target);
        dataRef.value.unshift(newNode);

        uiStore.ensureRelatedNodeIsExpanded(target);
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    function addCustomOthersNode() {
        const newNode = nodeOperationService.createCustomNode('others');
        othersCustomData.value.unshift(newNode);
        uiStore.ensureRelatedNodeIsExpanded('others');
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    // --- Action: Delete ---
    function deleteNode(nodeId: string): boolean {
        const wasRemoved = nodeOperationService.deleteNode(nodeId, allDataSources.value);
        if (wasRemoved) {
            editorStore.closeTab(nodeId);
        }
        return wasRemoved;
    }
    const deleteRelatedNode = deleteNode;
    const deleteCustomRelatedNode = deleteNode;
    const deleteCustomOthersNode = deleteNode;

    // --- Actions with specific naming for context menus ---
    const renameCustomRelatedNode = renameRelatedNode;
    const renameCustomOthersNode = renameRelatedNode;

    return {
        // State & Computed
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        // Actions
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult } from '@/novel/editor/types';
import { searchService } from '@/novel/editor/services/searchService';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const performSearch = (query: string) => {
        hasSearched.value = true;
        lastSearchedQuery.value = query;
        results.value = searchService.search(query);
    };

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\ai.ts
//

/**
 * AI 任务状态
 * - pending: 等待执行
 * - processing: 正在执行
 * - completed: 已完成，等待应用
 * - completed_with_conflict: 已完成，但源文档已被修改，等待用户处理
 * - applied: 已应用
 * - failed: 执行失败
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'completed_with_conflict' | 'applied' | 'failed';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 提供商（模型）配置
 */
export interface AIProviderConfig {
    id: string;
    name: string;
    model: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string;
    sourceItemContent: string;
    sourceItemVersion: number;
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
    applyAt?: number;
    aiConfig: AIProviderConfig;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string;
    title: string;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//

export * from './models';
export * from './chatTypes';
export * from './ui';
export * from './ai';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: TreeNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\project.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata as BaseNovelMetadata,
    TreeNode,
    ItemNode,
    PlotAnalysisItem,
} from '@/novel/editor/types';

export interface NovelMetadata extends BaseNovelMetadata {
    referenceNovelIds: string[];
}

export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    derivedPlotData: PlotAnalysisItem[];
    derivedAnalysisData: PlotAnalysisItem[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
}

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: src/novel/editor/utils/iconUtils.ts

const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\editor\views\EditorWorkspaceView.vue
//

import { ref, onMounted, onBeforeUnmount } from 'vue';
import { useRoute } from 'vue-router';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ActivityBar from '@/novel/editor/components/layout/ActivityBar.vue';
import SidebarPanel from '@/novel/editor/components/sidebar/SidebarPanel.vue';
import MainPane from '@/novel/editor/components/content/MainPane.vue';
import StatusBar from '@/novel/editor/components/layout/StatusBar.vue';
import ManageMenu from '@/novel/editor/components/layout/ManageMenu.vue';

type ActivityTabId = 'directory' | 'related' | 'notes' | 'references';
type ActionId = 'system:search' | 'system:ai_chat' | string;

const editorStore = useEditorStore();
const uiStore = useUIStore();
const route = useRoute();

const activeActivityBarTab = ref<ActivityTabId | null>('directory');
const isSidebarVisible = ref(true);
const manageMenuRef = ref<InstanceType<typeof ManageMenu> | null>(null);

// --- Resizing Logic ---
const sidebarPanelWidth = ref(320);
const isResizing = ref(false);

const startResize = (event: MouseEvent) => {
  isResizing.value = true;
  const startWidth = sidebarPanelWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    if (!isResizing.value) return;
    const dx = e.clientX - startX;
    const newWidth = startWidth + dx;
    sidebarPanelWidth.value = Math.max(240, Math.min(newWidth, 600));
  };

  const stopResize = () => {
    isResizing.value = false;
    window.removeEventListener('mousemove', handleResize);
    window.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  };

  window.addEventListener('mousemove', handleResize);
  window.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

const handleSelectActivityTab = (tabId: ActivityTabId) => {
  if (activeActivityBarTab.value === tabId && isSidebarVisible.value) {
    isSidebarVisible.value = false;
    activeActivityBarTab.value = null;
  } else {
    isSidebarVisible.value = true;
    activeActivityBarTab.value = tabId;
  }
};

const handleTriggerAction = (actionId: ActionId) => {
  editorStore.openTab(actionId);
}

const showManageMenu = (event: MouseEvent) => {
  manageMenuRef.value?.show(event.currentTarget as HTMLElement);
};

const handleMenuAction = (actionId: ActionId) => {
  if (actionId.startsWith('system:')) {
    editorStore.openTab(actionId);
  } else {
    // Handle other menu actions like 'keyboard_shortcuts' etc.
    alert(`Action '${actionId}' selected. Implementation pending.`);
  }
};

onMounted(() => {
  const novelId = route.query.id as string;
  if (novelId) {
    editorStore.fetchNovelData(novelId);
  } else {
    // Fallback or error handling
    console.warn("No novel ID provided in URL, loading default or showing error.");
    editorStore.fetchNovelData('novel-1'); // Fallback to a default novel
  }
});

onBeforeUnmount(() => {
  // A safeguard to ensure listeners are removed if component is unmounted during resize
  if (isResizing.value) {
    const emptyFn = () => {};
    window.removeEventListener('mousemove', emptyFn);
    window.removeEventListener('mouseup', emptyFn);
  }
});

// =
// 文件: ..\src\novel\editor\views\ReaderModeOverlay.vue
//

import { computed } from 'vue';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';

const uiStore = useUIStore();

const isVisible = computed(() => uiStore.isReaderModeVisible);
const item = computed(() => uiStore.readerModeItem);

const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

// =
// 文件: ..\src\novel\editor\views\SearchView.vue
//

import { ref, watch } from 'vue';
import { useSearchStore } from '@novel/editor/stores/searchStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';

const searchStore = useSearchStore();
const editorStore = useEditorStore();
const expandedResultIds = ref(new Set<string>());

let debounceTimer: number | undefined;

watch(() => searchStore.searchQuery, (newQuery) => {
  clearTimeout(debounceTimer);
  if (!newQuery.trim()) {
    searchStore.clearSearch();
    return;
  }
  debounceTimer = window.setTimeout(() => {
    expandedResultIds.value.clear(); // Clear old expansions
    searchStore.performSearch(newQuery);
    // Do not auto-expand results to match the new UI. Let the user decide.
  }, 300); // 300ms debounce delay
});

const handleResultClick = (itemId: string) => {
  editorStore.openTab(itemId);
};

const toggleExpansion = (resultId: string) => {
  if (expandedResultIds.value.has(resultId)) {
    expandedResultIds.value.delete(resultId);
  } else {
    expandedResultIds.value.add(resultId);
  }
};

