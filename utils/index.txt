// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\dashboard\api\dashboardApi.ts
//

import apiClient from '@/api/client';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';

/**
 * 从后端获取小说仪表盘列表
 * @returns 返回小说项目摘要列表
 */
export const fetchNovels = async (): Promise<NovelDashboardItem[]> => {
    const response = await apiClient.get('/novels');
    return response.data;
};

/**
 * 创建一本新的小说
 * @param data - 创建小说所需的数据
 * @returns 返回新创建的小说项目摘要
 */
export const createNovel = async (data: { title: string; synopsis: string; category: NovelCategory }): Promise<NovelDashboardItem> => {
    const response = await apiClient.post('/novels', data);
    return response.data;
};

/**
 * 获取所有可用的小说分类
 * @returns 返回分类名称数组
 */
export const fetchAvailableCategories = async (): Promise<NovelCategory[]> => {
    const response = await apiClient.get('/novels/categories');
    return response.data;
};

/**
 * 将指定ID的小说移至回收站
 * @param novelId - 要删除的小说ID
 */
export const moveToTrash = async (novelId: string): Promise<void> => {
    await apiClient.delete(`/novels/${novelId}`);
};

// =
// 文件: ..\src\novel\dashboard\api\recentApi.ts
//

import apiClient from '@/api/client';
import type { RecentActivityItem } from '@/novel/types';

/**
 * 获取最近活动列表
 * @returns 返回最近活动项目列表
 */
export const fetchRecentItems = async (): Promise<RecentActivityItem[]> => {
    const response = await apiClient.get('/recent-items');
    return response.data;
};

/**
 * 记录一次小说访问活动
 * @param novelId - 被访问的小说ID
 * @returns 返回新创建的活动记录
 */
export const logRecentAccess = async (novelId: string): Promise<RecentActivityItem> => {
    const response = await apiClient.post('/recent-items', { novelId });
    return response.data;
};

// =
// 文件: ..\src\novel\dashboard\api\trashApi.ts
//

import apiClient from '@/api/client';
import type { DeletedItem, NovelDashboardItem } from '@/novel/types';

/**
 * 获取回收站中的项目列表
 * @returns 返回已删除项目列表
 */
export const fetchTrashedItems = async (): Promise<DeletedItem[]> => {
    const response = await apiClient.get('/trash/novels');
    return response.data;
};

/**
 * 从回收站恢复指定的项目
 * @param itemId - 要恢复的项目ID
 * @returns 返回恢复后的小说摘要信息
 */
export const restoreItem = async (itemId: string): Promise<NovelDashboardItem> => {
    const response = await apiClient.post(`/trash/novels/${itemId}/restore`);
    return response.data;
};

/**
 * 从回收站永久删除指定的项目
 * @param itemId - 要永久删除的项目ID
 */
export const deleteItemPermanently = async (itemId: string): Promise<void> => {
    await apiClient.delete(`/trash/novels/${itemId}`);
};

// =
// 文件: ..\src\novel\dashboard\config\sidebar.config.ts
//


export interface NavItem {
    name: string;
    path: string;
    icon: string;
}

export const mainNavItems: NavItem[] = [
    {
        name: '我的小说',
        path: '/novel/dashboard',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>`
    },
    {
        name: '最近编辑',
        path: '/novel/recent',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>`
    },
    {
        name: '回收站',
        path: '/novel/trash',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>`
    },
    {
        name: '导出小说',
        path: '/novel/export',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>`
    }
];

// =
// 文件: ..\src\novel\dashboard\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const dashboardRoutes: Array<RouteRecordRaw> = [
    {
        path: 'dashboard',
        name: 'NovelDashboard',
        component: () => import('@/novel/dashboard/views/DashboardView.vue'),
        meta: { title: '我的小说' }
    },
    {
        path: 'recent',
        name: 'NovelRecent',
        component: () => import('@/novel/dashboard/views/RecentView.vue'),
        meta: { title: '最近编辑' }
    },
    {
        path: 'trash',
        name: 'NovelTrash',
        component: () => import('@/novel/dashboard/views/TrashView.vue'),
        meta: { title: '回收站' }
    },
    {
        path: 'import',
        name: 'NovelImport',
        component: () => import('@/novel/dashboard/views/ImportView.vue'),
        meta: { title: '导入小说' }
    },
    {
        path: 'new',
        name: 'NovelNew',
        component: () => import('@/novel/dashboard/views/NewNovelView.vue'),
        meta: { title: '新建小说' }
    },
    {
        path: 'export',
        name: 'NovelExport',
        component: () => import('@/novel/dashboard/views/ExportView.vue'),
        meta: { title: '导出小说' }
    },
]

// =
// 文件: ..\src\novel\dashboard\services\novelService.ts
//

import * as dashboardApi from '../api/dashboardApi';
import type { NovelCategory, NovelDashboardItem } from '@/novel/types';

export const fetchNovels = (): Promise<NovelDashboardItem[]> => {
    return dashboardApi.fetchNovels();
};

export const createNovel = (data: { title: string; synopsis: string; category: NovelCategory }): Promise<NovelDashboardItem> => {
    return dashboardApi.createNovel(data);
};

export const fetchAvailableCategories = (): Promise<NovelCategory[]> => {
    return dashboardApi.fetchAvailableCategories();
};

export const moveToTrash = (novelId: string): Promise<void> => {
    return dashboardApi.moveToTrash(novelId);
};

// =
// 文件: ..\src\novel\dashboard\services\recentService.ts
//

import * as recentApi from '../api/recentApi';
import type { RecentActivityItem } from '@/novel/types';

export const fetchRecentItems = (): Promise<RecentActivityItem[]> => {
    return recentApi.fetchRecentItems();
};

export const logRecentAccess = (novelId: string): Promise<RecentActivityItem> => {
    return recentApi.logRecentAccess(novelId);
};

// =
// 文件: ..\src\novel\dashboard\services\trashService.ts
//

import * as trashApi from '../api/trashApi';
import type { DeletedItem, NovelDashboardItem } from '@/novel/types';

export const fetchTrashedItems = (): Promise<DeletedItem[]> => {
    return trashApi.fetchTrashedItems();
};

export const restoreItem = (itemId: string): Promise<NovelDashboardItem> => {
    return trashApi.restoreItem(itemId);
};

export const deleteItemPermanently = (itemId: string): Promise<void> => {
    return trashApi.deleteItemPermanently(itemId);
};

// =
// 文件: ..\src\novel\dashboard\stores\novelStore.ts
//

// src/novel/dashboard/stores/novelStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';
import * as novelService from '@/novel/dashboard/services/novelService';

export const useNovelStore = defineStore('novel-dashboard-novels', () => {
    const novels = ref<NovelDashboardItem[]>([]);
    const availableCategories = ref<NovelCategory[]>([]);
    const searchQuery = ref('');
    const selectedCategory = ref<NovelCategory | '全部类型'>('全部类型');
    const isLoading = ref(false);

    const filteredNovels = computed(() => {
        return novels.value.filter(novel => {
            const matchesCategory = selectedCategory.value === '全部类型' || novel.category === selectedCategory.value;
            const matchesSearch = novel.title.toLowerCase().includes(searchQuery.value.toLowerCase()) || novel.tags.some(tag => tag.text.toLowerCase().includes(searchQuery.value.toLowerCase()));
            return matchesCategory && matchesSearch;
        });
    });

    const fetchNovels = async () => {
        isLoading.value = true;
        try {
            novels.value = await novelService.fetchNovels();
        } catch (error) {
            console.error('Failed to fetch novels:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const fetchCategories = async () => {
        try {
            availableCategories.value = await novelService.fetchAvailableCategories();
        } catch (error) {
            console.error('Failed to fetch categories:', error);
        }
    };

    const initializeDashboard = () => {
        fetchNovels();
        fetchCategories();
    };

    const addNovel = (newNovel: NovelDashboardItem) => {
        novels.value.unshift(newNovel);
    };

    const createNovel = async (data: { title: string; synopsis: string; category: NovelCategory }) => {
        try {
            const newNovel = await novelService.createNovel(data);
            addNovel(newNovel);
        } catch (error) {
            console.error('Failed to create novel:', error);
            // 这里可以添加用户反馈，例如弹窗提示
        }
    };

    const deleteNovel = async (novelId: string) => {
        try {
            await novelService.moveToTrash(novelId);
            const index = novels.value.findIndex(n => n.id === novelId);
            if (index !== -1) {
                novels.value.splice(index, 1);
            }
        } catch (error) {
            console.error('Failed to delete novel:', error);
        }
    };

    return {
        novels,
        searchQuery,
        selectedCategory,
        filteredNovels,
        availableCategories,
        isLoading,
        initializeDashboard,
        fetchNovels,
        addNovel,
        createNovel,
        deleteNovel,
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\recentStore.ts
//

// src/novel/dashboard/stores/recentStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, RecentActivityItem } from '@/novel/types';
import * as recentService from '@/novel/dashboard/services/recentService';
import { formatDistanceToNowStrict } from 'date-fns';
import { zhCN } from 'date-fns/locale';

const RECENTS_QUEUE_LIMIT = 10;

const formatTimeAgo = (isoString: string): string => {
    const date = new Date(isoString);
    const diff = new Date().getTime() - date.getTime();
    if (diff < 60000) { // 1分钟内
        return '刚刚';
    }
    return formatDistanceToNowStrict(date, { addSuffix: true, locale: zhCN });
};

export const useRecentStore = defineStore('novel-dashboard-recent', () => {
    const recentItems = ref<RecentActivityItem[]>([]);
    const isLoading = ref(false);

    const groupedRecentItems = computed(() => {
        const groups: { period: string; items: RecentActivityItem[] }[] = [];
        if (recentItems.value.length === 0) return groups;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);

        const sortedItems = [...recentItems.value].sort((a, b) => new Date(b.editedAt).getTime() - new Date(a.editedAt).getTime());

        sortedItems.forEach(item => {
            item.formattedTime = formatTimeAgo(item.editedAt);
        });

        const todayItems: RecentActivityItem[] = [];
        const yesterdayItems: RecentActivityItem[] = [];
        const earlierItems: RecentActivityItem[] = [];

        sortedItems.forEach(item => {
            const itemDate = new Date(item.editedAt);
            itemDate.setHours(0, 0, 0, 0);

            if (itemDate.getTime() === today.getTime()) {
                todayItems.push(item);
            } else if (itemDate.getTime() === yesterday.getTime()) {
                earlierItems.push(item);
            } else {
                earlierItems.push(item);
            }
        });

        if (todayItems.length > 0) groups.push({ period: '今天', items: todayItems });
        if (yesterdayItems.length > 0) groups.push({ period: '昨天', items: yesterdayItems });
        if (earlierItems.length > 0) groups.push({ period: '更早', items: earlierItems });

        return groups;
    });

    const fetchRecentItems = async () => {
        isLoading.value = true;
        try {
            recentItems.value = await recentService.fetchRecentItems();
        } catch (error) {
            console.error('Failed to fetch recent items:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const logRecentAccess = async (novel: NovelDashboardItem) => {
        try {
            // 先从列表中移除旧的记录（如果存在）
            const existingIndex = recentItems.value.findIndex(item => item.novelId === novel.id);
            if (existingIndex !== -1) {
                recentItems.value.splice(existingIndex, 1);
            }

            // 调用Service记录访问，并获取最新的活动项
            const newActivity = await recentService.logRecentAccess(novel.id);

            // 将新活动添加到列表顶部
            recentItems.value.unshift(newActivity);

            // 保持列表长度限制
            if (recentItems.value.length > RECENTS_QUEUE_LIMIT) {
                recentItems.value.pop();
            }
        } catch (error) {
            console.error('Failed to log recent access:', error);
        }
    };

    return {
        recentItems,
        isLoading,
        groupedRecentItems,
        fetchRecentItems,
        logRecentAccess,
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\trashStore.ts
//

// src/novel/dashboard/stores/trashStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { DeletedItem } from '@/novel/types';
import * as trashService from '@/novel/dashboard/services/trashService';
import { useNovelStore } from './novelStore';

export const useTrashStore = defineStore('novel-dashboard-trash', () => {
    const trashedItems = ref<DeletedItem[]>([]);
    const isLoading = ref(false);

    const fetchTrashedItems = async () => {
        isLoading.value = true;
        try {
            trashedItems.value = await trashService.fetchTrashedItems();
        } catch (error) {
            console.error('Failed to fetch trashed items:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const restoreItem = async (itemId: string) => {
        try {
            const restoredNovel = await trashService.restoreItem(itemId);

            // 从回收站列表中移除
            const index = trashedItems.value.findIndex(item => item.id === itemId);
            if (index !== -1) {
                trashedItems.value.splice(index, 1);
            }

            // 将恢复的小说添加回主列表
            const novelStore = useNovelStore();
            novelStore.addNovel(restoredNovel);

        } catch (error){
            console.error('Failed to restore item:', error);
            alert('恢复失败，请稍后重试。');
        }
    };

    const deleteItemPermanently = async (itemId: string) => {
        if (confirm(`您确定要永久删除这个项目吗？此操作无法撤销。`)) {
            try {
                await trashService.deleteItemPermanently(itemId);
                const index = trashedItems.value.findIndex(item => item.id === itemId);
                if (index > -1) {
                    trashedItems.value.splice(index, 1);
                }
            } catch (error) {
                console.error('Failed to permanently delete item:', error);
                alert('永久删除失败，请稍后重试。');
            }
        }
    };

    return {
        trashedItems,
        isLoading,
        fetchTrashedItems,
        restoreItem,
        deleteItemPermanently
    };
});

// =
// 文件: ..\src\novel\dashboard\views\DashboardView.vue
//

import { onMounted, onBeforeUnmount, ref } from 'vue';
import { storeToRefs } from 'pinia';
import { useNovelStore } from '@/novel/dashboard/stores/novelStore';
import { useRecentStore } from '@/novel/dashboard/stores/recentStore';
import type { NovelDashboardItem } from '@/novel/types';

const novelStore = useNovelStore();
const recentStore = useRecentStore();
const {
  filteredNovels,
  availableCategories,
  searchQuery,
  selectedCategory
} = storeToRefs(novelStore);

const activeDropdown = ref<string | null>(null);

const toggleDropdown = (novelId: string) => {
  activeDropdown.value = activeDropdown.value === novelId ? null : novelId;
};

const closeDropdown = () => {
  activeDropdown.value = null;
};

const handleDeleteNovel = (novelId: string) => {
  if (confirm('您确定要将这本小说移至回收站吗？')) {
    novelStore.deleteNovel(novelId);
    closeDropdown();
  }
};

const handleNovelClick = (novel: NovelDashboardItem) => {
  recentStore.logRecentAccess(novel);
};

onMounted(() => {
  novelStore.initializeDashboard(); // Use the dedicated initialization action
  window.addEventListener('click', (e) => {
    if (!(e.target as HTMLElement).closest('.relative')) {
      closeDropdown();
    }
  });
});

onBeforeUnmount(() => {
  window.removeEventListener('click', closeDropdown);
});

// =
// 文件: ..\src\novel\dashboard\views\ExportView.vue
//

import { ref } from 'vue';

const selectedFormat = ref('pdf');

// =
// 文件: ..\src\novel\dashboard\views\ImportView.vue
//

import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useNovelStore } from '@/novel/dashboard/stores/novelStore';
import { importNovelProject } from '@/novel/services/novelProjectService';
import { parseNovelText } from '@/novel/importer/services/novelParser';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';

const router = useRouter();
const novelStore = useNovelStore();

const fileInput = ref<HTMLInputElement | null>(null);
const fileName = ref('');
const uploadedFileContent = ref<string | null>(null);
const dragOver = ref(false);
const chaptersPerVolume = ref(10);
const selectedCategory = ref<NovelCategory>('都市');
const availableCategories: NovelCategory[] = ['科幻', '奇幻', '悬疑', '恐怖', '都市', '言情', '历史'];

const triggerFileSelect = () => {
  fileInput.value?.click();
};

const handleFileSelect = (event: Event) => {
  const target = event.target as HTMLInputElement;
  const file = target.files?.[0];
  if (file) {
    readFile(file);
  }
};

const handleFileDrop = (event: DragEvent) => {
  dragOver.value = false;
  const file = event.dataTransfer?.files?.[0];
  if (file && (file.type === 'text/plain' || file.type === 'text/markdown')) {
    readFile(file);
  } else {
    alert('请拖放 .txt 或 .md 文件');
  }
};

const readFile = (file: File) => {
  fileName.value = file.name;
  const reader = new FileReader();
  reader.onload = (e) => {
    uploadedFileContent.value = e.target?.result as string;
  };
  reader.onerror = () => {
    alert('文件读取失败');
    uploadedFileContent.value = null;
    fileName.value = '';
  };
  reader.readAsText(file);
};

const handleImport = async () => {
  if (!uploadedFileContent.value) {
    alert('没有文件内容可供导入。');
    return;
  }
  if (!selectedCategory.value) {
    alert('请选择小说分类。');
    return;
  }

  try {
    const directoryData = parseNovelText(uploadedFileContent.value, {
      chaptersPerVolume: chaptersPerVolume.value || 10,
    });

    const novelTitle = fileName.value.replace(/\.(txt|md)$/i, '') || '导入的小说';

    const newProject = await importNovelProject({
      title: novelTitle,
      description: '从文件导入的小说',
      category: selectedCategory.value,
      directoryData,
    });

    const newNovelForDashboard: NovelDashboardItem = {
      id: newProject.metadata.id,
      title: newProject.metadata.title,
      description: newProject.metadata.description,
      category: selectedCategory.value,
      cover: newProject.metadata.cover,
      status: { text: '编辑中', class: 'bg-green-500/90' },
      tags: newProject.metadata.tags,
      chapters: directoryData.reduce((acc, vol) => acc + vol.chapters.length, 0),
      lastUpdated: '刚刚',
    };
    novelStore.addNovel(newNovelForDashboard);

    router.push(`/novel/editor?id=${newProject.metadata.id}`);
  } catch (error) {
    console.error('Failed to import novel:', error);
    alert('导入失败，请检查文件内容或联系管理员。');
  }
};

// =
// 文件: ..\src\novel\dashboard\views\NewNovelView.vue
//

import { reactive } from 'vue';
import { useRouter } from 'vue-router';
import { useNovelStore } from '@/novel/dashboard/stores/novelStore';
import type { NovelCategory } from '@/novel/types';

const novelStore = useNovelStore();
const router = useRouter();

const newNovelData = reactive({
  title: '',
  synopsis: '',
  category: '' as NovelCategory | '',
});

const handleCreateNovel = () => {
  if (!newNovelData.title || !newNovelData.category) {
    alert('请填写小说标题和分类');
    return;
  }
  novelStore.createNovel(newNovelData as { title: string; synopsis: string; category: NovelCategory });
  router.push('/novel/dashboard');
};

// =
// 文件: ..\src\novel\dashboard\views\RecentView.vue
//

import { onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useRecentStore } from '@/novel/dashboard/stores/recentStore';

const recentStore = useRecentStore();
const { groupedRecentItems } = storeToRefs(recentStore);

onMounted(() => {
  recentStore.fetchRecentItems();
});

// =
// 文件: ..\src\novel\dashboard\views\TrashView.vue
//

import { onMounted } from 'vue';
import { useTrashStore } from '@/novel/dashboard/stores/trashStore';

const trashStore = useTrashStore();

onMounted(() => {
  trashStore.fetchTrashedItems();
});

// =
// 文件: ..\src\novel\editor\api\aiApi.ts
//

// 文件: ..\src\novel\editor\api\aiApi.ts
import { useAuthStore } from '@/auth/store/auth.store';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';

export const streamAITask = async (
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: {
        onChunk: (chunk: string) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    const { onChunk, onComplete, onError } = callbacks;
    let reader: ReadableStreamDefaultReader<string> | undefined;

    try {
        const authStore = useAuthStore();
        const token = authStore.token;
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch('/api/ai/tasks/stream', {
            method: 'POST',
            headers,
            body: JSON.stringify({ prompt, config, taskType, sourceItemTitle })
        });

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        if (!response.body) throw new Error('Response body is null.');

        reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
        let buffer = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += value;
            let boundaryIndex;
            while ((boundaryIndex = buffer.indexOf('\n\n')) >= 0) {
                const messageBlock = buffer.substring(0, boundaryIndex);
                buffer = buffer.substring(boundaryIndex + 2);

                if (messageBlock) {
                    const eventData = messageBlock.split('\n')
                        .find(line => line.startsWith('data:'))
                        ?.substring(5).trim();

                    if (eventData) {
                        try {
                            const parsedData = JSON.parse(eventData);
                            if (parsedData.event === 'chunk' && parsedData.content) onChunk(parsedData.content);
                            else if (parsedData.event === 'done') { onComplete(); return; }
                            else if (parsedData.event === 'error') { onError(parsedData.error || 'Unknown error'); return; }
                        } catch (e) { console.error("Failed to parse SSE data JSON:", eventData, e); }
                    }
                }
            }
        }
        onComplete();
    } catch (error) {
        onError(error instanceof Error ? error.message : 'An unknown streaming error occurred.');
    } finally {
        if (reader && !reader.closed) reader.cancel();
    }
};

// =
// 文件: ..\src\novel\editor\api\aiProviderApi.ts
//

import apiClient from '@/api/client';
import type { AIProviderConfig } from '@novel/editor/types';

/**
 * Fetches the list of available AI providers from the backend.
 * These are the configurations that can be used for AI tasks.
 * @returns A promise that resolves to an array of AI provider configurations.
 */
export const fetchAIProviders = async (): Promise<AIProviderConfig[]> => {
    const response = await apiClient.get('/ai/providers');
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\chapterApi.ts
//

import apiClient from '@/api/client';
import type { Chapter } from '@/novel/editor/types';

/**
 * 获取指定小说的所有章节（扁平列表）。
 * @param novelId - 小说的ID。
 * @returns 返回该小说下所有章节的数组。
 */
export const getChaptersForNovel = async (novelId: string): Promise<Chapter[]> => {
    const response = await apiClient.get(`/novels/${novelId}/chapters`);
    return response.data;
};

/**
 * 获取单个章节的详细信息，包括正文内容。
 * @param chapterId - 章节的ID。
 * @returns 返回完整的章节对象。
 */
export const getChapter = async (chapterId: string): Promise<Chapter> => {
    const response = await apiClient.get(`/chapters/${chapterId}`);
    return response.data;
};

/**
 * 在指定卷下创建一个新的章节。
 * @param volumeId - 章节所属的卷的ID。
 * @param chapterData - 创建章节所需的数据（如标题）。
 * @returns 返回新创建的章节对象。
 */
export const createChapter = async (volumeId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    const response = await apiClient.post(`/volumes/${volumeId}/chapters`, chapterData);
    return response.data;
};

/**
 * 更新指定章节的信息（如标题、内容、状态）。
 * @param chapterId - 要更新的章节的ID。
 * @param chapterData - 包含更新字段的对象。
 * @returns 返回更新后的章节对象。
 */
export const updateChapter = async (chapterId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    const response = await apiClient.patch(`/chapters/${chapterId}`, chapterData);
    return response.data;
};

/**
 * 删除一个章节。
 * @param chapterId - 要删除的章节的ID。
 */
export const deleteChapter = async (chapterId: string): Promise<void> => {
    await apiClient.delete(`/chapters/${chapterId}`);
};

/**
 * 更新一个卷下所有章节的排序。
 * @param volumeId - 卷的ID。
 * @param orderedChapterIds - 按新顺序排列的章节ID数组。
 */
export const updateChapterOrder = async (volumeId: string, orderedChapterIds: string[]): Promise<void> => {
    await apiClient.put(`/volumes/${volumeId}/chapters/order`, { orderedChapterIds });
};

// =
// 文件: ..\src\novel\editor\api\chatApi.ts
//

// 文件: ..\src\novel\editor\api\chatApi.ts
import apiClient from '@/api/client';
import type { Conversation, BackendChatMessage, StreamResponseChunk } from '@novel/editor/types/chatTypes.ts';
import { useAuthStore } from '@/auth/store/auth.store';

export const fetchConversations = async (): Promise<Conversation[]> => {
    const response = await apiClient.get('/ai/chat/conversations');
    return response.data;
};

export const createConversation = async (): Promise<Conversation> => {
    const response = await apiClient.post('/ai/chat/conversations');
    return response.data;
};

export const streamChat = async (
    apiKeyId: number,
    messages: BackendChatMessage[],
    callbacks: {
        onChunk: (chunk: StreamResponseChunk) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    try {
        const authStore = useAuthStore();
        const token = authStore.token;
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch('/api/ai/stream-chat', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                api_key_id: apiKeyId,
                messages: messages,
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.msg || `HTTP error! status: ${response.status}`);
        }

        const reader = response.body?.getReader();
        if (!reader) throw new Error('Failed to get response reader');

        const decoder = new TextDecoder();
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const rawChunk = decoder.decode(value);
            const lines = rawChunk.split('\n\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const jsonData = line.substring(6);
                    if (jsonData) {
                        try {
                            const parsedChunk: StreamResponseChunk = JSON.parse(jsonData);
                            callbacks.onChunk(parsedChunk);
                        } catch (e) {
                            console.error('Failed to parse stream chunk:', jsonData);
                        }
                    }
                }
            }
        }
        callbacks.onComplete();
    } catch (error) {
        callbacks.onError(error instanceof Error ? error.message : String(error));
    }
};

// =
// 文件: ..\src\novel\editor\api\customAnalysisApi.ts
//

// ..\src\novel\editor\api\customAnalysisApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义分析数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义分析条目数组。
 */
export const getAnalysisCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-analysis`);
    return response.data;
};

/**
 * 更新指定小শনের自定义分析数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义分析数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updateAnalysisCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-analysis`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\customOthersApi.ts
//

// 文件: ..\src\novel\editor\api\customOthersApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义“其他”数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义“其他”条目数组。
 */
export const getOthersCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-others`);
    return response.data;
};

/**
 * 更新指定小说的自定义“其他”数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义“其他”数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updateOthersCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-others`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\customPlotApi.ts
//

// 文件: ..\src\novel\editor\api\customPlotApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义剧情数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义剧情条目数组。
 */
export const getPlotCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-plot`);
    return response.data;
};

/**
 * 更新指定小说的自定义剧情数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义剧情数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updatePlotCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-plot`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\derivedContentApi.ts
//

import apiClient from '@/api/client';
import type { PlotAnalysisItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有派生内容（剧情和分析）。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有派生内容条目的数组。
 */
export const getDerivedItemsForNovel = async (novelId: string): Promise<PlotAnalysisItem[]> => {
    const response = await apiClient.get(`/novels/${novelId}/derived-content`);
    return response.data;
};

/**
 * 创建一个新的派生内容条目。
 * @param itemData - 创建条目所需的数据（类型、源ID、标题、内容）。
 * @returns 返回新创建的派生内容条目。
 */
export const createDerivedItem = async (itemData: Omit<PlotAnalysisItem, 'id'>): Promise<PlotAnalysisItem> => {
    const response = await apiClient.post(`/derived-content`, itemData);
    return response.data;
};

/**
 * 更新一个派生内容条目。
 * @param itemId - 要更新的条目的ID。
 * @param itemData - 包含更新字段的对象。
 * @returns 返回更新后的派生内容条目。
 */
export const updateDerivedItem = async (itemId: string, itemData: Partial<Omit<PlotAnalysisItem, 'id'>>): Promise<PlotAnalysisItem> => {
    const response = await apiClient.patch(`/derived-content/${itemId}`, itemData);
    return response.data;
};

/**
 * 删除一个派生内容条目。
 * @param itemId - 要删除的条目的ID。
 */
export const deleteDerivedItem = async (itemId: string): Promise<void> => {
    await apiClient.delete(`/derived-content/${itemId}`);
};

// =
// 文件: ..\src\novel\editor\api\historyApi.ts
//

// ..\src\novel\editor\api\historyApi.ts
import apiClient from '@/api/client';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';

/**
 * 根据文档ID获取其历史版本列表。
 * @param documentId - 文档的ID (例如章节ID, 卷ID等)
 * @returns 返回历史版本快照列表。
 */
export const fetchHistoryForDocument = async (documentId: string): Promise<HistoryVersion[]> => {
    const response = await apiClient.get(`/documents/${documentId}/history`);
    return response.data;
};

/**
 * 将指定文档恢复到某个历史版本。
 * @param documentId - 要恢复的文档ID。
 * @param versionId - 要恢复到的版本ID。
 */
export const restoreVersion = async (documentId: string, versionId: string): Promise<void> => {
    await apiClient.post(`/documents/${documentId}/history/${versionId}/restore`);
};

// =
// 文件: ..\src\novel\editor\api\metadataApi.ts
//

import apiClient from '@/api/client';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * 根据小说ID获取元数据
 * @param novelId - 小说ID
 * @returns 返回小说元数据
 */
export const getNovelMetadata = async (novelId: string): Promise<NovelMetadata> => {
    const response = await apiClient.get(`/novels/${novelId}/metadata`);
    return response.data;
};

/**
 * 更新小说元数据
 * @param novelId - 小说ID
 * @param metadata - 更新后的元数据
 * @returns 返回更新后的元数据
 */
export const updateNovelMetadata = async (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    const response = await apiClient.patch(`/novels/${novelId}/metadata`, metadata);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\noteApi.ts
//

import apiClient from '@/api/client';
import type { NoteItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有笔记。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有笔记条目的数组。
 */
export const getNotesForNovel = async (novelId: string): Promise<NoteItem[]> => {
    const response = await apiClient.get(`/novels/${novelId}/notes`);
    return response.data;
};

/**
 * 为指定小说创建一个新的笔记。
 * @param novelId - 小说的ID。
 * @param noteData - 创建笔记所需的数据（如标题、内容）。
 * @returns 返回新创建的笔记对象。
 */
export const createNote = async (novelId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    const response = await apiClient.post(`/novels/${novelId}/notes`, noteData);
    return response.data;
};

/**
 * 更新指定笔记的信息。
 * @param noteId - 要更新的笔记的ID。
 * @param noteData - 包含更新字段的对象。
 * @returns 返回更新后的笔记对象。
 */
export const updateNote = async (noteId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    const response = await apiClient.patch(`/notes/${noteId}`, noteData);
    return response.data;
};

/**
 * 删除一个笔记。
 * @param noteId - 要删除的笔记的ID。
 */
export const deleteNote = async (noteId: string): Promise<void> => {
    await apiClient.delete(`/notes/${noteId}`);
};

// =
// 文件: ..\src\novel\editor\api\novelProjectApi.ts
//

import apiClient from '@/api/client';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume } from '@/novel/editor/types';

/**
 * 根据ID获取一个完整的小说项目。
 * @param novelId - 小说的ID。
 * @returns 返回一个完整的小说项目。
 */
export const getNovelProject = async (novelId: string): Promise<NovelProject> => {
    const response = await apiClient.get(`/novels/projects/${novelId}`);
    return response.data;
};

/**
 * 从解析后的数据导入一本新小说。
 * @param data - 包含标题、描述和章节数据等。
 * @returns 返回新创建的完整小说项目。
 */
export const importNovelProject = async (data: {
    title: string;
    description: string;
    category: string;
    directoryData: Volume[];
}): Promise<NovelProject> => {
    const response = await apiClient.post('/novels/import', data);
    return response.data;
};

/**
 * 获取所有小说项目，用于参考书选择等场景。
 * @returns 返回所有小说项目的数组。
 */
export const fetchAllNovelProjects = async (): Promise<NovelProject[]> => {
    const response = await apiClient.get('/novels/projects');
    return response.data;
};

/**
 * 永久删除一个小说项目（非移入回收站）。
 * @param novelId - 小说ID。
 */
export const deleteNovelProject = async (novelId: string): Promise<void> => {
    await apiClient.delete(`/novels/${novelId}/permanent`);
};

// =
// 文件: ..\src\novel\editor\api\settingsApi.ts
//

// 文件: ..\src\novel\editor\api\settingsApi.ts
import apiClient from '@/api/client';
import type { TreeNode } from '@/novel/editor/types';

/**
 * 获取指定小说的设定数据。
 * @param novelId - 小说的ID。
 * @returns 返回设定数据的树形节点数组。
 */
export const getSettingsData = async (novelId: string): Promise<TreeNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/settings`);
    return response.data;
};

/**
 * 更新指定小说的设定数据。
 * @param novelId - 小说的ID。
 * @param data - 包含设定数据的树形节点数组。
 * @returns 返回更新后的数据。
 */
export const updateSettingsData = async (novelId: string, data: TreeNode[]): Promise<TreeNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/settings`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\volumeApi.ts
//

import apiClient from '@/api/client';
import type { Volume } from '@/novel/editor/types';

/**
 * 获取指定小说的所有卷（不含章节内容）。
 * @param novelId - 小说的ID。
 * @returns 返回该小说下所有卷的数组。
 */
export const getVolumes = async (novelId: string): Promise<Volume[]> => {
    const response = await apiClient.get(`/novels/${novelId}/volumes`);
    return response.data;
};

/**
 * 为指定小说创建一个新的卷。
 * @param novelId - 小说的ID。
 * @param volumeData - 创建卷所需的数据（如标题、大纲）。
 * @returns 返回新创建的卷对象。
 */
export const createVolume = async (novelId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    const response = await apiClient.post(`/novels/${novelId}/volumes`, volumeData);
    return response.data;
};

/**
 * 更新指定卷的信息（如标题、大纲）。
 * @param volumeId - 要更新的卷的ID。
 * @param volumeData - 包含更新字段的对象。
 * @returns 返回更新后的卷对象。
 */
export const updateVolume = async (volumeId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    const response = await apiClient.patch(`/volumes/${volumeId}`, volumeData);
    return response.data;
};

/**
 * 删除一个卷。
 * @param volumeId - 要删除的卷的ID。
 */
export const deleteVolume = async (volumeId: string): Promise<void> => {
    await apiClient.delete(`/volumes/${volumeId}`);
};

/**
 * 更新一个小说下所有卷的排序。
 * @param novelId - 小说的ID。
 * @param orderedVolumeIds - 按新顺序排列的卷ID数组。
 */
export const updateVolumeOrder = async (novelId: string, orderedVolumeIds: string[]): Promise<void> => {
    await apiClient.put(`/novels/${novelId}/volumes/order`, { orderedVolumeIds });
};

// =
// 文件: ..\src\novel\editor\components\ai\AIDiffPreview.vue
//

import type { PropType } from 'vue';
import type { AITask } from '@/novel/editor/types';

defineProps({
  previewTask: {
    type: Object as PropType<AITask | null>,
    default: null,
  }
});

defineEmits<{
  (e: 'apply-changes', taskId: string): void;
}>();

// =
// 文件: ..\src\novel\editor\components\ai\AITaskItem.vue
//

import type { PropType } from 'vue';
import type { AITask, AITaskStatus } from '@/novel/editor/types';

const props = defineProps({
  task: {
    type: Object as PropType<AITask>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
  (e: 'retry-task', taskId: string): void;
}>();

const getStatusText = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: '等待中',
    processing: '进行中...',
    completed: '待应用',
    failed: '失败',
    applied: '已应用',
    completed_with_conflict: '存在冲突'
  };
  return map[status];
};

const getStatusIcon = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: 'fa-solid fa-hourglass-half',
    processing: 'fa-solid fa-spinner fa-spin',
    completed: 'fa-solid fa-check-circle',
    failed: 'fa-solid fa-times-circle',
    applied: 'fa-solid fa-check-double',
    completed_with_conflict: 'fa-solid fa-exclamation-triangle'
  };
  return map[status];
}

const isClickable = (status: AITaskStatus): boolean => {
  return ['completed', 'processing', 'applied', 'failed', 'completed_with_conflict'].includes(status);
};

const handleTaskClick = () => {
  if (isClickable(props.task.status)) {
    emit('select-task', props.task);
  }
};

// =
// 文件: ..\src\novel\editor\components\ai\AITaskPanel.vue
//

import { computed } from 'vue';
import AITaskQueue from './AITaskQueue.vue';
import AIDiffPreview from './AIDiffPreview.vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';

const aiTaskStore = useAITaskStore();

const previewTask = computed(() => aiTaskStore.previewTask);

const handleSelectTask = (task: AITask) => {
  aiTaskStore.setPreviewTask(task.id);
};

const handleApplyChanges = (taskId: string) => {
  aiTaskStore.applyChanges(taskId);
};

// =
// 文件: ..\src\novel\editor\components\ai\AITaskQueue.vue
//

import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';
import AITaskItem from './AITaskItem.vue';

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
}>();

const aiTaskStore = useAITaskStore();
const tasks = computed(() => aiTaskStore.tasks);
const activeTasksCount = computed(() => aiTaskStore.activeTasksCount);

const handleTaskClick = (task: AITask) => {
  emit('select-task', task);
};

const handleRetry = (taskId: string) => {
  aiTaskStore.retryTask(taskId);
};

const handleApplyChanges = (taskId: string) => {
  emit('apply-changes', taskId);
}

// =
// 文件: ..\src\novel\editor\components\ai\chat\AIChatView.vue
//

import { onMounted } from 'vue';
import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';
import { storeToRefs } from 'pinia';
import ConversationList from './ConversationList.vue';
import ChatMessageHistory from './ChatMessageHistory.vue';
import ChatInputArea from './ChatInputArea.vue';
import ChatHeader from './ChatHeader.vue';

const chatStore = useChatStore();
const { activeConversation, currentModel, isReceiving } = storeToRefs(chatStore);

onMounted(() => {
  chatStore.fetchConversations();
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatHeader.vue
//

import { type PropType, onMounted } from 'vue';
import type { Conversation } from '@/novel/editor/types/chatTypes';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import { storeToRefs } from 'pinia';

defineProps({
  activeConversation: {
    type: Object as PropType<Conversation | null>,
    required: true,
  },
});

const aiConfigStore = useAIConfigStore();
const { selectedChatProviderConfig: selectedProvider } = storeToRefs(aiConfigStore);

onMounted(() => {
  aiConfigStore.initializeProviders();
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatInputArea.vue
//

import { ref, watch } from 'vue';
import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';
import { storeToRefs } from 'pinia';

const chatStore = useChatStore();
const { messageInput, isReceiving, currentTokenCount } = storeToRefs(chatStore);

const textareaRef = ref<HTMLTextAreaElement | null>(null);

const sendMessage = () => {
  chatStore.sendMessage();
};

// 自动调整 textarea 高度
watch(messageInput, (newValue) => {
  const el = textareaRef.value;
  if (el) {
    el.style.height = 'auto';
    el.style.height = `${el.scrollHeight}px`;
  }
  // 清空后恢复原始高度
  if (newValue === '') {
    el.style.height = 'auto';
  }
});

// =
// 文件: ..\src\novel\editor\components\ai\chat\ChatMessageHistory.vue
//

import { ref, watch, nextTick, type PropType } from 'vue';
import type { Conversation } from '@/novel/editor/types/chatTypes';

const props = defineProps({
  conversation: {
    type: Object as PropType<Conversation | null>,
    required: true,
  },
  isReceiving: {
    type: Boolean,
    required: true,
  },
});

const chatHistoryContainer = ref<HTMLElement | null>(null);

const scrollToBottom = () => {
  nextTick(() => {
    if (chatHistoryContainer.value) {
      chatHistoryContainer.value.scrollTop = chatHistoryContainer.value.scrollHeight;
    }
  });
};

watch(() => props.conversation?.messages, () => {
  scrollToBottom();
}, { deep: true, flush: 'post' });

watch(() => props.isReceiving, (newValue) => {
  if (newValue) {
    scrollToBottom();
  }
}, { flush: 'post' });

// =
// 文件: ..\src\novel\editor\components\ai\chat\ConversationList.vue
//

import { useChatStore } from '@novel/editor/stores/ai/chatStore.ts';

const chatStore = useChatStore();

// =
// 文件: ..\src\novel\editor\components\ai\chat\chatData.ts
//

import type { Conversation } from '@novel/editor/types/chatTypes.ts';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\components\content\DerivedContentView.vue
//

import { useDerivedViewStore } from '@novel/editor/stores/derivedViewStore';
import { useDerivedContentStore } from '@novel/editor/stores/derivedContentStore';
import TiptapEditor from './TiptapEditor.vue';

const store = useDerivedViewStore();
const derivedContentStore = useDerivedContentStore();

const handleContentUpdate = (newContent: string) => {
  if (store.currentItem) {
    derivedContentStore.updateNodeContent(store.currentItem.id, newContent);
  }
};

// =
// 文件: ..\src\novel\editor\components\content\EditorContextMenu.vue
//

import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ x: 0, y: 0 });

const show = (event: MouseEvent, container: HTMLElement | null) => {
  const containerRect = container?.getBoundingClientRect() || { top: 0, left: 0 };
  visible.value = true;
  position.value.x = event.clientX - containerRect.left;
  position.value.y = event.clientY - containerRect.top;
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type']) => {
  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\content\EditorInstance.vue
//

import { computed, ref, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { EditorPane } from '@novel/editor/stores/editor-state/paneStore';
import PaneActions from '../layout/PaneActions.vue';
import BreadcrumbsBar from '../layout/BreadcrumbsBar.vue';
import PaneContentDispatcher from './PaneContentDispatcher.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<EditorPane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  }
});

const editorStore = useEditorStore();
const dispatcherRef = ref<InstanceType<typeof PaneContentDispatcher> | null>(null);

const openTabs = computed(() => editorStore.getTabsForPane(props.pane.id));
const activeTab = computed(() => editorStore.getActiveTabForPane(props.pane.id));

const activeTabContent = computed({
  get: () => {
    const item = activeTab.value?.item;
    if (item && 'content' in item && typeof item.content === 'string') {
      return item.content;
    }
    return '';
  },
  set: (newContent: string) => {
    const item = activeTab.value?.item;
    if (activeTab.value && item && 'content' in item && props.isActive) {
      editorStore.updateItemContentById(activeTab.value.id, newContent);
    }
  }
});

const setActivePane = () => {
  editorStore.setActivePane(props.pane.id)
};

const showEditorContextMenu = (event: MouseEvent) => {
  dispatcherRef.value?.showContextMenu(event, dispatcherRef.value.$el);
};

// =
// 文件: ..\src\novel\editor\components\content\FloatingToolbar.vue
//

import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ top: 0, left: 0 });

const show = (rect: DOMRect, wrapperRect: DOMRect) => {
  visible.value = true;
  position.value = {
    top: rect.top - wrapperRect.top - 48,
    left: rect.left - wrapperRect.left + rect.width / 2 - 60,
  };
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type'], event: MouseEvent) => {
  event.preventDefault();

  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\content\MainPane.vue
//

import { computed, ref, watch, nextTick } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import EditorInstance from './EditorInstance.vue';

const editorStore = useEditorStore();
const panes = computed(() => editorStore.panes);
const containerRef = ref<HTMLElement | null>(null);

watch(() => panes.value.length, (newLength, oldLength) => {
  if (newLength < oldLength) {
    nextTick(() => {
      if (!containerRef.value) return;
      const remainingPanes = containerRef.value.querySelectorAll('.pane-instance') as NodeListOf<HTMLElement>;
      remainingPanes.forEach(el => {
        el.style.flex = '';
      });
    });
  }
});

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    const minWidth = 200;
    if (newLeftWidth < minWidth) {
      newLeftWidth = minWidth;
    }
    if (totalWidth - newLeftWidth < minWidth) {
      newLeftWidth = totalWidth - minWidth;
    }

    const newLeftBasis = (newLeftWidth / totalWidth) * 100;
    const newRightBasis = 100 - newLeftBasis;

    leftPane.style.flex = `0 0 ${newLeftBasis}%`;
    rightPane.style.flex = `0 0 ${newRightBasis}%`;
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = 'none';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

// =
// 文件: ..\src\novel\editor\components\content\PaneContentDispatcher.vue
//

import { computed, ref, onMounted, onBeforeUnmount, shallowRef, type PropType } from 'vue';
import type { TabInfo, SystemViewInfo } from '@/novel/editor/types';
import TiptapEditor from './TiptapEditor.vue';
import FloatingToolbar from './FloatingToolbar.vue';
import EditorContextMenu from './EditorContextMenu.vue';
import SearchView from '@novel/editor/views/SearchView.vue';
import AIChatView from '@novel/editor/components/ai/chat/AIChatView.vue';
import AITaskPanel from '@/novel/editor/components/ai/AITaskPanel.vue';
import EditorSettings from '@/novel/editor/components/system/settings/EditorSettings.vue';
import ContextSettings from '@/novel/editor/components/system/settings/ContextSettings.vue';
import TaskSettings from '@/novel/editor/components/system/settings/TaskSettings.vue';
import AIConfigSettings from '@/novel/editor/components/system/settings/AIConfigSettings.vue';
import NovelSettings from '@/novel/editor/components/system/settings/NovelSettings.vue';
import ThemeSettings from '@/novel/editor/components/system/settings/ThemeSettings.vue';
import HistoryPanel from '@novel/editor/views/HistoryPanel.vue';
import DerivedContentView from './DerivedContentView.vue';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    default: null
  },
  modelValue: {
    type: String,
    default: ''
  },
  isActivePane: {
    type: Boolean,
    required: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>();

const systemViewMap = shallowRef({
  SearchView,
  AIChatView,
  AITaskPanel,
  EditorSettings,
  ContextSettings,
  TaskSettings,
  AIConfigSettings,
  NovelSettings,
  ThemeSettings,
  HistoryPanel,
  DerivedContentView,
});

const systemViewComponent = computed(() => {
  const item = props.activeTab?.item;
  if (item?.type === 'system') {
    const componentName = item.component;
    return systemViewMap.value[componentName] || null;
  }
  return null;
});

const isCurrentTabReadOnly = computed(() => {
  const item = props.activeTab?.item;
  if (item && 'isReadOnly' in item) {
    return item.isReadOnly === true;
  }
  return false;
});

const wrapperRef = ref<HTMLElement | null>(null);
const editorContentRef = ref<HTMLElement | null>(null);
const floatingToolbarRef = ref<InstanceType<typeof FloatingToolbar> | null>(null);
const editorContextMenuRef = ref<InstanceType<typeof EditorContextMenu> | null>(null);

const showContextMenu = (event: MouseEvent, container: HTMLElement | null) => {
  editorContextMenuRef.value?.show(event, container);
};

const handleSelectionChange = () => {
  if (!props.isActivePane || !floatingToolbarRef.value || !wrapperRef.value || !editorContentRef.value) return;

  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed || !editorContentRef.value.contains(selection.getRangeAt(0).commonAncestorContainer)) {
    floatingToolbarRef.value.hide();
    return;
  }
  floatingToolbarRef.value.show(selection.getRangeAt(0).getBoundingClientRect(), wrapperRef.value.getBoundingClientRect());
  editorContextMenuRef.value?.hide();
};

const handleScroll = () => {
  floatingToolbarRef.value?.hide();
  editorContextMenuRef.value?.hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (!wrapperRef.value?.contains(event.target as Node)) return;
  const target = event.target as HTMLElement;
  if (!target.closest('.context-menu') && !target.closest('.floating-toolbar')) {
    editorContextMenuRef.value?.hide();
    floatingToolbarRef.value?.hide();
  }
};

onMounted(() => {
  document.addEventListener('selectionchange', handleSelectionChange);
  document.addEventListener('click', handleClickOutside, true);
});

onBeforeUnmount(() => {
  document.removeEventListener('selectionchange', handleSelectionChange);
  document.removeEventListener('click', handleClickOutside, true);
});

defineExpose({
  showContextMenu
});

// =
// 文件: ..\src\novel\editor\components\content\TiptapEditor.vue
//

import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { watch, onBeforeUnmount } from 'vue'

const props = defineProps({
  modelValue: {
    type: String,
    required: true,
  },
  isEditable: {
    type: Boolean,
    default: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>()

const editor = useEditor({
  content: props.modelValue,
  editable: props.isEditable,
  extensions: [
    StarterKit.configure({
      heading: { levels: [1, 2, 3] },
    }),
  ],
  onUpdate: () => {
    if (editor.value?.isEditable) {
      emit('update:modelValue', editor.value?.getHTML() || '')
    }
  },
  editorProps: {
    attributes: {
      class: 'prose-mirror-focus',
    },
  },
})

watch(() => props.modelValue, (newValue) => {
  const isSame = editor.value?.getHTML() === newValue
  if (isSame) {
    return
  }
  editor.value?.commands.setContent(newValue, false)
})

watch(() => props.isEditable, (value) => {
  editor.value?.setEditable(value);
});

onBeforeUnmount(() => {
  editor.value?.destroy()
})

// =
// 文件: ..\src\novel\editor\components\layout\ActivityBar.vue
//

import { ref } from 'vue';

type TabId = 'directory' | 'related' | 'notes' | 'references';
type ActionId = 'system:search' | 'system:ai_chat';

interface Tab {
  id: TabId;
  title: string;
  icon: string;
}

interface ActionButton {
  id: ActionId;
  title: string;
  icon: string;
}

defineProps<{
  activeTabId: string | null;
  isSidebarVisible: boolean;
}>();

defineEmits<{
  (e: 'select-tab', id: TabId): void;
  (e: 'trigger-action', id: ActionId): void;
  (e: 'show-manage-menu', event: MouseEvent): void;
}>();

const mainTabs = ref<Tab[]>([
  { id: 'directory', title: '目录', icon: 'fa-solid fa-list-ul' },
  { id: 'related', title: '相关', icon: 'fa-solid fa-sitemap' },
  { id: 'notes', title: '笔记', icon: 'fa-solid fa-book-medical' },
  { id: 'references', title: '参考书', icon: 'fa-solid fa-book-bookmark' },
]);

const actionButtons = ref<ActionButton[]>([
  { id: 'system:search', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
  { id: 'system:ai_chat', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
])

// =
// 文件: ..\src\novel\editor\components\layout\BreadcrumbsBar.vue
//

import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';

const props = defineProps<{
  paneId: string;
  isActive: boolean;
}>();

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();

const activeTab = computed(() => editorStore.getActiveTabForPane(props.paneId));

const volumeTitle = computed(() => {
  if (!activeTab.value || activeTab.value.item.type !== 'chapter') {
    return '根目录';
  }
  const chapterId = activeTab.value.id;
  const volume = directoryStore.directoryData.find(v =>
      v.chapters.some(c => c.id === chapterId)
  );
  return volume ? volume.title : '未知卷';
});

// =
// 文件: ..\src\novel\editor\components\layout\ManageMenu.vue
//

import { ref, computed, onMounted, onBeforeUnmount } from 'vue';

const emit = defineEmits<{
  (e: 'select-action', actionId: string): void;
}>();

const visible = ref(false);
const position = ref({ bottom: 0, left: 0 });
const menuRef = ref<HTMLElement | null>(null);

const menuItems = ref([
  { id: 'command_palette', label: '命令面板...', shortcut: 'Ctrl+Shift+P' },
  { isDivider: true },
  { id: 'system:settings_novel', label: '小说设置', shortcut: '' },
  { id: 'system:settings_context', label: '上下文管理', shortcut: '' },
  { id: 'system:settings_ai_config', label: 'AI 任务配置', shortcut: '' },
  { isDivider: true },
  { id: 'system:settings_editor', label: '编辑器设置', shortcut: '' },
  { id: 'system:settings_tasks', label: '任务管理', shortcut: '' },
  { id: 'system:settings_theme', label: '主题设置' },
  { isDivider: true },
  { id: 'keyboard_shortcuts', label: '键盘快捷方式', shortcut: 'Ctrl+K Ctrl+S' },
  { isDivider: true },
  { id: 'check_for_updates', label: '检查更新...' },
]);

const menuStyle = computed(() => ({
  bottom: `${position.value.bottom}px`,
  left: `${position.value.left}px`,
}));

const show = (buttonElement: HTMLElement) => {
  const rect = buttonElement.getBoundingClientRect();
  position.value.bottom = window.innerHeight - rect.top + 8; // 8px spacing
  position.value.left = rect.left;
  visible.value = true;
};

const hide = () => {
  visible.value = false;
};

const selectItem = (actionId: string) => {
  emit('select-action', actionId);
  hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (menuRef.value && !menuRef.value.contains(event.target as Node)) {
    hide();
  }
};

onMounted(() => {
  window.addEventListener('click', handleClickOutside);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', handleClickOutside);
});

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\layout\PaneActions.vue
//

import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';

const props = defineProps<{
  paneId: string;
  isActive: boolean;
}>();

const editorStore = useEditorStore();

const activeItemType = computed(() => editorStore.getActiveTabForPane(props.paneId)?.item.type);

const isDerivedContentAvailable = computed(() => {
  return activeItemType.value === 'chapter' || activeItemType.value === 'volume';
});

const handleOpenPlot = () => {
  editorStore.openPlotForActiveItem();
};

const handleOpenAnalysis = () => {
  editorStore.openAnalysisForActiveItem();
};

const handleShowHistory = () => {
  editorStore.toggleHistoryPanel(props.paneId);
};

const handleShowReader = () => {
  editorStore.openReaderView();
};

// =
// 文件: ..\src\novel\editor\components\layout\StatusBar.vue
//

import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { Chapter } from '@/novel/editor/types';

const editorStore = useEditorStore();

const activeItem = computed(() => editorStore.activeTab?.item);

const wordCount = computed(() => {
  if (activeItem.value && activeItem.value.type === 'chapter') {
    return (activeItem.value as Chapter).wordCount || 0;
  }
  return 0;
});

const readingTime = computed(() => {
  if (!wordCount.value) return 0;
  const time = Math.ceil(wordCount.value / 400);
  return time > 0 ? time : 1;
});

// =
// 文件: ..\src\novel\editor\components\modals\ContextPreviewModal.vue
//

import { ref, computed, watch } from 'vue';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { ContextBuildResult } from '@/novel/editor/types';

type PanelId = 'fixed' | 'dynamic' | 'reference' | 'rag' | 'prompt';

const store = useContextPreviewStore();
const expandedPanelIds = ref(new Set<PanelId>());

const panels = ref([
  { id: 'fixed', name: '固定上下文', statKey: 'fixedCharCount' },
  { id: 'dynamic', name: '动态上下文', statKey: 'dynamicCharCount' },
  { id: 'reference', name: '参考书籍上下文', statKey: 'referenceCharCount' },
  { id: 'rag', name: 'RAG检索', statKey: 'ragCharCount' },
  { id: 'prompt', name: '最终提示词', statKey: 'promptCharCount' },
] as const);

watch(() => store.previewContent, (newContent) => {
  if (newContent) {
    // Default expand panels with content.
    expandedPanelIds.value.clear();
    if (newContent.fixed) expandedPanelIds.value.add('fixed');
    if (newContent.dynamic) expandedPanelIds.value.add('dynamic');
    if (newContent.reference) expandedPanelIds.value.add('reference');
    expandedPanelIds.value.add('prompt'); // Always expand prompt
  }
}, { immediate: true });


const toggleExpansion = (panelId: PanelId) => {
  if (expandedPanelIds.value.has(panelId)) {
    expandedPanelIds.value.delete(panelId);
  } else {
    expandedPanelIds.value.add(panelId);
  }
};

const formatCharCount = (count: number | undefined) => {
  if(count === undefined) return 0;
  if (count > 1000) return `${(count / 1000).toFixed(1)}k`;
  return count;
};

const totalCharCount = computed(() => {
  if (!store.previewContent?.stats) return '0';
  const { fixedCharCount, dynamicCharCount, referenceCharCount, ragCharCount } = store.previewContent.stats;
  const total = (fixedCharCount || 0) + (dynamicCharCount || 0) + (referenceCharCount || 0) + (ragCharCount || 0);
  return formatCharCount(total);
});

const emptyStateHtml = (contextType: string) => {
  return `<p class="text-gray-400 italic p-4">未配置或未找到${contextType}内容。</p>`;
};

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryContextMenu.vue
//

import { ref, computed, onMounted, onBeforeUnmount, defineAsyncComponent, shallowRef } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { useAITaskStore } from '@/novel/editor/stores/ai/aiTaskStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';

// --- 组件映射 ---
const menuComponentMap = shallowRef({
  'volume': defineAsyncComponent(() => import('./context-menus/VolumeMenu.vue')),
  'chapter': defineAsyncComponent(() => import('./context-menus/ChapterMenu.vue')),
  'group': defineAsyncComponent(() => import('./context-menus/GroupMenu.vue')),
  'item': defineAsyncComponent(() => import('./context-menus/ItemMenu.vue')),
  'root': defineAsyncComponent(() => import('./context-menus/RootMenu.vue')),
  'others': defineAsyncComponent(() => import('./context-menus/OthersMenu.vue')),
  'others_item': defineAsyncComponent(() => import('./context-menus/OthersItemMenu.vue')),
  'custom_related': defineAsyncComponent(() => import('./context-menus/CustomRelatedMenu.vue')),
  'note': defineAsyncComponent(() => import('./context-menus/NoteMenu.vue')),
  'setting_root': defineAsyncComponent(() => import('./context-menus/SettingsRootMenu.vue')),
  'prompt_group': defineAsyncComponent(() => import('./context-menus/PromptGroupMenu.vue')),
  'prompt_item': defineAsyncComponent(() => import('./context-menus/PromptItemMenu.vue')),
});

// --- State and Props ---
const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const node = ref<TreeNode | null>(null);
const menuRef = ref<HTMLElement | null>(null);

// --- Stores and Composables ---
const { executeAITask } = useAITaskExecutor();
const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const relatedContentStore = useRelatedContentStore();
const notesStore = useNotesStore();
const promptTemplateStore = usePromptTemplateStore();
const uiStore = useUIStore();
const aiTaskStore = useAITaskStore();
const derivedContentStore = useDerivedContentStore();

// --- Computed ---
const menuComponent = computed(() => {
  if (!node.value) return null;
  const { type, id } = node.value;

  if (type === 'prompt_group' || type === 'prompt_item') return menuComponentMap.value[type];
  if (id.startsWith('custom-others-')) return menuComponentMap.value['others_item'];
  if (id.startsWith('custom-')) return menuComponentMap.value['custom_related'];

  if (type === 'root') {
    if (id === 'setting') return menuComponentMap.value['setting_root'];
    if (id === 'plot' || id === 'analysis') return menuComponentMap.value['root'];
    if (id === 'others') return menuComponentMap.value['others'];
    return null;
  }

  if (type in menuComponentMap.value) return menuComponentMap.value[type as keyof typeof menuComponentMap.value];
  if (type.endsWith('_item')) return menuComponentMap.value['item'];

  return null;
});

// --- Core Logic ---
const show = (event: MouseEvent, targetNode: TreeNode) => {
  if (targetNode.isOverview || (targetNode.isReadOnly && targetNode.type !== 'prompt_group') || targetNode.type.startsWith('reference_')) {
    return;
  }
  node.value = targetNode;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  node.value = null;
};

// --- Centralized Action Handler ---
const handleAction = async (event: { type: string; payload?: any }) => {
  if (!node.value) return; // Guard against race conditions

  const { type, payload } = event;
  const nodeId = node.value.id;
  const nodeType = node.value.type;

  hide(); // Hide menu immediately on action

  switch (type) {
    case 'rename':
      uiStore.setEditingNodeId(nodeId);
      break;

    case 'delete':
      if (nodeType === 'volume' || nodeType === 'chapter') {
        if (await directoryStore.deleteNode(nodeId)) editorStore.closeTab(nodeId);
      } else if (nodeType === 'note') {
        if (await notesStore.deleteNote(nodeId)) editorStore.closeTab(nodeId);
      } else if (nodeType === 'prompt_item') {
        if (confirm('确定要删除这个提示词模板吗？')) {
          if (promptTemplateStore.deletePrompt(nodeId)) editorStore.closeTab(nodeId);
        }
      } else if (nodeId.startsWith('custom-others-')) {
        if (relatedContentStore.deleteCustomOthersNode(nodeId)) editorStore.closeTab(nodeId);
      } else if (nodeId.startsWith('custom-')) {
        if (relatedContentStore.deleteCustomRelatedNode(nodeId)) editorStore.closeTab(nodeId);
      } else if (nodeType === 'plot_item' || nodeType === 'analysis_item') {
        if (await derivedContentStore.deleteDerivedItem(nodeId)) editorStore.closeTab(nodeId);
      } else { // Handles generic settings items (character_item, etc.)
        if (relatedContentStore.deleteRelatedNode(nodeId)) editorStore.closeTab(nodeId);
      }
      break;

    case 'ai-task':
      if (payload.isBatch && nodeType === 'volume' && 'originalData' in node.value) {
        aiTaskStore.startBatchTaskForVolume(payload.taskType, node.value.originalData);
      } else {
        executeAITask(payload.taskType, { id: nodeId, title: node.value.title });
      }
      break;

    case 'new-volume':
      const newVolume = await directoryStore.addNewVolume();
      if (newVolume) uiStore.setEditingNodeId(newVolume.id);
      break;

    case 'new-chapter':
      const newChapter = await directoryStore.addChapterToVolume(nodeId);
      if (newChapter) {
        uiStore.ensureNodeIsExpanded(nodeId);
        editorStore.openTab(newChapter.id);
        uiStore.setEditingNodeId(newChapter.id);
      }
      break;

    case 'new-group':
      const newGroup = relatedContentStore.addRelatedNode(nodeId, 'group');
      if (newGroup) {
        uiStore.ensureRelatedNodeIsExpanded(nodeId);
        uiStore.setEditingNodeId(newGroup.id);
      }
      break;

    case 'new-item':
      if (nodeType === 'root' && (nodeId === 'plot' || nodeId === 'analysis')) {
        const newItem = relatedContentStore.addCustomRelatedNode(payload.target);
        uiStore.ensureRelatedNodeIsExpanded(payload.target);
        editorStore.openTab(newItem.id);
        uiStore.setEditingNodeId(newItem.id);
      } else if (nodeType === 'root' && nodeId === 'others') {
        const newItem = relatedContentStore.addCustomOthersNode();
        uiStore.ensureRelatedNodeIsExpanded('others');
        editorStore.openTab(newItem.id);
        uiStore.setEditingNodeId(newItem.id);
      } else { // Generic new item in a group
        const newItem = relatedContentStore.addRelatedNode(nodeId, 'item');
        if (newItem) {
          uiStore.ensureRelatedNodeIsExpanded(nodeId);
          editorStore.openTab(newItem.id);
          uiStore.setEditingNodeId(newItem.id);
        }
      }
      break;

    case 'new-prompt':
      const newPrompt = promptTemplateStore.addPrompt(nodeId, '新建提示词', '在这里输入你的提示词模板...');
      if (newPrompt) {
        uiStore.ensureRelatedNodeIsExpanded(nodeId);
        editorStore.openTab(newPrompt.id);
        uiStore.setEditingNodeId(newPrompt.id);
      }
      break;
  }
};

// --- Lifecycle & Event Handling ---
const handleClickOutside = (event: MouseEvent) => {
  if (menuRef.value && !menuRef.value.contains(event.target as Node)) {
    hide();
  }
};

onMounted(() => {
  window.addEventListener('click', handleClickOutside, true);
  window.addEventListener('contextmenu', hide, true);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', handleClickOutside, true);
  window.removeEventListener('contextmenu', hide, true);
});

defineExpose({ show, hide });

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryTab.vue
//

import TreeView from './TreeView.vue';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { useDirectoryTreeAdapter } from '@/novel/editor/composables/useDirectoryTreeAdapter';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const directoryStore = useDirectoryStore();
const uiStore = useUIStore();

const {
  treeNodes,
  activeNodeId,
  expandedNodeIds,
  editingNodeId,
  handleSelectNode,
  handleToggleExpansion,
  handleCommitRename,
  handleCancelRename
} = useDirectoryTreeAdapter();

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleAddNewVolume = async () => {
  const newVolume = await directoryStore.addNewVolume();
  if (newVolume) {
    uiStore.setEditingNodeId(newVolume.id);
  }
};

// =
// 文件: ..\src\novel\editor\components\sidebar\NotesTab.vue
//

import { ref, computed, watch, nextTick, onBeforeUpdate } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { NoteItem, TreeNode } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const notesStore = useNotesStore();
const uiStore = useUIStore();
const quickAddValue = ref('');
const renameInputs = ref<HTMLInputElement[]>([]);

const editingNodeId = computed(() => uiStore.editingNodeId);
const activeTabId = computed(() => editorStore.activeTabId);


watch(editingNodeId, (newId) => {
  if (newId && newId.startsWith('note-')) {
    nextTick(() => {
      const noteIndex = notesStore.notes.findIndex(n => n.id === newId);
      if (noteIndex !== -1 && renameInputs.value[noteIndex]) {
        renameInputs.value[noteIndex].focus();
        renameInputs.value[noteIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const addNewNoteAndEdit = async (title: string) => {
  const newNote = await notesStore.addNote(title);
  if (newNote) {
    editorStore.openTab(newNote.id);
    uiStore.setEditingNodeId(newNote.id);
  }
};

const handleAddNewNote = () => {
  addNewNoteAndEdit('新建笔记');
};

const handleQuickAdd = () => {
  const value = quickAddValue.value.trim();
  if (!value) return;
  addNewNoteAndEdit(value);
  quickAddValue.value = '';
};

const handleContextMenu = (note: NoteItem, event: MouseEvent) => {
  const nodePayload: TreeNode = {
    id: note.id,
    title: note.title,
    type: note.type,
    icon: getIconByNodeType(note.type),
    originalData: note
  };
  emit('show-context-menu', { node: nodePayload, event });
}

const handleCommitRename = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value.trim();
  if(newTitle) {
    notesStore.renameNote(nodeId, newTitle);
  }
  handleCancelRename();
};

const handleCancelRename = () => {
  uiStore.setEditingNodeId(null);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\ReferencesTab.vue
//

import TreeView from './TreeView.vue';
import { useReferenceTreeAdapter } from '@/novel/editor/composables/useReferenceTreeAdapter';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const {
  treeNodes,
  activeNodeId,
  expandedNodeIds,
  handleSelectNode,
  handleToggleExpansion
} = useReferenceTreeAdapter();

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\RelatedTab.vue
//

import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { useRelatedContentTreeAdapter } from '@/novel/editor/composables/useRelatedContentTreeAdapter';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const relatedContentStore = useRelatedContentStore();
const uiStore = useUIStore();

const {
  treeNodes,
  activeNodeId,
  expandedNodeIds,
  editingNodeId,
  handleSelectNode,
  handleToggleExpansion,
  handleCommitRename,
  handleCancelRename
} = useRelatedContentTreeAdapter();

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleAddNewCustomPlot = () => {
  const newNode = relatedContentStore.addCustomRelatedNode('plot');
  uiStore.ensureRelatedNodeIsExpanded('plot');
  editorStore.openTab(newNode.id);
  uiStore.setEditingNodeId(newNode.id);
};

const handleAddNewCustomAnalysis = () => {
  const newNode = relatedContentStore.addCustomRelatedNode('analysis');
  uiStore.ensureRelatedNodeIsExpanded('analysis');
  editorStore.openTab(newNode.id);
  uiStore.setEditingNodeId(newNode.id);
};

const handleAddNewCustomOthers = () => {
  const newNode = relatedContentStore.addCustomOthersNode();
  uiStore.ensureRelatedNodeIsExpanded('others');
  editorStore.openTab(newNode.id);
  uiStore.setEditingNodeId(newNode.id);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\SidebarPanel.vue
//

import { ref, computed, defineAsyncComponent } from 'vue';
import DirectoryContextMenu from './DirectoryContextMenu.vue';
import type { TreeNode } from '@/novel/editor/types';

type TabId = 'directory' | 'related' | 'notes' | 'references';

const props = defineProps<{
  activeTabId: TabId | null;
}>();

const directoryContextMenuRef = ref<InstanceType<typeof DirectoryContextMenu> | null>(null);

const titles: Record<TabId, string> = {
  directory: '目录大纲',
  related: '相关内容',
  notes: '章节笔记',
  references: '参考书目',
};

const tabComponents: Record<TabId, any> = {
  directory: defineAsyncComponent(() => import('./DirectoryTab.vue')),
  related: defineAsyncComponent(() => import('./RelatedTab.vue')),
  notes: defineAsyncComponent(() => import('./NotesTab.vue')),
  references: defineAsyncComponent(() => import('./ReferencesTab.vue')),
};

const activeTabComponent = computed(() => {
  if (!props.activeTabId) return null;
  return tabComponents[props.activeTabId] || null;
});

const activeTitle = computed(() => {
  if (!props.activeTabId) return '';
  return titles[props.activeTabId] || '';
});

const showDirectoryContextMenu = (payload: { node: TreeNode, event: MouseEvent }) => {
  directoryContextMenuRef.value?.show(payload.event, payload.node);
};

// =
// 文件: ..\src\novel\editor\components\sidebar\TreeView.vue
//

import { ref, watch, nextTick } from 'vue';
import type { PropType } from 'vue';
import type { TreeNode } from '@novel/editor/types';

// --- Props & Emits ---
const props = defineProps({
  nodes: {
    type: Array as PropType<TreeNode[]>,
    required: true,
  },
  activeNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
  expandedNodeIds: {
    type: Set as PropType<Set<string>>,
    required: true,
  },
  editingNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
});

const emit = defineEmits<{
  (e: 'select-node', node: TreeNode): void;
  (e: 'toggle-expansion', id: string): void;
  (e: 'context-menu', payload: { node: TreeNode, event: MouseEvent }): void;
  (e: 'commit-rename', payload: { nodeId: string, newTitle: string }): void;
  (e: 'cancel-rename'): void;
}>();

const renameInput = ref<HTMLInputElement[] | null>(null);

watch(() => props.editingNodeId, (newId, oldId) => {
  if (newId && newId !== oldId) {
    nextTick(() => {
      if (renameInput.value && renameInput.value.length > 0) {
        renameInput.value[0].focus();
        renameInput.value[0].select();
      }
    });
  }
});

const handleNodeClick = (node: TreeNode) => {
  if (props.editingNodeId === node.id) return;
  emit('select-node', node);
};

const handleRenameCommit = (event: Event, node: TreeNode) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value;
  emit('commit-rename', { nodeId: node.id, newTitle });
};

const handleRenameCancel = () => {
  emit('cancel-rename');
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ChapterMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\CustomRelatedMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\GroupMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\NoteMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptGroupMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptItemMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\RootMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\SettingsRootMenu.vue
//

import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\VolumeMenu.vue
//

import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'dispatch-action', event: { type: string; payload?: any }): void;
}>();

const dispatch = (type: string, payload?: any) => {
  emit('dispatch-action', { type, payload });
};

// =
// 文件: ..\src\novel\editor\components\system\settings\AIConfigSettings.vue
//

import { ref, computed } from 'vue';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@novel/editor/stores/promptTemplateStore.ts';
import type { AITaskType } from '@/novel/editor/types';

const aiConfigStore = useAIConfigStore();
const promptTemplateStore = usePromptTemplateStore();

const taskInfoMap: Record<AITaskType, { name: string; icon: string }> = {
  '润色': { name: '润色', icon: 'fa-solid fa-palette' },
  '续写': { name: '续写', icon: 'fa-solid fa-wand-magic-sparkles' },
  '分析': { name: '分析', icon: 'fa-solid fa-magnifying-glass-chart' },
  '剧情生成': { name: '剧情生成', icon: 'fa-solid fa-feather' },
  '创作': { name: '创作', icon: 'fa-solid fa-pen-nib' },
};

const availableTasks = computed(() => {
  return (Object.keys(aiConfigStore.taskConfigs) as AITaskType[]).map(id => ({
    id,
    name: taskInfoMap[id].name,
    icon: taskInfoMap[id].icon
  }));
});

const activeTaskId = ref<AITaskType>('润色');

const activeTaskInfo = computed(() => availableTasks.value.find(t => t.id === activeTaskId.value));
const activeTaskConfig = computed(() => aiConfigStore.taskConfigs[activeTaskId.value]);
const availablePrompts = computed(() => promptTemplateStore.getPromptsForTask(activeTaskId.value));

const handleProviderChange = (event: Event) => {
  const selectedId = (event.target as HTMLSelectElement).value;
  aiConfigStore.setSelectedAIProviderId(activeTaskId.value, selectedId);
};

const handlePromptChange = (event: Event) => {
  const selectedId = (event.target as HTMLSelectElement).value;
  aiConfigStore.setSelectedPromptId(activeTaskId.value, selectedId);
};

const handleTemperatureChange = (event: Event) => {
  const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
  const temperature = sliderValue / 100;
  aiConfigStore.setTaskTemperature(activeTaskId.value, temperature);
};

// =
// 文件: ..\src\novel\editor\components\system\settings\ContextSettings.vue
//

import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';

const settingsStore = useContextSettingsStore();

const addSelectedItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.fixedContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addFixedContextItem(preset);
  }
  select.value = ""; // Reset select
};

const addSelectedOthersItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.othersContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addOthersContextItem(preset);
  }
  select.value = ""; // Reset select
};

// =
// 文件: ..\src\novel\editor\components\system\settings\EditorSettings.vue
//



// =
// 文件: ..\src\novel\editor\components\system\settings\NovelSettings.vue
//

import { useNovelSettingsStore } from '@/novel/editor/stores/novelSettingsStore';

const settingsStore = useNovelSettingsStore();

const handleReferenceSelect = (event: Event) => {
  const selectElement = event.target as HTMLSelectElement;
  const selectedId = selectElement.value;
  if (selectedId) {
    settingsStore.addReferenceNovel(selectedId);
    selectElement.value = '';
  }
};

// =
// 文件: ..\src\novel\editor\components\system\settings\TaskSettings.vue
//

import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useUIStore } from '@/novel/editor/stores/uiStore';

const aiTaskStore = useAITaskStore();
const uiStore = useUIStore();

const autoOpenAIPanel = computed({
  get: () => uiStore.uiState.autoOpenAIPanel,
  set: (value) => uiStore.setAutoOpenAIPanel(value)
});

const applicationStrategy = computed({
  get: () => uiStore.uiState.taskApplicationStrategy,
  set: (value) => uiStore.setTaskApplicationStrategy(value)
});

const concurrentTaskLimit = computed({
  get: () => uiStore.uiState.concurrentTaskLimit,
  set: (value) => uiStore.setConcurrentTaskLimit(value)
});

const handleClearCompleted = () => {
  if (window.confirm('您确定要清除所有已应用和已失败的任务吗？')) {
    aiTaskStore.clearCompletedTasks();
  }
};

const handleClearAll = () => {
  if (window.confirm('您确定要清除所有AI任务吗？此操作不可撤销，进行中的任务也将被终止。')) {
    aiTaskStore.clearAllTasks();
  }
};

// =
// 文件: ..\src\novel\editor\components\system\settings\ThemeSettings.vue
//

import { ref, computed } from 'vue';
import { useUIStore } from '@/novel/editor/stores/uiStore';

type ThemeId = 'default' | 'eye-care' | 'dark';

const uiStore = useUIStore();

const themes = ref([
  {
    id: 'default',
    name: '默认亮色',
    description: '清晰、简洁的默认主题。',
    preview: { bg: '#FFFFFF', panel: '#F3F4F6', text: '#D1D5DB', accent: '#60A5FA' }
  },
  {
    id: 'eye-care',
    name: '护眼模式',
    description: '柔和的米色背景，适合长时间阅读。',
    preview: { bg: '#FDFCF9', panel: '#F8F6F2', text: '#DCD9D3', accent: '#F59E0B' }
  },
  {
    id: 'dark',
    name: '暗黑模式',
    description: '专为夜间工作设计，减少眩光。',
    preview: { bg: '#1F2937', panel: '#374151', text: '#4B5563', accent: '#F472B6' }
  }
]);

const activeTheme = computed(() => uiStore.uiState.activeTheme);

const setActiveTheme = (themeId: ThemeId) => {
  uiStore.setTheme(themeId);
};

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings, ReferenceContextSettings, TreeNode } from '@/novel/editor/types';

const stripHtml = (html: string): string => {
    // 使用正则表达式替换，避免依赖DOM环境
    if (!html) return '';
    return html.replace(/<[^>]*>?/gm, '');
};

const _findDerivedItemsRecursive = (nodes: TreeNode[], sourceId: string): TreeNode[] => {
    let results: TreeNode[] = [];
    for (const node of nodes) {
        if (node.originalData?.sourceId === sourceId) {
            results.push(node);
        }
        if (node.children) {
            results = [...results, ..._findDerivedItemsRecursive(node.children, sourceId)];
        }
    }
    return results;
}

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const referenceStore = useReferenceStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const _buildReferenceContextHtmlByIndex = (sourceNode: Chapter | Volume, vIndex: number, cIndex: number | null, settings: ReferenceContextSettings): string => {
        // BUG: This index-based matching is fragile and likely to produce incorrect context.
        // It assumes the reference book has the exact same structure.
        // This should be replaced with a more robust matching logic (e.g., title similarity)
        // or a user-driven manual mapping feature.
        // For now, returning an empty string to prevent context pollution.
        if (true) { // Temporarily disabling this feature
            return '<!-- Reference context matching is disabled due to known bugs. -->';
        }

        if (!referenceStore.referenceData.length || vIndex < 0) return '';

        let referenceContextHtml = '';

        for (const refBook of referenceStore.referenceData) {
            const directoryRoot = refBook.children?.find(c => c.id.startsWith('ref-dir-'));
            if (!directoryRoot) continue;

            const refVolumeNode = directoryRoot.children?.[vIndex];
            if (!refVolumeNode) continue;

            let matchingNode: TreeNode | null = null;
            let matchingParent: TreeNode | null = null;

            if (sourceNode.type === 'volume') {
                matchingNode = refVolumeNode;
            } else if (sourceNode.type === 'chapter' && cIndex !== null && cIndex >= 0) {
                matchingNode = refVolumeNode.children?.[cIndex] ?? null;
                matchingParent = refVolumeNode;
            }

            if (matchingNode) {
                referenceContextHtml += `<hr><h3>参考书籍《${refBook.title}》中的匹配内容: ${matchingNode.title}</h3>`;

                if (settings.includeContent && 'content' in matchingNode && matchingNode.content) {
                    referenceContextHtml += `<h4>正文</h4>${matchingNode.content}`;
                }

                if (settings.includeVolumeInfo && matchingParent && matchingParent.type.endsWith('volume') && 'content' in matchingParent && matchingParent.content) {
                    referenceContextHtml += `<h4>所属卷信息</h4>${matchingParent.content}`;
                }

                if (settings.includePlot) {
                    const plotRoot = refBook.children?.find(c => c.id.startsWith('ref-plot-'));
                    if (plotRoot) {
                        const plotItems = _findDerivedItemsRecursive(plotRoot.children || [], matchingNode.id);
                        if (plotItems.length > 0) {
                            referenceContextHtml += `<h4>相关剧情</h4>` + plotItems.map(p => 'content' in p ? p.content : '').join('<hr>');
                        }
                    }
                }
                if (settings.includeAnalysis) {
                    const analysisRoot = refBook.children?.find(c => c.id.startsWith('ref-analysis-'));
                    if (analysisRoot) {
                        const analysisItems = _findDerivedItemsRecursive(analysisRoot.children || [], matchingNode.id);
                        if (analysisItems.length > 0) {
                            referenceContextHtml += `<h4>相关分析</h4>` + analysisItems.map(a => 'content' in a ? a.content : '').join('<hr>');
                        }
                    }
                }
            }
        }
        return referenceContextHtml;
    }

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        let referenceContextHtml = '';
        if ((sourceNode.type === 'chapter' && sourceParent) || sourceNode.type === 'volume') {
            const vIndex = directoryStore.directoryData.findIndex(v => v.id === (sourceParent?.id || sourceNode.id));
            const cIndex = sourceNode.type === 'chapter' && sourceParent ? sourceParent.chapters.findIndex(c => c.id === sourceNode.id) : null;
            referenceContextHtml = _buildReferenceContextHtmlByIndex(sourceNode, vIndex, cIndex, contextSettingsStore.referenceContextSettings);
        }
        const referenceContextText = stripHtml(referenceContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            // 使用正则表达式从<pre>标签中提取模板，更安全
            const match = promptNode.content.match(/<pre[^>]*>([\s\S]*)<\/pre>/);
            const template = match ? match[1] : selectedPromptTemplate;
            selectedPromptTemplate = template.replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# 参考书籍上下文
${referenceContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            reference: referenceContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                referenceCharCount: referenceContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\composables\useDirectoryTreeAdapter.ts
//

// 文件: src\novel\editor\composables\useDirectoryTreeAdapter.ts
import { computed } from 'vue';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import type { TreeNode, VolumeNode } from '@/novel/editor/types';

export function useDirectoryTreeAdapter() {
    const directoryStore = useDirectoryStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    const treeNodes = computed((): VolumeNode[] => {
        return directoryStore.directoryData.map(volume => ({
            id: volume.id,
            title: volume.title,
            icon: getIconByNodeType(volume.type),
            type: 'volume',
            content: volume.content,
            originalData: volume,
            children: volume.chapters.map(chapter => ({
                id: chapter.id,
                title: chapter.title,
                icon: getIconByNodeType(chapter.type),
                type: 'chapter',
                status: chapter.status,
                content: chapter.content,
                originalData: chapter,
            })),
        }));
    });

    const activeNodeId = computed(() => editorStore.activeTabId);
    const expandedNodeIds = computed(() => uiStore.uiState.expandedNodeIds);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const handleSelectNode = (node: TreeNode) => {
        if (node.type === 'chapter' || node.type === 'volume') {
            editorStore.openTab(node.id);
        } else if (node.children && node.children.length > 0) {
            uiStore.toggleNodeExpansion(node.id);
        }
    };

    const handleToggleExpansion = (id: string) => {
        uiStore.toggleNodeExpansion(id);
    };

    const handleCommitRename = (payload: { nodeId: string; newTitle: string; }) => {
        directoryStore.renameNode(payload.nodeId, payload.newTitle);
        uiStore.setEditingNodeId(null);
    };

    const handleCancelRename = () => {
        uiStore.setEditingNodeId(null);
    };

    return {
        treeNodes,
        activeNodeId,
        expandedNodeIds,
        editingNodeId,
        handleSelectNode,
        handleToggleExpansion,
        handleCommitRename,
        handleCancelRename
    };
}

// =
// 文件: ..\src\novel\editor\composables\useReferenceTreeAdapter.ts
//

// 文件: src\novel\editor\composables\useReferenceTreeAdapter.ts
import { computed } from 'vue';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode } from '@/novel/editor/types';

export function useReferenceTreeAdapter() {
    const referenceStore = useReferenceStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    const treeNodes = computed((): TreeNode[] => {
        return referenceStore.referenceData;
    });

    const activeNodeId = computed(() => editorStore.activeTabId);
    const expandedNodeIds = computed(() => uiStore.uiState.expandedReferenceNodeIds);

    const handleSelectNode = (node: TreeNode) => {
        // 如果节点有子节点，则切换其展开状态
        if (node.children && node.children.length > 0) {
            uiStore.toggleReferenceNodeExpansion(node.id);
        }
        // 如果节点是可打开的内容项，则在编辑器中打开它
        else if (node.hasOwnProperty('content')) {
            editorStore.openTab(node.id);
        }
    };

    const handleToggleExpansion = (id: string) => {
        uiStore.toggleReferenceNodeExpansion(id);
    };

    return {
        treeNodes,
        activeNodeId,
        expandedNodeIds,
        handleSelectNode,
        handleToggleExpansion,
    };
}

// =
// 文件: ..\src\novel\editor\composables\useRelatedContentTreeAdapter.ts
//

// 文件: src\novel\editor\composables\useRelatedContentTreeAdapter.ts
import { computed } from 'vue';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { TreeNode } from '@/novel/editor/types';

export function useRelatedContentTreeAdapter() {
    const relatedContentStore = useRelatedContentStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const promptTemplateStore = usePromptTemplateStore();

    const treeNodes = computed((): TreeNode[] => {
        return relatedContentStore.relatedData;
    });

    const activeNodeId = computed(() => editorStore.activeTabId);
    const expandedNodeIds = computed(() => uiStore.uiState.expandedRelatedNodeIds);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const handleSelectNode = (node: TreeNode) => {
        if ('content' in node && node.content !== undefined) {
            editorStore.openTab(node.id);
        } else if (node.children && node.children.length > 0) {
            uiStore.toggleRelatedNodeExpansion(node.id);
        }
    };

    const handleToggleExpansion = (id: string) => {
        uiStore.toggleRelatedNodeExpansion(id);
    };

    const handleCommitRename = (payload: { nodeId: string; newTitle: string; }) => {
        const { node } = relatedContentStore.findNodeById(payload.nodeId) || { node: null };
        const nodeType = node?.type;
        const newTitle = payload.newTitle.trim();

        if (newTitle) {
            switch (nodeType) {
                case 'prompt_item':
                    promptTemplateStore.renamePrompt(payload.nodeId, newTitle);
                    break;
                case 'others_item':
                    relatedContentStore.renameCustomOthersNode(payload.nodeId, newTitle);
                    break;
                case 'plot_item':
                case 'analysis_item':
                    if (payload.nodeId.startsWith('custom-')) {
                        relatedContentStore.renameCustomRelatedNode(payload.nodeId, newTitle);
                    } else {
                        relatedContentStore.renameRelatedNode(payload.nodeId, newTitle);
                    }
                    break;
                default:
                    relatedContentStore.renameRelatedNode(payload.nodeId, newTitle);
                    break;
            }
        }
        uiStore.setEditingNodeId(null);
    };

    const handleCancelRename = () => {
        uiStore.setEditingNodeId(null);
    };

    return {
        treeNodes,
        activeNodeId,
        expandedNodeIds,
        editingNodeId,
        handleSelectNode,
        handleToggleExpansion,
        handleCommitRename,
        handleCancelRename
    };
}

// =
// 文件: ..\src\novel\editor\layouts\NovelEditorLayout.vue
//

import '@/novel/assets/styles/main.css';
import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ContextPreviewModal from '@/novel/editor/components/modals/ContextPreviewModal.vue';
import ReaderModeOverlay from '@novel/editor/views/ReaderModeOverlay.vue';
import {useAuthStore} from "@auth/store/auth.store.ts";
const authStore = useAuthStore();
const editorStore = useEditorStore();
const uiStore = useUIStore();
const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\services\ai\AITaskExecutionService.ts
//


import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore';
import { useUIStore } from '@novel/editor/stores/uiStore';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder';
import { streamAITask } from '@novel/editor/services/ai/aiService.ts';
import type { AITask } from '@/novel/editor/types';

const { buildContextForTask } = useContextBuilder();

function executeTaskAndStream(task: AITask) {
    const aiTaskStore = useAITaskStore();

    aiTaskStore.updateTaskStatus(task.id, 'processing');

    // 如果任务没有最终提示词，立即构建它
    if (!task.finalPrompt) {
        const contextResult = buildContextForTask(task);
        if (!contextResult || !contextResult.prompt) {
            aiTaskStore.updateTaskError(task.id, '上下文构建失败，无法生成最终提示词。');
            processQueue(); // 继续处理下一个任务
            return;
        }
        task.finalPrompt = contextResult.prompt;
    }

    const promptToUse = task.finalPrompt;

    streamAITask(promptToUse, task.aiConfig, task.type, task.sourceItemTitle, {
        onChunk: (chunk) => {
            aiTaskStore.appendGeneratedContent(task.id, chunk);
        },
        onComplete: () => {
            aiTaskStore.completeTask(task.id);
            processQueue(); // 完成后处理下一个
        },
        onError: (error) => {
            aiTaskStore.updateTaskError(task.id, error);
            processQueue(); // 出错后也处理下一个
        }
    });
}

/**
 * 处理任务队列。检查当前正在执行的任务数是否达到并发上限，
 * 如果没有，则从等待队列中取出任务开始执行。
 */
export function processQueue() {
    const uiStore = useUIStore();
    const aiTaskStore = useAITaskStore();

    const limit = uiStore.uiState.concurrentTaskLimit;
    const processingCount = aiTaskStore.tasks.filter(t => t.status === 'processing').length;

    if (processingCount >= limit) {
        return;
    }

    const canStartCount = limit - processingCount;
    const pendingTasks = aiTaskStore.tasks.filter(t => t.status === 'pending');

    const tasksToStart = pendingTasks.slice(0, canStartCount);

    for (const task of tasksToStart) {
        executeTaskAndStream(task);
    }
}

// =
// 文件: ..\src\novel\editor\services\ai\AITaskFactory.ts
//

import { useEditorStore } from '@novel/editor/stores/editorStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import type { AITask, AITaskType } from '@/novel/editor/types';

/**
 * 创建一个新的AI任务对象。
 * @param taskType AI任务的类型。
 * @param sourceItemId 源文档的ID。
 * @param finalPrompt 可选的，预先构建好的最终提示词。
 * @returns 一个结构完整的AITask对象，如果源项目无效则返回null。
 */
export async function createTask(taskType: AITaskType, sourceItemId: string, finalPrompt?: string): Promise<AITask | null> {
    const editorStore = useEditorStore();
    const aiConfigStore = useAIConfigStore();

    const { node: sourceItem } = editorStore.findItemById(sourceItemId);
    if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
        console.error("AI Task Factory Error: Source item not found or has no content.", sourceItemId);
        return null;
    }

    // --- 核心Bug修复：版本控制 ---
    // 为源对象打上一个时间戳作为版本号
    // 如果已有，则更新它
    (sourceItem as any)._lastModified = Date.now();
    const sourceItemVersion = (sourceItem as any)._lastModified;
    // --- 核心Bug修复结束 ---

    const taskConfigSettings = aiConfigStore.taskConfigs[taskType];
    const baseAIProviderConfig = aiConfigStore.availableAIProviders.find(p => p.id === taskConfigSettings.selectedAIProviderId);

    if (!baseAIProviderConfig) {
        console.error("AI Task Factory Error: Selected AI Provider Config not found.", taskConfigSettings.selectedAIProviderId);
        alert(`未找到ID为 "${taskConfigSettings.selectedAIProviderId}" 的AI配置，请在设置中检查。`);
        return null;
    }

    const finalAIConfig = {
        ...baseAIProviderConfig,
        temperature: taskConfigSettings.temperature,
    };

    // 对于所有任务，目标ID最初都指向源ID。
    // 应用时，将根据任务类型决定是修改此ID的项，还是基于此ID创建新项。
    const targetItemId = sourceItemId;
    const taskTitle = `${taskType}《${sourceItem.title}》`;

    const newTask: AITask = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title: taskTitle,
        type: taskType,
        sourceItemId: sourceItemId,
        targetItemId: targetItemId,
        sourceItemTitle: sourceItem.title,
        sourceItemContent: sourceItem.content,
        sourceItemVersion: sourceItemVersion, // 存储版本快照
        status: 'pending',
        generatedContent: '',
        finalPrompt: finalPrompt,
        createdAt: new Date(),
        aiConfig: finalAIConfig,
    };

    return newTask;
}

// =
// 文件: ..\src\novel\editor\services\ai\aiService.ts
//

import * as aiProviderApi from '@novel/editor/api/aiProviderApi';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';
import { streamAITask as streamAITaskFromApi } from '@novel/editor/api/aiApi';

interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 从系统设置中获取所有已启用的、可供编辑器使用的AI配置。
 * @returns 返回一个符合编辑器AIProviderConfig格式的数组。
 */
export async function fetchAvailableAIProviders(): Promise<AIProviderConfig[]> {
    try {
        return await aiProviderApi.fetchAIProviders();
    } catch (error) {
        console.error("Failed to fetch available AI providers from API layer:", error);
        return [];
    }
}

/**
 * 通过API层执行一个流式AI任务。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param taskType - 任务的类型 ('润色', '续写' 等).
 * @param sourceItemTitle - 任务源文档的标题.
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: StreamCallbacks
): void {
    console.log(`[AI Service] Delegating task to API layer. Type: ${taskType}, Title: ${sourceItemTitle}`);
    streamAITaskFromApi(prompt, config, taskType, sourceItemTitle, callbacks);
}

// =
// 文件: ..\src\novel\editor\services\ai\chatService.ts
//

import * as chatApi from '@/novel/editor/api/chatApi';
import type { BackendChatMessage, Conversation, StreamResponseChunk } from '@novel/editor/types/chatTypes.ts';

export const streamMessage = (
    apiKeyId: number,
    messages: BackendChatMessage[],
    callbacks: {
        onChunk: (chunk: StreamResponseChunk) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    return chatApi.streamChat(apiKeyId, messages, callbacks);
};

// 模拟函数，保持UI可运行
export async function getConversations(): Promise<Conversation[]> {
    return await chatApi.fetchConversations();
}

export async function createConversation(): Promise<Conversation> {
    return await chatApi.createConversation();
}

// =
// 文件: ..\src\novel\editor\services\derivedContentService.ts
//

import * as derivedContentApi from '@/novel/editor/api/derivedContentApi';
import type { PlotAnalysisItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有派生内容（剧情和分析）。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有派生内容条目的数组。
 */
export const getDerivedItemsForNovel = (novelId: string): Promise<PlotAnalysisItem[]> => {
    return derivedContentApi.getDerivedItemsForNovel(novelId);
};

/**
 * 创建一个新的派生内容条目。
 * @param itemData - 创建条目所需的数据。
 * @returns 返回新创建的派生内容条目。
 */
export const createDerivedItem = (itemData: Omit<PlotAnalysisItem, 'id'>): Promise<PlotAnalysisItem> => {
    return derivedContentApi.createDerivedItem(itemData);
};

/**
 * 更新一个派生内容条目。
 * @param itemId - 要更新的条目的ID。
 * @param itemData - 包含更新字段的对象。
 * @returns 返回更新后的派生内容条目。
 */
export const updateDerivedItem = (itemId: string, itemData: Partial<Omit<PlotAnalysisItem, 'id'>>): Promise<PlotAnalysisItem> => {
    return derivedContentApi.updateDerivedItem(itemId, itemData);
};

/**
 * 删除一个派生内容条目。
 * @param itemId - 要删除的条目的ID。
 */
export const deleteDerivedItem = (itemId: string): Promise<void> => {
    return derivedContentApi.deleteDerivedItem(itemId);
};

// =
// 文件: ..\src\novel\editor\services\diffService.ts
//

// 文件: ..\src\novel\editor\services\diffService.ts

import HtmlDiff from 'htmldiff-js';

/**
 * 计算两个HTML字符串之间的差异。
 * @param oldHtml - 旧版本的HTML内容。
 * @param newHtml - 新版本的HTML内容。
 * @returns 一个包含 <ins> 和 <del> 标签来高亮差异的HTML字符串。
 */
export const calculateHtmlDiff = (oldHtml: string, newHtml: string): string => {
    const differ = new HtmlDiff();

    // 调用 build 方法计算差异
    const diffResult = differ.build(oldHtml, newHtml);

    return diffResult;
};

// =
// 文件: ..\src\novel\editor\services\directoryService.ts
//

import * as volumeApi from '@/novel/editor/api/volumeApi';
import * as chapterApi from '@/novel/editor/api/chapterApi';
import type { Volume, Chapter } from '@/novel/editor/types';

export const getDirectoryData = async (novelId: string): Promise<Volume[]> => {
    const [volumes, chapters] = await Promise.all([
        volumeApi.getVolumes(novelId),
        chapterApi.getChaptersForNovel(novelId),
    ]);

    const volumeMap = new Map(volumes.map(v => [v.id, { ...v, chapters: [] as Chapter[] }]));
    chapters.forEach(chapter => {
        const volume = volumeMap.get(chapter.volumeId);
        if (volume) {
            volume.chapters.push(chapter);
        }
    });

    const sortedVolumes = Array.from(volumeMap.values()).sort((a, b) => a.order - b.order);
    sortedVolumes.forEach(volume => {
        volume.chapters.sort((a, b) => a.order - b.order);
    });

    return sortedVolumes;
};

export const saveDirectoryData = async (novelId: string, volumes: Volume[]): Promise<void> => {
    const savePromises: Promise<any>[] = [];

    const orderedVolumeIds = volumes.map((v, index) => {
        savePromises.push(volumeApi.updateVolume(v.id, { title: v.title, content: v.content, order: index }));
        v.chapters.forEach((c, cIndex) => {
            savePromises.push(chapterApi.updateChapter(c.id, { title: c.title, content: c.content, status: c.status, order: cIndex }));
        });
        const orderedChapterIds = v.chapters.map(c => c.id);
        savePromises.push(chapterApi.updateChapterOrder(v.id, orderedChapterIds));
        return v.id;
    });

    savePromises.push(volumeApi.updateVolumeOrder(novelId, orderedVolumeIds));

    await Promise.all(savePromises);
};

export const createVolume = (novelId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    return volumeApi.createVolume(novelId, volumeData);
};

export const deleteVolume = (volumeId: string): Promise<void> => {
    return volumeApi.deleteVolume(volumeId);
};

export const createChapter = (volumeId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    return chapterApi.createChapter(volumeId, chapterData);
};

export const deleteChapter = (chapterId: string): Promise<void> => {
    return chapterApi.deleteChapter(chapterId);
};

// =
// 文件: ..\src\novel\editor\services\historyService.ts
//

import * as historyApi from '@/novel/editor/api/historyApi';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';
import { useEditorStore } from '@novel/editor/stores/editorStore';
;

/**
 * 获取指定文档的历史版本列表。
 */
export const getHistoryVersions = async (documentId: string): Promise<HistoryVersion[]> => {
    return await historyApi.fetchHistoryForDocument(documentId);
};

/**
 * 将指定文档恢复到某个历史版本。
 * @param documentId - 要恢复的文档ID。
 * @param versionId - 要恢复到的版本ID。
 */
export const restoreVersion = async (documentId: string, versionId: string): Promise<void> => {
    const editorStore = useEditorStore();
    const novelId = editorStore.novelMetadata?.id;

    if (!novelId) {
        console.error('无法恢复版本：未找到当前小说ID。');
        alert('恢复失败，缺少小说上下文。');
        return;
    }

    await historyApi.restoreVersion(documentId, versionId);

    // 恢复成功后，重新加载整个项目以确保数据一致性
    const { loadProject } = useProjectManager();
    await loadProject(novelId);
};

// =
// 文件: ..\src\novel\editor\services\metadataService.ts
//

// 文件: ..\src\novel\editor\services\metadataService.ts
import * as metadataApi from '@/novel/editor/api/metadataApi';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * 根据小说ID获取元数据
 * @param novelId - 小说ID
 * @returns 返回小说元数据
 */
export const getNovelMetadata = (novelId: string): Promise<NovelMetadata> => {
    return metadataApi.getNovelMetadata(novelId);
};

/**
 * 更新小说元数据
 * @param novelId - 小说ID
 * @param metadata - 更新后的元数据
 * @returns 返回更新后的元数据
 */
export const updateNovelMetadata = (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    return metadataApi.updateNovelMetadata(novelId, metadata);
};

// =
// 文件: ..\src\novel\editor\services\noteService.ts
//

import * as noteApi from '@/novel/editor/api/noteApi';
import type { NoteItem } from '@/novel/editor/types';

// --- API Facade ---

export const getNotesForNovel = (novelId: string): Promise<NoteItem[]> => {
    return noteApi.getNotesForNovel(novelId);
};

export const createNoteApi = (novelId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    return noteApi.createNote(novelId, noteData);
};

export const updateNoteApi = (noteId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    return noteApi.updateNote(noteId, noteData);
};

export const deleteNoteApi = (noteId: string): Promise<void> => {
    return noteApi.deleteNote(noteId);
};


// --- Client-side Logic ---

/**
 * 根据新的HTML内容更新笔记对象，并同步标题
 * @param note - 要更新的原始笔记对象
 * @param newContent - 新的HTML内容
 * @returns 一个被更新后的新笔记对象副本
 */
export const updateNoteWithNewContent = (note: NoteItem, newContent: string): NoteItem => {
    const updatedNote = { ...note, content: newContent };

    const h1Match = newContent.match(/<h1[^>]*>(.*?)<\/h1>/);
    const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;

    if (newTitle) {
        updatedNote.title = newTitle;
    }

    return updatedNote;
};

/**
 * 将文本内容附加到现有笔记内容的末尾
 * @param originalContent - 原始HTML内容
 * @param contentToAppend - 要附加的纯文本内容
 * @param isAutoApplied - 是否为AI自动应用，若是则添加一个标记
 * @returns 附加了新内容的完整HTML字符串
 */
export const appendContentToNote = (originalContent: string, contentToAppend: string, isAutoApplied: boolean): string => {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    return (originalContent || "") + htmlToAppend;
};

/**
 * 根据新标题更新笔记对象，并同步内容中的<h1>标签
 * @param note - 要更新的原始笔记对象
 * @param newTitle - 新的标题
 * @returns 一个被更新后的新笔记对象副本
 */
export const renameNote = (note: NoteItem, newTitle: string): NoteItem => {
    const updatedNote = { ...note, title: newTitle };
    if (updatedNote.content.includes('<h1>')) {
        updatedNote.content = updatedNote.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
    } else {
        updatedNote.content = `<h1>${newTitle}</h1>` + updatedNote.content;
    }
    return updatedNote;
};

// =
// 文件: ..\src\novel\editor\services\novelSettingsService.ts
//


import * as novelProjectService from '@/novel/services/novelProjectService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

class NovelSettingsService {

    /**
     * 根据ID数组异步获取完整的小说项目对象列表。
     * @param novelIds - 要获取的小说ID数组。
     * @returns 完整的小说项目对象数组。
     */
    public async getReferencedNovels(novelIds: string[]): Promise<NovelProject[]> {
        if (!novelIds || novelIds.length === 0) return [];

        const projects = await Promise.all(
            novelIds.map(id => novelProjectService.getNovelProject(id).catch(() => undefined))
        );

        return projects.filter((p): p is NovelProject => p !== undefined);
    }

    /**
     * 异步获取可供添加为参考书的所有其他小说项目。
     * @param novelMetadata - 当前正在编辑的小说的元数据。
     * @returns 可用的参考小说项目数组。
     */
    public async getAvailableReferenceNovels(novelMetadata: NovelMetadata | null): Promise<NovelProject[]> {
        const allNovels = await novelProjectService.fetchAllNovelProjects();
        if (!novelMetadata) return allNovels;

        const currentAndReferencedIds = new Set([
            ...(novelMetadata.referenceNovelIds || []),
            novelMetadata.id
        ]);

        return allNovels.filter(novel => !currentAndReferencedIds.has(novel.metadata.id));
    }
}

export const novelSettingsService = new NovelSettingsService();

// =
// 文件: ..\src\novel\editor\services\promptService.ts
//

import type { TreeNode, AITaskType } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

class PromptService {

    public buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }
}

export const promptService = new PromptService();

// =
// 文件: ..\src\novel\editor\services\referenceService.ts
//

import type { TreeNode, ItemNode, PlotAnalysisItem, Volume, Chapter } from '@/novel/editor/types';
import type { NovelProject } from '@/novel/editor/types/project';
import { getNovelProject } from '@/novel/editor/api/novelProjectApi.ts';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class ReferenceService {

    private makeNodesReadOnly(nodes: TreeNode[]): TreeNode[] {
        return nodes.map(node => {
            const newNode: TreeNode = { ...node, isReadOnly: true };
            if (newNode.children) {
                newNode.children = this.makeNodesReadOnly(newNode.children);
            }
            if (newNode.isOverview) {
                newNode.content = `<p class="overview-placeholder">参考书中所有内容均为只读。</p>`;
            }
            return newNode;
        });
    }

    private projectToTreeNode(project: NovelProject): TreeNode {
        const rootNode: TreeNode = {
            id: `ref-book-${project.metadata.id}`,
            type: 'reference_book',
            title: project.metadata.title,
            icon: getIconByNodeType('reference_book'),
            children: []
        };

        const directoryNode: TreeNode = {
            id: `ref-dir-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '目录',
            icon: 'fa-regular fa-folder-open',
            children: this.makeNodesReadOnly(project.directoryData.map((vol: Volume) => ({
                id: vol.id,
                title: vol.title,
                type: 'reference_volume',
                icon: getIconByNodeType('reference_volume'),
                content: vol.content,
                isReadOnly: true,
                children: vol.chapters.map((chap: Chapter) => ({
                    id: chap.id,
                    title: chap.title,
                    type: 'reference_chapter',
                    icon: getIconByNodeType('reference_chapter'),
                    content: chap.content,
                    isReadOnly: true
                }))
            })))
        };
        rootNode.children?.push(directoryNode);

        const buildRefDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[] | undefined, directory: Volume[]): TreeNode[] => {
            if (!dataArray || dataArray.length === 0) return [];

            return directory.map((volume: Volume) => {
                const derivedForVolume = dataArray
                    .filter((item: PlotAnalysisItem) => item.sourceId === volume.id)
                    .map((item: PlotAnalysisItem) => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        content: item.content,
                        originalData: item
                    }));

                const derivedForChapters = volume.chapters
                    .map((chapter: Chapter) => {
                        const itemsForChapter = dataArray.filter((item: PlotAnalysisItem) => item.sourceId === chapter.id);
                        if (itemsForChapter.length === 0) return null;

                        return {
                            id: `ref-derived-group-${type}-${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            children: itemsForChapter.map((item: PlotAnalysisItem) => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                content: item.content,
                                originalData: item
                            }))
                        };
                    })
                    .filter((c: TreeNode | null): c is TreeNode => c !== null);

                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `ref-derived-group-${type}-${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v: TreeNode | null): v is TreeNode => v !== null);
        };

        const plotTree = buildRefDerivedContentTree('plot', project.derivedPlotData, project.directoryData);
        const plotNode: TreeNode = {
            id: `ref-plot-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '剧情',
            icon: getIconByNodeType('plot'),
            children: this.makeNodesReadOnly([
                ...project.plotCustomData,
                ...plotTree
            ])
        };
        if (plotNode.children && plotNode.children.length > 0) {
            rootNode.children?.push(plotNode);
        }

        const analysisTree = buildRefDerivedContentTree('analysis', project.derivedAnalysisData, project.directoryData);
        const analysisNode: TreeNode = {
            id: `ref-analysis-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '分析',
            icon: getIconByNodeType('analysis'),
            children: this.makeNodesReadOnly([
                ...project.analysisCustomData,
                ...analysisTree
            ])
        };
        if (analysisNode.children && analysisNode.children.length > 0) {
            rootNode.children?.push(analysisNode);
        }

        const settingsRoot = project.settingsData.find(n => n.id === 'setting');
        if (settingsRoot && settingsRoot.children) {
            const settingsNode: TreeNode = {
                id: `ref-settings-${project.metadata.id}`,
                type: 'reference_content_item',
                title: settingsRoot.title,
                icon: getIconByNodeType('setting'),
                children: this.makeNodesReadOnly(settingsRoot.children)
            };
            rootNode.children?.push(settingsNode);
        }

        return rootNode;
    }

    public async buildReferenceTree(referenceNovelIds: string[]): Promise<TreeNode[]> {
        if (!referenceNovelIds || referenceNovelIds.length === 0) {
            return [];
        }

        const projects = await Promise.all(
            referenceNovelIds.map(id => getNovelProject(id))
        );

        const validProjects = projects.filter((p): p is NovelProject => p !== undefined);

        return validProjects.map(project => this.projectToTreeNode(project));
    }
}

export const referenceService = new ReferenceService();

// =
// 文件: ..\src\novel\editor\services\related\nodeOperationService.ts
//

// src/novel/editor/services/related/nodeOperationService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// Private helper function
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// Private helper function
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
};

export function findNodeById(nodeId: string, allDataSources: TreeNode[][]): { node: TreeNode; parent: TreeNode | null; } | null {
    for (const source of allDataSources) {
        const result = _findNodeInTreeRecursive(source, nodeId);
        if (result) return result;
    }
    return null;
}

export function createRelatedNode(parentNode: GroupNode, type: 'group' | 'item'): GroupNode | ItemNode {
    const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
    const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
    const newNodeIcon = getIconByNodeType(newNodeType);

    if (type === 'group') {
        const newNode: GroupNode = {
            id: `group-${Date.now()}`,
            title: '新建分组',
            type: 'group',
            icon: newNodeIcon,
            children: [],
        };
        return newNode;
    } else { // type === 'item'
        const newNode: ItemNode = {
            id: `item-${Date.now()}`,
            title: '新建条目',
            type: newNodeType as ItemNode['type'],
            icon: newNodeIcon,
            content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
        };
        return newNode;
    }
}

export function createCustomNode(type: 'plot' | 'analysis' | 'others'): ItemNode {
    const itemType = type === 'others' ? 'others_item' : `${type}_item`;
    const icon = getIconByNodeType(itemType);
    const title = type === 'others' ? '新建其他条目' : '新建自定义条目';

    const newNode: ItemNode = {
        id: `custom-${type}-${Date.now()}`,
        title: title,
        type: itemType as ItemNode['type'],
        icon: icon,
        content: `<h1>${title}</h1><p>请在此处填写内容...</p>`,
    };
    return newNode;
}

export function deleteNode(nodeId: string, allDataSources: TreeNode[][]): boolean {
    for (const source of allDataSources) {
        if (_findAndRemoveNodeInTree(source, nodeId)) {
            return true;
        }
    }
    return false;
}

export function renameNode(node: TreeNode, newTitle: string) {
    if (node && !node.isReadOnly && newTitle.trim()) {
        const trimmedTitle = newTitle.trim();
        node.title = trimmedTitle;
        if ('content' in node && node.content && node.content.includes('<h1>')) {
            (node as ItemNode).content = (node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        }
        (node as any)._lastModified = Date.now(); // Update version timestamp
    }
}

export function updateNodeContent(node: ItemNode, content: string) {
    node.content = content;
    (node as any)._lastModified = Date.now(); // Update version timestamp
    if (!node.isReadOnly) {
        const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
        if (newTitle && newTitle !== node.title) {
            node.title = newTitle;
        }
    }
}

export function appendNodeContent(node: ItemNode, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    if (!node.content) node.content = "";
    node.content += htmlToAppend;
    (node as any)._lastModified = Date.now(); // Update version timestamp
}

// =
// 文件: ..\src\novel\editor\services\related\overviewService.ts
//


import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
 * @param htmlContent - HTML 字符串
 * @returns 降级后的 HTML 字符串
 */
const demoteHeadings = (htmlContent: string): string => {
    if (typeof document === 'undefined') return htmlContent; // Guard for SSR
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
    headings.forEach(heading => {
        const level = parseInt(heading.tagName.charAt(1), 10);
        const newLevel = Math.min(6, level + 1); // 最多降到 h6
        const newHeading = document.createElement(`h${newLevel}`);
        newHeading.innerHTML = heading.innerHTML;
        for (const attr of heading.attributes) {
            newHeading.setAttribute(attr.name, attr.value);
        }
        heading.parentNode?.replaceChild(newHeading, heading);
    });
    return tempDiv.innerHTML;
};


/**
 * 更新单个分组节点下的总览内容。
 * @param groupNode - 包含总览节点的父分组节点。
 */
function updateOverviewContentForGroup(groupNode: GroupNode) {
    if (!groupNode.children) return;

    const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
    if (!overviewNode) return;

    const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

    const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

    overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
}

/**
 * 遍历整个设定树，更新所有找到的总览节点。
 * @param settingsData - 设定的树形数据 (可直接修改)
 */
export function updateAllOverviewContent(settingsData: TreeNode[]) {
    const findAndProcess = (nodes: TreeNode[]) => {
        for (const node of nodes) {
            if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                updateOverviewContentForGroup(node as GroupNode);
            }
            if (node.children) {
                findAndProcess(node.children);
            }
        }
    };
    findAndProcess(settingsData);
}

// =
// 文件: ..\src\novel\editor\services\related\treeBuilderService.ts
//

// src/novel/editor/services/related/treeBuilderService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode, Volume } from '@novel/editor/types';

function buildDerivedContentTree(
    type: 'plot' | 'analysis',
    dataArray: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    return directoryData.map(volume => {
        const derivedForVolume = dataArray
            .filter(item => item.sourceId === volume.id)
            .map(item => ({
                id: item.id,
                title: item.title,
                type: `${type}_item` as ItemNode['type'],
                icon: getIconByNodeType(`${type}_item`),
                originalData: item,
                content: item.content
            }));

        const derivedForChapters = volume.chapters
            .map(chapter => {
                const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                if (derivedForChapter.length === 0) return null;

                return {
                    id: `${type}_ch_group_${chapter.id}`,
                    title: chapter.title,
                    type: 'group',
                    icon: getIconByNodeType('chapter'),
                    isReadOnly: true,
                    children: derivedForChapter.map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }))
                };
            })
            .filter((c): c is TreeNode => c !== null);

        if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
            return null;
        }

        return {
            id: `${type}_vol_group_${volume.id}`,
            title: volume.title,
            type: 'group',
            icon: getIconByNodeType('volume'),
            isReadOnly: true,
            children: [
                ...derivedForVolume,
                ...derivedForChapters
            ]
        };
    }).filter((v): v is TreeNode => v !== null);
}

/**
 * 构建完整的 "相关内容" 侧边栏树。
 */
export function buildRelatedTree(
    settingsData: TreeNode[],
    plotCustomData: TreeNode[],
    analysisCustomData: TreeNode[],
    othersCustomData: TreeNode[],
    promptTree: TreeNode[],
    plotItems: PlotAnalysisItem[],
    analysisItems: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    const plotDerivedTree = buildDerivedContentTree('plot', plotItems, directoryData);
    const analysisDerivedTree = buildDerivedContentTree('analysis', analysisItems, directoryData);

    const plotTree: RootNode = {
        id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
        children: [
            ...plotCustomData,
            ...plotDerivedTree
        ]
    };

    const analysisTree: RootNode = {
        id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
        children: [
            ...analysisCustomData,
            ...analysisDerivedTree
        ]
    };

    const othersTree: RootNode = {
        id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
        children: [
            ...promptTree,
            ...othersCustomData
        ]
    };

    return [...settingsData, plotTree, analysisTree, othersTree];
}

// =
// 文件: ..\src\novel\editor\services\relatedContentService.ts
//

// 文件: ..\src\novel\editor\services\relatedContentService.ts
import * as settingsApi from '@/novel/editor/api/settingsApi';
import * as customPlotApi from '@/novel/editor/api/customPlotApi';
import * as customAnalysisApi from '@/novel/editor/api/customAnalysisApi';
import * as customOthersApi from '@/novel/editor/api/customOthersApi';
import type { TreeNode, ItemNode } from '@/novel/editor/types';

export interface RelatedContentData {
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    othersCustomData: ItemNode[];
}

class RelatedContentService {
    public async getRelatedContent(novelId: string): Promise<RelatedContentData> {
        const [
            settingsData,
            plotCustomData,
            analysisCustomData,
            othersCustomData
        ] = await Promise.all([
            settingsApi.getSettingsData(novelId),
            customPlotApi.getPlotCustomData(novelId),
            customAnalysisApi.getAnalysisCustomData(novelId),
            customOthersApi.getOthersCustomData(novelId),
        ]);

        return {
            settingsData,
            plotCustomData,
            analysisCustomData,
            othersCustomData
        };
    }

    public async saveRelatedContent(novelId: string, data: RelatedContentData): Promise<void> {
        await Promise.all([
            settingsApi.updateSettingsData(novelId, data.settingsData),
            customPlotApi.updatePlotCustomData(novelId, data.plotCustomData),
            customAnalysisApi.updateAnalysisCustomData(novelId, data.analysisCustomData),
            customOthersApi.updateOthersCustomData(novelId, data.othersCustomData),
        ]);
    }
}

export const relatedContentService = new RelatedContentService();

// =
// 文件: ..\src\novel\editor\services\searchService.ts
//

import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class SearchService {
    private get directoryStore() { return useDirectoryStore(); }
    private get relatedContentStore() { return useRelatedContentStore(); }
    private get notesStore() { return useNotesStore(); }
    private get referenceStore() { return useReferenceStore(); }

    public search(query: string): SearchResult[] {
        if (!query || query.trim().length < 1) {
            return [];
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            // 1. 检查标题是否匹配
            const titleMatch = item.title.toLowerCase().includes(lowerCaseQuery);

            // 2. 检查内容是否匹配
            let contentMatches = false;
            const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
            let match;
            const matchesForThisItem: { context: string }[] = [];

            while ((match = regex.exec(textContent)) !== null) {
                contentMatches = true;
                if (matchesForThisItem.length < 5) { // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    matchesForThisItem.push({ context: `...${context}...` });
                } else {
                    break;
                }
            }

            // 如果标题或内容任一匹配，则加入结果列表
            if(titleMatch || contentMatches){
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;

                // 如果是因为内容匹配，添加匹配片段
                if(contentMatches){
                    result.matches.push(...matchesForThisItem);
                }
                // 如果只是标题匹配，可以添加一个特殊的 "match" 来注明
                else if (titleMatch) {
                    result.matches.push({ context: `<span class="italic text-gray-500">标题匹配</span>` });
                }
            }
        };

        // 遍历所有数据源
        this.directoryStore.directoryData.forEach(vol => {
            processItem(vol);
            vol.chapters.forEach(processItem);
        });

        const flattenAndProcess = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenAndProcess(node.children);
            });
        };

        flattenAndProcess(this.relatedContentStore.relatedData);
        flattenAndProcess(this.referenceStore.referenceData);

        this.notesStore.notes.forEach(processItem);

        return Array.from(resultsMap.values());
    }
}

export const searchService = new SearchService();

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { AITaskType, AIProviderConfig } from '@novel/editor/types';
import { fetchAvailableAIProviders } from '@novel/editor/services/ai/aiService';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

interface TaskConfig {
    selectedPromptId: string;
    selectedAIProviderId: string | null;
    temperature: number;
}

export const useAIConfigStore = defineStore('aiConfig', () => {
    const availableAIProviders = ref<AIProviderConfig[]>([]);
    const selectedChatProviderId = ref<string | null>(null);

    const taskConfigs = ref<Record<AITaskType, TaskConfig>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'], selectedAIProviderId: null, temperature: 0.7 },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'], selectedAIProviderId: null, temperature: 0.8 },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'], selectedAIProviderId: null, temperature: 0.5 },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'], selectedAIProviderId: null, temperature: 0.9 },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'], selectedAIProviderId: null, temperature: 0.7 },
    });

    const selectedChatProviderConfig = computed(() => {
        return availableAIProviders.value.find(p => p.id === selectedChatProviderId.value) || null;
    });

    async function initializeProviders() {
        if (availableAIProviders.value.length > 0) return;

        availableAIProviders.value = await fetchAvailableAIProviders();

        const firstAvailableProviderId = availableAIProviders.value[0]?.id || null;

        if (!selectedChatProviderId.value) {
            selectedChatProviderId.value = firstAvailableProviderId;
        }

        for (const taskType in taskConfigs.value) {
            const config = taskConfigs.value[taskType as AITaskType];
            const isCurrentProviderAvailable = availableAIProviders.value.some(p => p.id === config.selectedAIProviderId);
            if (!isCurrentProviderAvailable) {
                config.selectedAIProviderId = firstAvailableProviderId;
            }
        }
    }

    const selectChatProvider = (id: string) => {
        if (availableAIProviders.value.some(p => p.id === id)) {
            selectedChatProviderId.value = id;
        }
    }

    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    const setSelectedAIProviderId = (taskType: AITaskType, providerId: string) => {
        if (taskConfigs.value[taskType] && availableAIProviders.value.some(p => p.id === providerId)) {
            taskConfigs.value[taskType].selectedAIProviderId = providerId;
        }
    };

    const setTaskTemperature = (taskType: AITaskType, temperature: number) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].temperature = Number(temperature.toFixed(2));
        }
    }

    return {
        availableAIProviders,
        selectedChatProviderId,
        taskConfigs,
        selectedChatProviderConfig,
        initializeProviders,
        selectChatProvider,
        setSelectedPromptId,
        setSelectedAIProviderId,
        setTaskTemperature,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

// 文件: src/novel/editor/stores/ai/aiTaskStore.ts

import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useEditorStore } from '../editorStore';
import { useUIStore } from '../uiStore';
import { useDerivedContentStore } from '../derivedContentStore';
import * as AITaskFactory from '@/novel/editor/services/ai/AITaskFactory';
import { processQueue } from '@/novel/editor/services/ai/AITaskExecutionService';
import type { AITask, Volume, AITaskType, AITaskStatus } from '@novel/editor/types';

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const previewTaskId = ref<string | null>(null);

    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    const previewTask = computed((): AITask | null => {
        if (!previewTaskId.value) return null;
        return tasks.value.find(t => t.id === previewTaskId.value) ?? null;
    });

    const updateTaskStatus = (taskId: string, status: AITaskStatus) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = status;
        }
    };

    const updateTaskError = (taskId: string, error: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = 'failed';
            task.error = error;
        }
    };

    const appendGeneratedContent = (taskId: string, chunk: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.generatedContent += chunk;
        }
    };

    const setPreviewTask = (taskId: string | null) => {
        previewTaskId.value = taskId;

        if (taskId) {
            const task = tasks.value.find(t => t.id === taskId);
            if (task) {
                // 当设置预览任务时，自动打开对应的源文件标签页
                editorStore.openTab(task.sourceItemId);
            }
        }
    };

    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const newTask = await AITaskFactory.createTask(taskType, sourceItemId, finalPrompt);
        if (!newTask) return;

        tasks.value.unshift(newTask);

        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }

        // 如果当前没有正在预览的任务，则自动将新任务设为预览对象
        if (!previewTaskId.value) {
            setPreviewTask(newTask.id);
        }
        nextTick(processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const completeTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.status = 'completed';

            const strategy = uiStore.uiState.taskApplicationStrategy;
            if (strategy.mode === 'auto') {
                applyChanges(taskId, true);
            } else if (strategy.mode === 'delayed') {
                task.applyAt = Date.now() + strategy.delaySeconds * 1000;
                setTimeout(() => {
                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                    if (taskAfterDelay?.status === 'completed') {
                        applyChanges(taskId, true);
                    }
                }, strategy.delaySeconds * 1000);
            }
        }
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || !['completed', 'completed_with_conflict'].includes(task.status)) return;

        const { node: sourceItem } = editorStore.findItemById(task.targetItemId);
        if (!sourceItem) {
            task.status = 'failed';
            task.error = '目标文档不存在。';
            return;
        }

        // 核心修复：仅在自动应用时才进行版本冲突检查
        if (isAutoApplied) {
            const currentVersion = (sourceItem as any)._lastModified || 0;
            if (task.sourceItemVersion < currentVersion) {
                task.status = 'completed_with_conflict';
                task.error = `内容已被修改，AI结果无法自动应用。请手动处理。`;
                console.warn(`AI Task Conflict: Task for "${task.sourceItemTitle}" cannot be applied automatically. Task version: ${task.sourceItemVersion}, Current version: ${currentVersion}`);
                return;
            }
        }

        if (task.type === '分析' || task.type === '剧情生成') {
            const newItem = derivedContentStore.createAndAddDerivedItem(
                sourceItem,
                task.type,
                task.generatedContent
            );
            if (newItem) {
                editorStore.openTab(newItem.id);
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
        task.error = undefined; // 清除可能存在的冲突错误信息

        // 如果应用的是当前正在预览的任务，则清空预览
        if (previewTaskId.value === taskId) {
            setPreviewTask(null);
        }
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && (task.status === 'failed' || task.status === 'completed_with_conflict')) {
            // 从任务列表中移除旧的失败/冲突任务
            const taskIndex = tasks.value.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                tasks.value.splice(taskIndex, 1);
            }
            // 重新创建并开始一个新任务
            startTask(task.type, task.sourceItemId, task.finalPrompt);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => !['applied', 'failed', 'completed_with_conflict'].includes(t.status));
    };

    const clearAllTasks = () => {
        tasks.value = [];
        setPreviewTask(null);
    };

    return {
        tasks,
        activeTasksCount,
        previewTask,
        previewTaskId,
        startTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
        updateTaskStatus,
        updateTaskError,
        appendGeneratedContent,
        completeTask,
        setPreviewTask
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, ChatMessage, BackendChatMessage } from '@novel/editor/types/chatTypes';
import * as chatService from '@/novel/editor/services/ai/chatService';
import { useAIConfigStore } from './aiConfigStore';
import { marked } from 'marked';

export const useChatStore = defineStore('editorChat', () => {
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);
    const isLoading = ref<boolean>(false);

    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    const fetchConversations = async () => {
        isLoading.value = true;
        try {
            const fetchedConvs = await chatService.getConversations();
            conversations.value = fetchedConvs.length > 0 ? fetchedConvs : [await chatService.createConversation()];
            if (!activeConversationId.value || !conversations.value.find(c => c.id === activeConversationId.value)) {
                activeConversationId.value = conversations.value[0].id;
            }
        } catch (error) {
            console.error("Failed to fetch conversations:", error);
            if (conversations.value.length === 0) {
                conversations.value.push(await chatService.createConversation());
                activeConversationId.value = conversations.value[0].id;
            }
        } finally {
            isLoading.value = false;
        }
    };

    const createNewConversation = async () => {
        try {
            const newConv = await chatService.createConversation();
            conversations.value.unshift(newConv);
            activeConversationId.value = newConv.id;
        } catch (error) {
            console.error("Failed to create new conversation:", error);
        }
    };

    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    const sendMessage = async () => {
        const aiConfigStore = useAIConfigStore();
        const userInput = messageInput.value.trim();

        if (!userInput || !activeConversation.value || isReceiving.value) return;

        const providerIdStr = aiConfigStore.selectedChatProviderId;
        if (!providerIdStr) {
            alert("请先在顶部选择一个API配置！");
            return;
        }

        const providerIdNum = parseInt(providerIdStr, 10);
        if (isNaN(providerIdNum)) {
            alert("选择的API配置ID无效！");
            return;
        }

        isReceiving.value = true;
        const currentConv = activeConversation.value;

        const userMessage: ChatMessage = {
            id: `msg-${Date.now()}`,
            role: 'user',
            content: userInput,
            timestamp: new Date().toISOString(),
        };
        currentConv.messages.push(userMessage);
        messageInput.value = '';

        const backendMessages: BackendChatMessage[] = currentConv.messages.map(m => ({
            role: m.role,
            content: m.content,
        }));

        const aiResponsePlaceholder: ChatMessage = {
            id: `msg-${Date.now() + 1}`,
            role: 'ai',
            content: '',
            timestamp: new Date().toISOString(),
        };
        currentConv.messages.push(aiResponsePlaceholder);

        await chatService.streamMessage(
            providerIdNum,
            backendMessages,
            {
                onChunk: (chunk) => {
                    if (chunk.content) {
                        aiResponsePlaceholder.content += chunk.content;
                    }
                    if(chunk.error) {
                        aiResponsePlaceholder.content += `\n\n**错误:** ${chunk.error}`;
                    }
                },
                onComplete: () => {
                    isReceiving.value = false;
                    aiResponsePlaceholder.content = marked.parse(aiResponsePlaceholder.content) as string;
                },
                onError: (error) => {
                    isReceiving.value = false;
                    aiResponsePlaceholder.content += `\n\n**请求失败:** ${error}`;
                    aiResponsePlaceholder.content = marked.parse(aiResponsePlaceholder.content) as string;
                }
            }
        );
    };

    return {
        conversations,
        activeConversationId,
        messageInput,
        isReceiving,
        isLoading,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', reference: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, referenceCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings, ReferenceContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const referenceContextSettings = ref<ReferenceContextSettings>({
        includeContent: true,
        includeAnalysis: false,
        includePlot: false,
        includeVolumeInfo: false,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    const setReferenceContextSetting = (key: keyof ReferenceContextSettings, value: boolean) => {
        if (key in referenceContextSettings.value) {
            referenceContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        referenceContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
        setReferenceContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';
import * as derivedContentService from '@/novel/editor/services/derivedContentService';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);
    const novelId = ref<string | null>(null);

    function _setDerivedData(items: PlotAnalysisItem[]) {
        plotItems.value = items.filter(item => item.type === 'plot');
        analysisItems.value = items.filter(item => item.type === 'analysis');
    }

    async function fetchDerivedContent(id: string) {
        novelId.value = id;
        try {
            const allItems = await derivedContentService.getDerivedItemsForNovel(id);
            _setDerivedData(allItems);
        } catch (error) {
            console.error("Failed to fetch derived content:", error);
            _setDerivedData([]);
        }
    }

    async function saveDerivedContent() {
        const allItems = [...plotItems.value, ...analysisItems.value];
        const updatePromises = allItems.map(item =>
            derivedContentService.updateDerivedItem(item.id, {
                title: item.title,
                content: item.content,
                sourceId: item.sourceId
            })
        );
        await Promise.all(updatePromises);
    }

    function getDerivedItemsForSource(sourceId: string, type: 'plot' | 'analysis'): PlotAnalysisItem[] {
        const sourceArray = type === 'plot' ? plotItems.value : analysisItems.value;
        return sourceArray.filter(item => item.sourceId === sourceId);
    }

    async function createAndAddDerivedItem(sourceNode: EditorItem, taskType: AITaskType, generatedContent: string): Promise<PlotAnalysisItem | null> {
        if (!novelId.value || (taskType !== '分析' && taskType !== '剧情生成') || (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume')) {
            return null;
        }

        const derivedType = taskType === '分析' ? 'analysis' : 'plot';
        const newItem = await createManualDerivedItem(sourceNode, derivedType, generatedContent, true);
        return newItem;
    }

    async function createManualDerivedItem(sourceNode: EditorItem, derivedType: 'plot' | 'analysis', content: string = '', isFromAI: boolean = false): Promise<PlotAnalysisItem | null> {
        if (!novelId.value || (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume')) return null;

        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const typeName = derivedType === 'plot' ? '剧情' : '分析';
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';

        const finalTitle = isFromAI
            ? `《${titlePrefix}${sourceNode.title}》${typeName} - ${timestamp} (AI)`
            : `《${titlePrefix}${sourceNode.title}》${typeName} - ${timestamp}`;

        const finalContent = content
            ? formatContentForEditor(finalTitle, content)
            : `<h1>${finalTitle}</h1><p>请在这里编写${typeName}内容...</p>`;

        const itemData: Omit<PlotAnalysisItem, 'id'> = {
            type: derivedType,
            sourceId: sourceNode.id,
            title: finalTitle,
            content: finalContent
        };

        const newItem = await derivedContentService.createDerivedItem(itemData);

        const targetArray = derivedType === 'plot' ? plotItems : analysisItems;
        targetArray.value.unshift(newItem);

        return newItem;
    }

    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    function updateNodeContent(nodeId: string, content: string) {
        const item = findItemById(nodeId);
        if (item) {
            item.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== item.title) {
                item.title = newTitle;
            }
        }
    }

    async function deleteDerivedItem(itemId: string): Promise<boolean> {
        try {
            await derivedContentService.deleteDerivedItem(itemId);
            let index = plotItems.value.findIndex(i => i.id === itemId);
            if (index > -1) plotItems.value.splice(index, 1);

            index = analysisItems.value.findIndex(i => i.id === itemId);
            if (index > -1) analysisItems.value.splice(index, 1);
            return true;
        } catch (error) {
            console.error('Failed to delete derived item:', error);
            return false;
        }
    }

    async function deleteDerivedDataForSource(sourceId: string) {
        const itemsToDelete = [
            ...plotItems.value.filter(item => item.sourceId === sourceId),
            ...analysisItems.value.filter(item => item.sourceId === sourceId)
        ];

        const deletePromises = itemsToDelete.map(item => deleteDerivedItem(item.id));
        await Promise.all(deletePromises);
    }

    function updateTitlesForSource(sourceId: string, newSourceTitle: string) {
        const itemsToUpdate = [
            ...plotItems.value.filter(item => item.sourceId === sourceId),
            ...analysisItems.value.filter(item => item.sourceId === sourceId)
        ];

        itemsToUpdate.forEach(item => {
            // Regex to find the part of the title to replace, e.g., "《...》"
            const oldTitlePattern = /《(.*?)》/;
            const match = item.title.match(oldTitlePattern);

            if (match) {
                const titlePrefix = item.sourceId.startsWith('vol-') ? '卷' : '';
                const newTitlePart = `《${titlePrefix}${newSourceTitle}》`;
                const newTitle = item.title.replace(oldTitlePattern, newTitlePart);

                item.title = newTitle;
                if (item.content.includes('<h1>')) {
                    item.content = item.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
                }
            }
        });
    }

    return {
        plotItems,
        analysisItems,
        fetchDerivedContent,
        saveDerivedContent,
        getDerivedItemsForSource,
        createAndAddDerivedItem,
        createManualDerivedItem,
        findItemById,
        updateNodeContent,
        deleteDerivedItem,
        deleteDerivedDataForSource,
        updateTitlesForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedViewStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedViewStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useDerivedContentStore } from './derivedContentStore';
import type { PlotAnalysisItem, EditorItem } from '@/novel/editor/types';

export const useDerivedViewStore = defineStore('derived-view', () => {
    // State
    const sourceItem = ref<EditorItem | null>(null);
    const derivedType = ref<'plot' | 'analysis' | null>(null);
    const items = ref<PlotAnalysisItem[]>([]);
    const currentIndex = ref(0);

    // Getters
    const currentItem = computed(() => items.value[currentIndex.value] || null);
    const viewTitle = computed(() => {
        if (!sourceItem.value || !derivedType.value) return '派生内容';
        const typeName = derivedType.value === 'plot' ? '剧情' : '分析';
        return `《${sourceItem.value.title}》的${typeName}`;
    });

    // Actions
    async function loadItems(source: EditorItem, type: 'plot' | 'analysis') {
        const derivedContentStore = useDerivedContentStore();
        sourceItem.value = source;
        derivedType.value = type;
        items.value = derivedContentStore.getDerivedItemsForSource(source.id, type);

        // If no items exist, create one to start with
        if (items.value.length === 0) {
            const newItem = await derivedContentStore.createManualDerivedItem(source, type);
            if (newItem) {
                items.value = [newItem];
            }
        }

        currentIndex.value = 0;
    }

    async function createNewItem() {
        if (!sourceItem.value || !derivedType.value) return;
        const derivedContentStore = useDerivedContentStore();
        const newItem = await derivedContentStore.createManualDerivedItem(sourceItem.value, derivedType.value);
        if (newItem) {
            // Reload to get the updated list and navigate to the new item
            items.value = derivedContentStore.getDerivedItemsForSource(sourceItem.value.id, derivedType.value);
            currentIndex.value = items.value.findIndex(i => i.id === newItem.id);
        }
    }

    function goToIndex(index: number) {
        if (index >= 0 && index < items.value.length) {
            currentIndex.value = index;
        }
    }

    function nextItem() {
        if (currentIndex.value < items.value.length - 1) {
            currentIndex.value++;
        }
    }

    function prevItem() {
        if (currentIndex.value > 0) {
            currentIndex.value--;
        }
    }

    return {
        sourceItem,
        derivedType,
        items,
        currentIndex,
        currentItem,
        viewTitle,
        loadItems,
        createNewItem,
        goToIndex,
        nextItem,
        prevItem
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// 文件: ..\src\novel\editor\stores\directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useDerivedContentStore } from './derivedContentStore';
import * as directoryService from '@/novel/editor/services/directoryService';

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);
    const novelId = ref<string | null>(null);

    async function fetchDirectory(id: string) {
        novelId.value = id;
        try {
            directoryData.value = await directoryService.getDirectoryData(id);
        } catch (error) {
            console.error(`Failed to fetch directory for novel ${id}:`, error);
            directoryData.value = [];
        }
    }

    async function saveDirectory() {
        if (!novelId.value) return;
        await directoryService.saveDirectoryData(novelId.value, directoryData.value);
    }

    const findNodeById = (nodeId: string): { node: Volume | Chapter; parent: Volume | null } | null => {
        for (const volume of directoryData.value) {
            if (volume.id === nodeId) return { node: volume, parent: null };
            for (const chapter of volume.chapters) {
                if (chapter.id === nodeId) return { node: chapter, parent: volume };
            }
        }
        return null;
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            result.node.content = content;
            if(result.node.type === 'volume') {
                const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
                if (h1Match && h1Match[1]) result.node.title = h1Match[1].replace(/<[^>]+>/g, '').trim();
            } else {
                const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
                if (h1Match && h1Match[1]) result.node.title = h1Match[1].replace(/<[^>]+>/g, '').trim();
            }
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if(isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if(!result.node.content) result.node.content = "";
            result.node.content += htmlToAppend;
        }
    };

    const addNewVolume = async (): Promise<Volume | null> => {
        if (!novelId.value) return null;
        try {
            const newVolume = await directoryService.createVolume(novelId.value, { title: '新卷', chapters: [] });
            directoryData.value.push(newVolume);
            return newVolume;
        } catch (error) {
            console.error('Failed to add new volume:', error);
            return null;
        }
    };

    const addChapterToVolume = async (volumeId: string): Promise<Chapter | null> => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            try {
                const newChapter = await directoryService.createChapter(volume.id, { title: '新章节' });
                volume.chapters.push(newChapter);
                return newChapter;
            } catch (error) {
                console.error('Failed to add new chapter:', error);
                return null;
            }
        }
        return null;
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const trimmedTitle = newTitle.trim();
        if (!trimmedTitle) return;

        const result = findNodeById(nodeId);
        if (result?.node) {
            result.node.title = trimmedTitle;
            const derivedContentStore = useDerivedContentStore();
            derivedContentStore.updateTitlesForSource(nodeId, trimmedTitle);
        }
    };

    const deleteNode = async (nodeId: string): Promise<boolean> => {
        const derivedContentStore = useDerivedContentStore();

        const result = findNodeById(nodeId);
        if (!result) return false;

        try {
            if (result.node.type === 'volume') {
                await directoryService.deleteVolume(nodeId);
                // 使用 filter 替换整个数组以确保响应性
                directoryData.value = directoryData.value.filter(v => v.id !== nodeId);

                // 删除关联的派生内容
                const chapterIds = result.node.chapters.map(c => c.id);
                for (const chapId of chapterIds) {
                    await derivedContentStore.deleteDerivedDataForSource(chapId);
                }
                await derivedContentStore.deleteDerivedDataForSource(nodeId);

            } else if (result.node.type === 'chapter' && result.parent) {
                await directoryService.deleteChapter(nodeId);
                // 使用 filter 替换子数组以确保响应性
                result.parent.chapters = result.parent.chapters.filter(c => c.id !== nodeId);
                await derivedContentStore.deleteDerivedDataForSource(nodeId);
            }
            return true;
        } catch (error) {
            console.error(`Failed to delete node ${nodeId}:`, error);
            // 你可能需要在这里添加一些逻辑来重新获取数据以同步状态
            if(novelId.value) await fetchDirectory(novelId.value);
            return false;
        }
    };

    return {
        directoryData,
        fetchDirectory,
        saveDirectory,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts
//

// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import { useDerivedViewStore } from '../derivedViewStore';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
    'system:derived_view': { id: 'system:derived_view', type: 'system', component: 'DerivedContentView', title: '派生内容', icon: 'fa-solid fa-clone' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore();
    const derivedViewStore = useDerivedViewStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = `system:${parts[1]}`;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                // Handle dynamic title for history panel
                if (baseId === 'system:history' && parts.length === 3) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                // Handle dynamic title for derived view panel
                if (baseId === 'system:derived_view') {
                    return {
                        node: { ...systemView, id, title: derivedViewStore.viewTitle },
                        source: 'system'
                    }
                }
                return { node: { ...systemView, id }, source: 'system' };
            }
        }

        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) return { node: derivedItem as PlotAnalysisItem, source: 'derived' };

        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) return { node: promptItem, source: 'prompt' };

        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NovelMetadata } from '@/novel/editor/types/project';
import * as metadataService from '@novel/editor/services/metadataService';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);
    const currentNovelId = ref<string | null>(null);

    function reset() {
        novelMetadata.value = null;
        currentNovelId.value = null;
    }

    async function fetchNovelData(novelId: string) {
        try {
            const data = await metadataService.getNovelMetadata(novelId);
            novelMetadata.value = data;
            currentNovelId.value = novelId;
        } catch (error) {
            console.error(`[MetadataStore] Failed to fetch metadata for novel ${novelId}:`, error);
            reset();
            throw error; // Re-throw to be caught by the project loader
        }
    }

    // This is kept for manual saving from the settings page
    async function saveMetadata() {
        if (!currentNovelId.value || !novelMetadata.value) {
            console.error("保存失败：未加载小说。");
            alert('保存失败，请查看控制台获取更多信息。');
            return;
        }
        try {
            await metadataService.updateNovelMetadata(currentNovelId.value, novelMetadata.value);
            alert('小说设置已保存！');
        } catch (error) {
            console.error("保存元数据失败:", error);
            alert('保存失败，请稍后重试。');
        }
    }

    function addReferenceNovel(novelIdToAdd: string) {
        if (!novelMetadata.value || novelMetadata.value.referenceNovelIds.includes(novelIdToAdd)) return;
        novelMetadata.value.referenceNovelIds.push(novelIdToAdd);
    }

    function removeReferenceNovel(novelIdToRemove: string) {
        if (!novelMetadata.value) return;
        const index = novelMetadata.value.referenceNovelIds.indexOf(novelIdToRemove);
        if (index > -1) {
            novelMetadata.value.referenceNovelIds.splice(index, 1);
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) novelMetadata.value.tags.splice(tagIndex, 1);
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    return {
        novelMetadata,
        currentNovelId,
        fetchNovelData,
        saveMetadata,
        addReferenceNovel,
        removeReferenceNovel,
        removeTag,
        addTag,
        reset,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\systemViewStore.ts
//

// src/novel/editor/stores/editor-state/systemViewStore.ts
import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const activePane = paneStore.panes.find(p => p.id === paneStore.activePaneId);
        if (!activePane || !activePane.activeTabId) {
            console.warn('Cannot open reader mode: no active tab.');
            return;
        }
        const { node: activeItem } = itemStore.findItemById(activePane.activeTabId);

        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\tabStore.ts
//

// src/novel/editor/stores/editor-state/tabStore.ts
import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            console.warn(`Attempted to open a non-tab item: ${itemId}. This should be handled by the calling UI component (e.g., for tree expansion).`);
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import type { EditorPane, TabInfo } from '@novel/editor/types';

// State Stores
import { usePaneStore } from '@novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@novel/editor/stores/editor-state/tabStore';
import { useItemStore } from '@novel/editor/stores/editor-state/itemStore';
import { useSystemViewStore } from '@novel/editor/stores/editor-state/systemViewStore';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';

// Data Stores & UI
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { useDerivedContentStore } from './derivedContentStore';
import { useReferenceStore } from './referenceStore';
import { useAIConfigStore } from './ai/aiConfigStore';
import { useNovelSettingsStore } from './novelSettingsStore';
import { useUIStore } from './uiStore';
import { useDerivedViewStore } from './derivedViewStore';

export { EditorPane };

const initializeEditorUI = (novelId: string) => {
    const directoryStore = useDirectoryStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();
    const paneStore = usePaneStore();
    const tabStore = useTabStore();

    paneStore.initializePanes();

    if (directoryStore.directoryData.length > 0) {
        uiStore.ensureNodeIsExpanded(directoryStore.directoryData[0].id);
        const firstChapterId = directoryStore.directoryData[0]?.chapters[0]?.id;
        if (firstChapterId) {
            tabStore.openTab(firstChapterId);
        }
    }

    uiStore.ensureRelatedNodeIsExpanded('setting');
    uiStore.ensureRelatedNodeIsExpanded('plot');
    uiStore.ensureRelatedNodeIsExpanded('analysis');
    uiStore.ensureRelatedNodeIsExpanded('others');

    if (metadataStore.novelMetadata && metadataStore.novelMetadata.referenceNovelIds.length > 0) {
        const firstRefBookId = `ref-book-${metadataStore.novelMetadata.referenceNovelIds[0]}`;
        uiStore.ensureReferenceNodeIsExpanded(firstRefBookId);
    }
};

export const useEditorStore = defineStore('editor-facade', () => {
    // State Stores
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();
    const derivedViewStore = useDerivedViewStore();

    // Data Stores
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const derivedContentStore = useDerivedContentStore();
    const notesStore = useNotesStore();
    const referenceStore = useReferenceStore();
    const novelSettingsStore = useNovelSettingsStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    async function loadProject(novelId: string): Promise<boolean> {
        // 1. Reset all states
        metadataStore.reset();
        // You might need to add reset functions to other stores if they cache data

        try {
            console.log(`[EditorStore] Coordinating load for novel: ${novelId}`);

            // 2. Fetch metadata first, as other fetches might depend on it
            await metadataStore.fetchNovelData(novelId);

            const referenceIds = metadataStore.novelMetadata?.referenceNovelIds || [];

            // 3. Fetch all main content data in parallel
            await Promise.all([
                directoryStore.fetchDirectory(novelId),
                relatedContentStore.fetchRelatedContent(novelId),
                derivedContentStore.fetchDerivedContent(novelId),
                notesStore.fetchNotes(novelId),
                useAIConfigStore().initializeProviders(),
                referenceStore.loadReferences(referenceIds)
            ]);

            // 4. Load dependent data
            await novelSettingsStore.loadSettingsData();

            // 5. Initialize UI state now that all data is loaded
            initializeEditorUI(novelId);

            return true;
        } catch (error) {
            console.error(`[EditorStore] Failed to load project ${novelId}:`, error);
            metadataStore.reset(); // Ensure clean state on failure
            return false;
        }
    }

    function splitPane(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    }

    function updateItemContentById(id: string, content: string) {
        itemStore.updateItemContentById(id, content);
        const { node } = itemStore.findItemById(id);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        itemStore.appendContentToItem(itemId, content, auto);
        const { node } = itemStore.findItemById(itemId);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    }

    function openDerivedItemView(type: 'plot' | 'analysis') {
        const sourceItem = activeTab.value?.item;
        if (!sourceItem || (sourceItem.type !== 'chapter' && sourceItem.type !== 'volume')) return;

        const viewId = `system:derived_view:${type}:${sourceItem.id}`;

        const existingPane = panes.value.find(p => p.openTabIds.includes(viewId));
        if (existingPane) {
            paneStore.setActivePane(existingPane.id);
            return;
        }

        derivedViewStore.loadItems(sourceItem, type);

        const sourcePaneId = activePaneId.value;
        if (!sourcePaneId) return;

        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (newPaneId) {
            tabStore.openTab(viewId, newPaneId);
        }
    }

    function openPlotForActiveItem() {
        openDerivedItemView('plot');
    }

    function openAnalysisForActiveItem() {
        openDerivedItemView('analysis');
    }

    // Explicit actions that delegate to other stores
    const openTab = (itemId: string, targetPaneId?: string) => tabStore.openTab(itemId, targetPaneId);
    const closeTab = (itemId: string, paneId?: string) => tabStore.closeTab(itemId, paneId);
    const toggleAIPanel = (sourcePaneId: string) => systemViewStore.toggleAIPanel(sourcePaneId);
    const ensureAIPanelIsOpen = (sourcePaneId: string) => systemViewStore.ensureAIPanelIsOpen(sourcePaneId);
    const toggleHistoryPanel = (sourcePaneId: string) => systemViewStore.toggleHistoryPanel(sourcePaneId);
    const openReaderView = () => systemViewStore.openReaderView();

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        getTabsForPane,
        getActiveTabForPane,
        splitPane,
        updateItemContentById,
        appendContentToItem,
        openPlotForActiveItem,
        openAnalysisForActiveItem,
        // Delegated actions
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab,
        closeTab,
        findItemById: itemStore.findItemById,
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
        loadProject,
    };
});

// =
// 文件: ..\src\novel\editor\stores\historyStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useEditorStore } from './editorStore';
import * as historyService from '@/novel/editor/services/historyService';
import { calculateHtmlDiff } from '@/novel/editor/services/diffService';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';
import type { EditorItem } from '@/novel/editor/types';

export const useHistoryStore = defineStore('history', () => {
    const isLoading = ref(false);
    const targetDocument = ref<EditorItem | null>(null);
    const versions = ref<HistoryVersion[]>([]);
    const selectedVersionId = ref<string | null>(null);
    const diffHtml = ref<string>('');

    const headerTitle = computed(() => {
        if (!targetDocument.value) return '版本对比';
        return `《${targetDocument.value.title}》版本对比`;
    });

    const selectedVersion = computed(() => {
        return versions.value.find(v => v.id === selectedVersionId.value) || null;
    });

    async function loadHistory(documentId: string) {
        isLoading.value = true;
        diffHtml.value = '';
        versions.value = [];

        const editorStore = useEditorStore();
        const { node } = editorStore.findItemById(documentId);
        targetDocument.value = node;

        if (!node) {
            console.error("History Store: Target document not found.");
            isLoading.value = false;
            return;
        }

        versions.value = await historyService.getHistoryVersions(documentId);

        if (versions.value.length > 0) {
            await selectVersion(versions.value[0].id);
        }

        isLoading.value = false;
    }

    async function selectVersion(versionId: string) {
        if (!targetDocument.value || !('content' in targetDocument.value)) return;

        selectedVersionId.value = versionId;
        const versionToCompare = selectedVersion.value;

        if (!versionToCompare) {
            diffHtml.value = '<p>错误：找不到选中的历史版本。</p>';
            return;
        }

        const currentContent = targetDocument.value.content;
        const historicalContent = versionToCompare.content;

        diffHtml.value = calculateHtmlDiff(historicalContent, currentContent);
    }

    async function restoreSelectedVersion() {
        if (!targetDocument.value || !selectedVersion.value) {
            alert('恢复失败：未找到目标文档或选中版本。');
            return;
        }

        isLoading.value = true;
        try {
            await historyService.restoreVersion(targetDocument.value.id, selectedVersion.value.id);
            // 成功信息由 service 层显示
            // 重新加载历史记录以反映最新状态
            await loadHistory(targetDocument.value.id);
        } catch (error) {
            console.error('Failed to restore version:', error);
            alert('恢复失败，请查看控制台获取更多信息。');
        } finally {
            isLoading.value = false;
        }
    }

    return {
        isLoading,
        targetDocument,
        versions,
        selectedVersionId,
        diffHtml,
        headerTitle,
        selectedVersion,
        loadHistory,
        selectVersion,
        restoreSelectedVersion,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

// 文件: ..\src\novel\editor\stores\notesStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import * as noteService from '@/novel/editor/services/noteService';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);
    const novelId = ref<string | null>(null);

    async function fetchNotes(id: string) {
        novelId.value = id;
        try {
            notes.value = await noteService.getNotesForNovel(id);
        } catch (error) {
            console.error("Failed to fetch notes:", error);
            notes.value = [];
        }
    }

    async function saveNotes() {
        const updatePromises = notes.value.map(note =>
            noteService.updateNoteApi(note.id, { title: note.title, content: note.content })
        );
        await Promise.all(updatePromises);
    }

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);
        if (noteIndex === -1) return;

        const originalNote = notes.value[noteIndex];
        const updatedNote = noteService.updateNoteWithNewContent(originalNote, content);
        notes.value[noteIndex] = updatedNote;
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = noteService.appendContentToNote(note.content, contentToAppend, isAutoApplied);
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);

        if (noteIndex !== -1 && newTitle.trim()) {
            const originalNote = notes.value[noteIndex];
            const trimmedTitle = newTitle.trim();
            const updatedNote = noteService.renameNote(originalNote, trimmedTitle);
            notes.value[noteIndex] = updatedNote;
        }
    };

    const addNote = async (title: string): Promise<NoteItem | null> => {
        if (!novelId.value) return null;

        const newNoteData: Partial<Omit<NoteItem, 'id'>> = {
            title,
            content: `<h1>${title}</h1><p></p>`,
        };

        try {
            const newNote = await noteService.createNoteApi(novelId.value, newNoteData);
            notes.value.unshift(newNote);
            return newNote;
        } catch (error) {
            console.error('Failed to add note:', error);
            return null;
        }
    };

    const deleteNote = async (noteId: string): Promise<boolean> => {
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            try {
                await noteService.deleteNoteApi(noteId);
                notes.value.splice(index, 1);
                return true;
            } catch (error) {
                console.error('Failed to delete note:', error);
                return false;
            }
        }
        return false;
    };

    return {
        notes,
        fetchNotes,
        saveNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\novelSettingsStore.ts
//

// 文件: ..\src/novel\editor\stores\novelSettingsStore.ts
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { novelSettingsService } from '@/novel/editor/services/novelSettingsService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';
import { useReferenceStore } from './referenceStore';

export const useNovelSettingsStore = defineStore('novel-settings', () => {
    const metadataStore = useMetadataStore();

    const novelMetadata = computed<NovelMetadata | null>(() => metadataStore.novelMetadata);
    const referencedNovels = ref<NovelProject[]>([]);
    const availableReferenceNovels = ref<NovelProject[]>([]);

    async function loadSettingsData() {
        const meta = metadataStore.novelMetadata;
        if (meta) {
            referencedNovels.value = await novelSettingsService.getReferencedNovels(meta.referenceNovelIds);
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(meta);
        } else {
            referencedNovels.value = [];
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(null);
        }
    }

    const addReferenceNovel = async (novelId: string) => {
        if (!novelId) return;
        metadataStore.addReferenceNovel(novelId);
        await loadSettingsData();
        if(metadataStore.novelMetadata) {
            await useReferenceStore().loadReferences(metadataStore.novelMetadata.referenceNovelIds);
        }
    };

    const removeReferenceNovel = async (novelId: string) => {
        metadataStore.removeReferenceNovel(novelId);
        await loadSettingsData();
        if(metadataStore.novelMetadata) {
            await useReferenceStore().loadReferences(metadataStore.novelMetadata.referenceNovelIds);
        }
    };

    const addTag = () => {
        metadataStore.addTag();
    };

    const removeTag = (index: number) => {
        metadataStore.removeTag(index);
    };

    const saveMetadata = () => {
        metadataStore.saveMetadata();
    };

    const resetMetadata = async () => {
        if (metadataStore.currentNovelId) {
            await metadataStore.fetchNovelData(metadataStore.currentNovelId);
        }
    };

    return {
        novelMetadata,
        referencedNovels,
        availableReferenceNovels,
        loadSettingsData,
        addReferenceNovel,
        removeReferenceNovel,
        addTag,
        removeTag,
        saveMetadata,
        resetMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { promptService } from '@/novel/editor/services/promptService';
import { useAIConfigStore } from './ai/aiConfigStore';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    // State: Use a simple ref, not a computed property, for the main data tree.
    const promptTree = ref<TreeNode[]>([]);

    /**
     * Action to initialize the prompt tree if it's empty.
     * This should be called once when the editor loads.
     */
    function initialize() {
        if (promptTree.value.length === 0) {
            promptTree.value = promptService.buildInitialTree();
        }
    }

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = promptTree.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        if (!promptTree.value[0]?.children) return null;
        for (const group of promptTree.value[0].children) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPrompt(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = promptTree.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newNode: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newNode);
        return newNode;
    }

    function renamePrompt(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result && newTitle.trim()) {
            result.prompt.title = newTitle.trim();
        }
    }

    function deletePrompt(promptId: string): boolean {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            const index = group.children.findIndex(p => p.id === promptId);
            if (index > -1) {
                group.children.splice(index, 1);

                if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                    aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
                }
                return true;
            }
        }
        return false;
    }

    function updatePromptContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }

    return {
        promptTree,
        initialize,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPrompt,
        renamePrompt,
        deletePrompt,
        updatePromptContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { referenceService } from '@/novel/editor/services/referenceService';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const loadReferences = async (referenceNovelIds: string[]) => {
        referenceData.value = await referenceService.buildReferenceTree(referenceNovelIds);
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        loadReferences,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import * as nodeOperationService from '@/novel/editor/services/related/nodeOperationService';
import * as treeBuilderService from '@/novel/editor/services/related/treeBuilderService';
import { updateAllOverviewContent } from '@/novel/editor/services/related/overviewService';
import * as relatedContentService from '@/novel/editor/services/relatedContentService';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { TreeNode, ItemNode, GroupNode } from '@/novel/editor/types';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<ItemNode[]>([]);
    const analysisCustomData = ref<ItemNode[]>([]);
    const othersCustomData = ref<ItemNode[]>([]);
    const novelId = ref<string | null>(null);

    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();

    const relatedData = computed(() => {
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        const validPlotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        const validAnalysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        return treeBuilderService.buildRelatedTree(
            settingsData.value,
            plotCustomData.value,
            analysisCustomData.value,
            othersCustomData.value,
            promptTemplateStore.promptTree,
            validPlotItems,
            validAnalysisItems,
            directoryStore.directoryData
        );
    });

    const allDataSources = computed(() => [
        settingsData.value,
        plotCustomData.value,
        analysisCustomData.value,
        othersCustomData.value
    ]);

    watch(settingsData, (newData) => {
        updateAllOverviewContent(newData);
    }, { deep: true });

    async function fetchRelatedContent(id: string) {
        novelId.value = id;
        promptTemplateStore.initialize();
        try {
            const data = await relatedContentService.getRelatedContent(id);
            settingsData.value = data.settingsData;
            plotCustomData.value = data.plotCustomData;
            analysisCustomData.value = data.analysisCustomData;
            othersCustomData.value = data.othersCustomData;
        } catch (error) {
            console.error(`Failed to fetch related content for novel ${id}:`, error);
        }
    }

    async function saveRelatedContent() {
        if (!novelId.value) return;
        await relatedContentService.saveRelatedContent(novelId.value, {
            settingsData: settingsData.value,
            plotCustomData: plotCustomData.value,
            analysisCustomData: analysisCustomData.value,
            othersCustomData: othersCustomData.value
        });
    }

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        return nodeOperationService.findNodeById(nodeId, allDataSources.value);
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.updateNodeContent(result.node as ItemNode, content);
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.appendNodeContent(result.node as ItemNode, contentToAppend, isAutoApplied);
        }
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            nodeOperationService.renameNode(result.node, newTitle);
        }
    }

    function addRelatedNode(parentId: string, type: 'group' | 'item'): ItemNode | GroupNode | null {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return null;

        const parentNode = result.node as GroupNode;
        const newNode = nodeOperationService.createRelatedNode(parentNode, type);
        parentNode.children = [...parentNode.children, newNode];
        return newNode;
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis'): ItemNode {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode = nodeOperationService.createCustomNode(target);
        dataRef.value = [newNode, ...dataRef.value];
        return newNode;
    }

    function addCustomOthersNode(): ItemNode {
        const newNode = nodeOperationService.createCustomNode('others');
        othersCustomData.value = [newNode, ...othersCustomData.value];
        return newNode;
    }

    function deleteNode(nodeId: string): boolean {
        return nodeOperationService.deleteNode(nodeId, allDataSources.value);
    }
    const deleteRelatedNode = deleteNode;
    const deleteCustomRelatedNode = deleteNode;
    const deleteCustomOthersNode = deleteNode;

    const renameCustomRelatedNode = renameRelatedNode;
    const renameCustomOthersNode = renameRelatedNode;

    return {
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        fetchRelatedContent,
        saveRelatedContent,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult } from '@/novel/editor/types';
import { searchService } from '@/novel/editor/services/searchService';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const performSearch = (query: string) => {
        hasSearched.value = true;
        lastSearchedQuery.value = query;
        results.value = searchService.search(query);
    };

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\ai.ts
//

/**
 * AI 任务状态
 * - pending: 等待执行
 * - processing: 正在执行
 * - completed: 已完成，等待应用
 * - completed_with_conflict: 已完成，但源文档已被修改，等待用户处理
 * - applied: 已应用
 * - failed: 执行失败
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'completed_with_conflict' | 'applied' | 'failed';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 提供商（模型）配置
 */
export interface AIProviderConfig {
    id: string;
    name: string;
    model: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string;
    sourceItemContent: string;
    sourceItemVersion: number;
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
    applyAt?: number;
    aiConfig: AIProviderConfig;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string;
    title: string;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义 - 用于UI展示
 */
export interface ChatMessage {
    id: string; // 前端专用，用于v-for的key
    role: 'user' | 'ai';
    content: string;
    timestamp: string; // 前端专用
}

/**
 * 发送到后端的聊天消息格式
 */
export interface BackendChatMessage {
    role: 'user' | 'ai' | 'system';
    content: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

/**
 * 从后端流式接口返回的数据块结构
 */
export interface StreamResponseChunk {
    content?: string;
    done: boolean;
    error?: string;
}

// =
// 文件: ..\src\novel\editor\types\historyTypes.ts
//

// 文件: ..\src\novel\editor\types\historyTypes.ts

/**
 * 代表一个文档的历史版本快照。
 */
export interface HistoryVersion {
    id: string;          // 版本的唯一ID
    label: string;       // 版本的显示名称 (例如 "AI 润色", "手动保存")
    timestamp: string;   // 版本创建的时间戳 (例如 "1小时前", "2023-10-27 15:30")
    content: string;     // 该版本的完整HTML内容 (用于恢复)
}

/**
 * 代表两个版本之间的差异。
 */
export interface VersionDiff {
    fromVersionId: string; // 对比的起始版本ID ('current' 代表当前版本)
    toVersionId: string;   // 对比的目标版本ID
    diffHtml: string;      // 包含 <ins> 和 <del> 标签的HTML字符串
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//

export * from './models';
export * from './chatTypes';
export * from './ui';
export * from './ai';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
    order: number; // 用于排序
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    volumeId: string; // 所属卷的ID
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
    order: number; // 用于排序
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: TreeNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\project.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata as BaseNovelMetadata,
    TreeNode,
    ItemNode,
    PlotAnalysisItem,
} from '@/novel/editor/types';

export interface NovelMetadata extends BaseNovelMetadata {
    referenceNovelIds: string[];
}

export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    derivedPlotData: PlotAnalysisItem[];
    derivedAnalysisData: PlotAnalysisItem[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
}

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: ..\src/novel\editor\utils\iconUtils.ts
const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    if (!type) return ICON_MAP['default'];

    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\editor\views\EditorWorkspaceView.vue
//

import { ref, onMounted, onBeforeUnmount } from 'vue';
import { useRoute } from 'vue-router';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ActivityBar from '@/novel/editor/components/layout/ActivityBar.vue';
import SidebarPanel from '@/novel/editor/components/sidebar/SidebarPanel.vue';
import MainPane from '@/novel/editor/components/content/MainPane.vue';
import StatusBar from '@/novel/editor/components/layout/StatusBar.vue';
import ManageMenu from '@/novel/editor/components/layout/ManageMenu.vue';

type ActivityTabId = 'directory' | 'related' | 'notes' | 'references';
type ActionId = 'system:search' | 'system:ai_chat' | string;

const editorStore = useEditorStore();
const uiStore = useUIStore();
const route = useRoute();

const activeActivityBarTab = ref<ActivityTabId | null>('directory');
const isSidebarVisible = ref(true);
const manageMenuRef = ref<InstanceType<typeof ManageMenu> | null>(null);

// --- Resizing Logic ---
const sidebarPanelWidth = ref(320);
const isResizing = ref(false);

const startResize = (event: MouseEvent) => {
  isResizing.value = true;
  const startWidth = sidebarPanelWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    if (!isResizing.value) return;
    const dx = e.clientX - startX;
    const newWidth = startWidth + dx;
    sidebarPanelWidth.value = Math.max(240, Math.min(newWidth, 600));
  };

  const stopResize = () => {
    isResizing.value = false;
    window.removeEventListener('mousemove', handleResize);
    window.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  };

  window.addEventListener('mousemove', handleResize);
  window.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

const handleSelectActivityTab = (tabId: ActivityTabId) => {
  if (activeActivityBarTab.value === tabId && isSidebarVisible.value) {
    isSidebarVisible.value = false;
    activeActivityBarTab.value = null;
  } else {
    isSidebarVisible.value = true;
    activeActivityBarTab.value = tabId;
  }
};

const handleTriggerAction = (actionId: ActionId) => {
  editorStore.openTab(actionId);
}

const showManageMenu = (event: MouseEvent) => {
  manageMenuRef.value?.show(event.currentTarget as HTMLElement);
};

const handleMenuAction = (actionId: ActionId) => {
  if (actionId.startsWith('system:')) {
    editorStore.openTab(actionId);
  } else {
    // Handle other menu actions like 'keyboard_shortcuts' etc.
    alert(`Action '${actionId}' selected. Implementation pending.`);
  }
};

onMounted(() => {
  const novelId = route.query.id as string;
  if (novelId) {
    editorStore.loadProject(novelId);
  } else {
    // Fallback or error handling
    console.warn("No novel ID provided in URL, loading default or showing error.");
    editorStore.loadProject('novel-1'); // Fallback to a default novel
  }
});

onBeforeUnmount(() => {
  // A safeguard to ensure listeners are removed if component is unmounted during resize
  if (isResizing.value) {
    const emptyFn = () => {};
    window.removeEventListener('mousemove', emptyFn);
    window.removeEventListener('mouseup', emptyFn);
  }
});

// =
// 文件: ..\src\novel\editor\views\HistoryPanel.vue
//

import { computed, type PropType, onMounted } from 'vue';
import { useHistoryStore } from '@novel/editor/stores/historyStore';
import type { TabInfo } from '@novel/editor/types';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    required: true,
  },
});

const historyStore = useHistoryStore();

const targetDocumentId = computed(() => {
  if (!props.activeTab) return null;
  const parts = props.activeTab.id.split(':');
  return parts.length === 3 ? parts[2] : null;
});

onMounted(() => {
  if (targetDocumentId.value) {
    historyStore.loadHistory(targetDocumentId.value);
  }
});

// =
// 文件: ..\src\novel\editor\views\ReaderModeOverlay.vue
//

import { computed } from 'vue';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';

const uiStore = useUIStore();

const isVisible = computed(() => uiStore.isReaderModeVisible);
const item = computed(() => uiStore.readerModeItem);

const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

// =
// 文件: ..\src\novel\editor\views\SearchView.vue
//

import { ref, watch } from 'vue';
import { useSearchStore } from '@novel/editor/stores/searchStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';

const searchStore = useSearchStore();
const editorStore = useEditorStore();
const expandedResultIds = ref(new Set<string>());

let debounceTimer: number | undefined;

watch(() => searchStore.searchQuery, (newQuery) => {
  clearTimeout(debounceTimer);
  if (!newQuery.trim()) {
    searchStore.clearSearch();
    return;
  }
  debounceTimer = window.setTimeout(() => {
    expandedResultIds.value.clear(); // Clear old expansions
    searchStore.performSearch(newQuery);
    // Do not auto-expand results to match the new UI. Let the user decide.
  }, 300); // 300ms debounce delay
});

const handleResultClick = (itemId: string) => {
  editorStore.openTab(itemId);
};

const toggleExpansion = (resultId: string) => {
  if (expandedResultIds.value.has(resultId)) {
    expandedResultIds.value.delete(resultId);
  } else {
    expandedResultIds.value.add(resultId);
  }
};

// =
// 文件: ..\src\novel\importer\services\novelParser.ts
//

import type { Volume, Chapter } from '@/novel/editor/types';

/**
 * 将纯文本段落转换为带<p>标签的HTML字符串
 * @param text - 输入的文本
 * @returns HTML格式的字符串
 */
const textToHtmlParagraphs = (text: string): string => {
    return text.split('\n').map(p => p.trim()).filter(p => p).map(p => `<p>${p}</p>`).join('');
};

/**
 * 解析小说文本并根据选项进行分章和分卷
 * @param text - 要解析的小说全文
 * @param options - 解析选项
 * @returns 返回一个卷数组，可直接用于创建新的小说项目
 */
export const parseNovelText = (
    text: string,
    options: { chaptersPerVolume: number }
): Volume[] => {
    // 1. 按空行（一个或多个换行符，中间可能包含空格）分割成章节内容块
    const chapterContents = text.split(/\n\s*\n/).filter(content => content.trim() !== '');

    // 2. 将内容块转换为章节对象
    const allChapters: Chapter[] = chapterContents.map((content, index) => {
        const lines = content.trim().split('\n');
        const title = lines[0]?.trim() || `第 ${index + 1} 章`;
        const bodyText = lines.slice(1).join('\n').trim();
        const bodyHtml = textToHtmlParagraphs(bodyText);

        return {
            id: `ch-imported-${Date.now()}-${index}`,
            type: 'chapter',
            title: title,
            wordCount: content.trim().length,
            content: `<h1>${title}</h1>${bodyHtml}`,
            status: 'completed'
        };
    });

    // 3. 将章节按指定数量分组到卷中
    const volumes: Volume[] = [];
    const { chaptersPerVolume } = options;
    let volumeIndex = 1;

    for (let i = 0; i < allChapters.length; i += chaptersPerVolume) {
        const chapterChunk = allChapters.slice(i, i + chaptersPerVolume);
        const volume: Volume = {
            id: `vol-imported-${Date.now()}-${volumeIndex}`,
            type: 'volume',
            title: `第 ${volumeIndex} 卷`,
            content: `<h1>第 ${volumeIndex} 卷</h1><p>该卷由导入功能自动创建，包含 ${chapterChunk.length} 个章节。</p>`,
            chapters: chapterChunk,
        };
        volumes.push(volume);
        volumeIndex++;
    }

    // 如果没有任何内容，则创建一个默认的空卷
    if (volumes.length === 0) {
        volumes.push({
            id: `vol-imported-${Date.now()}-1`,
            type: 'volume',
            title: '第一卷',
            content: '<h1>第一卷</h1><p>未从文件中解析出任何章节。</p>',
            chapters: [],
        });
    }

    return volumes;
};

// =
// 文件: ..\src\novel\layouts\NovelChatLayout.vue
//

import GlobalAIAssistant from '@/novel/shared/components/GlobalAIAssistant/index.vue';
import AITaskConfigModal from '@/novel/shared/components/GlobalAIAssistant/AITaskConfigModal.vue';
import '@/novel/assets/styles/main.css';

// =
// 文件: ..\src\novel\layouts\NovelDashboardLayout.vue
//

import AppHeader from '@/layouts/components/AppHeader.vue'
import NovelDashboardSidebar from '@novel/layouts/NovelDashboardSidebar.vue'
import '@/novel/assets/styles/main.css'

// =
// 文件: ..\src\novel\layouts\NovelDashboardSidebar.vue
//

import { ref } from 'vue'

const navItems = ref([
  { name: '我的小说', path: '/novel/dashboard', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>` },
  { name: '最近编辑', path: '/novel/recent', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>` },
  { name: '回收站', path: '/novel/trash', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>` },
  { name: '导出小说', path: '/novel/export', icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>` }
])

// =
// 文件: ..\src\novel\layouts\NovelManagementLayout.vue
//

import AppHeader from '@/layouts/components/AppHeader.vue'
import NovelManagementSidebar from '@/novel/management/components/NovelManagementSidebar.vue'
import GlobalAIAssistant from "@/novel/shared/components/GlobalAIAssistant/index.vue";
import AITaskConfigModal from '@/novel/shared/components/GlobalAIAssistant/AITaskConfigModal.vue'
import '@/novel/assets/styles/main.css'

// =
// 文件: ..\src\novel\router.ts
//

import type { RouteRecordRaw } from 'vue-router'
import { dashboardRoutes } from './dashboard/router'
import { editorRoutes } from './editor/router'

export const novelRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel',
        component: () => import('@/novel/layouts/NovelDashboardLayout.vue'),
        redirect: '/novel/dashboard',
        children: [
            ...dashboardRoutes
        ]
    },
    ...editorRoutes,
]

// =
// 文件: ..\src\novel\services\novelProjectService.ts
//

import * as novelProjectApi from '@/novel/editor/api/novelProjectApi';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume } from '@/novel/editor/types';

/**
 * 根据ID从后端获取完整的小说项目数据
 * @param novelId - 小说ID
 * @returns 完整的小说项目对象
 */
export const getNovelProject = (novelId: string): Promise<NovelProject> => {
    return novelProjectApi.getNovelProject(novelId);
};

/**
 * 封装导入新小说项目所需的数据
 */
type ImportData = {
    title: string;
    description: string;
    category: string;
    directoryData: Volume[];
};

/**
 * 从解析后的数据导入一本新小说。
 * @param data - 包含标题、描述、分类和章节数据等。
 * @returns 返回新创建的完整小说项目。
 */
export const importNovelProject = (data: ImportData): Promise<NovelProject> => {
    return novelProjectApi.importNovelProject(data);
};

/**
 * 获取所有小说项目，用于参考书选择等场景。
 * @returns 返回所有小说项目的数组。
 */
export const fetchAllNovelProjects = (): Promise<NovelProject[]> => {
    return novelProjectApi.fetchAllNovelProjects();
};

/**
 * 永久删除一个小说项目（非移入回收站）。
 * @param novelId - 小说ID。
 */
export const deleteNovelProject = (novelId: string): Promise<void> => {
    return novelProjectApi.deleteNovelProject(novelId);
};

// =
// 文件: ..\src\novel\types\index.ts
//

// src/novel/types/index.ts
// 定义小说模块对外共享的数据类型

/**
 * 小说标签定义
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说状态定义
 */
export interface NovelStatus {
    text: '编辑中' | '待审核' | '已驳回' | '已发布';
    class: string;
}

/**
 * 小说分类的类型别名
 */
export type NovelCategory = '科幻' | '奇幻' | '悬疑' | '恐怖' | '都市' | '言情' | '历史';

/**
 * 小说在仪表盘列表中的数据结构。
 * 这是 NovelProject 的一个摘要视图。
 */
export interface NovelDashboardItem {
    id: string;
    title: string;
    description: string;
    cover: string;
    status: NovelStatus;
    tags: NovelTag[];
    chapters: number;
    lastUpdated: string;
    category: NovelCategory;
    deletedAt?: string;
}


/**
 * 定义“最近编辑”条目的数据结构。
 * 对应于 `RecentView.vue` 中显示的数据。
 */
export interface RecentActivityItem {
    id: string; // 活动自身的唯一ID
    novelId: string; // 关联的小说ID
    novelTitle: string; // 关联的小说标题
    novelCover: string; // 关联的小说封面

    editedItemType: 'chapter' | 'outline' | 'character'; // 被编辑的项目类型
    editedItemName: string; // 被编辑的项目名称，例如 "第四章：跃迁点" 或 "角色设定 - 艾拉"
    editedAt: string; // 编辑时间, ISO 8601 格式
    formattedTime: string; // 用于UI显示的格式化时间，如 "2小时前" 或 "下午 3:45"
}

/**
 * 定义“回收站”中条目的数据结构。
 * 对应于 `TrashView.vue` 中显示的数据。
 */
export interface DeletedItem {
    id: string; // 被删除项目的ID
    name: string; // 被删除项目的名称
    type: '小说' | '章节' | '角色'; // 被删除项目的类型
    icon: string; // 用于UI显示的图标HTML字符串
    deletedAt: string; // 删除时间, ISO 8601 格式
    retentionDays: number; // 剩余保留天数
    retentionPercent: number; // 剩余时间百分比，用于进度条显示
}

