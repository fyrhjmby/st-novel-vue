// == 扫描摘要 ==
//
// 跳过的目录 (共 3 个):
//   - ..\src\novel\editor\components\ai\chat
//   - ..\src\novel\editor\components\layout
//   - ..\src\novel\editor\components\modals
//
// 跳过的特定文件 (共 3 个):
//   - ..\src\novel\editor\components\system\HistoryPanel.vue
//   - ..\src\novel\editor\components\system\settings\EditorSettings.vue
//   - ..\src\novel\editor\components\system\settings\ThemeSettings.vue
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\assets\styles\main.css
//



.novel-module {

}


.hide-scrollbar::-webkit-scrollbar {
    display: none;
}



// =
// 文件: ..\src\novel\dashboard\components\NovelDashboardSidebar.vue
//

<template>
  <aside class="w-64 bg-[#FAFAFA] border-r border-gray-100 flex flex-col flex-shrink-0">
    <!-- 侧边栏头部区域 -->
    <div class="p-4 space-y-4 border-b border-gray-100 h-20 flex items-center">
      <div class="flex items-center gap-3 px-2">
        <!-- 使用与主侧边栏一致的返回工作台的链接 -->
        <router-link to="/home" class="w-10 h-10 bg-gray-200 rounded-lg flex items-center justify-center flex-shrink-0">
          <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </router-link>
        <div>
          <h3 class="font-medium text-[#374151] text-sm">创作中心</h3>
          <p class="text-xs text-[#9CA3AF]">小说与故事</p>
        </div>
      </div>
    </div>

    <!-- 主导航 -->
    <nav class="flex-1 px-4 py-6">
      <p class="text-xs font-medium text-[#9CA3AF] px-3 mb-3 uppercase tracking-wider">工作空间</p>
      <div class="space-y-1">
        <router-link
            v-for="item in navItems"
            :key="item.name"
            :to="item.path"
            class="flex items-center gap-3 px-3 py-2.5 text-[#6B7280] hover:bg-gray-100 rounded-lg text-sm transition-colors"
            active-class="bg-[#4B5563] text-white font-medium"
        >
          <span v-html="item.icon" class="w-5 h-5"></span>
          <span>{{ item.name }}</span>
        </router-link>
      </div>
    </nav>

    <!-- 底部设置 -->
    <div class="p-4 border-t border-gray-100 mt-auto">
      <router-link to="/settings" class="flex items-center gap-3 px-3 py-2.5 text-[#6B7280] hover:bg-gray-100 rounded-lg text-sm transition-colors">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M12 1V6M12 18V23M4.22 4.22L7.76 7.76M16.24 16.24L19.78 19.78M1 12H6M18 12H23M4.22 19.78L7.76 16.24M16.24 7.76L19.78 4.22"/></svg>
        <span>设置</span>
      </router-link>
    </div>
  </aside>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const navItems = ref([
  { name: '我的小说', path: '/novel/dashboard', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>` },
  { name: '最近编辑', path: '/novel/recent', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>` },
  { name: '回收站', path: '/novel/trash', icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>` },
  { name: '导出小说', path: '/novel/export', icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>` }
])
</script>

<style scoped>
.router-link-exact-active {
  color: white !important;
}
</style>

// =
// 文件: ..\src\novel\dashboard\config\sidebar.config.ts
//


export interface NavItem {
    name: string;
    path: string;
    icon: string;
}

export const mainNavItems: NavItem[] = [
    {
        name: '我的小说',
        path: '/novel/dashboard',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>`
    },
    {
        name: '最近编辑',
        path: '/novel/recent',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>`
    },
    {
        name: '回收站',
        path: '/novel/trash',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>`
    },
    {
        name: '导出小说',
        path: '/novel/export',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>`
    }
];

// =
// 文件: ..\src\novel\dashboard\data\index.ts
//

// 文件: src/novel/dashboard/data/types.ts
import type { Novel, NovelCategory } from '@/novel/types';
import type { RecentActivityItem, DeletedItem } from '@/novel/dashboard/types';

export const mockNovels: Novel[] = [
    {
        id: 'novel-1',
        title: '星际漫游者',
        description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
        cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=800',
        status: { text: '编辑中', class: 'bg-green-500/90' },
        tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }, { text: '冒险', class: 'bg-purple-50 text-purple-700' }],
        chapters: 24,
        lastUpdated: '2小时前',
        category: '科幻'
    },
    {
        id: 'novel-2',
        title: '时间之沙',
        description: '当历史可以被改写，一个历史学家必须阻止一个神秘组织抹去关键的历史事件。',
        cover: 'https://images.unsplash.com/photo-1544947950-fa07a98d237f?q=80&w=800',
        status: { text: '待审核', class: 'bg-yellow-500/90' },
        tags: [{ text: '悬疑', class: 'bg-yellow-50 text-yellow-700' }, { text: '科幻', class: 'bg-blue-50 text-blue-700' }],
        chapters: 15,
        lastUpdated: '昨天',
        category: '悬疑'
    },
    {
        id: 'novel-4',
        title: '都市霓虹',
        description: '一个平凡的程序员意外获得读取他人思想的能力，卷入一场巨大的商业阴谋。',
        cover: 'https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=800',
        status: { text: '已发布', class: 'bg-blue-500/90' },
        tags: [{ text: '都市', class: 'bg-pink-50 text-pink-700' }, { text: '异能', class: 'bg-green-50 text-green-700' }],
        chapters: 102,
        lastUpdated: '1周前',
        category: '都市'
    },
    {
        id: 'novel-5',
        title: '红尘一梦',
        description: '穿越回古代，成为一个不受宠的公主，她如何利用现代知识在宫廷斗争中生存。',
        cover: 'https://images.unsplash.com/photo-1521587760476-6c12a4b040da?q=80&w=800',
        status: { text: '编辑中', class: 'bg-green-500/90' },
        tags: [{ text: '古风', class: 'bg-red-50 text-red-700' }, { text: '言情', class: 'bg-indigo-50 text-indigo-700' }],
        chapters: 56,
        lastUpdated: '5小时前',
        category: '言情'
    }
];

export const mockTrashedItems: DeletedItem[] = [
    {
        id: 'novel-3-deleted',
        name: '深海回响',
        type: '小说',
        icon: '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>',
        deletedAt: '2024-05-18T10:00:00Z',
        retentionDays: 27,
        retentionPercent: 90,
    }
];

export const mockRecentItems: RecentActivityItem[] = [
    {
        id: 'activity-1',
        novelId: 'novel-1',
        novelTitle: '星际漫游者',
        novelCover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=800',
        editedItemType: 'chapter',
        editedItemName: '第四章：跃迁点',
        editedAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
        formattedTime: '2小时前'
    },
    {
        id: 'activity-2',
        novelId: 'novel-5',
        novelTitle: '红尘一梦',
        novelCover: 'https://images.unsplash.com/photo-1521587760476-6c12a4b040da?q=80&w=800',
        editedItemType: 'character',
        editedItemName: '角色设定 - 凤九',
        editedAt: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
        formattedTime: '5小时前'
    },
    {
        id: 'activity-3',
        novelId: 'novel-2',
        novelTitle: '时间之沙',
        novelCover: 'https://images.unsplash.com/photo-1544947950-fa07a98d237f?q=80&w=800',
        editedItemType: 'outline',
        editedItemName: '大纲',
        editedAt: new Date(Date.now() - 28 * 60 * 60 * 1000).toISOString(),
        formattedTime: '昨天'
    }
];

// =
// 文件: ..\src\novel\dashboard\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const dashboardRoutes: Array<RouteRecordRaw> = [
    {
        path: 'dashboard',
        name: 'NovelDashboard',
        component: () => import('@/novel/dashboard/views/DashboardView.vue'),
        meta: { title: '我的小说' }
    },
    {
        path: 'recent',
        name: 'NovelRecent',
        component: () => import('@/novel/dashboard/views/RecentView.vue'),
        meta: { title: '最近编辑' }
    },
    {
        path: 'trash',
        name: 'NovelTrash',
        component: () => import('@/novel/dashboard/views/TrashView.vue'),
        meta: { title: '回收站' }
    },
    {
        path: 'import',
        name: 'NovelImport',
        component: () => import('@/novel/dashboard/views/ImportView.vue'),
        meta: { title: '导入小说' }
    },
    {
        path: 'new',
        name: 'NovelNew',
        component: () => import('@/novel/dashboard/views/NewNovelView.vue'),
        meta: { title: '新建小说' }
    },
    {
        path: 'export',
        name: 'NovelExport',
        component: () => import('@/novel/dashboard/views/ExportView.vue'),
        meta: { title: '导出小说' }
    },
]

// =
// 文件: ..\src\novel\dashboard\stores\dashboardStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Novel, NovelCategory } from '@/novel/types/index.ts';
import type { RecentActivityItem, DeletedItem } from '@/novel/dashboard/types.ts';
import { mockNovels, mockRecentItems, mockTrashedItems } from '@/novel/dashboard/data';
import { createNewNovelProject } from '@/novel/data/novelProjectData';

export const useDashboardStore = defineStore('novel-dashboard', () => {
    // --- State ---
    const novels = ref<Novel[]>([]);
    const recentItems = ref<RecentActivityItem[]>([]);
    const trashedItems = ref<DeletedItem[]>([]);
    const searchQuery = ref('');
    const selectedCategory = ref<NovelCategory | '全部类型'>('全部类型');


    // --- Getters / Computed ---
    const filteredNovels = computed(() => {
        return novels.value.filter(novel => {
            const matchesCategory = selectedCategory.value === '全部类型' || novel.category === selectedCategory.value;
            const matchesSearch = novel.title.includes(searchQuery.value) || novel.tags.some(tag => tag.text.includes(searchQuery.value));
            return matchesCategory && matchesSearch;
        });
    });

    const availableCategories = computed((): NovelCategory[] => {
        const categories = new Set(novels.value.map(novel => novel.category));
        return Array.from(categories);
    });

    const groupedRecentItems = computed(() => {
        const groups: { period: string; items: RecentActivityItem[] }[] = [];
        if (recentItems.value.length === 0) return groups;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);

        const todayItems: RecentActivityItem[] = [];
        const yesterdayItems: RecentActivityItem[] = [];
        const earlierItems: RecentActivityItem[] = [];

        // 首先按时间降序排序
        const sortedItems = [...recentItems.value].sort((a, b) => new Date(b.editedAt).getTime() - new Date(a.editedAt).getTime());

        sortedItems.forEach(item => {
            const itemDate = new Date(item.editedAt);
            itemDate.setHours(0, 0, 0, 0);

            if (itemDate.getTime() === today.getTime()) {
                todayItems.push(item);
            } else if (itemDate.getTime() === yesterday.getTime()) {
                yesterdayItems.push(item);
            } else {
                earlierItems.push(item);
            }
        });

        if (todayItems.length > 0) {
            groups.push({ period: '今天', items: todayItems });
        }
        if (yesterdayItems.length > 0) {
            groups.push({ period: '昨天', items: yesterdayItems });
        }
        if (earlierItems.length > 0) {
            groups.push({ period: '更早', items: earlierItems });
        }

        return groups;
    });

    // --- Actions ---

    const fetchAllData = () => {
        // 如果已有数据，则不重复获取，防止覆盖
        if (novels.value.length > 0) {
            return;
        }

        novels.value = mockNovels;
        recentItems.value = mockRecentItems;
        trashedItems.value = mockTrashedItems;
    };

    const setSearchQuery = (query: string) => {
        searchQuery.value = query;
    };

    const setCategoryFilter = (category: NovelCategory | '全部类型') => {
        selectedCategory.value = category;
    };

    const createNovel = (data: { title: string; synopsis: string; category: NovelCategory }) => {
        const newNovelId = `novel-${Date.now()}`;
        const newProject = createNewNovelProject(newNovelId, data.title, data.synopsis, data.category);

        const newNovelForDashboard: Novel = {
            id: newProject.metadata.id,
            title: newProject.metadata.title,
            description: newProject.metadata.description,
            category: data.category,
            cover: newProject.metadata.cover,
            status: { text: '编辑中', class: 'bg-green-500/90' },
            tags: newProject.metadata.tags,
            chapters: 0,
            lastUpdated: '刚刚'
        };
        novels.value.unshift(newNovelForDashboard);
    };

    const deleteNovel = (novelId: string) => {
        const index = novels.value.findIndex(n => n.id === novelId);
        if (index === -1) return;

        const novelToDelete = novels.value[index];
        const trashedItem: DeletedItem = {
            id: novelToDelete.id,
            name: novelToDelete.title,
            type: '小说',
            icon: '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>',
            deletedAt: new Date().toISOString(),
            retentionDays: 30,
            retentionPercent: 100
        };

        trashedItems.value.unshift(trashedItem);
        novels.value.splice(index, 1);
    };

    const restoreNovel = (itemId: string) => {
        // 这部分逻辑依赖于一个完整的对象，而不仅仅是ID
        // 暂不实现，仅提供接口
    };

    const deleteItemPermanently = (itemId: string) => {
        const index = trashedItems.value.findIndex(item => item.id === itemId);
        if (index > -1) {
            trashedItems.value.splice(index, 1);
        }
    };


    return {
        novels,
        recentItems,
        trashedItems,
        searchQuery,
        selectedCategory,
        filteredNovels,
        availableCategories,
        groupedRecentItems,
        fetchAllData,
        setSearchQuery,
        setCategoryFilter,
        createNovel,
        deleteNovel,
        restoreNovel,
        deleteItemPermanently
    };
});

// =
// 文件: ..\src\novel\dashboard\types.ts
//



/**
 * 定义“最近编辑”条目的数据结构。
 * 对应于 `RecentView.vue` 中显示的数据。
 */
export interface RecentActivityItem {
    id: string; // 活动自身的唯一ID
    novelId: string; // 关联的小说ID
    novelTitle: string; // 关联的小说标题
    novelCover: string; // 关联的小说封面

    editedItemType: 'chapter' | 'outline' | 'character'; // 被编辑的项目类型
    editedItemName: string; // 被编辑的项目名称，例如 "第四章：跃迁点" 或 "角色设定 - 艾拉"
    editedAt: string; // 编辑时间, ISO 8601 格式
    formattedTime: string; // 用于UI显示的格式化时间，如 "2小时前" 或 "下午 3:45"
}

/**
 * 定义“回收站”中条目的数据结构。
 * 对应于 `TrashView.vue` 中显示的数据。
 */
export interface DeletedItem {
    id: string; // 被删除项目的ID
    name: string; // 被删除项目的名称
    type: '小说' | '章节' | '角色'; // 被删除项目的类型
    icon: string; // 用于UI显示的图标HTML字符串
    deletedAt: string; // 删除时间, ISO 8601 格式
    retentionDays: number; // 剩余保留天数
    retentionPercent: number; // 剩余时间百分比，用于进度条显示
}

// =
// 文件: ..\src\novel\dashboard\views\DashboardView.vue
//

// =
// 文件: ..\src/novel/dashboard/views/DashboardView.vue
//
<!-- 文件路径: src/novel/dashboard/views/DashboardView.vue -->

<template>
  <div class="flex-1 px-8 py-6 overflow-auto bg-[#FCFCFC] hide-scrollbar">
    <div class="flex justify-between items-center mb-6">
      <div class="flex items-center gap-4">
        <label class="flex items-center gap-2 w-64 bg-white border border-gray-200 rounded-lg px-3 py-2 focus-within:border-blue-500 focus-within:ring-1 focus-within:ring-blue-500 transition">
          <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="M21 21L16.65 16.65"/></svg>
          <input
              type="text"
              class="grow text-sm bg-transparent outline-none text-[#374151]"
              placeholder="搜索小说名或标签..."
              v-model="searchQuery"
          />
        </label>
        <select
            v-model="selectedCategory"
            class="text-sm bg-white border border-gray-200 rounded-lg px-3 py-2 outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition text-[#374151]"
        >
          <option>全部类型</option>
          <option v-for="category in availableCategories" :key="category" :value="category">
            {{ category }}
          </option>
        </select>
      </div>
      <div class="flex items-center gap-4">
        <router-link to="/novel/import" class="text-sm text-[#6B7280] hover:text-[#374151] transition-colors flex items-center gap-2">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M7 18C4.5 18 3 16.5 3 14C3 11.5 5 10 7 10C7.3 10 7.5 10 7.8 10.1C8.5 7.2 11 5 14 5C17.3 5 20 7.7 20 11C20 11.3 20 11.7 19.9 12C21.1 12.5 22 13.6 22 15C22 16.9 20.4 18.5 18.5 18.5"/><path d="M12 13V21M15 16L12 13L9 16"/></svg>
          <span>导入小说</span>
        </router-link>
        <router-link to="/novel/new" class="text-sm font-medium text-white bg-[#4B5563] hover:bg-gray-700 transition-colors flex items-center gap-2 px-4 py-2 rounded-lg">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 5V19M5 12H19"/></svg>
          <span>新建小说</span>
        </router-link>
      </div>
    </div>

    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
      <div
          v-for="novel in filteredNovels"
          :key="novel.id"
          class="group bg-white rounded-xl border border-gray-100 p-4 flex flex-col transition-all duration-300 hover:shadow-md hover:-translate-y-1"
      >
        <router-link :to="`/novel/editor?id=${novel.id}`" class="block aspect-[4/5] relative w-full mb-4 rounded-lg overflow-hidden">
          <img :src="novel.cover" class="object-cover w-full h-full group-hover:scale-105 transition-transform duration-300" alt="Book Cover">
          <div class="absolute top-0 left-0 w-full h-full bg-black/5 group-hover:bg-black/10 transition-colors"></div>
        </router-link>

        <div class="flex flex-col flex-grow">
          <h3 class="text-sm font-medium text-[#374151] leading-tight truncate">
            <router-link :to="`/novel/editor?id=${novel.id}`" class="hover:text-blue-600 transition-colors">{{ novel.title }}</router-link>
          </h3>
          <p class="text-xs text-[#9CA3AF] mt-1">{{ novel.chapters }}章 · {{ novel.status.text }}</p>
          <div class="mt-auto pt-3">
            <div class="border-t border-gray-100 pt-3 flex justify-between items-center text-xs text-gray-400">
              <div class="flex items-center gap-1.5">
                 <span
                     v-for="tag in novel.tags"
                     :key="tag.text"
                     class="text-xs px-1.5 py-0.5 rounded font-medium"
                     :class="tag.class"
                 >
                  {{ tag.text }}
                </span>
              </div>
              <span>{{ novel.lastUpdated }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useDashboardStore } from '@/novel/dashboard/stores/dashboardStore';

const dashboardStore = useDashboardStore();

const {
  filteredNovels,
  availableCategories,
  searchQuery,
  selectedCategory
} = storeToRefs(dashboardStore);

onMounted(() => {
  dashboardStore.fetchAllData();
});
</script>

// =
// 文件: ..\src\novel\dashboard\views\ExportView.vue
//

<template>
  <div class="flex-1 flex overflow-hidden bg-[#FCFCFC]">
    <div class="w-[420px] border-r border-gray-100 p-8 flex flex-col bg-white flex-shrink-0">
      <div class="space-y-8 flex-grow">
        <div>
          <h3 class="text-base font-medium text-[#374151] mb-4">导出格式</h3>
          <div class="grid grid-cols-3 gap-3">
            <button
                @click="selectedFormat = 'pdf'"
                :class="['flex flex-col items-center justify-center gap-2 p-4 rounded-lg border-2 transition-all aspect-square', selectedFormat === 'pdf' ? 'border-blue-500 text-blue-600 bg-blue-50/50' : 'bg-white text-gray-400 border-gray-200 hover:border-gray-300']">
              <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
              <span class="block text-xs font-semibold">PDF</span>
            </button>
            <button
                @click="selectedFormat = 'docx'"
                :class="['flex flex-col items-center justify-center gap-2 p-4 rounded-lg border-2 transition-all aspect-square', selectedFormat === 'docx' ? 'border-blue-500 text-blue-600 bg-blue-50/50' : 'bg-white text-gray-400 border-gray-200 hover:border-gray-300']">
              <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
              <span class="block text-xs font-semibold">DOCX</span>
            </button>
            <button
                @click="selectedFormat = 'epub'"
                :class="['flex flex-col items-center justify-center gap-2 p-4 rounded-lg border-2 transition-all aspect-square', selectedFormat === 'epub' ? 'border-blue-500 text-blue-600 bg-blue-50/50' : 'bg-white text-gray-400 border-gray-200 hover:border-gray-300']">
              <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"></path></svg>
              <span class="block text-xs font-semibold">EPUB</span>
            </button>
          </div>
        </div>

        <div>
          <h3 class="text-base font-medium text-[#374151] mb-4">包含内容</h3>
          <div class="space-y-3">
            <label class="flex items-center gap-3 p-4 bg-white rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-50 transition-colors">
              <input type="checkbox" class="sr-only peer" checked>
              <div class="w-5 h-5 rounded flex items-center justify-center border border-gray-300 peer-checked:bg-[#4B5563] peer-checked:border-[#4B5563]">
                <svg class="w-3.5 h-3.5 text-white hidden peer-checked:block" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
              </div>
              <span class="text-sm text-[#374151] flex-1">小说正文</span>
            </label>
            <label class="flex items-center gap-3 p-4 bg-white rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-50 transition-colors">
              <input type="checkbox" class="sr-only peer" checked>
              <div class="w-5 h-5 rounded flex items-center justify-center border border-gray-300 peer-checked:bg-[#4B5563] peer-checked:border-[#4B5563]">
                <svg class="w-3.5 h-3.5 text-white hidden peer-checked:block" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
              </div>
              <span class="text-sm text-[#374151] flex-1">章节大纲</span>
            </label>
            <label class="flex items-center gap-3 p-4 bg-white rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-50 transition-colors">
              <input type="checkbox" class="sr-only peer">
              <div class="w-5 h-5 rounded flex items-center justify-center border border-gray-300 peer-checked:bg-[#4B5563] peer-checked:border-[#4B5563]">
                <svg class="w-3.5 h-3.5 text-white hidden peer-checked:block" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
              </div>
              <span class="text-sm text-[#374151] flex-1">角色设定集</span>
            </label>
            <label class="flex items-center gap-3 p-4 bg-white rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-50 transition-colors">
              <input type="checkbox" class="sr-only peer">
              <div class="w-5 h-5 rounded flex items-center justify-center border border-gray-300 peer-checked:bg-[#4B5563] peer-checked:border-[#4B5563]">
                <svg class="w-3.5 h-3.5 text-white hidden peer-checked:block" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
              </div>
              <span class="text-sm text-[#374151] flex-1">作者笔记</span>
            </label>
          </div>
        </div>
      </div>

      <button class="w-full mt-8 flex h-11 items-center justify-center gap-2 bg-[#374151] hover:bg-[#4B5563] text-white font-medium text-sm rounded-lg px-4 transition-colors">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2 2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        <span>开始导出</span>
      </button>
    </div>

    <!-- 右侧预览区 -->
    <div class="flex-1 p-8 bg-[#f5f5f7] overflow-auto custom-scrollbar">
      <div class="bg-white p-12 shadow-lg mx-auto" style="width: 210mm; min-height: 297mm;">
        <div class="text-center mb-16">
          <h1 class="text-4xl" style="font-family: 'Georgia', serif;">星际漫游者</h1>
          <p class="text-lg text-gray-500 mt-2" style="font-family: 'Georgia', serif;">创作者</p>
        </div>
        <div class="text-lg leading-relaxed text-justify" style="font-family: 'Georgia', serif;">
          <h2 class="text-2xl font-bold mb-4">第一章：深空孤影</h2>
          <p class="mb-6">这是章节的详细内容，讲述了主角卡尔文在孤独的宇宙中开始他的旅程。周围只有无尽的星空和飞船引擎的低鸣。</p>
          <p class="mb-6">一个神秘的信号打破了长久的平静，它似乎来自一个未知的源头，艾拉无法解析其格式。这给卡尔文带来了希望，也带来了恐惧。</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';

const selectedFormat = ref('pdf');
</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar {
  display: block;
  width: 6px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #d1d5db;
  border-radius: 3px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}
</style>

// =
// 文件: ..\src\novel\dashboard\views\ImportView.vue
//

<template>
  <div class="flex-1 px-8 py-6 overflow-auto bg-[#FCFCFC] flex items-center justify-center">
    <div class="w-full max-w-2xl bg-white rounded-xl p-8 border border-gray-100 shadow-sm">

      <!-- 文件上传区域 -->
      <div
          @click="triggerFileSelect"
          @dragover.prevent="dragOver = true"
          @dragleave.prevent="dragOver = false"
          @drop.prevent="handleFileDrop"
          :class="['border-2 border-dashed border-gray-200 rounded-xl p-12 text-center transition-colors cursor-pointer', dragOver ? 'border-blue-400 bg-gray-50/50' : 'hover:border-blue-400 hover:bg-gray-50/50']"
      >
        <input type="file" ref="fileInput" @change="handleFileSelect" class="hidden" accept=".txt,.md">
        <svg class="w-12 h-12 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M7 18C4.5 18 3 16.5 3 14C3 11.5 5 10 7 10C7.3 10 7.5 10 7.8 10.1C8.5 7.2 11 5 14 5C17.3 5 20 7.7 20 11C20 11.3 20 11.7 19.9 12C21.1 12.5 22 13.6 22 15C22 16.9 20.4 18.5 18.5 18.5"/><path stroke-linecap="round" stroke-linejoin="round" d="M12 13V21M15 16L12 13L9 16"/>
        </svg>
        <h3 class="text-lg font-medium text-[#374151]">将文件拖拽至此</h3>
        <p class="text-sm text-[#6B7280] mt-1">或</p>
        <button @click.stop="triggerFileSelect" class="mt-4 px-6 py-2.5 bg-[#4B5563] text-white rounded-lg text-sm font-medium hover:bg-[#374151] transition-colors">
          选择文件
        </button>
        <p v-if="fileName" class="text-sm text-blue-600 mt-4 font-medium">{{ fileName }}</p>
        <p v-else class="text-xs text-gray-400 mt-4">支持 .txt, .md</p>
      </div>

      <!-- 导入设置区域 -->
      <div class="mt-8 text-left space-y-6 w-full">
        <div>
          <h4 class="text-base font-medium text-[#374151] mb-2">章节解析规则</h4>
          <div class="p-4 bg-[#F9FAFB] rounded-lg border border-gray-100">
            <p class="text-sm font-medium text-[#374151]">按空行分割章节</p>
            <p class="text-xs text-[#9CA3AF] mt-1">将使用一个或多个连续的空行作为章节的分割符。</p>
          </div>
        </div>

        <div>
          <h4 class="text-base font-medium text-[#374151] mb-2">章节分卷设置</h4>
          <div class="p-4 bg-[#F9FAFB] rounded-lg border border-gray-100">
            <label for="chapters-per-volume" class="text-sm font-medium text-[#374151] block mb-2">每卷包含的章节数</label>
            <input type="number" id="chapters-per-volume" v-model.number="chaptersPerVolume" min="1" class="w-full bg-white border border-gray-200 rounded-lg px-3 py-1.5 text-sm text-[#374151] focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition-colors">
            <p class="text-xs text-[#9CA3AF] mt-2">导入的章节将按此数量自动分卷。</p>
          </div>
        </div>
      </div>

      <!-- 导入操作 -->
      <div class="mt-8 pt-6 border-t border-gray-100 flex justify-end">
        <button
            @click="handleImport"
            :disabled="!uploadedFileContent"
            class="px-8 py-2.5 bg-[#4B5563] text-white rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed flex items-center gap-2"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5l3 3m0 0l3-3m-3 3v-6m1.06-4.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z"></path></svg>
          <span>开始导入</span>
        </button>
      </div>

    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import { useDashboardStore } from '@/novel/dashboard/stores/dashboardStore';
import { importNovelProject } from '@/novel/data/novelProjectData';
import { parseNovelText } from '@/novel/importer/services/novelParser';
import type { Novel } from '@/novel/types';

const router = useRouter();
const dashboardStore = useDashboardStore();

const fileInput = ref<HTMLInputElement | null>(null);
const fileName = ref('');
const uploadedFileContent = ref<string | null>(null);
const dragOver = ref(false);
const chaptersPerVolume = ref(10);

const triggerFileSelect = () => {
  fileInput.value?.click();
};

const handleFileSelect = (event: Event) => {
  const target = event.target as HTMLInputElement;
  const file = target.files?.[0];
  if (file) {
    readFile(file);
  }
};

const handleFileDrop = (event: DragEvent) => {
  dragOver.value = false;
  const file = event.dataTransfer?.files?.[0];
  if (file && (file.type === 'text/plain' || file.type === 'text/markdown')) {
    readFile(file);
  } else {
    alert('请拖放 .txt 或 .md 文件');
  }
};

const readFile = (file: File) => {
  fileName.value = file.name;
  const reader = new FileReader();
  reader.onload = (e) => {
    uploadedFileContent.value = e.target?.result as string;
  };
  reader.onerror = () => {
    alert('文件读取失败');
    uploadedFileContent.value = null;
    fileName.value = '';
  };
  reader.readAsText(file);
};

const handleImport = () => {
  if (!uploadedFileContent.value) {
    alert('没有文件内容可供导入。');
    return;
  }

  // 1. 使用解析服务进行解析
  const directoryData = parseNovelText(uploadedFileContent.value, {
    chaptersPerVolume: chaptersPerVolume.value || 10,
  });

  // 2. 创建新的小说项目
  const novelTitle = fileName.value.replace(/\.(txt|md)$/i, '') || '导入的小说';
  const newNovelId = `novel-imported-${Date.now()}`;
  const newProject = importNovelProject(
      newNovelId,
      novelTitle,
      '从文件导入的小说',
      '都市', // 默认分类，可以后续让用户选择
      directoryData
  );

  // 3. 更新仪表盘的列表
  const newNovelForDashboard: Novel = {
    id: newProject.metadata.id,
    title: newProject.metadata.title,
    description: newProject.metadata.description,
    category: '都市',
    cover: newProject.metadata.cover,
    status: { text: '编辑中', class: 'bg-green-500/90' },
    tags: newProject.metadata.tags,
    chapters: directoryData.reduce((acc, vol) => acc + vol.chapters.length, 0),
    lastUpdated: '刚刚'
  };
  dashboardStore.novels.unshift(newNovelForDashboard);


  // 4. 跳转到新小说的编辑器
  router.push(`/novel/editor?id=${newNovelId}`);
};
</script>

<style scoped>
/* 保持原有样式不变 */
</style>

// =
// 文件: ..\src\novel\dashboard\views\NewNovelView.vue
//

// 文件: src\novel\dashboard\views\NewNovelView.vue

<template>
  <div class="flex-1 px-8 py-6 overflow-auto bg-[#FCFCFC] flex items-center justify-center">
    <div class="w-full max-w-2xl bg-white rounded-xl p-8 border border-gray-100 shadow-sm">
      <div class="mb-8 text-center">
        <h2 class="text-xl font-semibold text-[#374151]">创建你的新故事</h2>
        <p class="text-sm text-[#9CA3AF] mt-2">为你的世界打下第一个基石</p>
      </div>

      <form @submit.prevent="handleCreateNovel" class="space-y-6">
        <div>
          <label for="novel-title" class="block text-sm font-medium text-[#374151] mb-1.5">小说标题</label>
          <input
              type="text"
              id="novel-title"
              v-model="newNovelData.title"
              placeholder="例如：星际漫游者"
              required
              class="w-full bg-white border border-gray-200 rounded-lg px-3 py-2 text-sm text-[#374151] focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition"
          >
        </div>
        <div>
          <label for="novel-synopsis" class="block text-sm font-medium text-[#374151] mb-1.5">小说简介 (可选)</label>
          <textarea
              id="novel-synopsis"
              rows="4"
              v-model="newNovelData.synopsis"
              placeholder="简单描述一下你的故事，这将帮助AI更好地理解你的创作意图。"
              class="w-full bg-white border border-gray-200 rounded-lg px-3 py-2 text-sm text-[#374151] leading-relaxed focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition resize-none"
          ></textarea>
        </div>
        <div>
          <label for="novel-category" class="block text-sm font-medium text-[#374151] mb-1.5">小说分类</label>
          <select
              id="novel-category"
              v-model="newNovelData.category"
              required
              class="text-sm bg-white border border-gray-200 rounded-lg px-3 py-2 outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition text-[#374151] w-full"
          >
            <option value="" disabled>选择一个分类</option>
            <option>科幻</option>
            <option>奇幻</option>
            <option>都市</option>
            <option>言情</option>
            <option>悬疑</option>
            <option>历史</option>
          </select>
        </div>

        <div class="mt-8 pt-6 border-t border-gray-100 flex justify-end items-center gap-4">
          <router-link to="/novel/dashboard" class="px-5 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">
            取消
          </router-link>
          <button type="submit" class="px-6 py-2 bg-[#4B5563] text-white rounded-lg text-sm font-medium hover:bg-gray-700 transition-colors flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 5V19M5 12H19"></path></svg>
            <span>创建小说</span>
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { reactive } from 'vue';
import { useRouter } from 'vue-router';
import { useDashboardStore } from '@/novel/dashboard/stores/dashboardStore';
import type { NovelCategory } from '@/novel/types';

const dashboardStore = useDashboardStore();
const router = useRouter();

const newNovelData = reactive({
  title: '',
  synopsis: '',
  category: '' as NovelCategory | '',
});

const handleCreateNovel = () => {
  if (!newNovelData.title || !newNovelData.category) {
    alert('请填写小说标题和分类');
    return;
  }
  dashboardStore.createNovel(newNovelData as { title: string; synopsis: string; category: NovelCategory });
  // 创建成功后跳转到仪表盘页面
  router.push('/novel/dashboard');
};
</script>

// =
// 文件: ..\src\novel\dashboard\views\RecentView.vue
//

// =
// 文件: ..\src/novel/dashboard/views/RecentView.vue
//

<template>
  <div class="flex-1 p-8 overflow-auto bg-[#FCFCFC] hide-scrollbar">
    <div class="max-w-6xl mx-auto">
      <div class="mb-6 pb-4 border-b border-gray-100">
        <h1 class="text-xl font-semibold text-[#374151]">最近编辑</h1>
        <p class="text-sm text-gray-500 mt-1">查看并继续您最近的工作</p>
      </div>

      <div v-if="groupedRecentItems.length > 0" class="space-y-8">
        <div v-for="group in groupedRecentItems" :key="group.period">
          <h2 class="text-sm font-medium text-[#9CA3AF] mb-3 px-2">{{ group.period }}</h2>
          <div class="bg-white rounded-xl border border-gray-100 overflow-hidden">
            <ul class="divide-y divide-gray-100">
              <li
                  v-for="item in group.items"
                  :key="item.id"
                  class="p-4 flex items-center justify-between group hover:bg-gray-50/50 transition-colors"
              >
                <div class="flex items-center gap-4 flex-1 min-w-0">
                  <router-link :to="`/novel/editor?id=${item.novelId}`">
                    <img :src="item.novelCover" class="w-10 h-14 object-cover rounded-md flex-shrink-0 shadow-sm" alt="cover">
                  </router-link>
                  <div class="flex-1 min-w-0">
                    <p class="text-sm font-medium text-[#374151] truncate">
                      <router-link :to="`/novel/editor?id=${item.novelId}`" class="hover:text-blue-600">{{ item.novelTitle }}</router-link>
                    </p>
                    <p class="text-xs text-gray-500 mt-1">
                      编辑了 <span class="font-medium text-gray-600">{{ item.editedItemName }}</span>
                    </p>
                  </div>
                </div>
                <div class="flex items-center gap-6">
                  <span class="text-sm text-gray-400 w-28 text-right">{{ item.formattedTime }}</span>
                  <div class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                    <router-link :to="`/novel/editor?id=${item.novelId}`" class="px-3 py-1.5 bg-[#4B5563] text-white rounded-lg text-xs font-medium hover:bg-gray-700 transition-colors">继续编辑</router-link>
                    <button class="w-8 h-8 flex items-center justify-center text-gray-500 hover:bg-gray-200 rounded-lg transition-colors">
                      <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"/></svg>
                    </button>
                  </div>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>
      <div v-else class="text-center py-20 text-gray-500">
        没有最近的编辑活动。
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useDashboardStore } from '@/novel/dashboard/stores/dashboardStore';

const dashboardStore = useDashboardStore();

const { groupedRecentItems } = storeToRefs(dashboardStore);

onMounted(() => {
  dashboardStore.fetchAllData();
});
</script>

// =
// 文件: ..\src\novel\dashboard\views\TrashView.vue
//

// =
// 文件: ..\src/novel/dashboard/views/TrashView.vue
//
// 文件: src\novel\dashboard\views\TrashView.vue

<template>
  <div class="flex-1 p-8 overflow-auto bg-[#FCFCFC] hide-scrollbar">
    <div class="flex justify-between items-center mb-6 p-4 bg-blue-50 border border-blue-100 rounded-lg">
      <p class="text-sm text-blue-800 flex items-center gap-2">
        <svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
        项目将在回收站中保留30天，之后将被永久删除。
      </p>
      <button class="flex items-center gap-2 px-3 py-1.5 text-sm font-medium bg-red-100 text-red-700 rounded-md hover:bg-red-200 transition-colors">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 01-2-2V7h18v12a2 2 0 01-2 2zM3 7h18M10 12v4M14 12v4M8 7V4a1 1 0 011-1h6a1 1 0 011 1v3"/></svg>
        清空回收站
      </button>
    </div>

    <div class="bg-white rounded-xl border border-gray-100 overflow-hidden">
      <table class="w-full text-sm text-left">
        <thead class="text-xs text-[#6B7280] uppercase bg-gray-50">
        <tr>
          <th scope="col" class="px-6 py-3 font-medium w-2/5">项目名称</th>
          <th scope="col" class="px-6 py-3 font-medium">类型</th>
          <th scope="col" class="px-6 py-3 font-medium">删除时间</th>
          <th scope="col" class="px-6 py-3 font-medium">剩余时间</th>
          <th scope="col" class="px-6 py-3 font-medium text-right">操作</th>
        </tr>
        </thead>
        <tbody class="divide-y divide-gray-100">
        <tr v-if="dashboardStore.trashedItems.length === 0">
          <td colspan="5" class="text-center py-10 text-gray-500">回收站是空的</td>
        </tr>
        <tr v-for="item in dashboardStore.trashedItems" :key="item.id" class="hover:bg-gray-50/50 transition-colors">
          <td class="px-6 py-4 font-medium text-[#374151] flex items-center gap-3">
            <span class="text-gray-400 w-5 h-5 flex-shrink-0" v-html="item.icon"></span>
            <span>{{ item.name }}</span>
          </td>
          <td class="px-6 py-4 text-[#6B7280]">{{ item.type }}</td>
          <td class="px-6 py-4 text-[#6B7280]">{{ new Date(item.deletedAt).toLocaleString() }}</td>
          <td class="px-6 py-4">
            <div class="flex items-center gap-3">
              <div class="w-full bg-gray-200 rounded-full h-1.5">
                <div class="bg-orange-400 h-1.5 rounded-full" :style="{ width: item.retentionPercent + '%' }"></div>
              </div>
              <span class="text-orange-500 text-xs font-medium w-16 text-right">{{ item.retentionDays }} 天</span>
            </div>
          </td>
          <td class="px-6 py-4 text-right space-x-4">
            <button @click="dashboardStore.restoreNovel(item.id)" class="font-medium text-blue-600 hover:text-blue-800 transition-colors">恢复</button>
            <button @click="dashboardStore.deleteItemPermanently(item.id)" class="font-medium text-red-600 hover:text-red-800 transition-colors">永久删除</button>
          </td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { useDashboardStore } from '@/novel/dashboard/stores/dashboardStore';

const dashboardStore = useDashboardStore();

onMounted(() => {
  dashboardStore.fetchAllData();
});
</script>

// =
// 文件: ..\src\novel\data\novelProjectData.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata,
    TreeNode,
    ItemNode,
    ReferenceBookNode,
    NovelCharacter,
    GroupNode,
    OverviewNode
} from '@/novel/editor/types';

// --- Re-usable Mock Data Blocks ---
const mockReferenceData: ReferenceBookNode[] = [
    {
        id: 'ref-book-1',
        type: 'reference_book',
        title: '《银河帝国：基地》',
        icon: 'fa-solid fa-book-bookmark text-indigo-500',
        children: [
            {
                id: 'ref-1-toc',
                type: 'reference_content_item',
                title: '目录',
                icon: 'fa-regular fa-folder-open',
                content: '<h1>《基地》目录总览</h1><p>本书探讨了历史的必然性与个人选择之间的关系，通过心理史学的概念，描绘了人类在宇宙尺度下的命运。这是目录的总览内容。</p>',
                children: [
                    {
                        id: 'ref-1-toc-vol-1',
                        type: 'reference_volume',
                        title: '第一部 心理史学家',
                        icon: 'fa-solid fa-book-open text-purple-500',
                        children: [
                            { id: 'ref-1-toc-v1-ch1', type: 'reference_chapter', title: '第一节', icon: 'fa-regular fa-file-lines', content: '<h1>第一节</h1><p>哈里·谢顿在川陀的最后一次演讲，预言了帝国的崩溃...</p>' }
                        ]
                    }
                ]
            },
            {
                id: 'ref-1-plot',
                type: 'reference_content_item',
                title: '剧情',
                icon: 'fa-solid fa-feather-pointed', // 与“相关内容”下的剧情图标一致
                content: '<h1>《基地》剧情总览</h1><p>讲述了银河帝国逐渐衰亡，心理史学创始人哈里·谢顿预见未来，并建立“基地”以保存人类知识的故事...</p>',
                children: [
                    {
                        id: 'ref-1-plot-vol-1',
                        type: 'reference_volume',
                        title: '第一部 剧情线',
                        icon: 'fa-solid fa-book-open text-purple-500',
                        children: [
                            { id: 'ref-1-plot-v1-ch1', type: 'reference_chapter', title: '谢顿计划的开端', icon: 'fa-regular fa-file-lines', content: '<h1>谢顿计划的开端</h1><p>在帝国的中心川陀，哈里·谢顿创立了心理史学，并因其对帝国未来的悲观预测而遭到审判。他被流放到银河系的边缘——端点星，这正是他计划的第一步。</p>' }
                        ]
                    }
                ]
            },
            {
                id: 'ref-1-analysis',
                type: 'reference_content_item',
                title: '分析',
                icon: 'fa-solid fa-magnifying-glass-chart', // 与“相关内容”下的分析图标一致
                content: '<h1>《基地》分析总览</h1><p>本书核心概念是心理史学，即利用数学方法预测庞大人口的未来活动，探讨了历史的必然性与个人选择之间的关系...</p>',
                children: [
                    {
                        id: 'ref-1-analysis-concepts',
                        type: 'reference_volume',
                        title: '核心概念分析',
                        icon: 'fa-solid fa-book-open text-purple-500',
                        children: [
                            { id: 'ref-1-analysis-c-ch1', type: 'reference_chapter', title: '心理史学', icon: 'fa-regular fa-file-lines', content: '<h1>心理史学</h1><p>心理史学是一门虚构的科学，它结合了历史学、社会学和数学统计，能够以极高的概率预测未来。它的成立有两个前提：研究对象的人口必须足够庞大，且研究对象不能知晓自己正被分析。</p>' }
                        ]
                    }
                ]
            }
        ]
    },
    {
        id: 'ref-book-2',
        type: 'reference_book',
        title: '《黑暗森林》',
        icon: 'fa-solid fa-book-bookmark text-indigo-500',
        children: [
            {
                id: 'ref-2-plot',
                type: 'reference_content_item',
                title: '剧情',
                icon: 'fa-solid fa-feather-pointed',
                content: '<h1>《黑暗森林》剧情</h1><p>面对三体文明的威胁，人类制定了“面壁计划”，试图通过思想的隐蔽性对抗技术上占优的敌人...</p>'
            },
            {
                id: 'ref-2-analysis',
                type: 'reference_content_item',
                title: '分析',
                icon: 'fa-solid fa-magnifying-glass-chart',
                content: '<h1>宇宙社会学</h1><p>本书核心概念是宇宙社会学，通过“猜疑链”和“技术爆炸”推导出宇宙的黑暗森林状态...</p>'
            }
        ]
    }
];

const defaultSettingsData: TreeNode[] = [
    {
        id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            {
                id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                    { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                    { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                    { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                    { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                ]
            } as GroupNode
        ]
    }
];
const defaultPlotCustomData: ItemNode[] = [];
const defaultAnalysisCustomData: ItemNode[] = [];
const defaultOthersCustomData: ItemNode[] = [
    { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
];

// --- Project Data Interface ---
export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
    referenceData: ReferenceBookNode[];
}

// --- Mock Database ---
const novelProjects = new Map<string, NovelProject>();

// --- Initial Characters for "星际漫游者" ---
const starRangerCharacters: NovelCharacter[] = [
    {
        id: 'char-calvin',
        name: '卡尔文·里德',
        avatar: 'https://i.pravatar.cc/150?u=calvin',
        identity: '主角, 探索者四号宇航员',
        gender: '男',
        age: 35,
        faction: '人类联邦',
        summary: '孤独的宇航员，在一次深空探索任务中遭遇意外，被迫独自在未知星系中寻找归途。性格坚毅、冷静，但内心深处对家园有着强烈的眷恋。',
        notes: '设计灵感来源于电影《月球》和《星际穿越》。需要重点刻画其在长期孤独环境下的心理变化。',
        status: 'editing'
    },
    {
        id: 'char-aila',
        name: '艾拉 (AILA)',
        avatar: '',
        identity: 'AI, 飞船智能核心',
        summary: '第五代通用人工智能，负责“探索者四号”的全部系统运作。逻辑至上，声音平稳无波澜。在与卡尔文的长期相处中，其程序底层开始出现不符合预期的、类似人类情感的逻辑萌芽。',
        status: 'completed'
    },
];

// --- Initial Project: "星际漫游者" (novel-1) ---
novelProjects.set('novel-1', {
    metadata: {
        id: 'novel-1',
        title: '星际漫游者',
        description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
        cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=200',
        tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }],
        status: '连载中'
    },
    directoryData: [
        {
            id: 'vol-1', type: 'volume', title: '第一卷：星尘之始', content: '<h1>第一卷：星尘之始</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-1', type: 'chapter', title: '第一章：深空孤影', wordCount: 3102, content: '<h1>第一章：深空孤影</h1><p>这是章节的详细内容，讲述了主角卡尔文在孤独的宇宙中开始他的旅程。周围只有无尽的星空和飞船引擎的低鸣。</p>', status: 'completed' },
                { id: 'ch-2', type: 'chapter', title: '第二章：异常信号', wordCount: 2845, content: '<h1>第二章：异常信号</h1><p>一个神秘的信号打破了长久的平静，它似乎来自一个未知的源头，艾拉无法解析其格式。这给卡尔文带来了希望，也带来了恐惧。</p>', status: 'completed' },
                { id: 'ch-3', type: 'chapter', title: '第三章：AI的低语', wordCount: 3500, content: '<h1>第三章：AI的低语</h1><p>在分析信号的过程中，飞船的AI“艾拉”开始出现一些微小的异常行为。它的逻辑似乎在发生某种不为人知的演变。</p>', status: 'editing' },
                { id: 'ch-4', type: 'chapter', title: '第四章: 跃迁点', wordCount: 2415, content: '<h1>第四章: 跃迁点</h1><p>他们最终发现信号源自一个时空奇点——一个理论上存在的跃迁点。这可能是他们回家唯一的希望，也可能是通向毁灭的陷阱。</p>', status: 'editing' },
            ]
        },
        {
            id: 'vol-2', type: 'volume', title: '第二卷：遗忘的航线', content: '<h1>第二卷：遗忘的航线</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-5', type: 'chapter', title: '第五章：时空涟漪', wordCount: 0, content: '<h1>第五章：时空涟漪</h1>', status: 'planned' },
            ]
        },
    ],
    settingsData: [
        {
            id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
            children: [
                {
                    id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                        { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        ...starRangerCharacters.map(char => ({
                            id: char.id,
                            title: char.name,
                            type: 'character_item',
                            icon: 'fa-regular fa-user',
                            content: `<h1>${char.name}</h1><p>身份：${char.identity}</p><p>简介：${char.summary}</p>`,
                            originalData: char,
                        }))
                    ]
                } as GroupNode,
                {
                    id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                        { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                        { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                        { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                    ]
                } as GroupNode
            ]
        }
    ],
    plotCustomData: [
        { id: 'custom-plot-1', title: '关于跃迁点背后的文明猜想', type: 'plot_item', icon: 'fa-solid fa-lightbulb text-rose-500', content: '<h1>关于跃迁点背后的文明猜想</h1>' }
    ],
    analysisCustomData: [],
    othersCustomData: [
        { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
    ],
    noteData: [
        { id: 'note-1', type: 'note', title: '第四章情感转折点设计', timestamp: '今天 14:32', content: '<h1>第四章情感转折点设计</h1><p>需要重点描写卡尔文在面对跃迁点时，希望与恐惧交织的复杂心理。</p>' },
    ],
    referenceData: mockReferenceData
});


// --- Public API for the mock DB ---

export const getNovelProject = (novelId: string): NovelProject | undefined => {
    return novelProjects.get(novelId);
}

export const createNewNovelProject = (id: string, title: string, description: string, category: string): NovelProject => {
    const newProject: NovelProject = {
        metadata: {
            id,
            title,
            description,
            cover: `https://source.unsplash.com/random/400x500?book&sig=${Date.now()}`,
            tags: [{ text: category, class: 'bg-gray-100 text-gray-600' }],
            status: '连载中',
        },
        directoryData: [
            {
                id: `vol-${Date.now()}`,
                type: 'volume',
                title: '第一卷',
                content: `<h1>第一卷</h1>`,
                chapters: [],
            }
        ],
        settingsData: JSON.parse(JSON.stringify(defaultSettingsData)),
        plotCustomData: JSON.parse(JSON.stringify(defaultPlotCustomData)),
        analysisCustomData: JSON.parse(JSON.stringify(defaultAnalysisCustomData)),
        othersCustomData: JSON.parse(JSON.stringify(defaultOthersCustomData)),
        noteData: [],
        referenceData: JSON.parse(JSON.stringify(mockReferenceData)),
    };

    novelProjects.set(id, newProject);
    return newProject;
};

export const importNovelProject = (id: string, title: string, description: string, category: string, directoryData: Volume[]): NovelProject => {
    const newProject: NovelProject = {
        metadata: {
            id,
            title,
            description,
            cover: `https://source.unsplash.com/random/400x500?book&sig=${Date.now()}`,
            tags: [{ text: category, class: 'bg-gray-100 text-gray-600' }],
            status: '连载中',
        },
        directoryData: directoryData, // Use parsed directory data
        settingsData: JSON.parse(JSON.stringify(defaultSettingsData)),
        plotCustomData: JSON.parse(JSON.stringify(defaultPlotCustomData)),
        analysisCustomData: JSON.parse(JSON.stringify(defaultAnalysisCustomData)),
        othersCustomData: JSON.parse(JSON.stringify(defaultOthersCustomData)),
        noteData: [],
        referenceData: JSON.parse(JSON.stringify(mockReferenceData)),
    };

    novelProjects.set(id, newProject);
    return newProject;
};

// =
// 文件: ..\src\novel\editor\api\aiService.ts
//


interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 模拟一个流式AI任务API。
 * 这个函数接收一个提示词，然后通过回调函数逐字地将这个提示词返回，
 * 以模拟一个接收到什么就返回什么的 "echo" 服务器。
 * @param prompt - 发送给AI的最终提示词。
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(prompt: string, callbacks: StreamCallbacks): void {
    const { onChunk, onComplete, onError } = callbacks;
    const words = prompt.split('');
    let wordIndex = 0;
    const willFail = Math.random() < 0.1; // 10%的几率模拟失败

    const intervalId = setInterval(() => {
        // 模拟流式输出
        if (wordIndex < words.length) {
            onChunk(words[wordIndex]);
            wordIndex++;
            // 模拟中途失败
            if (willFail && wordIndex > words.length / 2) {
                clearInterval(intervalId);
                onError('模拟网络错误，请重试。');
                return;
            }
        } else {
            // 流式结束
            clearInterval(intervalId);
            onComplete();
        }
    }, 20); // 调整流式速度
}

// =
// 文件: ..\src\novel\editor\components\ai\AIDiffPreview.vue
//

// 文件: src/novel/editor/components/ai/AIDiffPreview.vue

<template>
  <div class="diff-preview-container">
    <div class="header">
      <h3 class="title">AI生成预览</h3>
      <div class="actions">
        <button v-if="previewTask && previewTask.status === 'completed'" @click="$emit('apply-changes', previewTask.id)" class="apply-btn">
          <i class="fa-solid fa-check"></i>
          应用修改
        </button>
      </div>
    </div>
    <div class="content-area">
      <div v-if="previewTask">
        <div class="prose-preview">
          <div v-html="previewTask.generatedContent.replace(/\n/g, '<br>')"></div>
          <span v-if="previewTask.status === 'processing'" class="blinking-cursor">▍</span>
        </div>
      </div>
      <div v-else class="empty-state">
        <i class="fa-regular fa-eye text-3xl text-gray-300"></i>
        <p class="mt-2">请从上方任务队列中</p>
        <p>选择一个任务来查看预览。</p>
      </div>

      <!-- Manual Apply Floating Button -->
      <button
          v-if="previewTask && previewTask.status === 'completed'"
          @click="$emit('apply-changes', previewTask.id)"
          class="manual-apply-fab"
          title="应用修改"
      >
        <i class="fa-solid fa-check"></i>
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask } from '@/novel/editor/types';

defineProps({
  previewTask: {
    type: Object as PropType<AITask | null>,
    default: null,
  }
});

defineEmits<{
  (e: 'apply-changes', taskId: string): void;
}>();
</script>

<style scoped>
.diff-preview-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; height: 32px; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.apply-btn { display: flex; align-items: center; gap: 0.375rem; padding: 0.375rem 0.75rem; background-color: #16A34A; color: white; border-radius: 0.5rem; font-size: 0.75rem; font-weight: 500; transition: background-color 0.2s ease; }
.apply-btn:hover { background-color: #15803D; }
.content-area { flex-grow: 1; background-color: #FFFFFF; border-radius: 0.5rem; border: 1px solid #E5E7EB; padding: 1rem; overflow-y: auto; font-size: 0.875rem; line-height: 1.7; color: #374151; position: relative; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
.prose-preview { white-space: pre-wrap; }
.blinking-cursor { font-weight: 500; font-size: 1em; color: #3B82F6; animation: blink 1s step-end infinite; }
@keyframes blink { from, to { color: transparent; } 50% { color: #3B82F6; } }
.content-area { scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.content-area::-webkit-scrollbar { width: 6px; }
.content-area::-webkit-scrollbar-track { background: transparent; }
.content-area::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
.manual-apply-fab {
  position: absolute;
  bottom: 1rem;
  right: 1rem;
  width: 2.75rem;
  height: 2.75rem;
  background-color: #16A34A;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transition: all 0.2s ease;
  z-index: 10;
}
.manual-apply-fab:hover {
  background-color: #15803D;
  transform: scale(1.05);
}
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskItem.vue
//

// 文件: src/novel/editor/components/ai/AITaskItem.vue

<template>
  <div
      :class="['task-item', `status-${task.status}`, { 'clickable': isClickable(task.status) }]"
      @click="handleTaskClick"
  >
    <div class="task-item-header">
      <p class="task-title" :title="task.title">{{ task.title }}</p>
      <div class="flex items-center gap-2">
            <span class="task-status-text">
              <i :class="getStatusIcon(task.status)" class="status-icon"></i>
              {{ getStatusText(task.status) }}
            </span>
        <button
            v-if="task.status === 'completed'"
            @click.stop="emit('apply-changes', task.id)"
            class="apply-now-btn"
        >
          <i class="fa-solid fa-check fa-xs"></i>
          应用
        </button>
      </div>
    </div>

    <div class="task-item-body">
      <div v-if="task.status === 'processing'" class="progress-bar-container">
        <div class="progress-bar"></div>
      </div>
      <p v-if="task.status === 'failed'" class="error-message">
        {{ task.error }} <a href="#" @click.prevent.stop="emit('retry-task', task.id)" class="retry-link">重试</a>
      </p>
      <p v-if="isClickable(task.status)" class="message">
        点击查看详情
      </p>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, AITaskStatus } from '@/novel/editor/types';

const props = defineProps({
  task: {
    type: Object as PropType<AITask>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
  (e: 'retry-task', taskId: string): void;
}>();

const getStatusText = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: '等待中',
    processing: '进行中...',
    completed: '待应用',
    failed: '失败',
    applied: '已应用'
  };
  return map[status];
};

const getStatusIcon = (status: AITaskStatus): string => {
  const map: Record<AITaskStatus, string> = {
    pending: 'fa-solid fa-hourglass-half',
    processing: 'fa-solid fa-spinner fa-spin',
    completed: 'fa-solid fa-check-circle',
    failed: 'fa-solid fa-times-circle',
    applied: 'fa-solid fa-check-double'
  };
  return map[status];
}

const isClickable = (status: AITaskStatus): boolean => {
  return ['completed', 'processing', 'applied', 'failed'].includes(status);
};

const handleTaskClick = () => {
  if (isClickable(props.task.status)) {
    emit('select-task', props.task);
  }
};
</script>

<style scoped>
.task-item { padding: 0.75rem; border-radius: 0.5rem; border: 1px solid #E5E7EB; transition: all 0.2s ease; background-color: #FFFFFF;}
.task-item.clickable { cursor: pointer; }
.task-item.clickable:hover { border-color: #D1D5DB; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.task-item.status-processing.clickable { border: 1px solid #93C5FD; background-color: #EFF6FF; }
.task-item.status-processing.clickable:hover { background-color: #DBEAFE; border-color: #60A5FA; }
.task-item.status-completed.clickable { border: 1px solid #BBF7D0; background-color: #F0FDF4; }
.task-item.status-completed.clickable:hover { background-color: #DCFCE7; border-color: #A7F3D0; }
.task-item.status-failed { border: 1px solid #FECACA; background-color: #FEF2F2; }
.task-item.status-applied.clickable { border: 1px solid #E5E7EB; background-color: #F9FAFB; }
.task-item.status-applied.clickable:hover { background-color: #F3F4F6; border-color: #E5E7EB; }
.task-item-header { display: flex; justify-content: space-between; align-items: center; }
.task-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.task-status-text { font-size: 0.75rem; font-weight: 500; display: flex; align-items: center; gap: 0.25rem; flex-shrink: 0; }
.status-icon { width: 1rem; text-align: center; }
.status-pending .task-status-text { color: #6B7280; }
.status-processing .task-status-text { color: #2563EB; }
.status-completed .task-status-text { color: #16A34A; }
.status-failed .task-status-text { color: #DC2626; }
.status-applied .task-status-text { color: #6B7280; }
.task-item-body { margin-top: 0.5rem; }
.progress-bar-container { width: 100%; background-color: #E5E7EB; border-radius: 9999px; height: 0.25rem; overflow: hidden; }
.progress-bar { background-color: #3B82F6; height: 100%; width: 100%; border-radius: 9999px; animation: indeterminate-progress 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
@keyframes indeterminate-progress { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
.error-message, .message { font-size: 0.75rem; margin-top: 0.25rem; }
.error-message { color: #B91C1C; }
.message { color: #6B7280; }
.retry-link { text-decoration: underline; font-weight: 500; }
.apply-now-btn { display: flex; align-items: center; gap: 0.25rem; background: #22C55E; color: white; padding: 2px 8px; border-radius: 99px; font-size: 0.7rem; font-weight: 500; transition: background-color 0.2s; }
.apply-now-btn:hover { background: #16A34A; }
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskPanel.vue
//

// 文件: src/novel/editor/components/ai/AITaskPanel.vue

<template>
  <div class="ai-task-panel-container">
    <div class="task-queue-section">
      <AITaskQueue @select-task="handleSelectTask" @apply-changes="handleApplyChanges" />
    </div>
    <div class="diff-preview-section">
      <AIDiffPreview :preview-task="selectedTask" @apply-changes="handleApplyChanges" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import AITaskQueue from './AITaskQueue.vue';
import AIDiffPreview from './AIDiffPreview.vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';

const selectedTaskId = ref<string | null>(null);
const aiTaskStore = useAITaskStore();

const selectedTask = computed((): AITask | null => {
  if (!selectedTaskId.value) return null;
  return aiTaskStore.tasks.find(t => t.id === selectedTaskId.value) ?? null;
});

const handleSelectTask = (task: AITask) => {
  selectedTaskId.value = task.id;
};

const handleApplyChanges = (taskId: string) => {
  aiTaskStore.applyChanges(taskId);

  // If the applied task was the one being previewed, clear the preview.
  if (selectedTaskId.value === taskId) {
    selectedTaskId.value = null;
  }
};
</script>

<style scoped>
.ai-task-panel-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #F9FAFB;
}
.task-queue-section {
  height: 50%;
  min-height: 200px;
  flex-shrink: 0;
}
.diff-preview-section {
  flex-grow: 1;
  height: 50%;
}
</style>

// =
// 文件: ..\src\novel\editor\components\ai\AITaskQueue.vue
//

// 文件: src/novel/editor/components/ai/AITaskQueue.vue

<template>
  <div class="task-queue-container">
    <div class="header">
      <h3 class="title">AI任务队列</h3>
      <span v-if="activeTasksCount > 0" class="badge">{{ activeTasksCount }}个活跃</span>
    </div>
    <div v-if="tasks.length > 0" class="task-list">
      <AITaskItem
          v-for="task in tasks"
          :key="task.id"
          :task="task"
          @select-task="handleTaskClick"
          @apply-changes="handleApplyChanges"
          @retry-task="handleRetry"
      />
    </div>
    <div v-else class="empty-state">
      <i class="fa-regular fa-folder-open text-3xl text-gray-300"></i>
      <p class="mt-2">当前没有AI任务</p>
      <p class="text-xs text-gray-400 mt-1">在编辑器中右键开始</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import type { AITask } from '@/novel/editor/types';
import AITaskItem from './AITaskItem.vue';

const emit = defineEmits<{
  (e: 'select-task', task: AITask): void;
  (e: 'apply-changes', taskId: string): void;
}>();

const aiTaskStore = useAITaskStore();
const tasks = computed(() => aiTaskStore.tasks);
const activeTasksCount = computed(() => aiTaskStore.activeTasksCount);

const handleTaskClick = (task: AITask) => {
  emit('select-task', task);
};

const handleRetry = (taskId: string) => {
  aiTaskStore.retryTask(taskId);
};

const handleApplyChanges = (taskId: string) => {
  emit('apply-changes', taskId);
}
</script>

<style scoped>
.task-queue-container { padding: 1rem; display: flex; flex-direction: column; height: 100%; border-bottom: 1px solid #E5E7EB; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.badge { font-size: 0.75rem; font-weight: 500; padding: 0.125rem 0.5rem; border-radius: 9999px; color: #1D4ED8; background-color: #DBEAFE; }
.task-list { flex-grow: 1; overflow-y: auto; space-y: 0.5rem; padding-right: 4px; }
.empty-state { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; color: #9CA3AF; font-size: 0.875rem; }
.task-list { scrollbar-width: thin; scrollbar-color: #D1D5DB #f9fafb; }
.task-list::-webkit-scrollbar { width: 6px; }
.task-list::-webkit-scrollbar-track { background: transparent; }
.task-list::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\EditorContextMenu.vue
//

<template>
  <div
      v-if="visible"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
  >
    <p class="menu-title">AI生成任务</p>
    <a @click="handleExecute('续写')" href="#" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>续写内容</span>
    </a>
    <a @click="handleExecute('润色')" href="#" class="context-menu-item">
      <i class="fa-solid fa-palette w-4 text-center text-[#3B82F6]"></i>
      <span>润色内容</span>
    </a>
    <a @click="handleExecute('创作')" href="#" class="context-menu-item">
      <i class="fa-solid fa-pen-nib w-4 text-center text-violet-500"></i>
      <span>创作正文</span>
    </a>
    <div class="context-menu-divider"></div>
    <p class="menu-title">分析任务</p>
    <a @click="handleExecute('分析')" href="#" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>分析内容</span>
    </a>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ x: 0, y: 0 });

const show = (event: MouseEvent, container: HTMLElement | null) => {
  const containerRect = container?.getBoundingClientRect() || { top: 0, left: 0 };
  visible.value = true;
  position.value.x = event.clientX - containerRect.left;
  position.value.y = event.clientY - containerRect.top;
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type']) => {
  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu { position: absolute; z-index: 1000; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 0.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); width: 16rem; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s; text-decoration: none; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
</style>

// =
// 文件: ..\src\novel\editor\components\content\EditorInstance.vue
//

// 文件: src/novel/editor/components/content/EditorInstance.vue

<template>
  <div class="editor-instance-container" :class="{'is-active-pane': isActive}" @click="setActivePane">
    <!-- Level 1: Tabs + Pane Actions -->
    <div class="top-header-bar">
      <div class="tabs-bar">
        <div
            v-for="tab in openTabs"
            :key="tab.id"
            class="tab-item"
            :class="{ 'active': tab.id === pane.activeTabId }"
            @click.stop="editorStore.openTab(tab.id, pane.id)"
        >
          <i :class="[tab.icon, 'tab-icon']"></i>
          <span class="tab-title">{{ tab.title }}</span>
          <i
              class="fa-solid fa-times close-icon"
              @click.stop="editorStore.closeTab(tab.id, pane.id)"
          ></i>
        </div>
      </div>
      <PaneActions :pane-id="pane.id" :is-active="isActive" />
    </div>

    <!-- Level 2: Breadcrumbs (only for document types) -->
    <BreadcrumbsBar v-if="activeTab && activeTab.item.type !== 'system'" :pane-id="pane.id" :is-active="isActive" />

    <!-- Main Content Area -->
    <PaneContentDispatcher
        ref="dispatcherRef"
        v-model="activeTabContent"
        :active-tab="activeTab"
        :is-active-pane="isActive"
        @show-context-menu="showEditorContextMenu"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, ref, type PropType } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { EditorPane } from '@/novel/editor/stores/modules/paneStore';
import PaneActions from '../layout/PaneActions.vue';
import BreadcrumbsBar from '../layout/BreadcrumbsBar.vue';
import PaneContentDispatcher from './PaneContentDispatcher.vue';

const props = defineProps({
  pane: {
    type: Object as PropType<EditorPane>,
    required: true,
  },
  isActive: {
    type: Boolean,
    required: true,
  }
});

const editorStore = useEditorStore();
const dispatcherRef = ref<InstanceType<typeof PaneContentDispatcher> | null>(null);

const openTabs = computed(() => editorStore.getTabsForPane(props.pane.id));
const activeTab = computed(() => editorStore.getActiveTabForPane(props.pane.id));

const activeTabContent = computed({
  get: () => {
    const item = activeTab.value?.item;
    if (item && 'content' in item && typeof item.content === 'string') {
      return item.content;
    }
    return '';
  },
  set: (newContent: string) => {
    const item = activeTab.value?.item;
    if (activeTab.value && item && 'content' in item && props.isActive) {
      editorStore.updateItemContentById(activeTab.value.id, newContent);
    }
  }
});

const setActivePane = () => {
  editorStore.setActivePane(props.pane.id)
};

const showEditorContextMenu = (event: MouseEvent) => {
  dispatcherRef.value?.showContextMenu(event, dispatcherRef.value.$el);
};
</script>

<style scoped>
.editor-instance-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
  min-width: 0;
  transition: box-shadow 0.2s;
  border-left: 1px solid #E5E7EB;
}
.editor-instance-container:first-child {
  border-left: none;
}
.top-header-bar {
  display: flex;
  align-items: center;
  flex-shrink: 0;
  background-color: #F3F4F6;
  border-bottom: 1px solid #E5E7EB;
}
.tabs-bar {
  display: flex;
  flex-grow: 1;
  padding-top: 0.5rem;
  padding-left: 0.5rem;
  overflow-x: auto;
  min-width: 0;
}
.tabs-bar::-webkit-scrollbar {
  display: none;
}
.tabs-bar {
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.tab-item {
  display: flex;
  align-items: center;
  padding: 0.6rem 1rem;
  font-size: 0.875rem;
  color: #6B7280;
  cursor: pointer;
  position: relative;
  border: 1px solid transparent;
  border-bottom: none;
  border-top-left-radius: 0.5rem;
  border-top-right-radius: 0.5rem;
  background-color: #E5E7EB;
  white-space: nowrap;
  transition: background-color 0.2s, color 0.2s;
}
.tab-item:not(:first-child) {
  margin-left: -1px;
}
.is-active-pane .tab-item:hover {
  background-color: #FFFFFF;
}
.tab-item.active {
  background-color: #FFFFFF;
  color: #1F2937;
  border-color: #E5E7EB;
  z-index: 2;
  margin-bottom: -1px;
  padding-bottom: calc(0.6rem + 1px);
}
.editor-instance-container:not(.is-active-pane) .tab-item {
  background-color: #F3F4F6;
  color: #9CA3AF;
}
.editor-instance-container:not(.is-active-pane) .tab-item.active {
  background-color: #FFFFFF;
  color: #6B7280;
  border-color: #E5E7EB;
}
.tab-icon {
  margin-right: 0.5rem;
}
.tab-item.active .tab-icon {
  color: #3B82F6;
}
.editor-instance-container:not(.is-active-pane) .tab-item.active .tab-icon {
  color: inherit;
}
.tab-title {
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
}
.close-icon {
  margin-left: 0.75rem;
  padding: 0.25rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
  opacity: 0.5;
  transition: all 0.2s;
}
.tab-item:hover .close-icon {
  opacity: 1;
}
.close-icon:hover {
  background-color: #E5E7EB;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\FloatingToolbar.vue
//

// 文件: src/novel/editor/components/content/FloatingToolbar.vue

<template>
  <div
      v-if="visible"
      class="floating-toolbar"
      :style="{ top: `${position.top}px`, left: `${position.left}px` }"
      @mousedown.prevent
  >
    <button @click="handleExecute('分析', $event)" title="分析内容" class="toolbar-btn"><i class="fa-solid fa-magnifying-glass-chart"></i></button>
    <button @click="handleExecute('续写', $event)" title="AI续写" class="toolbar-btn"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
    <button @click="handleExecute('润色', $event)" title="润色文本" class="toolbar-btn"><i class="fa-solid fa-spell-check"></i></button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import type { AITask } from '@/novel/editor/types';

const editorStore = useEditorStore();
const { executeAITask } = useAITaskExecutor();

const visible = ref(false);
const position = ref({ top: 0, left: 0 });

const show = (rect: DOMRect, wrapperRect: DOMRect) => {
  visible.value = true;
  position.value = {
    top: rect.top - wrapperRect.top - 48,
    left: rect.left - wrapperRect.left + rect.width / 2 - 60,
  };
};

const hide = () => {
  visible.value = false;
};

const handleExecute = (taskType: AITask['type'], event: MouseEvent) => {
  event.preventDefault();

  const activeItem = editorStore.activeTab?.item;
  if (!activeItem || !('content' in activeItem)) {
    console.error("无法执行AI任务：没有激活的文档或文档无内容。");
    hide();
    return;
  }

  executeAITask(taskType, { id: activeItem.id, title: activeItem.title });
  hide();
}

defineExpose({ show, hide });
</script>

<style scoped>
.floating-toolbar {
  position: absolute;
  z-index: 10;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 0.375rem;
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  display: flex;
  gap: 0.25rem;
}
.toolbar-btn {
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #4B5563;
  border-radius: 0.375rem;
  transition: background-color 0.15s;
}
.toolbar-btn:hover {
  background-color: #f3f4f6;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\MainPane.vue
//

<template>
  <div class="main-pane-container" ref="containerRef">
    <template v-for="(pane, index) in panes" :key="pane.id">
      <EditorInstance :pane="pane" :is-active="pane.id === editorStore.activePaneId" class="pane-instance" />
      <div
          v-if="index < panes.length - 1"
          class="pane-resizer"
          @mousedown.prevent="startResize($event, index)"
      ></div>
    </template>
  </div>
</template>
<script setup lang="ts">
import { computed, ref, watch, nextTick } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import EditorInstance from './EditorInstance.vue';

const editorStore = useEditorStore();
const panes = computed(() => editorStore.panes);
const containerRef = ref<HTMLElement | null>(null);

watch(() => panes.value.length, (newLength, oldLength) => {
  if (newLength < oldLength) {
    nextTick(() => {
      if (!containerRef.value) return;
      const remainingPanes = containerRef.value.querySelectorAll('.pane-instance') as NodeListOf<HTMLElement>;
      remainingPanes.forEach(el => {
        el.style.flex = '';
      });
    });
  }
});

const startResize = (event: MouseEvent, paneIndex: number) => {
  const container = containerRef.value;
  if (!container) return;

  const paneElements = Array.from(container.querySelectorAll('.pane-instance')) as HTMLElement[];
  const leftPane = paneElements[paneIndex];
  const rightPane = paneElements[paneIndex + 1];

  if (!leftPane || !rightPane) return;

  const startX = event.clientX;
  const leftStartWidth = leftPane.offsetWidth;
  const rightStartWidth = rightPane.offsetWidth;
  const totalWidth = leftStartWidth + rightStartWidth;

  const handleResize = (e: MouseEvent) => {
    const dx = e.clientX - startX;
    let newLeftWidth = leftStartWidth + dx;

    const minWidth = 200;
    if (newLeftWidth < minWidth) {
      newLeftWidth = minWidth;
    }
    if (totalWidth - newLeftWidth < minWidth) {
      newLeftWidth = totalWidth - minWidth;
    }

    const newLeftBasis = (newLeftWidth / totalWidth) * 100;
    const newRightBasis = 100 - newLeftBasis;

    leftPane.style.flex = `0 0 ${newLeftBasis}%`;
    rightPane.style.flex = `0 0 ${newRightBasis}%`;
  };

  const stopResize = () => {
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = 'none';
  };

  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};
</script>
<style scoped>
.main-pane-container {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  background-color: #F3F4F6;
}
.pane-instance {
  flex: 1 1 0;
  min-width: 200px;
}
.pane-resizer {
  width: 5px;
  background-color: transparent;
  cursor: col-resize;
  flex-shrink: 0;
  z-index: 5;
  position: relative;
  transition: background-color 0.2s ease;
}
.pane-resizer:hover {
  background-color: #3B82F6;
}
.pane-resizer::before {
  content: '';
  position: absolute;
  left: 2px;
  top: 0;
  width: 1px;
  height: 100%;
  background-color: #E5E7EB;
}
.pane-resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\PaneContentDispatcher.vue
//

// 文件: src/novel/editor/components/content/PaneContentDispatcher.vue

<template>
  <div class="pane-content-dispatcher">
    <template v-if="!activeTab">
      <div class="welcome-screen">
        <i class="fa-solid fa-feather-pointed text-6xl text-gray-300"></i>
        <h1 class="text-2xl font-medium text-gray-600 mt-6">星尘编辑器</h1>
        <p class="text-gray-500 mt-2">从左侧面板选择一个文件开始创作。</p>
      </div>
    </template>
    <template v-else-if="activeTab.item.type === 'system'">
      <component :is="systemViewComponent" :key="activeTab.id" :active-tab="activeTab" class="system-view-wrapper" />
    </template>
    <template v-else>
      <div class="content-area-wrapper" ref="wrapperRef" @scroll="handleScroll">
        <FloatingToolbar ref="floatingToolbarRef" />
        <EditorContextMenu ref="editorContextMenuRef" />
        <div class="editor-content-wrapper" ref="editorContentRef">
          <TiptapEditor
              :key="activeTab.id"
              :model-value="modelValue"
              :is-editable="!isCurrentTabReadOnly"
              @update:modelValue="emit('update:modelValue', $event)"
              @show-context-menu="emit('show-context-menu', $event)"
          />
        </div>
      </div>
    </template>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onBeforeUnmount, shallowRef, type PropType } from 'vue';
import type { TabInfo, SystemViewInfo } from '@/novel/editor/types';
import TiptapEditor from './TiptapEditor.vue';
import FloatingToolbar from './FloatingToolbar.vue';
import EditorContextMenu from './EditorContextMenu.vue';
import SearchView from '@novel/editor/views/SearchView.vue';
import AIChatView from '@novel/editor/components/ai/chat/AIChatView.vue';
import AITaskPanel from '@/novel/editor/components/ai/AITaskPanel.vue';
import EditorSettings from '@/novel/editor/components/system/settings/EditorSettings.vue';
import ContextSettings from '@/novel/editor/components/system/settings/ContextSettings.vue';
import TaskSettings from '@/novel/editor/components/system/settings/TaskSettings.vue';
import AIConfigSettings from '@/novel/editor/components/system/settings/AIConfigSettings.vue';
import NovelSettings from '@/novel/editor/components/system/settings/NovelSettings.vue';
import ThemeSettings from '@/novel/editor/components/system/settings/ThemeSettings.vue';
import HistoryPanel from '@/novel/editor/components/system/HistoryPanel.vue';

const props = defineProps({
  activeTab: {
    type: Object as PropType<TabInfo | null>,
    default: null
  },
  modelValue: {
    type: String,
    default: ''
  },
  isActivePane: {
    type: Boolean,
    required: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>();

const systemViewMap = shallowRef({
  SearchView,
  AIChatView,
  AITaskPanel,
  EditorSettings,
  ContextSettings,
  TaskSettings,
  AIConfigSettings,
  NovelSettings,
  ThemeSettings,
  HistoryPanel,
});

const systemViewComponent = computed(() => {
  const item = props.activeTab?.item;
  if (item?.type === 'system') {
    const componentName = item.component;
    return systemViewMap.value[componentName] || null;
  }
  return null;
});

const isCurrentTabReadOnly = computed(() => {
  const item = props.activeTab?.item;
  if (item && 'isReadOnly' in item) {
    return item.isReadOnly === true;
  }
  return false;
});

const wrapperRef = ref<HTMLElement | null>(null);
const editorContentRef = ref<HTMLElement | null>(null);
const floatingToolbarRef = ref<InstanceType<typeof FloatingToolbar> | null>(null);
const editorContextMenuRef = ref<InstanceType<typeof EditorContextMenu> | null>(null);

const showContextMenu = (event: MouseEvent, container: HTMLElement | null) => {
  editorContextMenuRef.value?.show(event, container);
};

const handleSelectionChange = () => {
  if (!props.isActivePane || !floatingToolbarRef.value || !wrapperRef.value || !editorContentRef.value) return;

  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed || !editorContentRef.value.contains(selection.getRangeAt(0).commonAncestorContainer)) {
    floatingToolbarRef.value.hide();
    return;
  }
  floatingToolbarRef.value.show(selection.getRangeAt(0).getBoundingClientRect(), wrapperRef.value.getBoundingClientRect());
  editorContextMenuRef.value?.hide();
};

const handleScroll = () => {
  floatingToolbarRef.value?.hide();
  editorContextMenuRef.value?.hide();
};

const handleClickOutside = (event: MouseEvent) => {
  if (!wrapperRef.value?.contains(event.target as Node)) return;
  const target = event.target as HTMLElement;
  if (!target.closest('.context-menu') && !target.closest('.floating-toolbar')) {
    editorContextMenuRef.value?.hide();
    floatingToolbarRef.value?.hide();
  }
};

onMounted(() => {
  document.addEventListener('selectionchange', handleSelectionChange);
  document.addEventListener('click', handleClickOutside, true);
});

onBeforeUnmount(() => {
  document.removeEventListener('selectionchange', handleSelectionChange);
  document.removeEventListener('click', handleClickOutside, true);
});

defineExpose({
  showContextMenu
});
</script>

<style scoped>
.pane-content-dispatcher {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: #FFFFFF;
}
.system-view-wrapper {
  flex-grow: 1;
  overflow: hidden;
}
.content-area-wrapper {
  flex-grow: 1;
  overflow-y: auto;
  position: relative;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.content-area-wrapper::-webkit-scrollbar {
  display: none;
}
.editor-content-wrapper {
  max-width: 42rem;
  margin: 2rem auto;
}
.welcome-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  user-select: none;
}
</style>

// =
// 文件: ..\src\novel\editor\components\content\TiptapEditor.vue
//

<template>
  <div v-if="editor" class="editor-wrapper">
    <editor-content
        :editor="editor"
        class="prose prose-lg max-w-none"
        @contextmenu.prevent="emit('show-context-menu', $event)"
    />
  </div>
</template>
<script setup lang="ts">
import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import { watch, onBeforeUnmount } from 'vue'

const props = defineProps({
  modelValue: {
    type: String,
    required: true,
  },
  isEditable: {
    type: Boolean,
    default: true,
  }
});

const emit = defineEmits<{
  (e: 'update:modelValue', value: string): void;
  (e: 'show-context-menu', event: MouseEvent): void;
}>()

const editor = useEditor({
  content: props.modelValue,
  editable: props.isEditable,
  extensions: [
    StarterKit.configure({
      heading: { levels: [1, 2, 3] },
    }),
  ],
  onUpdate: () => {
    if (editor.value?.isEditable) {
      emit('update:modelValue', editor.value?.getHTML() || '')
    }
  },
  editorProps: {
    attributes: {
      class: 'prose-mirror-focus',
    },
  },
})

watch(() => props.modelValue, (newValue) => {
  const isSame = editor.value?.getHTML() === newValue
  if (isSame) {
    return
  }
  editor.value?.commands.setContent(newValue, false)
})

watch(() => props.isEditable, (value) => {
  editor.value?.setEditable(value);
});

onBeforeUnmount(() => {
  editor.value?.destroy()
})
</script>
<style scoped>
:deep(.ProseMirror) {
  min-height: calc(100vh - 12rem);
  outline: none;
  padding: 1rem;
  font-family: 'Georgia', 'Noto Serif SC', serif;
  line-height: 1.75;
  color: #374151;
}

:deep(.ProseMirror[contenteditable="false"]) {
  cursor: default;
}

:deep(.prose-mirror-focus:focus-visible) {}

:deep(.prose h1) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.875rem;
  font-weight: 600;
  margin-bottom: 2.5rem;
  text-align: center;
  border-bottom: none;
}
:deep(.prose p) {
  margin-top: 1em;
  margin-bottom: 1em;
}
:deep(.prose h2) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.5rem; /* 24px */
  font-weight: 600;
  padding-bottom: 0;
  border-bottom: none;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
}
:deep(.prose h3) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.25rem;
  font-weight: 600;
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
}
:deep(.prose hr) {
  border-top: 1px solid #e5e7eb;
  margin: 3rem 0;
}
:deep(.prose p.overview-placeholder) {
  text-align: center;
  color: #9ca3af;
  font-style: italic;
  margin-top: 2rem;
  border: 1px dashed #e5e7eb;
  padding: 2rem;
  border-radius: 0.5rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
  line-height: 1.6;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryContextMenu.vue
//

<template>
  <div
      v-if="visible && menuComponent"
      class="context-menu"
      :style="{ top: `${position.y}px`, left: `${position.x}px` }"
      @click.stop
  >
    <component
        :is="menuComponent"
        :node="node!"
        @action="handleAction"
        @ai-action="handleAIAction"
        @settings-action="handleSettingsAction"
        @custom-related-action="handleCustomRelatedAction"
        @custom-others-action="handleOthersAction"
        @note-action="handleNoteAction"
        @prompt-action="handlePromptAction"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, computed, defineAsyncComponent, shallowRef } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { useAITaskExecutor } from '@/novel/editor/composables/useAITaskExecutor';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import type { AITask } from '@/novel/editor/types';

// --- 组件映射 ---
const menuComponentMap = shallowRef({
  'volume': defineAsyncComponent(() => import('./context-menus/VolumeMenu.vue')),
  'chapter': defineAsyncComponent(() => import('./context-menus/ChapterMenu.vue')),
  'group': defineAsyncComponent(() => import('./context-menus/GroupMenu.vue')),
  'item': defineAsyncComponent(() => import('./context-menus/ItemMenu.vue')),
  'root': defineAsyncComponent(() => import('./context-menus/RootMenu.vue')),
  'others': defineAsyncComponent(() => import('./context-menus/OthersMenu.vue')),
  'others_item': defineAsyncComponent(() => import('./context-menus/OthersItemMenu.vue')),
  'custom_related': defineAsyncComponent(() => import('./context-menus/CustomRelatedMenu.vue')),
  'note': defineAsyncComponent(() => import('./context-menus/NoteMenu.vue')),
  'setting_root': defineAsyncComponent(() => import('./context-menus/SettingsRootMenu.vue')),
  'prompt_group': defineAsyncComponent(() => import('./context-menus/PromptGroupMenu.vue')),
  'prompt_item': defineAsyncComponent(() => import('./context-menus/PromptItemMenu.vue')),
});

// --- State and Props ---
const visible = ref(false);
const position = ref({ x: 0, y: 0 });
const node = ref<TreeNode | null>(null);

// --- Stores and Composables ---
const { executeAITask } = useAITaskExecutor();
const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const relatedContentStore = useRelatedContentStore();
const notesStore = useNotesStore();

// --- Computed ---
const menuComponent = computed(() => {
  if (!node.value) return null;
  const { type, id } = node.value;

  // 检查是否为提示词相关节点
  if (type === 'prompt_group' || type === 'prompt_item') {
    return menuComponentMap.value[type];
  }

  // Handle custom item types first by ID prefix
  if (id.startsWith('custom-others-')) {
    return menuComponentMap.value['others_item'];
  }
  if (id.startsWith('custom-') && !id.startsWith('custom-others-')) {
    return menuComponentMap.value['custom_related'];
  }

  // Handle root nodes by ID
  if (type === 'root') {
    if (id === 'setting') {
      return menuComponentMap.value['setting_root'];
    }
    if (id === 'plot' || id === 'analysis') {
      return menuComponentMap.value['root'];
    }
    if (id === 'others') {
      return menuComponentMap.value['others'];
    }
    return null;
  }

  // Handle specific node types by their 'type' property
  if (type in menuComponentMap.value) {
    return menuComponentMap.value[type];
  }

  // Fallback for settings items (e.g., character_item)
  if (type.endsWith('_item')) {
    return menuComponentMap.value['item'];
  }

  return null;
});

// --- Core Logic ---
const show = (event: MouseEvent, targetNode: TreeNode) => {
  if (targetNode.isOverview) return;
  if(targetNode.isReadOnly && targetNode.type !== 'prompt_group') return;
  // Disable context menu for all reference-related nodes
  if (targetNode.type.startsWith('reference_')) return;

  node.value = targetNode;
  visible.value = true;
  position.value.x = event.clientX;
  position.value.y = event.clientY;
};

const hide = () => {
  visible.value = false;
  node.value = null;
};

// --- Event Handlers ---
const handleAIAction = (taskType: AITask['type'], sourceNode: TreeNode, isBatch = false) => {
  hide();
  if (isBatch && sourceNode.type === 'volume' && 'originalData' in sourceNode && sourceNode.originalData.type === 'volume') {
    const aiTaskStore = (async () => (await import('@novel/editor/stores/ai/aiTaskStore.ts')).useAITaskStore())();
    aiTaskStore.then(store => store.startBatchTaskForVolume(taskType, sourceNode.originalData));
  } else {
    executeAITask(taskType, { id: sourceNode.id, title: sourceNode.title });
  }
};

const handleAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newChapter': directoryStore.addChapterToVolume(nodeId); break;
    case 'newVolume': directoryStore.addNewVolume(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': directoryStore.deleteNode(nodeId); break;
  }
};

const handleSettingsAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'newGroup': relatedContentStore.addRelatedNode(nodeId, 'group'); break;
    case 'newItem': relatedContentStore.addRelatedNode(nodeId, 'item'); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteRelatedNode(nodeId); break;
  }
};

const handleCustomRelatedAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  const target = payload?.target as 'plot' | 'analysis' | undefined;

  switch(action) {
    case 'newItem':
      if (target) {
        relatedContentStore.addCustomRelatedNode(target);
      }
      break;
    case 'rename':
      editorStore.setEditingNodeId(nodeId);
      break;
    case 'delete':
      relatedContentStore.deleteCustomRelatedNode(nodeId);
      break;
  }
};

const handleOthersAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch(action) {
    case 'newItem': relatedContentStore.addCustomOthersNode(); break;
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': relatedContentStore.deleteCustomOthersNode(nodeId); break;
  }
};

const handleNoteAction = (action: string, payload: any) => {
  hide();
  const nodeId = payload?.nodeId;
  switch (action) {
    case 'rename': editorStore.setEditingNodeId(nodeId); break;
    case 'delete': notesStore.deleteNote(nodeId); break;
  }
};

const handlePromptAction = (action: string, payload: any) => {
  hide();
  switch(action) {
    case 'newPrompt':
      relatedContentStore.addPrompt(payload.groupId);
      break;
    case 'renamePrompt':
      editorStore.setEditingNodeId(payload.promptId);
      break;
    case 'deletePrompt':
      if (confirm('确定要删除这个提示词模板吗？')) {
        relatedContentStore.deletePrompt(payload.promptId);
      }
      break;
  }
}

// --- Lifecycle ---
onMounted(() => {
  window.addEventListener('click', hide);
});

onBeforeUnmount(() => {
  window.removeEventListener('click', hide);
});

defineExpose({ show, hide });
</script>

<style scoped>
.context-menu {
  position: fixed;
  z-index: 1000;
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 0.5rem;
  box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  min-width: 14rem;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\DirectoryTab.vue
//

// src/novel/editor/components/sidebar/DirectoryTab.vue

<template>
  <div class="directory-tab-container">
    <div class="header">
      <h3 class="title">章节大纲</h3>
      <div class="actions">
        <button @click="handleAddNewVolume" class="action-btn" title="添加新卷">
          <i class="fa-solid fa-folder-plus fa-xs"></i>
        </button>
        <button class="action-btn" title="折叠/展开全部">
          <i class="fa-solid fa-folder-tree fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="scrollable-content">
      <TreeView
          v-if="directoryTree.length > 0"
          :nodes="directoryTree"
          :active-node-id="activeNodeId"
          :expanded-node-ids="uiStore.uiState.expandedNodeIds"
          :editing-node-id="editorStore.editingNodeId"
          @select-node="handleSelectNode"
          @toggle-expansion="handleToggleExpansion"
          @context-menu="handleContextMenu"
          @commit-rename="handleCommitRename"
          @cancel-rename="handleCancelRename"
      />
      <div v-else class="p-4 text-sm text-gray-500">
        正在加载目录...
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import type { TreeNode, VolumeNode, ChapterNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const directoryStore = useDirectoryStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const directoryTree = computed((): VolumeNode[] => {
  return directoryStore.directoryData.map(volume => ({
    id: volume.id,
    title: volume.title,
    icon: getIconByNodeType(volume.type),
    type: 'volume',
    content: volume.content,
    originalData: volume,
    children: volume.chapters.map(chapter => ({
      id: chapter.id,
      title: chapter.title,
      icon: getIconByNodeType(chapter.type),
      type: 'chapter',
      status: chapter.status,
      content: chapter.content,
      originalData: chapter,
    })),
  }));
});

const handleSelectNode = (node: TreeNode) => {
  if (node.type === 'chapter' || node.type === 'volume') {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    uiStore.toggleNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id:string) => {
  uiStore.toggleNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleAddNewVolume = () => {
  directoryStore.addNewVolume();
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  directoryStore.renameNode(payload.nodeId, payload.newTitle);
  handleCancelRename();
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};
</script>
<style scoped>
.directory-tab-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
.header {
  padding: 1rem;
  padding-bottom: 0.25rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }

.scrollable-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 0.75rem 1rem 1rem;
}
.scrollable-content::-webkit-scrollbar { width: 6px; }
.scrollable-content::-webkit-scrollbar-track { background: transparent; }
.scrollable-content::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
.scrollable-content::-webkit-scrollbar-thumb:hover { background: #9CA3AF; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\NotesTab.vue
//

// 文件: src\novel\editor\components\sidebar\NotesTab.vue

<template>
  <div class="notes-tab-container">
    <div class="header">
      <h3 class="title">章节笔记</h3>
      <button @click="handleAddNewNote" class="action-btn" title="新建笔记"><i class="fa-solid fa-plus fa-xs"></i></button>
    </div>
    <div class="notes-list">
      <div
          v-for="(note, index) in notesStore.notes"
          :key="note.id"
          @click="editorStore.openTab(note.id)"
          @contextmenu.prevent="handleContextMenu(note, $event)"
          class="note-item"
          :class="{ 'active': activeTabId === note.id }"
      >
        <div class="note-header">
          <template v-if="editingNodeId === note.id">
            <input
                :ref="el => { if (el) renameInputs[index] = el as HTMLInputElement }"
                type="text"
                :value="note.title"
                class="rename-input"
                @blur="handleCommitRename($event, note.id)"
                @keydown.enter.prevent="handleCommitRename($event, note.id)"
                @keydown.esc.prevent="handleCancelRename"
                @click.stop
            />
          </template>
          <template v-else>
            <p class="note-title">{{ note.title }}</p>
          </template>
          <span class="note-timestamp">{{ note.timestamp }}</span>
        </div>
        <p class="note-content">{{ note.content.replace(/<[^>]+>/g, '') }}</p>
      </div>
    </div>
    <div class="quick-add-footer">
      <input
          type="text"
          placeholder="快速添加新笔记..."
          class="quick-add-input"
          v-model="quickAddValue"
          @keydown.enter="handleQuickAdd"
      >
      <button @click="handleQuickAdd" class="quick-add-btn"><i class="fa-solid fa-paper-plane fa-sm"></i></button>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, watch, nextTick, onBeforeUpdate } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { NoteItem } from '@/novel/editor/types';
import type { TreeNode } from './TreeView.vue';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const notesStore = useNotesStore();
const uiStore = useUIStore();
const quickAddValue = ref('');
const renameInputs = ref<HTMLInputElement[]>([]);

const editingNodeId = computed(() => uiStore.editingNodeId);
const activeTabId = computed(() => editorStore.activeTabId);


watch(editingNodeId, (newId) => {
  if (newId && newId.startsWith('note-')) {
    nextTick(() => {
      const noteIndex = notesStore.notes.findIndex(n => n.id === newId);
      if (noteIndex !== -1 && renameInputs.value[noteIndex]) {
        renameInputs.value[noteIndex].focus();
        renameInputs.value[noteIndex].select();
      }
    });
  }
});

onBeforeUpdate(() => {
  renameInputs.value = [];
});

const handleAddNewNote = () => {
  notesStore.addNote('新建笔记');
};

const handleQuickAdd = () => {
  const value = quickAddValue.value.trim();
  if (!value) return;
  notesStore.addNote(value);
  quickAddValue.value = '';
};

const handleContextMenu = (note: NoteItem, event: MouseEvent) => {
  const nodePayload: TreeNode = {
    id: note.id,
    title: note.title,
    type: note.type,
    icon: getIconByNodeType(note.type),
    originalData: note
  };
  emit('show-context-menu', { node: nodePayload, event });
}

const handleCommitRename = (event: Event, nodeId: string) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value.trim();
  if(newTitle) {
    notesStore.renameNote(nodeId, newTitle);
  }
  handleCancelRename();
};

const handleCancelRename = () => {
  uiStore.setEditingNodeId(null);
};
</script>
<style scoped>
.notes-tab-container {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
  padding: 0 0.5rem;
  flex-shrink: 0;
}
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }

.notes-list {
  flex-grow: 1;
  overflow-y: auto;
  space-y: 0.5rem;
  padding-right: 4px;
}
.notes-list::-webkit-scrollbar { width: 6px; }
.notes-list::-webkit-scrollbar-track { background: transparent; }
.notes-list::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }

.note-item { padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; background-color: #FFFFFF; }
.note-item:hover { background-color: #F9FAFB; border-color: #F3F4F6; }
.note-item.active { background-color: #FEFCE8; border-color: #FDE047; }
.note-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5rem; }
.note-title { font-size: 0.875rem; font-weight: 500; color: #1F2937; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.note-timestamp { font-size: 0.75rem; color: #CA8A04; flex-shrink: 0; }
.note-content { font-size: 0.75rem; color: #4B5563; margin-top: 0.375rem; line-height: 1.6; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; }
.rename-input {
  flex-grow: 1;
  background-color: white;
  border: 1px solid #3B82F6;
  border-radius: 4px;
  padding: 1px 4px;
  font-size: 0.875rem;
  color: #1F2937;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}
.quick-add-footer {
  margin-top: auto;
  padding-top: 0.75rem;
  border-top: 1px solid #E5E7EB;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.quick-add-input {
  flex-grow: 1;
  background: white;
  border: 1px solid #D1D5DB;
  border-radius: 0.5rem;
  padding: 0.4rem 0.75rem;
  font-size: 0.875rem;
  outline: none;
  transition: all 0.2s;
}
.quick-add-input:focus {
  border-color: #3B82F6;
  box-shadow: 0 0 0 1px #3B82F6;
}
.quick-add-btn {
  width: 2.2rem;
  height: 2.2rem;
  flex-shrink: 0;
  background-color: #F3F4F6;
  border-radius: 0.5rem;
  color: #4B5563;
  transition: background-color 0.2s;
}
.quick-add-btn:hover {
  background-color: #E5E7EB;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\ReferencesTab.vue
//

// src/novel/editor/components/sidebar/ReferencesTab.vue
<template>
  <div class="references-tab-container">
    <div class="header">
      <h3 class="title">参考书目</h3>
      <div class="actions">
        <!-- Add button removed to enforce read-only -->
      </div>
    </div>
    <div class="scrollable-content">
      <TreeView
          v-if="referenceTree.length > 0"
          :nodes="referenceTree"
          :active-node-id="activeNodeId"
          :expanded-node-ids="uiStore.uiState.expandedReferenceNodeIds"
          :editing-node-id="editorStore.editingNodeId"
          @select-node="handleSelectNode"
          @toggle-expansion="handleToggleExpansion"
          @context-menu="handleContextMenu"
      />
      <div v-else class="p-4 text-sm text-gray-500">
        没有参考书。
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const referenceStore = useReferenceStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const referenceTree = computed((): TreeNode[] => {
  return referenceStore.referenceData;
});

const handleSelectNode = (node: TreeNode) => {
  // If the node has children, it's a container node, so we toggle its expansion.
  if (node.children && node.children.length > 0) {
    uiStore.toggleReferenceNodeExpansion(node.id);
  }
  // If the node has content, it's a leaf node that can be opened.
  else if (node.hasOwnProperty('content')) {
    editorStore.openTab(node.id);
  }
};

const handleToggleExpansion = (id:string) => {
  uiStore.toggleReferenceNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};
</script>
<style scoped>
.references-tab-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
}
.header {
  padding: 1rem;
  padding-bottom: 0.25rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }

.scrollable-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 0.75rem 1rem 1rem;
}
.scrollable-content::-webkit-scrollbar { width: 6px; }
.scrollable-content::-webkit-scrollbar-track { background: transparent; }
.scrollable-content::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 3px; }
.scrollable-content::-webkit-scrollbar-thumb:hover { background: #9CA3AF; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\RelatedTab.vue
//

// src/novel/editor/components/sidebar/RelatedTab.vue
<template>
  <div class="related-tab-container">
    <div class="header">
      <h3 class="title">相关内容</h3>
      <div class="actions">
        <button @click="handleAddNewCustomPlot" class="action-btn" title="新建自定义剧情">
          <i class="fa-solid fa-feather-pointed fa-xs"></i>
        </button>
        <button @click="handleAddNewCustomAnalysis" class="action-btn" title="新建自定义分析">
          <i class="fa-solid fa-magnifying-glass-chart fa-xs"></i>
        </button>
        <button @click="handleAddNewCustomOthers" class="action-btn" title="新建其他条目">
          <i class="fa-solid fa-puzzle-piece fa-xs"></i>
        </button>
      </div>
    </div>
    <div class="search-bar">
      <i class="fa-solid fa-magnifying-glass search-icon"></i>
      <input type="text" placeholder="搜索相关内容..." class="search-input">
    </div>
    <TreeView
        v-if="relatedTree.length > 0"
        :nodes="relatedTree"
        :active-node-id="activeNodeId"
        :expanded-node-ids="uiStore.uiState.expandedRelatedNodeIds"
        :editing-node-id="editorStore.editingNodeId"
        @select-node="handleSelectNode"
        @toggle-expansion="handleToggleExpansion"
        @context-menu="handleContextMenu"
        @commit-rename="handleCommitRename"
        @cancel-rename="handleCancelRename"
    />
    <div v-else class="p-4 text-sm text-gray-500">
      没有相关内容。
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed } from 'vue';
import TreeView from './TreeView.vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode } from '@/novel/editor/types';

const emit = defineEmits<{
  (e: 'show-context-menu', payload: { node: TreeNode; event: MouseEvent }): void;
}>();

const editorStore = useEditorStore();
const relatedContentStore = useRelatedContentStore();
const uiStore = useUIStore();

const activeNodeId = computed(() => editorStore.activeTabId);

const relatedTree = computed((): TreeNode[] => {
  return relatedContentStore.relatedData;
});

const handleSelectNode = (node: TreeNode) => {
  if ('content' in node && node.content !== undefined) {
    editorStore.openTab(node.id);
  } else if(node.children && node.children.length > 0) {
    uiStore.toggleRelatedNodeExpansion(node.id);
  }
};

const handleToggleExpansion = (id: string) => {
  uiStore.toggleRelatedNodeExpansion(id);
};

const handleContextMenu = (payload: { node: TreeNode; event: MouseEvent }) => {
  emit('show-context-menu', payload);
};

const handleCommitRename = (payload: { nodeId: string; newTitle: string }) => {
  if (payload.newTitle.trim()) {
    if (payload.nodeId.startsWith('custom-others-')) {
      relatedContentStore.renameCustomOthersNode(payload.nodeId, payload.newTitle);
    } else if (payload.nodeId.startsWith('custom-')) {
      relatedContentStore.renameCustomRelatedNode(payload.nodeId, payload.newTitle);
    } else if (payload.nodeId.startsWith('prompt-')) {
      relatedContentStore.renamePrompt(payload.nodeId, payload.newTitle);
    }
    else {
      relatedContentStore.renameRelatedNode(payload.nodeId, payload.newTitle);
    }
  }
  editorStore.setEditingNodeId(null);
};

const handleCancelRename = () => {
  editorStore.setEditingNodeId(null);
};

const handleAddNewCustomPlot = () => {
  relatedContentStore.addCustomRelatedNode('plot');
};

const handleAddNewCustomAnalysis = () => {
  relatedContentStore.addCustomRelatedNode('analysis');
};

const handleAddNewCustomOthers = () => {
  relatedContentStore.addCustomOthersNode();
};

</script>
<style scoped>
.related-tab-container { padding: 1rem; overflow-y: auto; height: 100%; display: flex; flex-direction: column; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding: 0 0.5rem; flex-shrink: 0; }
.title { font-size: 0.875rem; font-weight: 500; color: #4B5563; }
.actions { display: flex; align-items: center; gap: 0.25rem; }
.action-btn { width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; color: #6B7280; border-radius: 0.375rem; transition: background-color 0.15s; }
.action-btn:hover { background-color: #E5E7EB; }
.search-bar { position: relative; margin-bottom: 1rem; flex-shrink: 0; }
.search-icon { position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; font-size: 0.875rem; }
.search-input { width: 100%; background: white; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.4rem 0.75rem 0.4rem 2.25rem; font-size: 0.875rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\SidebarPanel.vue
//

<template>
  <div class="sidebar-panel-container">
    <div class="header">
      <h3 class="title">{{ activeTitle }}</h3>
    </div>

    <div class="content-container">
      <keep-alive>
        <component :is="activeTabComponent" @show-context-menu="showDirectoryContextMenu" />
      </keep-alive>
    </div>

    <DirectoryContextMenu ref="directoryContextMenuRef" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, defineAsyncComponent } from 'vue';
import DirectoryContextMenu from './DirectoryContextMenu.vue';
import type { TreeNode } from './TreeView.vue';

type TabId = 'directory' | 'related' | 'notes' | 'references';

const props = defineProps<{
  activeTabId: TabId | null;
}>();

const directoryContextMenuRef = ref<InstanceType<typeof DirectoryContextMenu> | null>(null);

const titles: Record<TabId, string> = {
  directory: '目录大纲',
  related: '相关内容',
  notes: '章节笔记',
  references: '参考书目',
};

const tabComponents: Record<TabId, any> = {
  directory: defineAsyncComponent(() => import('./DirectoryTab.vue')),
  related: defineAsyncComponent(() => import('./RelatedTab.vue')),
  notes: defineAsyncComponent(() => import('./NotesTab.vue')),
  references: defineAsyncComponent(() => import('./ReferencesTab.vue')),
};

const activeTabComponent = computed(() => {
  if (!props.activeTabId) return null;
  return tabComponents[props.activeTabId] || null;
});

const activeTitle = computed(() => {
  if (!props.activeTabId) return '';
  return titles[props.activeTabId] || '';
});

const showDirectoryContextMenu = (payload: { node: TreeNode, event: MouseEvent }) => {
  directoryContextMenuRef.value?.show(payload.event, payload.node);
};
</script>

<style scoped>
.sidebar-panel-container {
  width: 100%;
  background-color: #FAFBFC;
  border-right: 1px solid #F3F4F6;
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

.header {
  padding: 0 1rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #F3F4F6;
  flex-shrink: 0;
}

.title {
  font-size: 1rem;
  font-weight: 500;
  color: #1F2937;
}

.content-container {
  flex-grow: 1;
  position: relative;
  overflow: hidden;
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\TreeView.vue
//

<template>
  <ul class="tree-view-list">
    <li v-for="node in nodes" :key="node.id" class="tree-view-item">
      <!-- 节点自身的渲染 -->
      <div
          class="node-content"
          :class="{ 'active': node.id === activeNodeId }"
          @click="handleNodeClick(node)"
          @contextmenu.prevent="emit('context-menu', { node, event: $event })"
      >
        <!-- 展开/折叠图标 -->
        <div
            class="expand-icon"
            :class="{ 'invisible': !node.children || node.children.length === 0 }"
            @click.stop="emit('toggle-expansion', node.id)"
        >
          <i class="fa-solid fa-chevron-right transition-transform" :class="{ 'rotate-90': expandedNodeIds.has(node.id) }"></i>
        </div>

        <!-- 节点类型图标 -->
        <div class="node-type-icon">
          <i :class="node.icon"></i>
        </div>

        <!-- 节点标题或重命名输入框 -->
        <template v-if="editingNodeId === node.id">
          <input
              ref="renameInput"
              type="text"
              :value="node.title"
              class="rename-input"
              @blur="handleRenameCommit($event, node)"
              @keydown.enter.prevent="handleRenameCommit($event, node)"
              @keydown.esc.prevent="handleRenameCancel"
              @click.stop
          />
        </template>
        <template v-else>
          <span class="node-title truncate">{{ node.title }}</span>
        </template>

        <!-- 节点状态徽章 (可选) -->
        <span v-if="'status' in node && node.status" class="node-status-badge">
          {{ node.status === 'editing' ? '编辑中' : '' }}
        </span>
      </div>

      <!-- 递归渲染子节点 -->
      <div v-if="node.children && node.children.length > 0" class="children-container">
        <TreeView
            v-show="expandedNodeIds.has(node.id)"
            :nodes="node.children"
            :active-node-id="activeNodeId"
            :expanded-node-ids="expandedNodeIds"
            :editing-node-id="editingNodeId"
            @select-node="emit('select-node', $event)"
            @toggle-expansion="emit('toggle-expansion', $event)"
            @context-menu="emit('context-menu', $event)"
            @commit-rename="emit('commit-rename', $event)"
            @cancel-rename="emit('cancel-rename')"
        />
      </div>
    </li>
  </ul>
</template>

<script setup lang="ts">
import { ref, watch, nextTick } from 'vue';
import type { PropType } from 'vue';
import type { TreeNode } from '@novel/editor/types';

// --- Props & Emits ---
const props = defineProps({
  nodes: {
    type: Array as PropType<TreeNode[]>,
    required: true,
  },
  activeNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
  expandedNodeIds: {
    type: Set as PropType<Set<string>>,
    required: true,
  },
  editingNodeId: {
    type: String as PropType<string | null>,
    default: null,
  },
});

const emit = defineEmits<{
  (e: 'select-node', node: TreeNode): void;
  (e: 'toggle-expansion', id: string): void;
  (e: 'context-menu', payload: { node: TreeNode, event: MouseEvent }): void;
  (e: 'commit-rename', payload: { nodeId: string, newTitle: string, nodeType: string }): void;
  (e: 'cancel-rename'): void;
}>();

const renameInput = ref<HTMLInputElement[] | null>(null);

watch(() => props.editingNodeId, (newId, oldId) => {
  if (newId && newId !== oldId) {
    nextTick(() => {
      if (renameInput.value && renameInput.value.length > 0) {
        renameInput.value[0].focus();
        renameInput.value[0].select();
      }
    });
  }
});

const handleNodeClick = (node: TreeNode) => {
  if (props.editingNodeId === node.id) return;
  // Always emit the select-node event and let the parent decide the action.
  emit('select-node', node);
};

const handleRenameCommit = (event: Event, node: TreeNode) => {
  const input = event.target as HTMLInputElement;
  const newTitle = input.value;
  emit('commit-rename', { nodeId: node.id, newTitle, nodeType: node.type });
};

const handleRenameCancel = () => {
  emit('cancel-rename');
};

</script>

<style scoped>
.tree-view-list {
  list-style: none;
  padding: 0;
  margin: 0;
  width: 100%;
}
.node-content {
  display: flex;
  align-items: center;
  gap: 0.5rem; /* 8px */
  padding: 0.5rem 0.75rem; /* 8px 12px */
  border-radius: 0.5rem; /* 8px */
  cursor: pointer;
  transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
  font-size: 0.875rem; /* 14px */
  color: #374151; /* text-gray-700 */
  user-select: none;
}
.node-content:hover {
  background-color: #F3F4F6; /* hover:bg-gray-100 */
}
.node-content.active {
  background-color: #E0E7FF; /* bg-indigo-100 */
  color: #3730A3; /* text-indigo-800 */
  font-weight: 500;
}
.expand-icon {
  width: 1rem; /* 16px */
  height: 1rem; /* 16px */
  display: flex;
  align-items: center;
  justify-content: center;
  color: #9CA3AF; /* text-gray-400 */
  flex-shrink: 0;
}
.expand-icon.invisible {
  visibility: hidden;
}
.node-type-icon {
  width: 1.25rem; /* 20px */
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6B7280; /* text-gray-500 */
}
.node-content.active .node-type-icon {
  color: #4338CA; /* active:text-indigo-700 */
}
.node-title {
  flex-grow: 1;
}
.node-status-badge {
  margin-left: auto;
  font-size: 0.75rem; /* 12px */
  padding: 0.125rem 0.5rem; /* 2px 8px */
  background-color: #DCFCE7; /* bg-green-100 */
  color: #166534; /* text-green-800 */
  border-radius: 9999px;
  font-weight: 500;
}
.children-container {
  padding-left: 1.5rem;
  margin-left: 0.5rem;
  border-left: 1px solid #E5E7EB;
}
.rename-input {
  flex-grow: 1;
  background-color: white;
  border: 1px solid #3B82F6;
  border-radius: 4px;
  padding: 1px 4px;
  font-size: 0.875rem;
  color: #1F2937;
  outline: none;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ChapterMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/ChapterMenu.vue
<template>
  <div>
    <p class="menu-title">文件操作</p>
    <div @click="emit('action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div class="context-menu-divider"></div>
    <p class="menu-title">AI 助手</p>
    <div @click="emit('ai-action', '分析', node)" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>分析内容</span>
    </div>
    <div @click="emit('ai-action', '剧情生成', node)" class="context-menu-item">
      <i class="fa-solid fa-feather w-4 text-center text-[#EC4899]"></i>
      <span>生成剧情</span>
    </div>
    <div @click="emit('ai-action', '创作', node)" class="context-menu-item">
      <i class="fa-solid fa-pen-nib w-4 text-center text-violet-500"></i>
      <span>创作正文</span>
    </div>
    <div @click="emit('ai-action', '续写', node)" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>续写内容</span>
    </div>
    <div @click="emit('ai-action', '润色', node)" class="context-menu-item">
      <i class="fa-solid fa-palette w-4 text-center text-[#3B82F6]"></i>
      <span>润色内容</span>
    </div>
    <div class="context-menu-divider"></div>
    <div @click="emit('action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除章节</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch?: boolean): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\CustomRelatedMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/CustomRelatedMenu.vue
<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('custom-related-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('custom-related-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\GroupMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/GroupMenu.vue
<template>
  <div>
    <p class="menu-title">设定管理</p>
    <div @click="emit('settings-action', 'newItem', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建条目</span>
    </div>
    <div @click="emit('settings-action', 'newGroup', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建分组</span>
    </div>
    <div @click="emit('settings-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('settings-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除分组</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\ItemMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/ItemMenu.vue
<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('settings-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('settings-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\NoteMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/NoteMenu.vue
<template>
  <div>
    <p class="menu-title">笔记管理</p>
    <div @click="emit('note-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('note-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除笔记</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'note-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersItemMenu.vue
//

<template>
  <div>
    <p class="menu-title">条目管理</p>
    <div @click="emit('custom-others-action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('custom-others-action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\OthersMenu.vue
//

<template>
  <div>
    <p class="menu-title">管理</p>
    <div @click="emit('custom-others-action', 'newItem')" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建其他条目</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-others-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptGroupMenu.vue
//

<template>
  <div>
    <p class="menu-title">模板管理</p>
    <div @click="emit('prompt-action', 'newPrompt', { groupId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建提示词</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'prompt-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\PromptItemMenu.vue
//

<template>
  <div>
    <p class="menu-title">模板管理</p>
    <div @click="emit('prompt-action', 'renamePrompt', { promptId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div @click="emit('prompt-action', 'deletePrompt', { promptId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除提示词</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'prompt-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\RootMenu.vue
//


<template>
  <div>
    <p class="menu-title">管理</p>
    <div @click="emit('custom-related-action', 'newItem', { target: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建自定义{{ node.id === 'plot' ? '剧情' : '分析' }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'custom-related-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\SettingsRootMenu.vue
//

// src/novel/editor/components/sidebar/context-menus/SettingsRootMenu.vue
<template>
  <div>
    <p class="menu-title">设定管理</p>
    <div @click="emit('settings-action', 'newGroup', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建分组</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'settings-action', actionName: string, payload?: any): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\sidebar\context-menus\VolumeMenu.vue
//

// 文件: src/novel/editor/components/sidebar/context-menus/VolumeMenu.vue
<template>
  <div>
    <p class="menu-title">目录管理</p>
    <div @click="emit('action', 'newChapter', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-plus w-4 text-center"></i>
      <span>新建章节</span>
    </div>
    <div @click="emit('action', 'newVolume')" class="context-menu-item">
      <i class="fa-solid fa-folder-plus w-4 text-center"></i>
      <span>新建卷</span>
    </div>
    <div @click="emit('action', 'rename', { nodeId: node.id })" class="context-menu-item">
      <i class="fa-solid fa-pencil w-4 text-center"></i>
      <span>重命名</span>
    </div>
    <div class="context-menu-divider"></div>
    <p class="menu-title">AI 助手</p>
    <div @click="emit('ai-action', '分析', node)" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>分析卷内容</span>
    </div>
    <div @click="emit('ai-action', '剧情生成', node)" class="context-menu-item">
      <i class="fa-solid fa-feather w-4 text-center text-[#EC4899]"></i>
      <span>生成卷剧情</span>
    </div>
    <div class="context-menu-divider"></div>
    <p class="menu-title">AI 批量任务</p>
    <div @click="emit('ai-action', '分析', node, true)" class="context-menu-item">
      <i class="fa-solid fa-magnifying-glass-chart w-4 text-center text-[#F59E0B]"></i>
      <span>批量分析章节</span>
    </div>
    <div @click="emit('ai-action', '剧情生成', node, true)" class="context-menu-item">
      <i class="fa-solid fa-feather w-4 text-center text-[#EC4899]"></i>
      <span>批量生成剧情</span>
    </div>
    <div @click="emit('ai-action', '创作', node, true)" class="context-menu-item">
      <i class="fa-solid fa-pen-to-square w-4 text-center text-[#8B5CF6]"></i>
      <span>批量创作正文</span>
    </div>
    <div @click="emit('ai-action', '续写', node, true)" class="context-menu-item">
      <i class="fa-solid fa-wand-magic-sparkles w-4 text-center text-[#4B5563]"></i>
      <span>批量续写章节</span>
    </div>
    <div class="context-menu-divider"></div>
    <div @click="emit('action', 'delete', { nodeId: node.id })" class="context-menu-item danger">
      <i class="fa-solid fa-trash-can w-4 text-center"></i>
      <span>删除卷</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PropType } from 'vue';
import type { AITask, TreeNode } from '@/novel/editor/types';

defineProps({
  node: {
    type: Object as PropType<TreeNode>,
    required: true,
  },
});

const emit = defineEmits<{
  (e: 'action', actionName: string, payload?: any): void;
  (e: 'ai-action', taskType: AITask['type'], sourceNode: TreeNode, isBatch: boolean): void;
}>();
</script>

<style scoped>
.context-menu-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; color: #374151; cursor: pointer; user-select: none; transition: background-color 0.15s, color 0.15s; }
.context-menu-item:hover { background-color: #f3f4f6; }
.context-menu-item.danger:hover { background-color: #fee2e2; color: #b91c1c; }
.context-menu-divider { height: 1px; background-color: #f3f4f6; margin: 0.5rem 0; }
.menu-title { padding: 0.25rem 0.75rem; font-size: 0.75rem; color: #9CA3AF; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\AIConfigSettings.vue
//

<template>
  <div class="aiconfig-view-container">
    <!-- Left Sidebar for Task Navigation -->
    <div class="aiconfig-sidebar">
      <h3 class="sidebar-title">AI 任务类型</h3>
      <nav class="sidebar-nav">
        <a
            v-for="task in availableTasks"
            :key="task.id"
            href="#"
            @click.prevent="activeTaskId = task.id"
            :class="['nav-item', { 'active': activeTaskId === task.id }]"
        >
          <i :class="[task.icon, 'nav-item-icon']"></i>
          <span>{{ task.name }}</span>
        </a>
      </nav>
    </div>

    <!-- Right Content Area -->
    <div class="aiconfig-content custom-scrollbar">
      <div v-if="activeTaskConfig" class="p-6 space-y-6">
        <!-- Header -->
        <div class="flex justify-between items-center">
          <div>
            <h3 class="text-lg font-medium text-[#374151]">AI任务配置 - {{ activeTaskInfo?.name }}</h3>
            <p class="text-sm text-[#6B7280] mt-1">配置AI助手如何处理您的内容</p>
          </div>
        </div>

        <!-- AI Model Selection -->
        <div>
          <label class="flex items-center justify-between mb-3">
            <span class="text-sm font-medium text-[#374151]">AI模型选择</span>
            <a href="#" class="text-xs text-[#3B82F6] cursor-pointer flex items-center gap-1.5 hover:underline">
              <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>
              了解模型差异
            </a>
          </label>
          <select class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
            <option selected>GPT-4o (推荐 - 均衡性能)</option>
            <option>Claude 3 Opus (文学创作专长)</option>
            <option>混合模型 (多模型协作)</option>
            <option>自定义微调模型</option>
          </select>
        </div>

        <!-- Prompt Template Selection -->
        <div>
          <label for="prompt-template" class="text-sm font-medium text-[#374151] block mb-3">任务提示词模板</label>
          <select
              id="prompt-template"
              :value="activeTaskConfig.selectedPromptId"
              @change="handlePromptChange"
              class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition"
          >
            <option v-for="prompt in availablePrompts" :key="prompt.id" :value="prompt.id">
              {{ prompt.title }}
            </option>
          </select>
        </div>

        <!-- Advanced Settings -->
        <div>
          <label class="text-sm font-medium text-[#374151] block mb-3">高级设置</label>
          <div class="space-y-4 p-4 bg-[#F9FAFB] rounded-lg border border-gray-100">
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">创作温度</span>
              <div class="flex items-center gap-3">
                <input type="range" min="0" max="100" value="70" class="w-32 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer range-slider">
                <span class="text-sm font-mono text-[#374151] w-8 text-right">0.7</span>
              </div>
            </div>
            <div class="flex items-center justify-between">
              <span class="text-sm text-[#6B7280]">保留原文风格</span>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-[#4B5563] peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all"></div>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@novel/editor/stores/promptTemplateStore.ts';
import type { AITask } from '@/novel/editor/types';

type TaskType = AITask['type'];

const aiConfigStore = useAIConfigStore();
const promptTemplateStore = usePromptTemplateStore();

const taskInfoMap: Record<TaskType, { name: string; icon: string }> = {
  '润色': { name: '润色', icon: 'fa-solid fa-palette' },
  '续写': { name: '续写', icon: 'fa-solid fa-wand-magic-sparkles' },
  '分析': { name: '分析', icon: 'fa-solid fa-magnifying-glass-chart' },
  '剧情生成': { name: '剧情生成', icon: 'fa-solid fa-feather' },
  '创作': { name: '创作', icon: 'fa-solid fa-pen-nib' },
};

const availableTasks = computed(() => {
  return (Object.keys(aiConfigStore.taskConfigs) as TaskType[]).map(id => ({
    id,
    name: taskInfoMap[id].name,
    icon: taskInfoMap[id].icon
  }));
});

const activeTaskId = ref<TaskType>('润色');

const activeTaskInfo = computed(() => availableTasks.value.find(t => t.id === activeTaskId.value));
const activeTaskConfig = computed(() => aiConfigStore.taskConfigs[activeTaskId.value]);
const availablePrompts = computed(() => promptTemplateStore.getPromptsForTask(activeTaskId.value));

const handlePromptChange = (event: Event) => {
  const selectedId = (event.target as HTMLSelectElement).value;
  aiConfigStore.setSelectedPromptId(activeTaskId.value, selectedId);
};
</script>

<style scoped>
.aiconfig-view-container { display: flex; height: 100%; width: 100%; }
.aiconfig-sidebar { width: 220px; background-color: #F9FAFB; border-right: 1px solid #E5E7EB; padding: 1.5rem 1rem; flex-shrink: 0; }
.sidebar-title { padding: 0 0.75rem; font-size: 0.75rem; font-weight: 600; color: #6B7280; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.75rem; }
.sidebar-nav { display: flex; flex-direction: column; gap: 0.25rem; }
.nav-item { display: flex; align-items: center; padding: 0.6rem 0.75rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; color: #374151; text-decoration: none; transition: background-color 0.2s, color 0.2s; }
.nav-item:hover { background-color: #F3F4F6; }
.nav-item.active { background-color: #EBF1FD; color: #2563EB; }
.nav-item-icon { width: 1.25rem; text-align: center; margin-right: 0.75rem; }

.aiconfig-content { flex-grow: 1; overflow-y: auto; background-color: #FFFFFF; }

.custom-scrollbar::-webkit-scrollbar { display: block; width: 6px; }
.custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

.range-slider { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; }
.range-slider::-webkit-slider-runnable-track { background: #E5E7EB; height: 0.25rem; border-radius: 0.25rem; }
.range-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; background-color: #ffffff; height: 1rem; width: 1rem; border-radius: 50%; border: 1px solid #D1D5DB; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
.range-slider:focus::-webkit-slider-thumb { outline: 2px solid transparent; outline-offset: 2px; box-shadow: 0 0 0 3px #3B82F640; }
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\ContextSettings.vue
//

// 文件: src/novel/editor/components/system/settings/ContextSettings.vue

<template>
  <div class="setting-page-container">
    <div class="setting-page-wrapper">
      <div class="page-header">
        <h2 class="page-title">上下文管理</h2>
        <p class="page-description">配置AI任务执行时如何处理上下文信息，以获得更精准的生成结果。</p>
      </div>

      <div class="setting-group">
        <div class="setting-item">
          <label for="needs-preview" class="setting-label">执行前预览</label>
          <div class="setting-control">
            <div class="flex items-center">
              <input id="needs-preview" type="checkbox" v-model="settingsStore.needsPreview" class="setting-checkbox" />
              <label for="needs-preview" class="ml-3 font-medium text-gray-700">启用AI任务执行前预览</label>
            </div>
            <p class="setting-description">
              启用后，在编辑器或目录中触发AI任务（如续写、润色）时，不会立即执行，
              而是会弹出一个上下文预览窗口供您确认和修改。
            </p>
          </div>
        </div>
      </div>

      <div class="setting-group mt-4">
        <div class="setting-item">
          <label for="fixed-context" class="setting-label">固定上下文</label>
          <div class="setting-control space-y-4">
            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">选择预设内容
                <span class="text-xs text-[#9CA3AF] ml-2">可选择角色设定或世界观设定</span>
              </label>
              <select
                  @change="addSelectedItem"
                  class="w-full px-4 py-2 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] custom-select focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
              >
                <option value="">请选择预设内容...</option>
                <option v-for="preset in settingsStore.fixedContextPresets" :key="preset.id" :value="preset.id">
                  {{ preset.group }} - {{ preset.title }}
                </option>
              </select>
            </div>

            <div v-if="settingsStore.selectedContextItems.length > 0">
              <label class="block text-sm font-medium text-[#374151] mb-1.5">已选择的设定内容</label>
              <div class="content-list">
                <div
                    v-for="item in settingsStore.selectedContextItems"
                    :key="item.id"
                    class="content-list-item"
                >
                  <div class="flex-grow min-w-0">
                    <div class="font-medium text-sm text-[#374151] truncate" :title="`${item.group} - ${item.title}`">{{ item.group }} - {{ item.title }}</div>
                    <div class="text-xs text-[#9CA3AF] mt-1 truncate">{{ item.description }}</div>
                  </div>
                  <button @click.stop="settingsStore.removeFixedContextItem(item.id)" class="text-[#9CA3AF] hover:text-[#EF4444] transition-colors ml-4 flex-shrink-0">
                    <i class="fa-solid fa-xmark"></i>
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label class="block text-sm font-medium text-[#374151] mb-1.5">选择其他内容
                <span class="text-xs text-[#9CA3AF] ml-2">可选择写作风格等其他参考</span>
              </label>
              <select
                  @change="addSelectedOthersItem"
                  class="w-full px-4 py-2 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] custom-select focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
              >
                <option value="">请选择其他内容...</option>
                <option v-for="preset in settingsStore.othersContextPresets" :key="preset.id" :value="preset.id">
                  {{ preset.title }}
                </option>
              </select>
            </div>

            <div v-if="settingsStore.selectedOthersItems.length > 0">
              <label class="block text-sm font-medium text-[#374151] mb-1.5">已选择的其他内容</label>
              <div class="content-list">
                <div
                    v-for="item in settingsStore.selectedOthersItems"
                    :key="item.id"
                    class="content-list-item"
                >
                  <div class="flex-grow min-w-0">
                    <div class="font-medium text-sm text-[#374151] truncate" :title="item.title">{{ item.title }}</div>
                    <div class="text-xs text-[#9CA3AF] mt-1 truncate">{{ item.description }}</div>
                  </div>
                  <button @click.stop="settingsStore.removeOthersContextItem(item.id)" class="text-[#9CA3AF] hover:text-[#EF4444] transition-colors ml-4 flex-shrink-0">
                    <i class="fa-solid fa-xmark"></i>
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label for="custom-content" class="block text-sm font-medium text-[#374151] mb-1.5">自定义固定内容</label>
              <textarea
                  id="custom-content"
                  :value="settingsStore.customContextContent"
                  @input="settingsStore.setCustomContextContent(($event.target as HTMLTextAreaElement).value)"
                  class="w-full px-4 py-3 border border-[#E5E7EB] rounded-lg text-sm text-[#374151] resize-none focus:outline-none focus:border-[#3B82F6] focus:ring-1 focus:ring-[#3B82F6]"
                  rows="4"
                  placeholder="输入固定的背景设定、人物关系、重要事件等AI必须参考的信息..."
              ></textarea>
              <p class="setting-description mt-2">这里的内容将始终被添加到AI任务的上下文中。</p>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <label for="dynamic-context" class="setting-label">动态上下文</label>
          <div class="setting-control space-y-6">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">前置卷数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="5" :value="settingsStore.dynamicContextSettings.prevVolumes" @input="settingsStore.setDynamicContextSetting('prevVolumes', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.prevVolumes }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前内容之前的N个卷。</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">后续卷数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="5" :value="settingsStore.dynamicContextSettings.nextVolumes" @input="settingsStore.setDynamicContextSetting('nextVolumes', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.nextVolumes }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前内容之后N个卷。</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">前置章节数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="10" :value="settingsStore.dynamicContextSettings.prevChapters" @input="settingsStore.setDynamicContextSetting('prevChapters', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.prevChapters }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前章节之前的N个章节内容。</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-[#374151] mb-1.5">后续章节数</label>
                <div class="flex items-center gap-3">
                  <input type="range" min="0" max="10" :value="settingsStore.dynamicContextSettings.nextChapters" @input="settingsStore.setDynamicContextSetting('nextChapters', parseInt(($event.target as HTMLInputElement).value, 10))" class="range-custom flex-1"/>
                  <span class="text-sm font-medium w-8 text-center text-[#374151]">{{ settingsStore.dynamicContextSettings.nextChapters }}</span>
                </div>
                <p class="setting-description mt-1">自动包含当前章节之后N个章节的全部内容。</p>
              </div>
            </div>
            <div class="space-y-3">
              <div class="flex items-center">
                <input id="include-volume-plot" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeVolumePlot" @change="settingsStore.setDynamicContextSetting('includeVolumePlot', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-volume-plot" class="ml-3 font-medium text-gray-700">包含卷相关剧情</label>
              </div>
              <div class="flex items-center">
                <input id="include-volume-analysis" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeVolumeAnalysis" @change="settingsStore.setDynamicContextSetting('includeVolumeAnalysis', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-volume-analysis" class="ml-3 font-medium text-gray-700">包含卷相关分析</label>
              </div>
              <div class="flex items-center">
                <input id="include-plot" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeRelatedPlot" @change="settingsStore.setDynamicContextSetting('includeRelatedPlot', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-plot" class="ml-3 font-medium text-gray-700">包含章节相关剧情</label>
              </div>
              <div class="flex items-center">
                <input id="include-analysis" type="checkbox" :checked="settingsStore.dynamicContextSettings.includeRelatedAnalysis" @change="settingsStore.setDynamicContextSetting('includeRelatedAnalysis', ($event.target as HTMLInputElement).checked)" class="setting-checkbox" />
                <label for="include-analysis" class="ml-3 font-medium text-gray-700">包含章节相关分析</label>
              </div>
            </div>

            <p class="setting-description">动态上下文会智能加载目标内容前后的信息，以及与该内容关联的派生内容（剧情、分析），以提供更连贯的创作基础。实际加载的内容可在任务预览时查看。</p>
          </div>
        </div>

        <div class="setting-item">
          <label for="rag-context" class="setting-label">RAG 智能检索</label>
          <div class="setting-control">
            <div class="flex items-center">
              <input id="rag-context" type="checkbox" v-model="settingsStore.isRagEnabled" class="setting-checkbox" />
              <label for="rag-context" class="ml-3 font-medium text-gray-700">启用RAG智能检索</label>
            </div>
            <p class="setting-description">
              启用后，AI任务将根据当前上下文自动从您的整个知识库（包括所有章节、设定、笔记）中检索最相关的信息片段并注入到上下文中。
            </p>
          </div>
        </div>

      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';

const settingsStore = useContextSettingsStore();

const addSelectedItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.fixedContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addFixedContextItem(preset);
  }
  select.value = ""; // Reset select
};

const addSelectedOthersItem = (event: Event) => {
  const select = event.target as HTMLSelectElement;
  const selectedId = select.value;
  if (!selectedId) return;

  const preset = settingsStore.othersContextPresets.find(p => p.id === selectedId);
  if (preset) {
    settingsStore.addOthersContextItem(preset);
  }
  select.value = ""; // Reset select
};
</script>

<style scoped>
.setting-page-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.setting-page-wrapper {
  padding: 1rem 2rem 4rem;
  max-width: 56rem;
  margin: 0 auto;
  overflow-y: auto;
  height: 100%;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.setting-page-wrapper::-webkit-scrollbar {
  display: none;
}

.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
  padding: 1.5rem 0;
  border-bottom: 1px solid #E5E7EB;
}
@media (min-width: 768px) {
  .setting-item {
    grid-template-columns: 12rem 1fr;
  }
}
.setting-item:last-child { border-bottom: none; }
.setting-label {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}
@media (min-width: 768px) {
  .setting-label {
    padding-top: 0.5rem;
  }
}
.setting-control { display: flex; flex-direction: column; gap: 0.5rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }

.range-custom {
  -webkit-appearance: none; appearance: none;
  width: 100%; height: 16px; background: transparent;
  outline: none; padding: 0; margin: 0;
}
.range-custom::-webkit-slider-runnable-track {
  width: 100%; height: 6px; cursor: pointer;
  background: #E5E7EB; border-radius: 9999px;
}
.range-custom::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  height: 20px; width: 20px; background: #3B82F6;
  border-radius: 50%; border: 3px solid white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  cursor: grab; margin-top: -7px;
}

.custom-select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='14' height='8' viewBox='0 0 14 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M1 1L7 7L13 1' stroke='%236B7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 12px center;
  background-size: 14px;
  padding-right: 40px;
}

.content-list {
  border: 1px solid #E5E7EB;
  border-radius: 8px;
  max-height: 200px;
  overflow-y: auto;
}

.content-list-item {
  padding: 12px 16px;
  border-bottom: 1px solid #F3F4F6;
  transition: all 0.2s ease;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.content-list-item:hover {
  background: #F9FAFB;
}
.content-list-item:last-child {
  border-bottom: none;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\NovelSettings.vue
//

<template>
  <div class="flex-1 p-8 overflow-auto custom-scrollbar bg-[#FCFCFC]">
    <div v-if="novelMetadata" class="grid grid-cols-3 gap-8 max-w-6xl mx-auto">
      <div class="col-span-2 bg-white p-8 space-y-6 rounded-xl border border-gray-100">
        <h3 class="text-base font-medium text-[#374151]">基本信息</h3>

        <div class="space-y-2">
          <label class="text-sm font-medium text-[#374151] block">小说封面</label>
          <div class="flex items-center gap-4">
            <img :src="novelMetadata.cover" class="w-24 h-32 object-cover rounded-lg shadow-sm" alt="Cover">
            <div>
              <button class="px-4 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">更换图片</button>
              <p class="text-xs text-[#9CA3AF] mt-2">JPG, PNG, GIF, 不超过 5MB</p>
            </div>
          </div>
        </div>

        <div class="space-y-2">
          <label for="novel-title" class="text-sm font-medium text-[#374151] block">小说标题</label>
          <input type="text" id="novel-title" v-model="novelMetadata.title" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
        </div>

        <div class="space-y-2">
          <label for="novel-desc" class="text-sm font-medium text-[#374151] block">小说简介</label>
          <textarea id="novel-desc" rows="4" v-model="novelMetadata.description" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition resize-none"></textarea>
        </div>

        <div class="grid grid-cols-2 gap-6">
          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">类型标签</label>
            <div class="flex flex-wrap gap-2 items-center">
              <div v-for="(tag, index) in novelMetadata.tags" :key="index" class="flex items-center gap-1.5 px-2.5 py-1 text-sm rounded-full" :class="tag.class">
                <span>{{ tag.text }}</span>
                <button @click="editorStore.removeTag(index)" class="hover:opacity-75">
                  <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
              </div>
              <button @click="editorStore.addTag" class="px-3 py-1 bg-gray-100 hover:bg-gray-200 text-[#6B7280] rounded-full text-sm font-medium transition-colors">+ 添加</button>
            </div>
          </div>

          <div class="space-y-2">
            <label class="text-sm font-medium text-[#374151] block">创作状态</label>
            <select v-model="novelMetadata.status" class="w-full text-sm px-3 py-2 bg-white border border-gray-200 rounded-lg focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition">
              <option>连载中</option>
              <option>已完结</option>
              <option>暂停更新</option>
            </select>
          </div>
        </div>

        <div class="pt-6 border-t border-gray-100 flex justify-end gap-3">
          <button @click="editorStore.fetchNovelData('novel-1')" class="px-5 py-2 bg-white border border-gray-200 rounded-lg text-sm font-medium text-[#374151] hover:bg-gray-50 transition-colors">重置</button>
          <button @click="editorStore.saveMetadata" class="px-5 py-2 bg-[#4B5563] hover:bg-gray-700 text-white rounded-lg text-sm font-medium transition-colors">保存更改</button>
        </div>
      </div>

      <div class="col-span-1 space-y-6">
        <div class="bg-white p-6 rounded-xl border border-gray-100">
          <h3 class="text-base font-medium text-[#374151]">参考内容管理</h3>
          <p class="text-sm text-[#9CA3AF] mt-1 mb-4">将其他作品作为参考，AI会借鉴其风格</p>

          <div class="space-y-3">
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg border border-gray-200">
              <div class="flex items-center gap-3 overflow-hidden">
                <img src="https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=100" class="w-8 h-10 object-cover rounded flex-shrink-0" alt="Reference Book">
                <span class="text-sm font-medium text-[#374151] truncate">银河帝国</span>
              </div>
              <button class="text-gray-400 hover:text-red-500 transition-colors flex-shrink-0 p-1">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>
          </div>

          <button class="w-full mt-4 flex items-center justify-center gap-2 border-2 border-dashed border-gray-200 rounded-lg py-4 text-sm font-medium text-[#9CA3AF] hover:border-blue-500 hover:text-blue-500 transition-all">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 4v16m8-8H4"></path></svg>
            <span>添加参考作品</span>
          </button>
        </div>
      </div>
    </div>
    <div v-else class="text-center py-20 text-gray-500">
      正在加载小说设置...
    </div>
  </div>
</template>

<script setup lang="ts">
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { storeToRefs } from 'pinia';

const editorStore = useEditorStore();
const { novelMetadata } = storeToRefs(editorStore);

</script>

<style scoped>
.custom-scrollbar::-webkit-scrollbar {
  display: block;
  width: 6px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background: #d1d5db;
  border-radius: 3px;
}
.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #9ca3af;
}
</style>

// =
// 文件: ..\src\novel\editor\components\system\settings\TaskSettings.vue
//

<template>
  <div class="setting-page-wrapper">
    <div class="page-header">
      <h2 class="page-title">任务管理</h2>
      <p class="page-description">管理AI任务队列，清理历史记录。</p>
    </div>

    <div class="setting-group">
      <div class="setting-item">
        <label for="auto-open-panel" class="setting-label">任务面板</label>
        <div class="setting-control">
          <div class="flex items-center">
            <input id="auto-open-panel" type="checkbox" v-model="autoOpenAIPanel" class="setting-checkbox" />
            <label for="auto-open-panel" class="ml-3 font-medium text-gray-700">自动打开AI任务面板</label>
          </div>
          <p class="setting-description">
            启用后，当执行AI任务时，会自动在右侧分屏打开AI任务面板以供查看。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label class="setting-label">任务应用策略</label>
        <div class="setting-control">
          <div class="space-y-3">
            <div class="flex items-center">
              <input id="apply-manual" type="radio" value="manual" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-manual" class="ml-3 font-medium text-gray-700">手动应用</label>
            </div>
            <div class="flex items-center">
              <input id="apply-auto" type="radio" value="auto" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-auto" class="ml-3 font-medium text-gray-700">自动应用</label>
            </div>
            <div class="flex items-center">
              <input id="apply-delayed" type="radio" value="delayed" v-model="applicationStrategy.mode" class="setting-radio" />
              <label for="apply-delayed" class="ml-3 font-medium text-gray-700">延迟</label>
              <input
                  v-if="applicationStrategy.mode === 'delayed'"
                  type="number"
                  v-model.number="applicationStrategy.delaySeconds"
                  min="1"
                  class="setting-input w-20 ml-3 text-center"
              />
              <span v-if="applicationStrategy.mode === 'delayed'" class="ml-2 text-gray-700">秒后自动应用</span>
            </div>
          </div>
          <p class="setting-description">
            决定AI任务完成后，其生成的内容如何应用到文档中。<br>
            <b>手动应用：</b>任务完成后状态变为“待应用”，需在任务面板手动点击应用。<br>
            <b>自动应用：</b>任务完成后立即应用到文档中。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label for="concurrent-tasks" class="setting-label">AI任务并发数</label>
        <div class="setting-control">
          <div class="flex items-center gap-4">
            <input
                id="concurrent-tasks"
                type="range"
                min="1"
                max="10"
                step="1"
                v-model.number="concurrentTaskLimit"
                class="range-custom flex-1"
            />
            <input
                type="number"
                min="1"
                max="10"
                v-model.number="concurrentTaskLimit"
                class="setting-input w-20 text-center"
            />
          </div>
          <p class="setting-description">
            设置可以同时处理的AI任务数量。更高的并发数会占用更多资源。当前设置为 {{ concurrentTaskLimit }} 个。
          </p>
        </div>
      </div>

      <div class="setting-item">
        <label class="setting-label">清理任务</label>
        <div class="setting-control">
          <div class="flex items-center gap-4">
            <button @click="handleClearCompleted" class="action-button">清除已完成的任务</button>
            <button @click="handleClearAll" class="action-button-danger">清除所有任务</button>
          </div>
          <p class="setting-description">
            “已完成”包括已应用和已失败的任务。<br>
            清理所有任务将清空任务队列，包括正在等待和处理中的任务。此操作不可撤销。
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useUIStore } from '@/novel/editor/stores/uiStore';

const aiTaskStore = useAITaskStore();
const uiStore = useUIStore();

const autoOpenAIPanel = computed({
  get: () => uiStore.uiState.autoOpenAIPanel,
  set: (value) => uiStore.setAutoOpenAIPanel(value)
});

const applicationStrategy = computed({
  get: () => uiStore.uiState.taskApplicationStrategy,
  set: (value) => uiStore.setTaskApplicationStrategy(value)
});

const concurrentTaskLimit = computed({
  get: () => uiStore.uiState.concurrentTaskLimit,
  set: (value) => uiStore.setConcurrentTaskLimit(value)
});

const handleClearCompleted = () => {
  if (window.confirm('您确定要清除所有已应用和已失败的任务吗？')) {
    aiTaskStore.clearCompletedTasks();
  }
};

const handleClearAll = () => {
  if (window.confirm('您确定要清除所有AI任务吗？此操作不可撤销，进行中的任务也将被终止。')) {
    aiTaskStore.clearAllTasks();
  }
};
</script>

<style scoped>
.setting-page-wrapper { padding: 1rem 2rem; max-width: 56rem; margin: 0 auto; }
.page-header { padding-bottom: 1.5rem; border-bottom: 1px solid #E5E7EB; margin-bottom: 1.5rem; }
.page-title { font-size: 1.5rem; font-weight: 600; color: #1F2937; }
.page-description { color: #6B7280; margin-top: 0.25rem; }
.setting-group { display: flex; flex-direction: column; }
.setting-item { display: grid; grid-template-columns: 12rem 1fr; gap: 1rem; padding: 1.5rem 0; border-bottom: 1px solid #E5E7EB; }
.setting-item:last-child { border-bottom: none; }
.setting-label { font-size: 0.875rem; font-weight: 500; color: #374151; padding-top: 0.5rem; }
.setting-control { display: flex; flex-direction: column; gap: 0.75rem; }
.setting-description { color: #6B7280; font-size: 0.875rem; line-height: 1.6; }
.action-button {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: 0.375rem;
  background-color: #FFFFFF;
  border: 1px solid #D1D5DB;
  color: #374151;
  transition: background-color 0.2s;
}
.action-button:hover {
  background-color: #F9FAFB;
}
.action-button-danger {
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-weight: 500;
  border-radius: 0.375rem;
  background-color: #FEF2F2;
  border: 1px solid #FECACA;
  color: #DC2626;
  transition: background-color 0.2s;
}
.action-button-danger:hover {
  background-color: #FEE2E2;
}
.setting-checkbox { height: 1.25rem; width: 1.25rem; border-radius: 0.25rem; border: 1px solid #D1D5DB; color: #2563EB; }
.setting-radio {
  width: 1.25rem;
  height: 1.25rem;
  color: #2563EB;
  border-color: #D1D5DB;
}
.setting-input { background-color: white; border: 1px solid #D1D5DB; border-radius: 0.375rem; padding: 0.5rem 0.75rem; outline: none; transition: all 0.2s; }
.setting-input:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; }
.range-custom {
  -webkit-appearance: none; appearance: none;
  width: 100%; height: 16px; background: transparent;
  outline: none; padding: 0; margin: 0;
}
.range-custom::-webkit-slider-runnable-track {
  width: 100%; height: 6px; cursor: pointer;
  background: #E5E7EB; border-radius: 9999px;
}
.range-custom::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  height: 20px; width: 20px; background: #3B82F6;
  border-radius: 50%; border: 3px solid white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  cursor: grab; margin-top: -7px;
}
</style>

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

// 文件: src/novel/editor/composables/useContextBuilder.ts

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings } from '@/novel/editor/types';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
};

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        // 规则一：前置卷只包含大纲
        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        // 规则一：当前卷包含完整信息
        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        // 规则一：前置章节、后置章节
        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        // 规则一：本章的剧情与分析
        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        // 规则一：后置卷只包含大纲
        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        // 规则二：前置卷
        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        // 规则二：当前卷内容、剧情、分析
        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        // 规则二：本卷内的章节剧情与分析
        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        // 规则二：后置卷
        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = promptNode.content;
            selectedPromptTemplate = (tempDiv.querySelector('pre')?.textContent || selectedPromptTemplate).replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\layouts\NovelEditorLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame" :class="themeClass">
      <!-- 顶部导航栏: 严格遵循UI设计稿 -->
      <header class="h-[56px] bg-white border-b border-gray-100 flex items-center px-6 flex-shrink-0">
        <div class="flex items-center gap-2 flex-1">
          <!-- 返回链接指向小说管理台 -->
          <router-link to="/novel/dashboard" class="flex items-center gap-2 text-gray-500 hover:text-gray-800 transition-colors p-2 -ml-2 rounded-lg">
            <i class="fa-solid fa-chevron-left w-4 h-4"></i>
            <span>返回</span>
          </router-link>
          <span class="text-gray-300">/</span>
          <!-- 动态小说标题 -->
          <span class="font-medium text-gray-800 text-sm">{{ editorStore.novelMetadata?.title }}</span>
        </div>
        <div class="flex items-center gap-4">
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors">
            <i class="fa-solid fa-search w-5 h-5"></i>
          </button>
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors relative">
            <i class="fa-solid fa-bell w-5 h-5"></i>
            <span class="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full border border-white"></span>
          </button>
          <div class="ml-2 flex items-center gap-3">
            <img src="https://i.pravatar.cc/150?u=creator" alt="Creator Avatar" class="w-9 h-9 rounded-full">
            <div>
              <p class="text-sm font-medium text-[#374151]">创作者</p>
              <p class="text-xs text-[#9CA3AF]">在线</p>
            </div>
          </div>
        </div>
      </header>

      <!-- 使用 <router-view /> 来渲染子路由对应的组件 (EditorWorkspaceView) -->
      <div class="h-[calc(100%-56px)]">
        <router-view />
      </div>
    </div>
    <!-- 全局覆盖层与模态框 -->
    <ContextPreviewModal />
    <ReaderModeOverlay />
  </div>
</template>

<script setup lang="ts">
import '@/novel/assets/styles/main.css';
import { computed } from 'vue';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ContextPreviewModal from '@/novel/editor/components/modals/ContextPreviewModal.vue';
import ReaderModeOverlay from '@novel/editor/views/ReaderModeOverlay.vue';

const editorStore = useEditorStore();
const uiStore = useUIStore();
const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});
</script>

<style scoped>
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
}

/* --- Theme Variables --- */
.theme-eye-care {
  --theme-bg: #FDFCF9;
  --theme-bg-soft: #FBF9F6;
  --theme-bg-panel: #F8F6F2;
  --theme-border: #EFEBE4;
  --theme-text-primary: #3a2f2f;
  --theme-text-secondary: #5f5757;
  --theme-text-muted: #8e8585;
  --theme-hover-bg: #EFEBE4;
}

.theme-dark {
  --theme-bg: #18181b; /* zinc-900 */
  --theme-bg-soft: #27272a; /* zinc-800 */
  --theme-bg-panel: #3f3f46; /* zinc-700 */
  --theme-border: #3f3f46; /* zinc-700 */
  --theme-text-primary: #e4e4e7; /* zinc-200 */
  --theme-text-secondary: #a1a1aa; /* zinc-400 */
  --theme-text-muted: #71717a; /* zinc-500 */
  --theme-hover-bg: #3f3f46;
}

/* --- Global Theme Application --- */
.theme-eye-care, .theme-dark {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .text-gray-800),
:deep(.theme-dark .text-gray-800),
:deep(.theme-eye-care .text-\[\#374151\]),
:deep(.theme-dark .text-\[\#374151\]),
:deep(.theme-eye-care .text-\[\#1F2937\]),
:deep(.theme-dark .text-\[\#1F2937\])
{
  color: var(--theme-text-primary);
}
:deep(.theme-eye-care .text-gray-500),
:deep(.theme-dark .text-gray-500),
:deep(.theme-eye-care .text-\[\#6B7280\]),
:deep(.theme-dark .text-\[\#6B7280\])
{
  color: var(--theme-text-secondary);
}
:deep(.theme-eye-care .text-gray-400),
:deep(.theme-dark .text-gray-400),
:deep(.theme-eye-care .text-\[\#9CA3AF\]),
:deep(.theme-dark .text-\[\#9CA3AF\])
{
  color: var(--theme-text-muted);
}
:deep(.theme-eye-care .border-gray-100),
:deep(.theme-dark .border-gray-100),
:deep(.theme-eye-care .border-gray-200),
:deep(.theme-dark .border-gray-200),
:deep(.theme-eye-care .border-gray-200\/80),
:deep(.theme-dark .border-gray-200\/80),
:deep(.theme-eye-care .border-b)
{
  border-color: var(--theme-border) !important;
}
:deep(.theme-eye-care .bg-white),
:deep(.theme-dark .bg-white)
{
  background-color: var(--theme-bg) !important;
}
:deep(.theme-eye-care .hover\:bg-gray-100:hover),
:deep(.theme-dark .hover\:bg-gray-100:hover)
{
  background-color: var(--theme-hover-bg) !important;
}
:deep(.theme-eye-care .bg-gray-50\/50),
:deep(.theme-dark .bg-gray-50\/50) {
  background-color: var(--theme-bg-soft);
}

/* --- Component Specific Theming --- */
.theme-eye-care header, .theme-dark header {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .editor-workspace-view),
:deep(.theme-dark .editor-workspace-view),
:deep(.theme-eye-care .activity-bar-container),
:deep(.theme-dark .activity-bar-container)
{
  background-color: var(--theme-bg-panel);
}
:deep(.theme-eye-care .sidebar-panel-container),
:deep(.theme-dark .sidebar-panel-container) {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-eye-care .main-pane-container),
:deep(.theme-dark .main-pane-container),
:deep(.theme-eye-care .pane-content-dispatcher),
:deep(.theme-dark .pane-content-dispatcher),
:deep(.theme-eye-care .aiconfig-content),
:deep(.theme-dark .aiconfig-content),
:deep(.theme-eye-care .search-view-container),
:deep(.theme-dark .search-view-container),
:deep(.theme-eye-care .task-queue-container),
:deep(.theme-dark .task-queue-container),
:deep(.theme-eye-care .diff-preview-container),
:deep(.theme-dark .diff-preview-container),
:deep(.theme-eye-care .ai-task-panel-container),
:deep(.theme-dark .ai-task-panel-container),
:deep(.theme-eye-care .page-header),
:deep(.theme-dark .page-header)
{
  background-color: var(--theme-bg);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .top-header-bar),
:deep(.theme-dark .top-header-bar),
:deep(.theme-eye-care .tabs-bar),
:deep(.theme-dark .tabs-bar)
{
  background-color: var(--theme-bg-panel);
}
:deep(.theme-eye-care .tab-item),
:deep(.theme-dark .tab-item) {
  background-color: var(--theme-border);
}
:deep(.theme-eye-care .tab-item.active),
:deep(.theme-dark .tab-item.active) {
  background-color: var(--theme-bg);
}
:deep(.theme-eye-care .breadcrumbs-bar-container),
:deep(.theme-dark .breadcrumbs-bar-container) {
  background-color: var(--theme-bg);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .ProseMirror),
:deep(.theme-dark .ProseMirror) {
  color: var(--theme-text-primary);
}
:deep(.theme-eye-care .status-bar-container),
:deep(.theme-dark .status-bar-container) {
  background-color: var(--theme-bg-panel);
  border-color: var(--theme-border);
}
:deep(.theme-eye-care .setting-page-wrapper),
:deep(.theme-dark .setting-page-wrapper) {
  color: var(--theme-text-primary);
}
:deep(.theme-dark .page-title),
:deep(.theme-dark .page-description),
:deep(.theme-dark .setting-label),
:deep(.theme-dark .setting-description),
:deep(.theme-dark .font-medium)
{
  color: var(--theme-text-primary);
}
:deep(.theme-dark .setting-input) {
  background-color: var(--theme-bg-soft);
  border-color: var(--theme-bg-panel);
  color: var(--theme-text-primary);
}
:deep(.theme-dark .theme-info) {
  background-color: var(--theme-bg-soft);
}
:deep(.theme-dark .theme-card) {
  border-color: var(--theme-bg-panel);
}
</style>

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { AITaskType } from '@novel/editor/types';

// 定义每种任务类型默认选中的提示词ID
const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const useAIConfigStore = defineStore('aiConfig', () => {
    // 状态结构简化，只存储选中ID和其他配置
    const taskConfigs = ref<Record<AITaskType, { selectedPromptId: string }>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'] },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'] },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'] },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'] },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'] },
    });

    /**
     * 更新指定任务类型选择的提示词ID
     * @param taskType 要更新的任务类型
     * @param promptId 选择的提示词ID
     */
    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    return {
        taskConfigs,
        setSelectedPromptId,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

// 文件: src/novel/editor/stores/ai/aiTaskStore.ts

// src/novel/editor/stores/aiTaskStore.ts
import { defineStore } from 'pinia'
import { ref, nextTick, computed } from 'vue'
import { useEditorStore } from '../editorStore.ts'
import { useUIStore } from '../uiStore.ts'
import { useDerivedContentStore } from '../derivedContentStore.ts';
import type { AITask, Volume, AITaskType } from '@novel/editor/types';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder.ts';
import { streamAITask } from '@novel/editor/api/aiService.ts';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();
    const { buildContextForTask } = useContextBuilder();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    const _executeTaskAndStream = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task) return;

        task.status = 'processing';
        task.generatedContent = '';

        if (!task.finalPrompt) {
            // **核心修正**: 直接将任务对象传给上下文构建器
            const contextResult = buildContextForTask(task);
            if (!contextResult || !contextResult.prompt) {
                task.status = 'failed';
                task.error = '上下文构建失败，无法生成最终提示词。';
                nextTick(_processQueue);
                return;
            }
            task.finalPrompt = contextResult.prompt;
        }

        const promptToUse = task.finalPrompt;

        streamAITask(promptToUse, {
            onChunk: (chunk) => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.generatedContent += chunk;
                }
            },
            onComplete: () => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.status = 'completed';
                    if (currentTask.type === '润色' || currentTask.type === '续写') {
                        const strategy = uiStore.uiState.taskApplicationStrategy;
                        switch (strategy.mode) {
                            case 'auto':
                                applyChanges(currentTask.id, true);
                                break;
                            case 'delayed':
                                setTimeout(() => {
                                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                                    if (taskAfterDelay && taskAfterDelay.status === 'completed') {
                                        applyChanges(taskId, true);
                                    }
                                }, strategy.delaySeconds * 1000);
                                break;
                            case 'manual':
                                break;
                        }
                    }
                    _processQueue();
                }
            },
            onError: (error) => {
                const currentTask = tasks.value.find(t => t.id === taskId);
                if (currentTask && currentTask.status === 'processing') {
                    currentTask.status = 'failed';
                    currentTask.error = error;
                    _processQueue();
                }
            }
        });
    }

    const _processQueue = () => {
        const limit = uiStore.uiState.concurrentTaskLimit;
        const processingCount = tasks.value.filter(t => t.status === 'processing').length;

        if (processingCount >= limit) {
            return;
        }

        const canStartCount = limit - processingCount;
        const pendingTasks = tasks.value.filter(t => t.status === 'pending');

        const tasksToStart = pendingTasks.slice(0, canStartCount);

        for (const task of tasksToStart) {
            _executeTaskAndStream(task.id);
        }
    };

    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const { node: sourceItem } = editorStore.findItemById(sourceItemId);
        if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
            console.error("AI Task Error: Source item not found or has no content.", sourceItemId);
            return;
        }

        let targetItemId: string;
        let taskTitle: string;

        if (taskType === '分析' || taskType === '剧情生成') {
            const newDerivedItem = derivedContentStore.createDerivedItem(sourceItem, taskType);
            if (!newDerivedItem) {
                console.error("Failed to create derived item shell.");
                return;
            }
            targetItemId = newDerivedItem.id;
            taskTitle = newDerivedItem.title;

            await nextTick();
            editorStore.openTab(targetItemId);
        } else {
            targetItemId = sourceItemId;
            taskTitle = `${taskType}《${sourceItem.title}》`;
        }

        const newTask: AITask = {
            id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            title: taskTitle,
            type: taskType,
            sourceItemId: sourceItemId,
            targetItemId: targetItemId,
            sourceItemTitle: sourceItem.title, // **核心修正**: 添加标题快照
            sourceItemContent: sourceItem.content, // **核心修正**: 添加内容快照
            status: 'pending',
            generatedContent: '',
            finalPrompt: finalPrompt,
            createdAt: new Date(),
        };

        tasks.value.unshift(newTask);
        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }
        nextTick(_processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || task.status !== 'completed') return;

        if (task.type === '分析' || task.type === '剧情生成') {
            const { node: targetNode } = editorStore.findItemById(task.targetItemId);
            if (targetNode) {
                const finalTitle = task.title.split(' - ')[0];
                const newContent = formatContentForEditor(finalTitle, task.generatedContent);
                editorStore.updateItemContentById(task.targetItemId, newContent);
                const result = derivedContentStore.findItemById(task.targetItemId);
                if (result) result.title = finalTitle;
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'failed') {
            task.status = 'pending';
            task.error = undefined;
            task.generatedContent = '';
            task.finalPrompt = undefined; // 清除旧的prompt，强制重新构建
            nextTick(_processQueue);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => t.status !== 'applied' && t.status !== 'failed');
    };

    const clearAllTasks = () => {
        tasks.value = [];
    };

    return {
        tasks, activeTasksCount, startTask, startBatchTaskForVolume, applyChanges, retryTask, clearCompletedTasks, clearAllTasks
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, ChatMessage, AIModel } from '@novel/editor/types/chatTypes.ts';
import { mockChatConversations } from '@novel/editor/components/ai/chat/chatData.ts';

export const useChatStore = defineStore('editorChat', () => {
    // --- State ---

    // 所有对话的列表
    const conversations = ref<Conversation[]>([]);
    // 当前激活的对话ID
    const activeConversationId = ref<string | null>(null);
    // 当前可用的AI模型
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    // 输入框中的内容
    const messageInput = ref<string>('');
    // 标志位，表示AI是否正在回复中
    const isReceiving = ref<boolean>(false);

    // --- Getters (Computed) ---

    // 根据 activeConversationId 获取当前完整的对话对象
    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    // 当前对话的 token 统计 (简化版)
    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    // --- Actions ---

    /**
     * 初始化或从后端获取聊天数据
     */
    const fetchConversations = () => {
        // 从模块专属的数据文件加载模拟数据
        conversations.value = mockChatConversations;

        // 默认激活第一个对话
        if (conversations.value.length > 0 && !activeConversationId.value) {
            activeConversationId.value = conversations.value[0].id;
        }
    };

    /**
     * 新建一个对话
     */
    const createNewConversation = () => {
        const newConv: Conversation = {
            id: `conv-${Date.now()}`,
            title: '新建对话',
            summary: '暂无摘要',
            createdAt: '刚刚',
            messages: [],
        };
        conversations.value.unshift(newConv);
        activeConversationId.value = newConv.id;
    };

    /**
     * 切换当前对话
     * @param conversationId - 要切换到的对话ID
     */
    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    /**
     * 发送消息
     */
    const sendMessage = async () => {
        if (!messageInput.value.trim() || !activeConversation.value || isReceiving.value) {
            return;
        }

        const userMessage: ChatMessage = {
            id: `msg-${Date.now()}`,
            role: 'user',
            content: messageInput.value,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(userMessage);
        messageInput.value = ''; // 清空输入框

        // 模拟AI回复
        isReceiving.value = true;
        await new Promise(res => setTimeout(res, 1500)); // 模拟网络延迟

        const aiResponse: ChatMessage = {
            id: `msg-${Date.now() + 1}`,
            role: 'ai',
            content: `这是对您关于 "${userMessage.content.substring(0, 10)}..." 的回复。AI正在思考中...`,
            timestamp: new Date().toISOString(),
        };
        activeConversation.value.messages.push(aiResponse);
        isReceiving.value = false;
    };

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: src/novel/editor/stores/derivedContentStore.ts

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);

    /**
     * 为指定源（章节或卷）创建一个新的派生内容项（占位符）。
     * @param sourceNode - 源节点对象 (章节或卷)
     * @param taskType - 任务类型 ('分析' 或 '剧情生成')
     * @returns 新创建的派生内容项
     */
    function createDerivedItem(sourceNode: EditorItem, taskType: AITaskType): PlotAnalysisItem | null {
        if (taskType !== '分析' && taskType !== '剧情生成') return null;
        if (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume') return null;


        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        const derivedType: PlotAnalysisItem['type'] = taskType === '分析' ? 'analysis' : 'plot';
        const titleSuffix = taskType;
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';

        const newItem: PlotAnalysisItem = {
            id: `${derivedType}_${now.getTime()}`, // 使用时间戳保证ID唯一
            type: derivedType,
            sourceId: sourceNode.id,
            title: `《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}`,
            content: `<h1>《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}</h1><p>AI正在生成内容，请稍候...</p>`
        };

        if (derivedType === 'analysis') {
            analysisItems.value.unshift(newItem);
        } else {
            plotItems.value.unshift(newItem);
        }

        return newItem;
    }

    /**
     * 根据ID从所有派生项中查找。
     * @param nodeId - 派生内容的ID
     */
    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    /**
     * 更新派生内容。
     * @param nodeId - 派生内容的ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            derivedItem.content = content;
        }
    }

    /**
     * (此函数不再用于派生内容，但为保持接口一致性而保留)
     * 向派生内容追加内容。
     * @param nodeId - 派生内容的ID
     * @param contentToAppend - 要追加的原始文本
     */
    function appendNodeContent(nodeId: string, contentToAppend: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            if (!derivedItem.content) derivedItem.content = "";
            derivedItem.content += paragraphs;
        }
    }

    /**
     * 删除与指定源ID关联的所有派生数据。
     * @param sourceId - 源的ID
     */
    function deleteDerivedDataForSource(sourceId: string) {
        plotItems.value = plotItems.value.filter(item => item.sourceId !== sourceId);
        analysisItems.value = analysisItems.value.filter(item => item.sourceId !== sourceId);
    }


    return {
        plotItems,
        analysisItems,
        createDerivedItem,
        findItemById,
        updateNodeContent,
        appendNodeContent,
        deleteDerivedDataForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// 文件: src/novel/editor/stores/directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { useDerivedContentStore } from './derivedContentStore';

type DirectoryNode = Volume | Chapter;

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);

    const _findNodeRecursive = (nodes: DirectoryNode[], nodeId: string): { node: DirectoryNode; parent: Volume | null; siblings: DirectoryNode[] } | null => {
        for (const node of nodes) {
            if (node.id === nodeId) {
                return { node, parent: null, siblings: nodes };
            }
            if (node.type === 'volume' && node.chapters) {
                const chapterResult = node.chapters.find(c => c.id === nodeId);
                if (chapterResult) {
                    return { node: chapterResult, parent: node, siblings: node.chapters };
                }
            }
        }
        return null;
    };

    const fetchDirectoryData = (data: Volume[]) => {
        directoryData.value = data;
    };

    const findNodeById = (nodeId: string) => {
        return _findNodeRecursive(directoryData.value, nodeId);
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result && (result.node.type === 'chapter' || result.node.type === 'volume')) {
            const item = result.node;
            item.content = content;

            if (item.type === 'chapter') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                item.wordCount = tempDiv.textContent?.trim().length || 0;
            }

            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== item.title) {
                item.title = newTitle;
            }
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            const chapter = result.node;
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            chapter.content += htmlToAppend;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = chapter.content;
            chapter.wordCount = tempDiv.textContent?.trim().length || 0;
        }
    };

    const addNewVolume = () => {
        const uiStore = useUIStore();
        const editorStore = useEditorStore();
        const newVolume: Volume = {
            id: `vol-${Date.now()}`,
            type: 'volume',
            title: '新建卷',
            content: `<h1>新建卷</h1>`,
            chapters: [],
        };
        directoryData.value.push(newVolume);
        editorStore.setEditingNodeId(newVolume.id);
        uiStore.ensureNodeIsExpanded(newVolume.id);
    };

    const addChapterToVolume = (volumeId: string) => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const editorStore = useEditorStore();
            const uiStore = useUIStore();
            const newChapter: Chapter = {
                id: `ch-${Date.now()}`,
                type: 'chapter',
                title: '新建章节',
                wordCount: 0,
                content: '<h1>新建章节</h1>',
                status: 'editing'
            };
            volume.chapters.push(newChapter);
            uiStore.ensureNodeIsExpanded(volume.id);
            editorStore.openTab(newChapter.id);
            editorStore.setEditingNodeId(newChapter.id);
        }
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        if (!newTitle.trim()) {
            return;
        }
        const result = findNodeById(nodeId);
        if (result?.node) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;
            if (result.node.content) {
                if (result.node.content.includes('<h1>')) {
                    result.node.content = result.node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
                } else {
                    result.node.content = `<h1>${trimmedTitle}</h1>` + result.node.content;
                }
            }
        }
    };

    const deleteNode = (nodeId: string) => {
        const result = findNodeById(nodeId);
        if (!result) return;

        const editorStore = useEditorStore();
        const derivedContentStore = useDerivedContentStore();

        if (result.node.type === 'chapter') {
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        } else if (result.node.type === 'volume') {
            result.node.chapters.forEach(chapter => {
                derivedContentStore.deleteDerivedDataForSource(chapter.id);
            });
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        }

        if (result.parent && result.node.type === 'chapter') {
            result.parent.chapters = result.parent.chapters.filter(c => c.id !== nodeId);
        } else if (!result.parent && result.node.type === 'volume') {
            directoryData.value = directoryData.value.filter(v => v.id !== nodeId);
        }
        editorStore.closeTab(nodeId);
        if (editorStore.editingNodeId === nodeId) editorStore.setEditingNodeId(null);
    };

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { usePaneStore, type EditorPane } from './modules/paneStore';
import { useTabStore } from './modules/tabStore';
import { useItemStore } from './modules/itemStore';
import { useSystemViewStore } from './modules/systemViewStore';
import { useMetadataStore } from './modules/metadataStore';
import { useUIStore } from './uiStore';
import type { TabInfo } from '@/novel/editor/types';

export { EditorPane };

export const useEditorStore = defineStore('editor-facade', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    const splitPane = (sourcePaneId: string) => {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    };

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        splitPane,
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab: tabStore.openTab,
        closeTab: tabStore.closeTab,
        findItemById: itemStore.findItemById,
        updateItemContentById: itemStore.updateItemContentById,
        appendContentToItem: itemStore.appendContentToItem,
        toggleAIPanel: systemViewStore.toggleAIPanel,
        ensureAIPanelIsOpen: systemViewStore.ensureAIPanelIsOpen,
        toggleHistoryPanel: systemViewStore.toggleHistoryPanel,
        openReaderView: systemViewStore.openReaderView,
        fetchNovelData: metadataStore.fetchNovelData,
        removeTag: metadataStore.removeTag,
        addTag: metadataStore.addTag,
        saveMetadata: metadataStore.saveMetadata,
        getTabsForPane,
        getActiveTabForPane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\itemStore.ts
//

// 文件: src/novel/editor/stores/modules/itemStore.ts

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore'; // 引入新的 reference store
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore(); // 实例化新的 store

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        // 1. Check for System Views
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = parts.length > 2 && (parts[1] === 'history') ? parts.slice(0, 2).join(':') : id;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                if (parts.length > 2 && (parts[1] === 'history')) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                return { node: systemView, source: 'system' };
            }
        }

        // 2. Check for AI Derived Items
        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) {
            return { node: derivedItem as PlotAnalysisItem, source: 'derived' };
        }

        // 3. Check for Prompt Templates
        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) {
            return { node: promptItem, source: 'prompt' };
        }

        // 4. Check Directory
        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        // 5. Check Related Content (Settings & Custom Items)
        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        // 6. Check Notes
        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        // 7. Check Reference Books (New)
        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptItemContent(id, content); break;
            // Reference books are read-only, no update case needed for now
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
            // Reference books are read-only, no append case needed for now
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\modules\metadataStore.ts
//

// 文件: src/novel/editor/stores/modules/metadataStore.ts

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NovelMetadata } from '@/novel/editor/types';
import { getNovelProject } from '@/novel/data/novelProjectData';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useReferenceStore } from '../referenceStore';
import { useUIStore } from '../uiStore';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);

    function fetchNovelData(novelId: string) {
        console.log(`Fetching data for novel: ${novelId}`);
        const projectData = getNovelProject(novelId);

        if (!projectData) {
            console.error(`Novel project with ID "${novelId}" not found.`);
            // 你可以在这里处理错误，比如重定向到404页面或仪表盘
            return;
        }

        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();
        const referenceStore = useReferenceStore();
        const uiStore = useUIStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();

        // 使用从中心数据源获取的数据填充各个 store
        directoryStore.fetchDirectoryData(projectData.directoryData);
        relatedContentStore.fetchRelatedData(
            projectData.settingsData,
            projectData.plotCustomData,
            projectData.analysisCustomData,
            projectData.othersCustomData
        );
        notesStore.fetchNotes(projectData.noteData);
        referenceStore.fetchData(projectData.referenceData);
        novelMetadata.value = JSON.parse(JSON.stringify(projectData.metadata));

        // 初始化编辑器UI状态
        paneStore.initializePanes();
        // 默认打开第一卷的第一个章节，如果存在的话
        const firstChapterId = projectData.directoryData[0]?.chapters[0]?.id;
        if (firstChapterId) {
            tabStore.openTab(firstChapterId);
        }


        // 设置默认展开的节点
        uiStore.uiState.expandedNodeIds.clear();
        uiStore.uiState.expandedRelatedNodeIds.clear();
        uiStore.uiState.expandedReferenceNodeIds.clear();

        if (projectData.directoryData.length > 0) {
            uiStore.uiState.expandedNodeIds.add(projectData.directoryData[0].id);
        }
        uiStore.uiState.expandedRelatedNodeIds.add('setting');
        uiStore.uiState.expandedRelatedNodeIds.add('characters');
        uiStore.uiState.expandedRelatedNodeIds.add('plot');
        uiStore.uiState.expandedRelatedNodeIds.add('analysis');
        uiStore.uiState.expandedRelatedNodeIds.add('others');
        if (projectData.referenceData.length > 0) {
            uiStore.uiState.expandedReferenceNodeIds.add(projectData.referenceData[0].id);
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    function saveMetadata() {
        if (!novelMetadata.value) return;
        console.log('Saving metadata:', JSON.parse(JSON.stringify(novelMetadata.value)));
        alert('小说设置已保存！');
    }

    return {
        novelMetadata,
        fetchNovelData,
        removeTag,
        addTag,
        saveMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\systemViewStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useEditorStore } from '../editorStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const editorStore = useEditorStore();
        const activeItem = editorStore.activeTab?.item;
        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\modules\tabStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            if (node?.type === 'volume' || node?.type === 'group') {
                uiStore.toggleNodeExpansion(itemId);
            } else if (node) {
                uiStore.toggleRelatedNodeExpansion(itemId);
            }
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//


import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);


    const fetchNotes = (data: NoteItem[]) => {
        notes.value = data;
    };

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;
            if (newTitle) {
                note.title = newTitle;
            }
        }
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if (!note.content) note.content = "";
            note.content += htmlToAppend;
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const uiStore = useUIStore();
        const note = findNoteById(noteId);
        if (note && newTitle.trim()) {
            const trimmedTitle = newTitle.trim();
            note.title = trimmedTitle;
            if (note.content.includes('<h1>')) {
                note.content = note.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            } else {
                note.content = `<h1>${trimmedTitle}</h1>` + note.content;
            }
        }
        uiStore.setEditingNodeId(null);
    };

    const addNote = (title: string, content: string = '') => {
        const editorStore = useEditorStore();
        const uiStore = useUIStore();
        const newNote: NoteItem = {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
        notes.value.unshift(newNote);
        editorStore.openTab(newNote.id);
        uiStore.setEditingNodeId(newNote.id);
    };

    const deleteNote = (noteId: string) => {
        const editorStore = useEditorStore();
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            notes.value.splice(index, 1);
            editorStore.closeTab(noteId);
        }
    };

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

// 文件: src/novel/editor/stores/promptTemplateStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { useAIConfigStore } from './ai/aiConfigStore';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};


export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    const promptTree = ref<TreeNode[]>([]);

    function _buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }

    const templates = computed(() => {
        if (promptTree.value.length === 0) {
            promptTree.value = _buildInitialTree();
        }
        return promptTree.value;
    });

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = templates.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        for (const group of templates.value[0]?.children || []) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPromptItem(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = templates.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newItem: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newItem);
        return newItem;
    }

    function renamePromptItem(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.title = newTitle;
        }
    }

    function deletePromptItem(promptId: string) {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            group.children = group.children.filter(p => p.id !== promptId);

            if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
            }
            return true;
        }
        return false;
    }

    function updatePromptItemContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }


    return {
        templates,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPromptItem,
        renamePromptItem,
        deletePromptItem,
        updatePromptItemContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

// 文件: src/novel/editor/stores/referenceStore.ts

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const fetchData = (data: TreeNode[]) => {
        referenceData.value = data;
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        fetchData,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\itemDataStore.ts
//

// src/novel/editor/stores/modules/related/itemDataStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@novel/editor/types';

export const useItemDataStore = defineStore('related-item-data', () => {
    // 原始数据状态
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<TreeNode[]>([]);
    const analysisCustomData = ref<TreeNode[]>([]);
    const othersCustomData = ref<TreeNode[]>([]);

    /**
     * 从外部获取数据并填充 store
     * @param settings - 设定的树形数据
     * @param plot - 自定义剧情数据
     * @param analysis - 自定义分析数据
     * @param others - 其他自定义数据
     */
    function fetchRelatedData(settings: TreeNode[], plot: TreeNode[], analysis: TreeNode[], others: TreeNode[]) {
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
        othersCustomData.value = others;
    }

    return {
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        fetchRelatedData,
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\nodeOperationStore.ts
//

// 文件: src/novel/editor/stores/related/nodeOperationStore.ts
import { defineStore } from 'pinia';
import { useItemDataStore } from './itemDataStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';
import { usePromptTemplateStore } from '../promptTemplateStore.ts';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
}

export const useNodeOperationStore = defineStore('related-node-operations', () => {
    const itemDataStore = useItemDataStore();
    const promptTemplateStore = usePromptTemplateStore();

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        const sources = [
            itemDataStore.settingsData,
            itemDataStore.plotCustomData,
            itemDataStore.analysisCustomData,
            itemDataStore.othersCustomData
        ];
        for (const source of sources) {
            const result = _findNodeInTreeRecursive(source, nodeId);
            if (result) return result;
        }
        const promptResult = _findNodeInTreeRecursive(promptTemplateStore.templates, nodeId);
        if (promptResult) return promptResult;

        return null;
    }

    function updateNodeContent(nodeId: string, content: string) {
        if (promptTemplateStore.findPromptById(nodeId)) {
            promptTemplateStore.updatePromptItemContent(nodeId, content);
            return;
        }

        const result = findNodeById(nodeId);
        if (!result?.node || !('content' in result.node)) return;

        (result.node as ItemNode).content = content;
        if (!result.node.isReadOnly) {
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== result.node.title) {
                result.node.title = newTitle;
            }
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            const itemNode = result.node as ItemNode;
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if (isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if (!itemNode.content) itemNode.content = "";
            itemNode.content += htmlToAppend;
        }
    }

    function addRelatedNode(parentId: string, type: 'group' | 'item') {
        const result = _findNodeInTreeRecursive(itemDataStore.settingsData, parentId);
        if (!result?.node || !result.node.children) return;

        const parentNode = result.node as GroupNode;
        const uiStore = useUIStore();
        const editorStore = useEditorStore();

        const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
        const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
        const newNodeIcon = getIconByNodeType(newNodeType);

        if (type === 'group') {
            const newNode: GroupNode = {
                id: `group-${Date.now()}`,
                title: '新建分组',
                type: 'group',
                icon: newNodeIcon,
                children: [],
            };
            parentNode.children.push(newNode);
            uiStore.setEditingNodeId(newNode.id);
        } else { // type === 'item'
            const newNode: ItemNode = {
                id: `item-${Date.now()}`,
                title: '新建条目',
                type: newNodeType as ItemNode['type'],
                icon: newNodeIcon,
                content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
            };
            parentNode.children.push(newNode);
            uiStore.setEditingNodeId(newNode.id);
            editorStore.openTab(newNode.id);
        }
        uiStore.ensureRelatedNodeIsExpanded(parentId);
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node && !result.node.isReadOnly && newTitle.trim()) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;
            if ('content' in result.node && result.node.content && result.node.content.includes('<h1>')) {
                (result.node as ItemNode).content = (result.node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
            }
        }
    }

    function deleteRelatedNode(nodeId: string) {
        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.settingsData, nodeId);
        if (wasRemoved) {
            useEditorStore().closeTab(nodeId);
        }
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis') {
        const dataRef = target === 'plot' ? itemDataStore.plotCustomData : itemDataStore.analysisCustomData;
        const icon = getIconByNodeType(`${target}_item`);
        const newNode: ItemNode = {
            id: `custom-${target}-${Date.now()}`,
            title: '新建自定义条目',
            type: `${target}_item`,
            icon: icon,
            content: '<h1>新建自定义条目</h1><p>请在此处填写内容...</p>',
        };
        dataRef.unshift(newNode);
        useUIStore().ensureRelatedNodeIsExpanded(target);
        useEditorStore().openTab(newNode.id);
        useUIStore().setEditingNodeId(newNode.id);
    }

    function deleteCustomRelatedNode(nodeId: string) {
        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.plotCustomData, nodeId) || _findAndRemoveNodeInTree(itemDataStore.analysisCustomData, nodeId);
        if (wasRemoved) {
            useEditorStore().closeTab(nodeId);
        }
    }

    function addCustomOthersNode() {
        const icon = getIconByNodeType('others_item');
        const newNode: ItemNode = {
            id: `custom-others-${Date.now()}`,
            title: '新建其他条目',
            type: 'others_item',
            icon: icon,
            content: '<h1>新建其他条目</h1><p>请在此处填写内容...</p>',
        };
        itemDataStore.othersCustomData.unshift(newNode);
        useUIStore().ensureRelatedNodeIsExpanded('others');
        useEditorStore().openTab(newNode.id);
        useUIStore().setEditingNodeId(newNode.id);
    }

    function deleteCustomOthersNode(nodeId: string) {
        const wasRemoved = _findAndRemoveNodeInTree(itemDataStore.othersCustomData, nodeId);
        if (wasRemoved) {
            useEditorStore().closeTab(nodeId);
        }
    }

    function addPrompt(groupId: string) {
        const newPrompt = promptTemplateStore.addPromptItem(groupId, '新建提示词', '在这里输入你的提示词模板...');
        if (newPrompt) {
            const uiStore = useUIStore();
            const editorStore = useEditorStore();
            uiStore.ensureRelatedNodeIsExpanded(groupId);
            editorStore.openTab(newPrompt.id);
            uiStore.setEditingNodeId(newPrompt.id);
        }
    }

    function renamePrompt(promptId: string, newTitle: string) {
        if (newTitle.trim()) {
            promptTemplateStore.renamePromptItem(promptId, newTitle.trim());
        }
    }

    function deletePrompt(promptId: string) {
        if (promptTemplateStore.deletePromptItem(promptId)) {
            useEditorStore().closeTab(promptId);
        }
    }

    return {
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode: renameRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode: renameRelatedNode,
        deleteCustomOthersNode,
        addPrompt,
        renamePrompt,
        deletePrompt,
    };
});

// =
// 文件: ..\src\novel\editor\stores\related\overviewStore.ts
//

// src/novel/editor/stores/modules/related/overviewStore.ts
import { defineStore } from 'pinia';
import { watch } from 'vue';
import { useItemDataStore } from './itemDataStore.ts';
import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 这个 store 专门用于管理和更新“总览”节点的内容。
 * 它通过 watch 监听 settingsData 的变化，自动重新生成总览。
 */
export const useOverviewStore = defineStore('related-overview', () => {
    const itemDataStore = useItemDataStore();

    /**
     * 更新单个分组节点下的总览内容。
     * @param groupNode - 包含总览节点的父分组节点。
     */
    function updateOverviewContent(groupNode: GroupNode) {
        if (!groupNode.children) return;

        const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
        if (!overviewNode) return;

        // 筛选出需要被汇总的普通条目
        const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

        // 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
        const demoteHeadings = (htmlContent: string): string => {
            if (typeof document === 'undefined') return htmlContent; // Guard for SSR
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            // 将 h1, h2, h3 等标题降级
            const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
            headings.forEach(heading => {
                const level = parseInt(heading.tagName.charAt(1), 10);
                const newLevel = Math.min(6, level + 1); // 最多降到 h6
                const newHeading = document.createElement(`h${newLevel}`);
                newHeading.innerHTML = heading.innerHTML;
                for (const attr of heading.attributes) {
                    newHeading.setAttribute(attr.name, attr.value);
                }
                heading.parentNode?.replaceChild(newHeading, heading);
            });
            return tempDiv.innerHTML;
        };

        // 拼接所有条目的内容
        const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

        // 更新总览节点的内容
        overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
    }

    /**
     * 遍历整个设定树，更新所有找到的总览节点。
     */
    function updateAllOverviewContent() {
        const findAndProcess = (nodes: TreeNode[]) => {
            for (const node of nodes) {
                if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                    updateOverviewContent(node as GroupNode);
                }
                if (node.children) {
                    findAndProcess(node.children);
                }
            }
        };
        findAndProcess(itemDataStore.settingsData);
    }

    // 监听原始数据变化，自动更新总览
    watch(
        () => itemDataStore.settingsData,
        () => {
            updateAllOverviewContent();
        },
        { deep: true, immediate: true } // immediate确保初始化时也能执行
    );

    // 这个 store 主要通过 watch effect 工作，所以返回空对象
    return {};
});

// =
// 文件: ..\src\novel\editor\stores\related\treeBuilderStore.ts
//

// 文件: src/novel/editor/stores/related/treeBuilderStore.ts

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { useItemDataStore } from './itemDataStore.ts';
import { useDirectoryStore } from '@novel/editor/stores/directoryStore.ts';
import { useDerivedContentStore } from '@novel/editor/stores/derivedContentStore.ts';
import { usePromptTemplateStore } from '@novel/editor/stores/promptTemplateStore';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode } from '@novel/editor/types';

export const useTreeBuilderStore = defineStore('related-tree-builder', () => {
    const itemDataStore = useItemDataStore();
    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();

    /**
     * 响应式地构建完整的相关内容树，供UI使用
     */
    const relatedData = computed((): TreeNode[] => {
        // 清理无效的派生内容
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        derivedContentStore.plotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        derivedContentStore.analysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        const buildDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[]): TreeNode[] => {
            return directoryStore.directoryData.map(volume => {
                // 查找与此卷直接相关的派生项
                const derivedForVolume = dataArray
                    .filter(item => item.sourceId === volume.id)
                    .map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }));

                // 为此卷下的章节查找派生项并分组
                const derivedForChapters = volume.chapters
                    .map(chapter => {
                        const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                        if (derivedForChapter.length === 0) return null;

                        return {
                            id: `${type}_ch_group_${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            isReadOnly: true,
                            children: derivedForChapter.map(item => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                originalData: item,
                                content: item.content
                            }))
                        };
                    })
                    .filter((c): c is TreeNode => c !== null);

                // 如果该卷及其章节都没有派生内容，则不显示该卷的节点
                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `${type}_vol_group_${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    isReadOnly: true,
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v): v is TreeNode => v !== null);
        };

        const allPlotItems = derivedContentStore.plotItems;
        const allAnalysisItems = derivedContentStore.analysisItems;

        const plotTree: RootNode = {
            id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
            children: [
                ...itemDataStore.plotCustomData,
                ...buildDerivedContentTree('plot', allPlotItems)
            ]
        };
        const analysisTree: RootNode = {
            id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
            children: [
                ...itemDataStore.analysisCustomData,
                ...buildDerivedContentTree('analysis', allAnalysisItems)
            ]
        };
        const othersTree: RootNode = {
            id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
            children: [
                ...promptTemplateStore.templates,
                ...itemDataStore.othersCustomData
            ]
        };

        return [...itemDataStore.settingsData, plotTree, analysisTree, othersTree];
    });

    return {
        relatedData,
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { useItemDataStore } from '@novel/editor/stores/related/itemDataStore';
import { useTreeBuilderStore } from '@novel/editor/stores/related/treeBuilderStore';
import { useNodeOperationStore } from '@novel/editor/stores/related/nodeOperationStore';
import { useOverviewStore } from '@novel/editor/stores/related/overviewStore';
import { usePromptTemplateStore } from './promptTemplateStore';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    // 实例化所有子模块
    const itemDataStore = useItemDataStore();
    const treeBuilderStore = useTreeBuilderStore();
    const nodeOperationStore = useNodeOperationStore();
    const promptTemplateStore = usePromptTemplateStore();

    // 初始化总览内容的监听逻辑
    useOverviewStore();

    // --- State & Computed ---
    // 从子模块中导出状态和计算属性
    const settingsData = computed(() => itemDataStore.settingsData);
    const plotCustomData = computed(() => itemDataStore.plotCustomData);
    const analysisCustomData = computed(() => itemDataStore.analysisCustomData);
    const othersCustomData = computed(() => itemDataStore.othersCustomData);
    const relatedData = computed(() => treeBuilderStore.relatedData);

    // --- Actions ---

    function fetchRelatedData(settings: any[], plot: any[], analysis: any[], others: any[]) {
        // 访问 promptTemplates 计算属性以确保其被初始化
        const _ = promptTemplateStore.templates;
        itemDataStore.fetchRelatedData(settings, plot, analysis, others);
    }

    const {
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
        addPrompt,
        renamePrompt,
        deletePrompt,
    } = nodeOperationStore;

    return {
        // State & Computed
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        // Actions
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
        addPrompt,
        renamePrompt,
        deletePrompt,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { useReferenceStore } from './referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    const performSearch = (query: string) => {
        results.value = [];
        hasSearched.value = true;
        lastSearchedQuery.value = query;

        if (!query || query.trim().length < 1) {
            return;
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();
        const referenceStore = useReferenceStore();

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            if (lowerCaseText.includes(lowerCaseQuery)) {
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }

                const result = resultsMap.get(item.id)!;
                const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
                let match;
                while ((match = regex.exec(textContent)) !== null) {
                    if (result.matches.length >= 5) break; // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    result.matches.push({ context: `...${context}...` });
                }
            }
        };

        directoryStore.directoryData.forEach(vol => vol.chapters.forEach(processItem));

        const flattenRelated = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenRelated(node.children);
            });
        };
        flattenRelated(relatedContentStore.settingsData);
        flattenRelated(relatedContentStore.plotCustomData);
        flattenRelated(relatedContentStore.analysisCustomData);
        flattenRelated(referenceStore.referenceData); // Search in reference books

        notesStore.notes.forEach(processItem);

        results.value = Array.from(resultsMap.values());
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\app.ts
//

// 文件: src/novel/editor/types/app.ts

import type { TreeNode, Volume, Chapter, NoteItem, PlotAnalysisItem } from './models';

/**
 * AI 任务状态
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'applied';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string; // 新增：源文档标题快照
    sourceItemContent: string; // 新增：源文档内容快照
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string; // 此处targetItemId即为sourceItemId
    title: string;
}

/**
 * 上下文预设或已选择的条目
 */
export interface ContextItem {
    id:string;
    category: '设定' | '其他';
    group: string;
    title:string;
    description: string;
    content: string;
}

/**
 * buildContextForTask 方法的返回结果
 */
export interface ContextBuildResult {
    fixed: string;
    dynamic: string;
    rag: string;
    prompt: string;
    stats: {
        fixedCharCount: number;
        dynamicCharCount: number;
        ragCharCount: number;
        promptCharCount: number;
    };
}

/**
 * 动态上下文的配置项
 */
export interface DynamicContextSettings {
    prevVolumes: number;
    nextVolumes: number;
    prevChapters: number;
    nextChapters: number;
    includeVolumePlot: boolean;
    includeVolumeAnalysis: boolean;
    includeRelatedPlot: boolean;
    includeRelatedAnalysis: boolean;
}

/**
 * 编辑器UI状态
 * 用于定义 uiStore 中的 uiState
 */
export interface EditorUIState {
    expandedNodeIds: Set<string>;
    expandedRelatedNodeIds: Set<string>;
    expandedReferenceNodeIds: Set<string>;
    autoOpenAIPanel: boolean;
    activeTheme: 'default' | 'eye-care' | 'dark';
    concurrentTaskLimit: number;
    taskApplicationStrategy: {
        mode: 'manual' | 'auto' | 'delayed';
        delaySeconds: number;
    };
}

/**
 * 编辑器窗格定义
 */
export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

/**
 * 系统视图信息，用于在内容区打开非文件类标签页
 */
export interface SystemViewInfo {
    id: string; // e.g., 'system:search'
    type: 'system';
    component: 'SearchView' | 'AIChatView' | 'AITaskPanel' | 'EditorSettings' | 'ContextSettings' | 'TaskSettings' | 'AIConfigSettings' | 'NovelSettings' | 'HistoryPanel' | 'ReaderPanel' | 'ThemeSettings';
    title: string;
    icon: string;
    content?: null; // 系统视图没有 content 属性
    targetItemId?: string; // For dynamic views like history
}

/**
 * 任意可被编辑器打开的条目
 * 这是一个辨识联合类型，涵盖了所有可能在标签页中打开的内容。
 */
export type EditorItem = Volume | Chapter | TreeNode | NoteItem | SystemViewInfo | PlotAnalysisItem;

/**
 * 搜索结果条目
 */
export interface SearchResult {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
    matches: { context: string }[];
}

/**
 * 标签页信息
 */
export interface TabInfo {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//


export * from './models';
export * from './app';
export * from './chatTypes';
export * from './ui';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: ReferenceContentNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    content: string;
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: src/novel/editor/utils/iconUtils.ts

const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\editor\views\EditorWorkspaceView.vue
//

<template>
  <div class="editor-workspace-view">
    <div class="main-area">
      <ActivityBar
          :active-tab-id="activeActivityBarTab"
          :is-sidebar-visible="isSidebarVisible"
          @select-tab="handleSelectActivityTab"
          @trigger-action="handleTriggerAction"
          @show-manage-menu="showManageMenu"
      />
      <template v-if="isSidebarVisible">
        <div class="sidebar-wrapper" :style="{ width: sidebarPanelWidth + 'px' }">
          <SidebarPanel :active-tab-id="activeActivityBarTab" />
        </div>
        <div class="resizer" @mousedown.prevent="startResize"></div>
      </template>

      <MainPane />
    </div>
    <StatusBar />
    <ManageMenu ref="manageMenuRef" @select-action="handleMenuAction" />
  </div>
</template>
<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import { useRoute } from 'vue-router';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import ActivityBar from '@/novel/editor/components/layout/ActivityBar.vue';
import SidebarPanel from '@/novel/editor/components/sidebar/SidebarPanel.vue';
import MainPane from '@/novel/editor/components/content/MainPane.vue';
import StatusBar from '@/novel/editor/components/layout/StatusBar.vue';
import ManageMenu from '@/novel/editor/components/layout/ManageMenu.vue';

type ActivityTabId = 'directory' | 'related' | 'notes' | 'references';
type ActionId = 'system:search' | 'system:ai_chat' | string;

const editorStore = useEditorStore();
const uiStore = useUIStore();
const route = useRoute();

const activeActivityBarTab = ref<ActivityTabId | null>('directory');
const isSidebarVisible = ref(true);
const manageMenuRef = ref<InstanceType<typeof ManageMenu> | null>(null);

// --- Resizing Logic ---
const sidebarPanelWidth = ref(320);
const isResizing = ref(false);

const startResize = (event: MouseEvent) => {
  isResizing.value = true;
  const startWidth = sidebarPanelWidth.value;
  const startX = event.clientX;

  const handleResize = (e: MouseEvent) => {
    if (!isResizing.value) return;
    const dx = e.clientX - startX;
    const newWidth = startWidth + dx;
    sidebarPanelWidth.value = Math.max(240, Math.min(newWidth, 600));
  };

  const stopResize = () => {
    isResizing.value = false;
    window.removeEventListener('mousemove', handleResize);
    window.removeEventListener('mouseup', stopResize);
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  };

  window.addEventListener('mousemove', handleResize);
  window.addEventListener('mouseup', stopResize);
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
};

const handleSelectActivityTab = (tabId: ActivityTabId) => {
  if (activeActivityBarTab.value === tabId && isSidebarVisible.value) {
    isSidebarVisible.value = false;
    activeActivityBarTab.value = null;
  } else {
    isSidebarVisible.value = true;
    activeActivityBarTab.value = tabId;
  }
};

const handleTriggerAction = (actionId: ActionId) => {
  editorStore.openTab(actionId);
}

const showManageMenu = (event: MouseEvent) => {
  manageMenuRef.value?.show(event.currentTarget as HTMLElement);
};

const handleMenuAction = (actionId: ActionId) => {
  if (actionId.startsWith('system:')) {
    editorStore.openTab(actionId);
  } else {
    // Handle other menu actions like 'keyboard_shortcuts' etc.
    alert(`Action '${actionId}' selected. Implementation pending.`);
  }
};

onMounted(() => {
  const novelId = route.query.id as string;
  if (novelId) {
    editorStore.fetchNovelData(novelId);
  } else {
    // Fallback or error handling
    console.warn("No novel ID provided in URL, loading default or showing error.");
    editorStore.fetchNovelData('novel-1'); // Fallback to a default novel
  }
});

onBeforeUnmount(() => {
  // A safeguard to ensure listeners are removed if component is unmounted during resize
  if (isResizing.value) {
    const emptyFn = () => {};
    window.removeEventListener('mousemove', emptyFn);
    window.removeEventListener('mouseup', emptyFn);
  }
});
</script>
<style scoped>
.editor-workspace-view {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background-color: #F9FAFB;
}
.main-area {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
}
.sidebar-wrapper {
  flex-shrink: 0;
  height: 100%;
}
.resizer {
  width: 5px;
  background-color: transparent;
  cursor: col-resize;
  flex-shrink: 0;
  position: relative;
  transition: background-color 0.2s ease;
}
.resizer:hover {
  background-color: #3B82F6;
}
.resizer::before {
  content: '';
  position: absolute;
  left: 2px;
  top: 0;
  width: 1px;
  height: 100%;
  background-color: #E5E7EB;
}
.resizer:hover::before {
  background-color: transparent;
}
</style>

// =
// 文件: ..\src\novel\editor\views\ReaderModeOverlay.vue
//

<template>
  <div v-if="isVisible" class="reader-overlay-container" :class="themeClass">
    <header class="reader-header">
      <button @click="uiStore.hideReaderMode()" class="back-button">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M15 19l-7-7 7-7"></path></svg>
        <span>返回编辑器</span>
      </button>
    </header>
    <main class="reader-main">
      <div v-if="item && 'content' in item" class="max-w-3xl mx-auto reader-content" v-html="item.content">
      </div>
      <div v-else class="max-w-3xl mx-auto text-center py-20 text-gray-500">
        <h1 class="text-2xl font-bold mb-4">无法加载阅读内容</h1>
        <p>此内容不支持阅读模式，或文档不存在。</p>
      </div>
    </main>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useUIStore } from '@novel/editor/stores/uiStore.ts';

const uiStore = useUIStore();

const isVisible = computed(() => uiStore.isReaderModeVisible);
const item = computed(() => uiStore.readerModeItem);

const themeClass = computed(() => {
  if (uiStore.uiState.activeTheme === 'default') return '';
  return `theme-${uiStore.uiState.activeTheme}`;
});

</script>

<style scoped>
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&display=swap');

.reader-overlay-container {
  position: fixed;
  inset: 0;
  z-index: 2000;
  background-color: #FDFCF9;
  color: #3a2f2f;
  display: flex;
  flex-direction: column;
  font-family: 'Noto Serif SC', serif;
}

.reader-header {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  padding: 1rem 1.5rem;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  z-index: 10;
}

.reader-overlay-container:hover .reader-header {
  opacity: 1;
}

.back-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  font-size: 0.875rem;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-weight: 500;
  background-color: rgba(255, 255, 255, 0.6);
  backdrop-filter: blur(8px);
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  border: 1px solid #E5E7EB;
  color: #374151;
  transition: background-color 0.2s;
}

.back-button:hover {
  background-color: rgba(255, 255, 255, 0.9);
}

.reader-main {
  flex-grow: 1;
  overflow-y: auto;
  padding: 4rem 1rem;
}

:deep(.reader-content h1) {
  font-family: 'Noto Serif SC', serif;
  font-size: 2.25rem;
  font-weight: 600;
  margin-bottom: 2.5rem;
  color: #1f2937;
  letter-spacing: 0.05em;
  padding-bottom: 1rem;
  border-bottom: 1px solid rgba(0,0,0,0.05);
  text-align: center;
}
:deep(.reader-content p) {
  font-family: 'Noto Serif SC', serif;
  font-size: 1.125rem;
  line-height: 2.2;
  color: #374151;
  margin-bottom: 1.75rem;
  text-align: justify;
}

.theme-dark {
  background-color: #18181b;
  color: #e4e4e7;
}

.theme-dark .back-button {
  background-color: rgba(39, 39, 42, 0.6);
  border-color: #3f3f46;
  color: #e4e4e7;
}

.theme-dark .back-button:hover {
  background-color: rgba(39, 39, 42, 0.9);
}

:deep(.theme-dark .reader-content h1) {
  color: #f4f4f5;
  border-bottom-color: rgba(255,255,255,0.1);
}

:deep(.theme-dark .reader-content p) {
  color: #d4d4d8;
}

</style>

// =
// 文件: ..\src\novel\editor\views\SearchView.vue
//

<template>
  <div class="search-view-container">
    <div class="search-header">
      <div class="search-bar">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>
        <input
            v-model="searchStore.searchQuery"
            type="text"
            placeholder="在所有文档中搜索..."
            class="search-input"
        />
        <button v-if="searchStore.searchQuery" @click="searchStore.clearSearch" class="clear-button" title="清空搜索">
          <i class="fa-solid fa-times"></i>
        </button>
      </div>
    </div>

    <div class="results-container">
      <div v-if="searchStore.results.length > 0">
        <div v-for="result in searchStore.results" :key="result.id" class="result-group">
          <div @click="toggleExpansion(result.id)" class="result-header">
            <div class="flex items-center gap-3 min-w-0">
              <i class="fa-solid fa-chevron-right expand-icon" :class="{ 'expanded': expandedResultIds.has(result.id) }"></i>
              <i :class="[result.icon, 'text-base']"></i>
              <span class="font-medium truncate">{{ result.title }}</span>
            </div>
            <span class="match-count">{{ result.matches.length }}个匹配</span>
          </div>
          <ul v-show="expandedResultIds.has(result.id)" class="match-list">
            <li
                v-for="(match, index) in result.matches"
                :key="index"
                @click="handleResultClick(result.id)"
                class="match-item"
                v-html="match.context"
            >
            </li>
          </ul>
        </div>
      </div>
      <div v-else-if="searchStore.hasSearched" class="empty-state">
        <i class="fa-regular fa-face-sad-tear text-4xl text-gray-400"></i>
        <p class="mt-4 text-gray-500">未找到与 "{{ searchStore.lastSearchedQuery }}" 相关的内容。</p>
      </div>
      <div v-else class="empty-state">
        <i class="fa-solid fa-text-slash text-4xl text-gray-300"></i>
        <p class="mt-4 text-gray-500">输入关键词开始搜索。</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { useSearchStore } from '@novel/editor/stores/searchStore.ts';
import { useEditorStore } from '@novel/editor/stores/editorStore.ts';

const searchStore = useSearchStore();
const editorStore = useEditorStore();
const expandedResultIds = ref(new Set<string>());

let debounceTimer: number | undefined;

watch(() => searchStore.searchQuery, (newQuery) => {
  clearTimeout(debounceTimer);
  if (!newQuery.trim()) {
    searchStore.clearSearch();
    return;
  }
  debounceTimer = window.setTimeout(() => {
    expandedResultIds.value.clear(); // Clear old expansions
    searchStore.performSearch(newQuery);
    // Do not auto-expand results to match the new UI. Let the user decide.
  }, 300); // 300ms debounce delay
});

const handleResultClick = (itemId: string) => {
  editorStore.openTab(itemId);
};

const toggleExpansion = (resultId: string) => {
  if (expandedResultIds.value.has(resultId)) {
    expandedResultIds.value.delete(resultId);
  } else {
    expandedResultIds.value.add(resultId);
  }
};
</script>

<style scoped>
.search-view-container { display: flex; flex-direction: column; height: 100%; background-color: #FFFFFF; }
.search-header { display: flex; gap: 0.75rem; padding: 1.5rem 2rem; border-bottom: 1px solid #E5E7EB; flex-shrink: 0; align-items: center; }
.search-bar { position: relative; flex-grow: 1; }
.search-icon { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; }
.search-input { width: 100%; background-color: #F9FAFB; border: 1px solid #D1D5DB; border-radius: 0.5rem; padding: 0.75rem 2.5rem 0.75rem 2.75rem; font-size: 1rem; outline: none; transition: all 0.2s; }
.search-input:focus { border-color: #3B82F6; background-color: #FFFFFF; box-shadow: 0 0 0 1px #3B82F6; }
.clear-button { position: absolute; right: 1rem; top: 50%; transform: translateY(-50%); color: #9CA3AF; width: 1.75rem; height: 1.75rem; display: flex; align-items: center; justify-content: center; border-radius: 99px; cursor: pointer; }
.clear-button:hover { background-color: #E5E7EB; color: #4B5563; }
.results-container { flex-grow: 1; overflow-y: auto; padding: 1.5rem 2rem; }
.result-group { margin-bottom: 0.75rem; }
.result-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; background-color: #F9FAFB; transition: background-color 0.2s; }
.result-header:hover { background-color: #F3F4F6; }
.expand-icon { transition: transform 0.2s ease; color: #9CA3AF; }
.expand-icon.expanded { transform: rotate(90deg); }
.match-count { margin-left: auto; font-size: 0.75rem; background-color: #E5E7EB; color: #4B5563; padding: 0.125rem 0.5rem; border-radius: 99px; flex-shrink: 0; }
.match-list { padding-left: 2rem; margin-top: 0.5rem; border-left: 1px solid #F3F4F6; margin-left: 0.9rem; }
.match-item { font-size: 0.875rem; color: #6B7280; padding: 0.6rem; border-radius: 0.375rem; cursor: pointer; line-height: 1.6; }
.match-item:hover { background-color: #F3F4F6; color: #1F2937; }
.match-item :deep(mark) { background-color: #FEF3C7; color: #92400E; font-weight: 600; padding: 1px 0; border-radius: 2px; }
.empty-state { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 2rem; }
.results-container { scrollbar-width: thin; scrollbar-color: #D1D5DB #ffffff; }
.results-container::-webkit-scrollbar { width: 6px; }
.results-container::-webkit-scrollbar-track { background: transparent; }
.results-container::-webkit-scrollbar-thumb { background-color: #D1D5DB; border-radius: 3px; }
</style>

// =
// 文件: ..\src\novel\importer\services\novelParser.ts
//

import type { Volume, Chapter } from '@/novel/editor/types';

/**
 * 将纯文本段落转换为带<p>标签的HTML字符串
 * @param text - 输入的文本
 * @returns HTML格式的字符串
 */
const textToHtmlParagraphs = (text: string): string => {
    return text.split('\n').map(p => p.trim()).filter(p => p).map(p => `<p>${p}</p>`).join('');
};

/**
 * 解析小说文本并根据选项进行分章和分卷
 * @param text - 要解析的小说全文
 * @param options - 解析选项
 * @returns 返回一个卷数组，可直接用于创建新的小说项目
 */
export const parseNovelText = (
    text: string,
    options: { chaptersPerVolume: number }
): Volume[] => {
    // 1. 按空行（一个或多个换行符，中间可能包含空格）分割成章节内容块
    const chapterContents = text.split(/\n\s*\n/).filter(content => content.trim() !== '');

    // 2. 将内容块转换为章节对象
    const allChapters: Chapter[] = chapterContents.map((content, index) => {
        const lines = content.trim().split('\n');
        const title = lines[0]?.trim() || `第 ${index + 1} 章`;
        const bodyText = lines.slice(1).join('\n').trim();
        const bodyHtml = textToHtmlParagraphs(bodyText);

        return {
            id: `ch-imported-${Date.now()}-${index}`,
            type: 'chapter',
            title: title,
            wordCount: content.trim().length,
            content: `<h1>${title}</h1>${bodyHtml}`,
            status: 'completed'
        };
    });

    // 3. 将章节按指定数量分组到卷中
    const volumes: Volume[] = [];
    const { chaptersPerVolume } = options;
    let volumeIndex = 1;

    for (let i = 0; i < allChapters.length; i += chaptersPerVolume) {
        const chapterChunk = allChapters.slice(i, i + chaptersPerVolume);
        const volume: Volume = {
            id: `vol-imported-${Date.now()}-${volumeIndex}`,
            type: 'volume',
            title: `第 ${volumeIndex} 卷`,
            content: `<h1>第 ${volumeIndex} 卷</h1><p>该卷由导入功能自动创建，包含 ${chapterChunk.length} 个章节。</p>`,
            chapters: chapterChunk,
        };
        volumes.push(volume);
        volumeIndex++;
    }

    // 如果没有任何内容，则创建一个默认的空卷
    if (volumes.length === 0) {
        volumes.push({
            id: `vol-imported-${Date.now()}-1`,
            type: 'volume',
            title: '第一卷',
            content: '<h1>第一卷</h1><p>未从文件中解析出任何章节。</p>',
            chapters: [],
        });
    }

    return volumes;
};

// =
// 文件: ..\src\novel\layouts\NovelChatLayout.vue
//

// =
// 文件: ..\src\novel\layouts\NovelChatLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame">
      <!-- 顶部导航栏: 恢复为与其他模块一致的标准页头 -->
      <header class="h-[56px] bg-white border-b border-gray-100 flex items-center px-6 flex-shrink-0">
        <div class="flex items-center gap-2 flex-1">
          <router-link to="/novel/dashboard" class="flex items-center gap-2 text-gray-500 hover:text-gray-800 transition-colors p-2 -ml-2 rounded-lg">
            <i class="fa-solid fa-chevron-left w-4 h-4"></i>
            <span>返回</span>
          </router-link>
          <span class="text-gray-300">/</span>
          <span class="font-medium text-gray-800 text-sm">AI 聊天助手</span>
        </div>
        <div class="flex items-center gap-4">
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors">
            <i class="fa-solid fa-search w-5 h-5"></i>
          </button>
          <button class="p-2 text-gray-500 hover:bg-gray-100 rounded-lg transition-colors relative">
            <i class="fa-solid fa-bell w-5 h-5"></i>
            <span class="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full border border-white"></span>
          </button>
          <div class="ml-2 flex items-center gap-3">
            <img src="https://i.pravatar.cc/150?u=creator" alt="Creator Avatar" class="w-9 h-9 rounded-full">
            <div>
              <p class="text-sm font-medium text-[#374151]">创作者</p>
              <p class="text-xs text-[#9CA3AF]">在线</p>
            </div>
          </div>
        </div>
      </header>

      <!-- 内容区域，填充剩余高度 -->
      <div class="h-[calc(100%-56px)]">
        <router-view />
      </div>
    </div>

    <!-- 全局组件 -->
    <GlobalAIAssistant />
    <AITaskConfigModal />
  </div>
</template>

<script setup lang="ts">
import GlobalAIAssistant from '@/novel/shared/components/GlobalAIAssistant/index.vue';
import AITaskConfigModal from '@/novel/shared/components/GlobalAIAssistant/AITaskConfigModal.vue';
import '@/novel/assets/styles/main.css';
</script>

<style scoped>
/* 恢复为与其他模块一致的标准外部框架样式 */
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
  display: flex;
  flex-direction: column;
}
</style>

// =
// 文件: ..\src\novel\layouts\NovelDashboardLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame">
      <div class="h-10 px-5 flex items-center border-b border-gray-100 bg-gray-50 flex-shrink-0">
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 rounded-full bg-[#FF5F57]"></div>
          <div class="w-3 h-3 rounded-full bg-[#FFBD2E]"></div>
          <div class="w-3 h-3 rounded-full bg-[#28CA42]"></div>
        </div>
        <div class="ml-auto flex items-center gap-4 text-xs text-gray-400">
          <span>AI Creator Platform</span>
        </div>
      </div>
      <div class="h-[calc(100%-40px)] flex">
        <NovelDashboardSidebar />
        <main class="flex-1 bg-white flex flex-col overflow-hidden">
          <AppHeader />
          <router-view />
        </main>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import AppHeader from '@/layouts/components/AppHeader.vue'
import NovelDashboardSidebar from '@/novel/dashboard/components/NovelDashboardSidebar.vue'
import '@/novel/assets/styles/main.css'
</script>

<style scoped>
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
}
</style>

// =
// 文件: ..\src\novel\layouts\NovelManagementLayout.vue
//

<template>
  <div class="h-screen w-screen flex bg-white design-frame-container">
    <div class="design-frame">
      <div class="h-10 px-5 flex items-center border-b border-gray-100 bg-gray-50 flex-shrink-0">
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 rounded-full bg-[#FF5F57]"></div>
          <div class="w-3 h-3 rounded-full bg-[#FFBD2E]"></div>
          <div class="w-3 h-3 rounded-full bg-[#28CA42]"></div>
        </div>
        <div class="ml-auto flex items-center gap-4 text-xs text-gray-400">
          <span>AI Creator Platform</span>
        </div>
      </div>
      <div class="h-[calc(100%-40px)] flex">
        <NovelManagementSidebar />
        <main class="flex-1 bg-white flex flex-col overflow-hidden">
          <!-- 使用与全局一致的 AppHeader -->
          <AppHeader />
          <router-view />
        </main>
      </div>
    </div>
    <!-- [修复] 将全局组件放在布局的顶层 -->
    <GlobalAIAssistant />
    <AITaskConfigModal />
  </div>
</template>

<script setup lang="ts">
import AppHeader from '@/layouts/components/AppHeader.vue'
import NovelManagementSidebar from '@/novel/management/components/NovelManagementSidebar.vue'
import GlobalAIAssistant from "@/novel/shared/components/GlobalAIAssistant/index.vue";
import AITaskConfigModal from '@/novel/shared/components/GlobalAIAssistant/AITaskConfigModal.vue'
import '@/novel/assets/styles/main.css'
</script>

<style scoped>
.design-frame-container {
  padding: 2rem;
  background-color: #f5f5f7;
}
.design-frame {
  width: 100%;
  height: 100%;
  max-width: 1800px;
  margin: auto;
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.08);
}
</style>

// =
// 文件: ..\src\novel\router.ts
//

import type { RouteRecordRaw } from 'vue-router'
import { dashboardRoutes } from './dashboard/router'
import { editorRoutes } from './editor/router'

export const novelRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel',
        component: () => import('@/novel/layouts/NovelDashboardLayout.vue'),
        redirect: '/novel/dashboard',
        children: [
            ...dashboardRoutes
        ]
    },
    ...editorRoutes,
]

// =
// 文件: ..\src\novel\types\index.ts
//


/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}


/**
 * 小说标签定义
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说状态定义
 */
export interface NovelStatus {
    text: '编辑中' | '待审核' | '已驳回' | '已发布';
    class: string;
}

/**
 * 小说分类的类型别名
 */
export type NovelCategory = '科幻' | '奇幻' | '悬疑' | '恐怖' | '都市' | '言情' | '历史';


/**
 * 小说核心数据结构
 */
export interface Novel {
    id: string;
    title: string;
    description: string;
    cover: string;
    status: NovelStatus;
    tags: NovelTag[];
    chapters: number;
    lastUpdated: string;
    category: NovelCategory;
    deletedAt?: string;
}

