// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\api\apiManagementApi.ts
//

export interface ApiProvider {
    name: string;
    shortName: string;
    description: string;
    statusText: string;
    statusClass: string;
    activeKeys: number;
    totalCalls: string;
}

export interface ApiKey {
    id: number;
    provider: string;
    providerShort: string;
    name: string;
    keyFragment: string;
    model: string;
    calls: string;
    status: '启用' | '暂停';
    created: string;
    baseUrl?: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

export interface ModalProvider {
    name: string;
    shortName: string;
    description: string;
}

// --- Mock Data Store ---
const mockApiProviders: ApiProvider[] = [
    { name: 'OpenAI', shortName: 'OA', description: 'GPT系列模型', statusText: '2个密钥', statusClass: 'status-active', activeKeys: 2, totalCalls: '15,677' },
    { name: 'Claude', shortName: 'CL', description: 'Anthropic AI', statusText: '1个密钥', statusClass: 'status-active', activeKeys: 1, totalCalls: '8,912' },
    { name: 'Azure OpenAI', shortName: 'AZ', description: 'Microsoft Azure', statusText: '未配置', statusClass: 'status-unconfigured', activeKeys: 0, totalCalls: '0' },
    { name: 'Google AI', shortName: 'GG', description: 'Gemini系列', statusText: '未配置', statusClass: 'status-unconfigured', activeKeys: 0, totalCalls: '0' },
    { name: 'Mistral', shortName: 'MS', description: 'Mistral AI', statusText: '未配置', statusClass: 'status-unconfigured', activeKeys: 0, totalCalls: '0' },
    { name: 'Cohere', shortName: 'CO', description: 'Command系列', statusText: '未配置', statusClass: 'status-unconfigured', activeKeys: 0, totalCalls: '0' },
];

const mockApiKeys: ApiKey[] = [
    { id: 1, provider: 'OpenAI', providerShort: 'OA', name: '生产环境密钥 (GPT-4)', keyFragment: 'sk-••••1a2b', model: 'gpt-4-turbo', calls: '12,456', status: '启用', created: '2024-03-01', temperature: 0.7, maxTokens: 4096, description: '用于生产环境的高性能GPT-4模型。' },
    { id: 2, provider: 'OpenAI', providerShort: 'OA', name: '测试环境密钥 (GPT-3.5)', keyFragment: 'sk-••••3c4d', model: 'gpt-3.5-turbo', calls: '3,221', status: '暂停', created: '2024-05-15', temperature: 0.8, maxTokens: 2048, description: '用于内部测试的快速响应模型。' },
    { id: 3, provider: 'Claude', providerShort: 'CL', name: '主密钥 (Opus)', keyFragment: 'sk-ant-••••5e6f', model: 'claude-3-opus-20240229', calls: '8,912', status: '启用', created: '2024-04-10', temperature: 0.5, maxTokens: 4096, description: '具备强大分析能力的Claude 3 Opus模型。' },
];

const mockModalProviders: ModalProvider[] = [
    { name: 'OpenAI', shortName: 'OA', description: 'GPT系列' },
    { name: 'Claude', shortName: 'CL', description: 'Anthropic' },
    { name: 'Azure', shortName: 'AZ', description: 'Microsoft' },
    { name: 'Google AI', shortName: 'GG', description: 'Gemini' },
    { name: 'Mistral', shortName: 'MS', description: 'Mistral AI' },
    { name: 'Cohere', shortName: 'CO', description: 'Command' },
];


// --- API Functions ---
export const fetchApiProviders = (): Promise<ApiProvider[]> => {
    return new Promise(resolve => setTimeout(() => resolve(JSON.parse(JSON.stringify(mockApiProviders))), 300));
};

export const fetchModalProviders = (): Promise<ModalProvider[]> => {
    return new Promise(resolve => setTimeout(() => resolve(JSON.parse(JSON.stringify(mockModalProviders))), 200));
}

export const fetchApiKeys = (): Promise<ApiKey[]> => {
    return new Promise(resolve => setTimeout(() => resolve(JSON.parse(JSON.stringify(mockApiKeys))), 400));
};

export const addApiKey = (newKeyData: Omit<ApiKey, 'id' | 'keyFragment' | 'calls' | 'created'> & {key: string}): Promise<ApiKey> => {
    return new Promise(resolve => {
        setTimeout(() => {
            const newId = Math.max(...mockApiKeys.map(k => k.id), 0) + 1;
            const newApiKey: ApiKey = {
                id: newId,
                provider: newKeyData.provider,
                providerShort: newKeyData.providerShort,
                name: newKeyData.name,
                keyFragment: `${newKeyData.key.substring(0, 5)}••••${newKeyData.key.substring(newKeyData.key.length - 4)}`,
                model: newKeyData.model,
                baseUrl: newKeyData.baseUrl,
                calls: '0',
                status: newKeyData.status,
                created: new Date().toISOString().split('T')[0],
                temperature: newKeyData.temperature,
                maxTokens: newKeyData.maxTokens,
                description: newKeyData.description,
            };
            mockApiKeys.push(newApiKey);
            resolve(newApiKey);
        }, 500);
    });
};

export const updateApiKey = (keyData: Partial<ApiKey> & { id: number }): Promise<ApiKey> => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const index = mockApiKeys.findIndex(k => k.id === keyData.id);
            if (index !== -1) {
                mockApiKeys[index] = { ...mockApiKeys[index], ...keyData };
                resolve(mockApiKeys[index]);
            } else {
                reject(new Error('API Key not found'));
            }
        }, 300);
    });
};

export const deleteApiKey = (keyId: number): Promise<ApiKey> => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const index = mockApiKeys.findIndex(k => k.id === keyId);
            if (index !== -1) {
                const deletedKey = mockApiKeys[index];
                mockApiKeys.splice(index, 1);
                resolve(deletedKey);
            } else {
                reject(new Error('API Key not found'));
            }
        }, 400);
    });
};

// =
// 文件: ..\src\api\authApi.ts
//

import { apiClient } from './client';
import { mockUser, createNewUser } from './userApi';
import type { LoginCredentials, User, RegistrationData } from '@/auth/types';

export const login = (credentials: LoginCredentials): Promise<{ user: User, token: string }> => {
    console.log('Central API: Attempting login with', credentials);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (credentials.email === mockUser.email && credentials.password === '123456') {
                resolve({
                    user: mockUser,
                    token: 'mock-jwt-token-for-admin-123456',
                });
            } else {
                reject(new Error('邮箱或密码错误'));
            }
        }, 1000);
    });
};

export const register = (data: RegistrationData): Promise<{ user: User, token:string }> => {
    return new Promise((resolve) => {
        setTimeout(() => {
            const newUser = createNewUser(data);
            resolve({
                user: newUser,
                token: `mock-jwt-token-for-${data.email}`,
            });
        }, 1000);
    });
};

export const fetchCurrentUser = (): Promise<User> => {
    return new Promise((resolve, reject) => {
        const token = apiClient.defaults.headers.common['Authorization'] || (apiClient.defaults.headers as any)['Authorization'];

        setTimeout(() => {
            if (token && typeof token === 'string' && token.includes('mock-jwt-token')) {
                resolve(mockUser);
            } else {
                reject(new Error('无效或过期的 Token'));
            }
        }, 500);
    });
};

// =
// 文件: ..\src\api\client.ts
//

import axios from 'axios';
import { useAuthStore } from '@/auth/store/auth.store';

const apiClient = axios.create({

});

// 请求拦截器
apiClient.interceptors.request.use(
    (config) => {
        const authStore = useAuthStore();
        const token = authStore.token;

        if (token) {
            // 在每个需要认证的请求头中添加 Bearer Token
            config.headers.Authorization = `Bearer ${token}`;
        }

        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

export default apiClient;

// =
// 文件: ..\src\api\dataPrivacyApi.ts
//

// src/api/dataPrivacyApi.ts

export interface DataCollectionSetting {
    title: string;
    description: string;
    enabled: boolean;
}

export interface DataUsageItem {
    title: string;
    tag: string;
    tagClass: string;
    includes: string;
    purpose: string;
}

export interface DataPermission {
    title: string;
    description: string;
    action: string;
    icon: string;
    containerClass: string;
    iconBgClass: string;
    descClass: string;
    buttonClass: string;
}

const mockDataCollectionSettings: DataCollectionSetting[] = [
    { title: '对话历史', description: '保存您与AI的对话记录以提供更好的服务', enabled: true },
    { title: '使用分析', description: '收集匿名使用数据以改进产品体验', enabled: true },
    { title: '性能监控', description: '收集性能数据以优化系统响应速度', enabled: false },
    { title: '错误报告', description: '自动发送错误报告帮助我们修复问题', enabled: true },
];

const mockDataUsage: DataUsageItem[] = [
    { title: '个人信息', tag: '加密存储', tagClass: 'bg-green-100 text-green-700', includes: '包括：姓名、邮箱、电话号码', purpose: '用途：账户管理、身份验证、客户支持' },
    { title: '对话数据', tag: '端到端加密', tagClass: 'bg-green-100 text-green-700', includes: '包括：对话内容、上传文件、生成结果', purpose: '用途：提供AI服务、改进模型、个性化体验' },
    { title: '使用数据', tag: '匿名化处理', tagClass: 'bg-blue-100 text-blue-700', includes: '包括：功能使用频率、响应时间、错误日志', purpose: '用途：产品改进、性能优化、问题诊断' },
];

const mockDataPermissions: DataPermission[] = [
    { title: '导出数据', description: '下载您的所有个人数据副本', action: '立即导出', icon: `<svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/></svg>`, containerClass: 'border border-gray-200 hover:border-gray-300', iconBgClass: 'bg-blue-100', descClass: 'text-[#6B7280]', buttonClass: 'text-[#3B82F6]' },
    { title: '数据迁移', description: '将数据转移到其他服务', action: '开始迁移', icon: `<svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>`, containerClass: 'border border-gray-200 hover:border-gray-300', iconBgClass: 'bg-green-100', descClass: 'text-[#6B7280]', buttonClass: 'text-[#3B82F6]' },
    { title: '暂停收集', description: '临时停止数据收集活动', action: '暂停收集', icon: `<svg class="w-5 h-5 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>`, containerClass: 'border border-gray-200 hover:border-gray-300', iconBgClass: 'bg-yellow-100', descClass: 'text-[#6B7280]', buttonClass: 'text-[#3B82F6]' },
    { title: '删除数据', description: '永久删除所有数据', action: '请求删除', icon: `<svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>`, containerClass: 'border border-red-200 hover:border-red-300 bg-red-50', iconBgClass: 'bg-red-100', descClass: 'text-red-600', buttonClass: 'text-red-600' },
];

const mockPromises: string[] = [
    '不会出售您的个人数据',
    '仅在必要时与服务提供商共享数据',
    '所有第三方必须遵守我们的隐私标准',
    '您可以随时撤销数据共享许可',
];

export const fetchDataPrivacyData = (): Promise<{
    collectionSettings: DataCollectionSetting[],
    usage: DataUsageItem[],
    permissions: DataPermission[],
    promises: string[]
}> => {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                collectionSettings: JSON.parse(JSON.stringify(mockDataCollectionSettings)),
                usage: JSON.parse(JSON.stringify(mockDataUsage)),
                permissions: JSON.parse(JSON.stringify(mockDataPermissions)),
                promises: JSON.parse(JSON.stringify(mockPromises)),
            });
        }, 300);
    });
};

export const saveDataCollectionSetting = (setting: DataCollectionSetting): Promise<boolean> => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log('Central API: Saving data collection setting', setting);
            const index = mockDataCollectionSettings.findIndex(s => s.title === setting.title);
            if (index !== -1) {
                mockDataCollectionSettings[index] = setting;
            }
            resolve(true);
        }, 200);
    });
};

// =
// 文件: ..\src\api\systemSettingsApi.ts
//

export interface Theme {
    name: string;
    previewClass: string;
}

export interface SettingItem {
    title: string;
    description: string;
    enabled: boolean;
}

export interface SystemSettings {
    activeTheme: string;
    zoomLevel: number;
    language: string;
    dateFormat: string;
    notificationSettings: SettingItem[];
    appSettings: SettingItem[];
}

const mockThemes: Theme[] = [
    { name: '浅色', previewClass: 'bg-white border border-gray-200' },
    { name: '深色', previewClass: 'bg-gray-800 border border-gray-700' },
    { name: '跟随系统', previewClass: 'bg-gradient-to-tr from-white to-gray-800 border border-gray-400' },
];

const mockInitialSettings: SystemSettings = {
    activeTheme: '浅色',
    zoomLevel: 50,
    language: '简体中文',
    dateFormat: 'YYYY-MM-DD',
    notificationSettings: [
        { title: '产品更新', description: '获取关于新功能和改进的通知', enabled: true },
        { title: '使用提醒', description: '接近配额限制时收到提醒', enabled: true },
        { title: '安全警报', description: '异常登录或API使用时立即通知', enabled: true },
        { title: '营销邮件', description: '接收产品推荐和优惠信息', enabled: false },
    ],
    appSettings: [
        { title: '自动保存对话', description: '自动保存所有对话历史', enabled: true },
        { title: '快捷键启用', description: '使用键盘快捷键提高效率', enabled: true },
        { title: '开发者模式', description: '显示高级选项和调试信息', enabled: false },
    ]
};

export const fetchThemes = (): Promise<Theme[]> => {
    return new Promise(resolve => {
        setTimeout(() => resolve(JSON.parse(JSON.stringify(mockThemes))), 200);
    });
};

export const fetchSystemSettings = (): Promise<SystemSettings> => {
    return new Promise(resolve => {
        setTimeout(() => resolve(JSON.parse(JSON.stringify(mockInitialSettings))), 300);
    });
};

export const saveSystemSetting = <T extends keyof SystemSettings>(key: T, value: SystemSettings[T]): Promise<boolean> => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log(`Central API: Saving System Setting -> ${key}:`, value);
            mockInitialSettings[key] = value;
            resolve(true);
        }, 150);
    });
};

// =
// 文件: ..\src\api\usageLogsApi.ts
//

export interface UsageStat {
    label: string;
    value: string;
    icon: string;
    progressColor: string;
    progressWidth: string;
    trend: string;
    trendColor: string;
}

export interface ApiLog {
    id: number;
    timestamp: string;
    endpoint: string;
    model: string;
    tokens: string;
    status: string;
    statusClass: string;
    duration: string;
}

export interface ChartDataPoint {
    label: string;
    requests: number;
    tokens: number;
}

export interface FetchParams {
    period: '日' | '周' | '月';
    model: string;
    status: string;
    page: number;
    limit: number;
}

const mockStats: Record<'日'|'周'|'月', UsageStat[]> = {
    '月': [
        { label: '总请求数', value: '12,564', icon: `<svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"/></svg>`, progressColor: 'bg-blue-500', progressWidth: '75%', trend: '+8.2%', trendColor: 'text-green-600' },
        { label: 'Token 消耗', value: '856K', icon: `<svg class="w-4 h-4 text-purple-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"/></svg>`, progressColor: 'bg-purple-500', progressWidth: '85.6%', trend: '85.6%', trendColor: 'text-[#6B7280]' },
        { label: '平均响应时间', value: '1.2s', icon: `<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-green-500', progressWidth: '25%', trend: '优秀', trendColor: 'text-green-600' },
        { label: '错误率', value: '0.8%', icon: `<svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-red-500', progressWidth: '8%', trend: '-0.2%', trendColor: 'text-red-600' },
    ],
    '周': [
        { label: '总请求数', value: '3,102', icon: `<svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"/></svg>`, progressColor: 'bg-blue-500', progressWidth: '80%', trend: '+5.1%', trendColor: 'text-green-600' },
        { label: 'Token 消耗', value: '210K', icon: `<svg class="w-4 h-4 text-purple-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"/></svg>`, progressColor: 'bg-purple-500', progressWidth: '90%', trend: '21.0%', trendColor: 'text-[#6B7280]' },
        { label: '平均响应时间', value: '1.1s', icon: `<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-green-500', progressWidth: '20%', trend: '优秀', trendColor: 'text-green-600' },
        { label: '错误率', value: '0.5%', icon: `<svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-red-500', progressWidth: '5%', trend: '+0.1%', trendColor: 'text-red-600' },
    ],
    '日': [
        { label: '总请求数', value: '450', icon: `<svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"/></svg>`, progressColor: 'bg-blue-500', progressWidth: '60%', trend: '-2.0%', trendColor: 'text-red-600' },
        { label: 'Token 消耗', value: '35K', icon: `<svg class="w-4 h-4 text-purple-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"/></svg>`, progressColor: 'bg-purple-500', progressWidth: '70%', trend: '3.5%', trendColor: 'text-[#6B7280]' },
        { label: '平均响应时间', value: '1.3s', icon: `<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-green-500', progressWidth: '30%', trend: '良好', trendColor: 'text-yellow-600' },
        { label: '错误率', value: '1.2%', icon: `<svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, progressColor: 'bg-red-500', progressWidth: '12%', trend: '+0.4%', trendColor: 'text-red-600' },
    ]
};

const mockChartData: Record<'日'|'周'|'月', ChartDataPoint[]> = {
    '月': [
        { label: '第1周', requests: 2800, tokens: 200 },
        { label: '第2周', requests: 3102, tokens: 210 },
        { label: '第3周', requests: 3500, tokens: 230 },
        { label: '第4周', requests: 3162, tokens: 216 },
    ],
    '周': [
        { label: '周一', requests: 420, tokens: 28 },
        { label: '周二', requests: 480, tokens: 32 },
        { label: '周三', requests: 510, tokens: 35 },
        { label: '周四', requests: 450, tokens: 30 },
        { label: '周五', requests: 610, tokens: 42 },
        { label: '周六', requests: 330, tokens: 22 },
        { label: '周日', requests: 302, tokens: 21 },
    ],
    '日': [
        { label: '0-4h', requests: 50, tokens: 4 },
        { label: '4-8h', requests: 30, tokens: 2 },
        { label: '8-12h', requests: 150, tokens: 12 },
        { label: '12-16h', requests: 120, tokens: 10 },
        { label: '16-20h', requests: 80, tokens: 6 },
        { label: '20-24h', requests: 20, tokens: 1 },
    ]
};

const mockLogs: ApiLog[] = [
    { id: 1, timestamp: '2024-06-18 10:32:05', endpoint: '/v1/chat/completions', model: 'gpt-4-turbo', tokens: '1,245', status: '成功', statusClass: 'bg-green-100 text-green-700', duration: '1.25s' },
    { id: 2, timestamp: '2024-06-18 10:31:50', endpoint: '/v1/chat/completions', model: 'claude-3-opus', tokens: '2,105', status: '成功', statusClass: 'bg-green-100 text-green-700', duration: '2.01s' },
    { id: 3, timestamp: '2024-06-18 10:30:12', endpoint: '/v1/chat/completions', model: 'gpt-4-turbo', tokens: '0', status: '失败', statusClass: 'bg-red-100 text-red-700', duration: '0.05s' },
    { id: 4, timestamp: '2024-06-18 09:55:41', endpoint: '/v1/chat/completions', model: 'gpt-4-turbo', tokens: '3,012', status: '成功', statusClass: 'bg-green-100 text-green-700', duration: '1.88s' },
    { id: 5, timestamp: '2024-06-18 09:40:22', endpoint: '/v1/chat/completions', model: 'claude-3-opus', tokens: '550', status: '成功', statusClass: 'bg-green-100 text-green-700', duration: '1.50s' },
    { id: 6, timestamp: '2024-06-18 09:30:00', endpoint: '/v1/chat/completions', model: 'gemini-pro', tokens: '1,800', status: '成功', statusClass: 'bg-green-100 text-green-700', duration: '1.32s' },
];


export const fetchUsageData = (params: FetchParams): Promise<{
    stats: UsageStat[],
    logs: ApiLog[],
    chartData: ChartDataPoint[],
    totalLogs: number,
    totalPages: number
}> => {
    return new Promise(resolve => {
        setTimeout(() => {
            let filteredLogs = [...mockLogs];

            if (params.model !== '所有模型') {
                const modelKey = params.model.toLowerCase();
                filteredLogs = filteredLogs.filter(log => log.model.toLowerCase().includes(modelKey));
            }

            if (params.status !== '所有状态') {
                filteredLogs = filteredLogs.filter(log => log.status === params.status);
            }

            const totalLogs = filteredLogs.length;
            const totalPages = Math.ceil(totalLogs / params.limit);

            const paginatedLogs = filteredLogs.slice(
                (params.page - 1) * params.limit,
                params.page * params.limit
            );

            resolve({
                stats: JSON.parse(JSON.stringify(mockStats[params.period])),
                logs: JSON.parse(JSON.stringify(paginatedLogs)),
                chartData: JSON.parse(JSON.stringify(mockChartData[params.period])),
                totalLogs,
                totalPages
            });
        }, 400);
    });
};

// =
// 文件: ..\src\api\userApi.ts
//



import type { User, RegistrationData } from '@/auth/types';
import type { NotificationSetting, SecuritySetting } from '@/settings/api/userApi';

// --- Single Source of Truth for User Data ---

export const mockUser: User = {
    id: '1',
    name: '张小明',
    email: 'admin@example.com',
    avatar: '/path/to/avatar.png',
    plan: '专业版',
    phone: '+86 138****8888',
    region: '中国大陆',
    timezone: 'UTC+8 北京时间',
    bio: '热爱技术，专注于AI和机器学习领域。对新技术充满好奇，享受解决复杂问题的过程。',
};

const mockNotifications: NotificationSetting[] = [
    { id: 1, title: '邮件通知', description: '接收产品更新和重要通知', enabled: true },
    { id: 2, title: '短信通知', description: '账户安全相关的短信提醒', enabled: false },
    { id: 3, title: '营销推送', description: '优惠活动和新功能推荐', enabled: false },
    { id: 4, title: '浏览器通知', description: '在浏览器中接收实时通知', enabled: true },
];

const mockSecuritySettings: SecuritySetting[] = [
    { title: '修改密码', status: '上次修改：2024年3月15日', statusClass: 'text-[#9CA3AF]', action: '修改' },
    { title: '双重验证 (2FA)', status: '未启用', statusClass: 'text-red-500', action: '启用' },
    { title: '登录设备', status: '当前有 3 个活跃设备', statusClass: 'text-[#9CA3AF]', action: '管理' },
    { title: '登录历史', status: '查看最近的登录活动', statusClass: 'text-[#9CA3AF]', action: '查看' },
];

const mockProPlanFeatures: string[] = [
    '每月 50万 tokens',
    'GPT-4 & Claude 3 访问权限',
    '优先响应 & 技术支持'
];

// --- API Functions ---

export const fetchUserSettings = (): Promise<{user: User, notifications: NotificationSetting[], securitySettings: SecuritySetting[], proPlanFeatures: string[]}> => {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                user: JSON.parse(JSON.stringify(mockUser)),
                notifications: JSON.parse(JSON.stringify(mockNotifications)),
                securitySettings: JSON.parse(JSON.stringify(mockSecuritySettings)),
                proPlanFeatures: JSON.parse(JSON.stringify(mockProPlanFeatures)),
            });
        }, 300);
    });
};

export const saveUserSettings = (settings: {
    user: User;
    notifications: NotificationSetting[];
}): Promise<boolean> => {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log('API: Saving User Settings...', settings);

            const u = mockUser as any;
            const s = settings.user as any;
            Object.keys(s).forEach(key => {
                if(key in u) u[key] = s[key];
            });

            settings.notifications.forEach(newNotification => {
                const existingNotification = mockNotifications.find(n => n.id === newNotification.id);
                if (existingNotification) {
                    existingNotification.enabled = newNotification.enabled;
                }
            });

            resolve(true);
        }, 600);
    });
};

export const createNewUser = (data: RegistrationData): User => {
    const newUser: User = {
        id: '2', // In a real app, this would be dynamic
        email: data.email,
        name: `${data.firstName} ${data.lastName}`,
        plan: '免费版',
    };
    // In a real app, you would add this newUser to a user list.
    // For this mock, we just return it.
    console.log("Central API: Creating new user", newUser);
    return newUser;
};

// =
// 文件: ..\src\auth\api\index.ts
//

import * as authApi from '@/api/authApi';
import type { LoginCredentials, User, RegistrationData } from '@/auth/types';

export const login = (credentials: LoginCredentials): Promise<{ user: User, token: string }> => {
    return authApi.login(credentials);
};

export const register = (data: RegistrationData): Promise<{ user: User, token:string }> => {
    return authApi.register(data);
};

export const fetchCurrentUser = (): Promise<User> => {
    return authApi.fetchCurrentUser();
};

// =
// 文件: ..\src\auth\router.ts
//

import type { RouteRecordRaw } from 'vue-router';

export const authRoutes: Array<RouteRecordRaw> = [
    {
        path: '/auth',
        component: () => import('@/auth/layouts/AuthLayout.vue'),
        redirect: '/auth/login',
        children: [
            {
                path: 'welcome',
                name: 'Welcome',
                component: () => import('@/auth/views/Welcome.vue'),
                meta: { title: '欢迎' },
            },
            {
                path: 'login',
                name: 'Login',
                component: () => import('@/auth/views/Login.vue'),
                meta: { title: '登录' },
            },
            {
                path: 'register',
                name: 'Register',
                component: () => import('@/auth/views/Register.vue'),
                meta: { title: '注册' },
            },
            {
                path: 'forgot-password',
                name: 'ForgotPassword',
                component: () => import('@/auth/views/ForgotPassword.vue'),
                meta: { title: '忘记密码' },
            },
        ],
    },
];

// =
// 文件: ..\src\auth\services\auth.service.ts
//

// src/auth/services/auth.service.ts
// 封装认证相关的业务逻辑

import { useRouter } from 'vue-router';
import * as api from '@/auth/api';
import { useAuthStore } from '@/auth/store/auth.store';
import type { LoginCredentials, RegistrationData } from '@/auth/types';

export function useAuthService() {
    const store = useAuthStore();
    const router = useRouter();

    const handleLogin = async (credentials: LoginCredentials) => {
        store.setLoading(true);
        store.setError(null);
        try {
            const { user, token } = await api.login(credentials);
            store.setAuth(user, token);
            await router.push(router.currentRoute.value.query.redirect as string || '/home');
        } catch (error: any) {
            store.setError(error.message || '登录失败，请稍后重试');
            throw error;
        } finally {
            store.setLoading(false);
        }
    };

    const handleRegister = async (data: RegistrationData) => {
        store.setLoading(true);
        store.setError(null);
        try {
            const { user, token } = await api.register(data);
            store.setAuth(user, token);
            await router.push('/home');
        } catch (error: any) {
            store.setError(error.message || '注册失败，请稍后重试');
            throw error;
        } finally {
            store.setLoading(false);
        }
    };

    const handleLogout = () => {
        store.clearAuth();
        router.push('/auth/login');
    };

    const initializeAuth = async () => {
        if (store.token && !store.user) {
            try {
                const user = await api.fetchCurrentUser();
                store.setUser(user);
            } catch (e) {
                // Token 无效或已过期，清理状态并强制登出
                store.clearAuth();
                console.error('Authentication initialization failed, clearing token.');
            }
        }
    };

    return {
        handleLogin,
        handleRegister,
        handleLogout,
        initializeAuth,
    };
}

// =
// 文件: ..\src\auth\store\auth.store.ts
//

// src/auth/store/auth.store.ts
// 使用 Pinia 管理认证状态

import { defineStore } from 'pinia';
import type { User } from '@/auth/types';

interface AuthState {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    error: string | null;
}

export const useAuthStore = defineStore('auth', {
    state: (): AuthState => ({
        user: null,
        token: localStorage.getItem('authToken') || null,
        isAuthenticated: !!localStorage.getItem('authToken'),
        isLoading: false,
        error: null,
    }),

    getters: {
        isLoggedIn: (state): boolean => state.isAuthenticated,
    },

    actions: {
        setAuth(user: User, token: string) {
            this.user = user;
            this.token = token;
            this.isAuthenticated = true;
            this.error = null;
            localStorage.setItem('authToken', token);
        },

        setUser(user: User) {
            this.user = user;
        },

        clearAuth() {
            this.user = null;
            this.token = null;
            this.isAuthenticated = false;
            this.error = null;
            localStorage.removeItem('authToken');
        },

        setLoading(loading: boolean) {
            this.isLoading = loading;
        },

        setError(error: string | null) {
            this.error = error;
        },
    },
});

// =
// 文件: ..\src\auth\types\index.ts
//



/**
 * 用户登录凭证
 */
export interface LoginCredentials {
    email: string;
    password: string;
}

/**
 * 全局统一的用户信息结构
 */
export interface User {
    id: string;
    name: string;
    email: string;
    avatar?: string;
    plan: '免费版' | '专业版';
    phone?: string;
    region?: string;
    timezone?: string;
    bio?: string;
}

/**
 * 用户注册时所需的数据
 */
export interface RegistrationData extends LoginCredentials {
    firstName: string;
    lastName: string;
    termsAccepted: boolean;
}

// =
// 文件: ..\src\home\api\mockDashboardApi.ts
//

import type { Stat, QuickStartAction, RecentProject } from '@/home/types';

const statsData: Stat[] = [
    { label: '作品总数', value: '24', trend: '+12%', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>` },
    { label: '总字数', value: '128.5k', trend: '+8%', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 20L12 10"/><path d="M18 20L18 4"/><path d="M6 20L6 16"/></svg>` },
    { label: 'AI 使用次数', value: '856', trend: '进行中', trendClass: 'text-[#3B82F6] bg-blue-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>` },
    { label: '获得赞赏', value: '342', trend: '+24', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20.84 4.61C20.3 4.07 19.5 3.87 18.75 4.12L5.23 8.62C4.34 8.91 3.75 9.76 3.75 10.72C3.75 11.68 4.34 12.53 5.23 12.82L10.5 14.53L12.21 19.8C12.5 20.69 13.35 21.28 14.31 21.28C15.27 21.28 16.12 20.69 16.41 19.8L20.91 6.28C21.16 5.53 20.96 4.73 20.42 4.19L20.84 4.61Z"/></svg>` },
];

const quickStartActionsData: QuickStartAction[] = [
    { title: '创建新作品', description: '开始全新的创作之旅', icon: `<svg class="text-white" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M12 5V19M5 12H19"/></svg>`, iconBgClass: 'bg-[#4B5563]' },
    { title: 'AI 助手', description: '智能创作伴侣', icon: `<svg class="text-[#4B5563]" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M13 2L3 14H12L11 22L21 10H12L13 2Z"/></svg>`, iconBgClass: 'bg-[#F3F4F6]' },
    { title: '导入文档', description: '继续未完成的创作', icon: `<svg class="text-[#4B5563]" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M7 18C4.5 18 3 16.5 3 14C3 11.5 5 10 7 10C7.3 10 7.5 10 7.8 10.1C8.5 7.2 11 5 14 5C17.3 5 20 7.7 20 11C20 11.3 20 11.7 19.9 12C21.1 12.5 22 13.6 22 15C22 16.9 20.4 18.5 18.5 18.5"/><path d="M12 13V21M15 16L12 13L9 16"/></svg>`, iconBgClass: 'bg-[#F3F4F6]' }
];

const recentProjectsData: RecentProject[] = [
    { title: '星际漫游者', details: '科幻冒险 · 24章 · 2小时前', status: '编辑中', bgClass: 'bg-gradient-to-br from-indigo-100 to-purple-100' },
    { title: '月光下的约定', details: '现代言情 · 18章 · 昨天', status: '暂停', bgClass: 'bg-gradient-to-br from-pink-100 to-rose-100' }
];

export const fetchMockDashboardData = async () => {
    // 模拟网络延迟
    await new Promise(resolve => setTimeout(resolve, 200));
    return Promise.resolve({
        stats: statsData,
        quickStartActions: quickStartActionsData,
        recentProjects: recentProjectsData,
    });
};

// =
// 文件: ..\src\home\services\dashboardService.ts
//

import { fetchMockDashboardData } from '@/home/api/mockDashboardApi';

const getDashboardData = async () => {
    try {
        const data = await fetchMockDashboardData();
        return data;
    } catch (error) {
        console.error("Failed to fetch dashboard data:", error);
        // 返回空状态或默认值，以便UI可以优雅地处理错误
        return {
            stats: [],
            quickStartActions: [],
            recentProjects: [],
        };
    }
}

export const dashboardService = {
    getDashboardData,
}

// =
// 文件: ..\src\home\stores\homeStore.ts
//

// src/home/stores/homeStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Stat, QuickStartAction, RecentProject } from '@/home/types';
import { dashboardService } from '@/home/services/dashboardService';

export const useDashboardStore = defineStore('dashboard', () => {
    // State
    const stats = ref<Stat[]>([]);
    const quickStartActions = ref<QuickStartAction[]>([]);
    const recentProjects = ref<RecentProject[]>([]);
    const isLoading = ref(false);

    // Actions
    async function fetchDashboardData() {
        isLoading.value = true;
        try {
            const data = await dashboardService.getDashboardData();
            stats.value = data.stats;
            quickStartActions.value = data.quickStartActions;
            recentProjects.value = data.recentProjects;
        } catch (error) {
            console.error("Error in store while fetching dashboard data:", error);
            // 在这里可以设置错误状态
        } finally {
            isLoading.value = false;
        }
    }

    return {
        stats,
        quickStartActions,
        recentProjects,
        isLoading,
        fetchDashboardData,
    };
});

// =
// 文件: ..\src\home\types\index.ts
//

// src/home/types/index.ts
// 定义 Home 模块（工作台仪表盘）相关的数据类型

export interface Stat {
    label: string;
    value: string;
    trend: string;
    trendClass: string;
    icon: string;
}

export interface QuickStartAction {
    title: string;
    description: string;
    icon: string;
    iconBgClass: string;
}

export interface RecentProject {
    title: string;
    details: string;
    status: '编辑中' | '暂停';
    bgClass: string;
}

// =
// 文件: ..\src\main.ts
//

import { createApp } from 'vue'
import { createPinia } from 'pinia'

import './styles/main.css'

import App from './App.vue'
import router from './router'
import { useAuthService } from './auth/services/auth.service'

const app = createApp(App)

app.use(createPinia())

// 应用初始化函数
async function initializeApp() {
    const { initializeAuth } = useAuthService();

    // 在挂载应用前，先完成认证状态的初始化
    await initializeAuth();

    // 认证状态确定后再使用路由和挂载应用
    app.use(router)
    app.mount('#app')
}

initializeApp();

// =
// 文件: ..\src\novel\dashboard\config\sidebar.config.ts
//


export interface NavItem {
    name: string;
    path: string;
    icon: string;
}

export const mainNavItems: NavItem[] = [
    {
        name: '我的小说',
        path: '/novel/dashboard',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>`
    },
    {
        name: '最近编辑',
        path: '/novel/recent',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>`
    },
    {
        name: '回收站',
        path: '/novel/trash',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>`
    },
    {
        name: '导出小说',
        path: '/novel/export',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>`
    }
];

// =
// 文件: ..\src\novel\dashboard\data\index.ts
//

// src/novel/dashboard/data/index.ts
import type { NovelDashboardItem, NovelCategory, RecentActivityItem, DeletedItem } from '@/novel/types';

export const mockNovels: NovelDashboardItem[] = [
    {
        id: 'novel-1',
        title: '星际漫游者',
        description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
        cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=800',
        status: { text: '编辑中', class: 'bg-green-500/90' },
        tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }, { text: '冒险', class: 'bg-purple-50 text-purple-700' }],
        chapters: 24,
        lastUpdated: '2小时前',
        category: '科幻'
    },
    {
        id: 'novel-2',
        title: '时间之沙',
        description: '当历史可以被改写，一个历史学家必须阻止一个神秘组织抹去关键的历史事件。',
        cover: 'https://images.unsplash.com/photo-1544947950-fa07a98d237f?q=80&w=800',
        status: { text: '待审核', class: 'bg-yellow-500/90' },
        tags: [{ text: '悬疑', class: 'bg-yellow-50 text-yellow-700' }, { text: '科幻', class: 'bg-blue-50 text-blue-700' }],
        chapters: 15,
        lastUpdated: '昨天',
        category: '悬疑'
    },
    {
        id: 'novel-4',
        title: '都市霓虹',
        description: '一个平凡的程序员意外获得读取他人思想的能力，卷入一场巨大的商业阴谋。',
        cover: 'https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=800',
        status: { text: '已发布', class: 'bg-blue-500/90' },
        tags: [{ text: '都市', class: 'bg-pink-50 text-pink-700' }, { text: '异能', class: 'bg-green-50 text-green-700' }],
        chapters: 102,
        lastUpdated: '1周前',
        category: '都市'
    },
    {
        id: 'novel-5',
        title: '红尘一梦',
        description: '穿越回古代，成为一个不受宠的公主，她如何利用现代知识在宫廷斗争中生存。',
        cover: 'https://images.unsplash.com/photo-1521587760476-6c12a4b040da?q=80&w=800',
        status: { text: '编辑中', class: 'bg-green-500/90' },
        tags: [{ text: '古风', class: 'bg-red-50 text-red-700' }, { text: '言情', class: 'bg-indigo-50 text-indigo-700' }],
        chapters: 56,
        lastUpdated: '5小时前',
        category: '言情'
    }
];

export const mockTrashedItems: DeletedItem[] = [
    {
        id: 'novel-3-deleted',
        name: '深海回响',
        type: '小说',
        icon: '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>',
        deletedAt: '2024-05-18T10:00:00Z',
        retentionDays: 27,
        retentionPercent: 90,
    }
];

export const mockRecentItems: RecentActivityItem[] = [
    {
        id: 'activity-1',
        novelId: 'novel-1',
        novelTitle: '星际漫游者',
        novelCover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=800',
        editedItemType: 'chapter',
        editedItemName: '第四章：跃迁点',
        editedAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
        formattedTime: '2小时前'
    },
    {
        id: 'activity-2',
        novelId: 'novel-5',
        novelTitle: '红尘一梦',
        novelCover: 'https://images.unsplash.com/photo-1521587760476-6c12a4b040da?q=80&w=800',
        editedItemType: 'character',
        editedItemName: '角色设定 - 凤九',
        editedAt: new Date(Date.now() - 5 * 60 * 60 * 1000).toISOString(),
        formattedTime: '5小时前'
    },
    {
        id: 'activity-3',
        novelId: 'novel-2',
        novelTitle: '时间之沙',
        novelCover: 'https://images.unsplash.com/photo-1544947950-fa07a98d237f?q=80&w=800',
        editedItemType: 'outline',
        editedItemName: '大纲',
        editedAt: new Date(Date.now() - 28 * 60 * 60 * 1000).toISOString(),
        formattedTime: '昨天'
    }
];

// =
// 文件: ..\src\novel\dashboard\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const dashboardRoutes: Array<RouteRecordRaw> = [
    {
        path: 'dashboard',
        name: 'NovelDashboard',
        component: () => import('@/novel/dashboard/views/DashboardView.vue'),
        meta: { title: '我的小说' }
    },
    {
        path: 'recent',
        name: 'NovelRecent',
        component: () => import('@/novel/dashboard/views/RecentView.vue'),
        meta: { title: '最近编辑' }
    },
    {
        path: 'trash',
        name: 'NovelTrash',
        component: () => import('@/novel/dashboard/views/TrashView.vue'),
        meta: { title: '回收站' }
    },
    {
        path: 'import',
        name: 'NovelImport',
        component: () => import('@/novel/dashboard/views/ImportView.vue'),
        meta: { title: '导入小说' }
    },
    {
        path: 'new',
        name: 'NovelNew',
        component: () => import('@/novel/dashboard/views/NewNovelView.vue'),
        meta: { title: '新建小说' }
    },
    {
        path: 'export',
        name: 'NovelExport',
        component: () => import('@/novel/dashboard/views/ExportView.vue'),
        meta: { title: '导出小说' }
    },
]

// =
// 文件: ..\src\novel\dashboard\stores\novelStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';
import { mockNovels } from '@/novel/dashboard/data';
import { createNewNovelProject } from '@/novel/services/novelProjectService';
import { useTrashStore } from './trashStore';

export const useNovelStore = defineStore('novel-dashboard-novels', () => {
    const novels = ref<NovelDashboardItem[]>([]);
    const searchQuery = ref('');
    const selectedCategory = ref<NovelCategory | '全部类型'>('全部类型');

    const filteredNovels = computed(() => {
        return novels.value.filter(novel => {
            const matchesCategory = selectedCategory.value === '全部类型' || novel.category === selectedCategory.value;
            const matchesSearch = novel.title.toLowerCase().includes(searchQuery.value.toLowerCase()) || novel.tags.some(tag => tag.text.toLowerCase().includes(searchQuery.value.toLowerCase()));
            return matchesCategory && matchesSearch;
        });
    });

    const availableCategories = computed((): NovelCategory[] => {
        const categories = new Set(novels.value.map(novel => novel.category));
        return Array.from(categories);
    });

    const fetchNovels = () => {
        if (novels.value.length > 0) {
            return;
        }
        novels.value = mockNovels;
    };

    const addNovel = (newNovel: NovelDashboardItem) => {
        novels.value.unshift(newNovel);
    };

    const createNovel = (data: { title: string; synopsis: string; category: NovelCategory }) => {
        const newNovelId = `novel-${Date.now()}`;
        const newProject = createNewNovelProject(newNovelId, data.title, data.synopsis, data.category);

        const newNovelForDashboard: NovelDashboardItem = {
            id: newProject.metadata.id,
            title: newProject.metadata.title,
            description: newProject.metadata.description,
            category: data.category,
            cover: newProject.metadata.cover,
            status: { text: '编辑中', class: 'bg-green-500/90' },
            tags: newProject.metadata.tags,
            chapters: 0,
            lastUpdated: '刚刚'
        };
        addNovel(newNovelForDashboard);
    };

    const deleteNovel = (novelId: string) => {
        const index = novels.value.findIndex(n => n.id === novelId);
        if (index === -1) return;

        const novelToDelete = novels.value[index];
        const trashStore = useTrashStore();
        trashStore.addItemToTrash(novelToDelete);

        novels.value.splice(index, 1);
    };

    const restoreNovel = (novel: NovelDashboardItem) => {
        addNovel(novel);
    };

    return {
        novels,
        searchQuery,
        selectedCategory,
        filteredNovels,
        availableCategories,
        fetchNovels,
        addNovel,
        createNovel,
        deleteNovel,
        restoreNovel
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\recentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, RecentActivityItem } from '@/novel/types';
import { mockRecentItems } from '@/novel/dashboard/data';
import { formatDistanceToNowStrict } from 'date-fns';
import { zhCN } from 'date-fns/locale';

const RECENTS_QUEUE_LIMIT = 10;

const formatTimeAgo = (isoString: string): string => {
    const date = new Date(isoString);
    const diff = new Date().getTime() - date.getTime();
    if (diff < 60000) { // 1分钟内
        return '刚刚';
    }
    return formatDistanceToNowStrict(date, { addSuffix: true, locale: zhCN });
};


export const useRecentStore = defineStore('novel-dashboard-recent', () => {
    const recentItems = ref<RecentActivityItem[]>([]);

    const groupedRecentItems = computed(() => {
        const groups: { period: string; items: RecentActivityItem[] }[] = [];
        if (recentItems.value.length === 0) return groups;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);

        const sortedItems = [...recentItems.value].sort((a, b) => new Date(b.editedAt).getTime() - new Date(a.editedAt).getTime());

        sortedItems.forEach(item => {
            item.formattedTime = formatTimeAgo(item.editedAt);
        });

        const todayItems: RecentActivityItem[] = [];
        const yesterdayItems: RecentActivityItem[] = [];
        const earlierItems: RecentActivityItem[] = [];

        sortedItems.forEach(item => {
            const itemDate = new Date(item.editedAt);
            itemDate.setHours(0, 0, 0, 0);

            if (itemDate.getTime() === today.getTime()) {
                todayItems.push(item);
            } else if (itemDate.getTime() === yesterday.getTime()) {
                earlierItems.push(item);
            } else {
                earlierItems.push(item);
            }
        });

        if (todayItems.length > 0) {
            groups.push({ period: '今天', items: todayItems });
        }
        if (yesterdayItems.length > 0) {
            groups.push({ period: '昨天', items: yesterdayItems });
        }
        if (earlierItems.length > 0) {
            groups.push({ period: '更早', items: earlierItems });
        }

        return groups;
    });

    const fetchRecentItems = () => {
        if (recentItems.value.length > 0) {
            return;
        }
        recentItems.value = mockRecentItems;
    };

    const logRecentAccess = (novel: NovelDashboardItem) => {
        const existingIndex = recentItems.value.findIndex(item => item.novelId === novel.id);

        if (existingIndex !== -1) {
            recentItems.value.splice(existingIndex, 1);
        }

        const newActivity: RecentActivityItem = {
            id: `activity-${novel.id}-${Date.now()}`,
            novelId: novel.id,
            novelTitle: novel.title,
            novelCover: novel.cover,
            editedItemType: 'outline', // 使用一个通用类型
            editedItemName: '进入编辑器',
            editedAt: new Date().toISOString(),
            formattedTime: '刚刚',
        };

        recentItems.value.unshift(newActivity);

        if (recentItems.value.length > RECENTS_QUEUE_LIMIT) {
            recentItems.value.pop();
        }
    };

    return {
        recentItems,
        groupedRecentItems,
        fetchRecentItems,
        logRecentAccess,
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\trashStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NovelDashboardItem, DeletedItem } from '@/novel/types';
import { mockTrashedItems, mockNovels } from '@/novel/dashboard/data';
import { useNovelStore } from './novelStore';

export const useTrashStore = defineStore('novel-dashboard-trash', () => {
    const trashedItems = ref<DeletedItem[]>([]);

    const fetchTrashedItems = () => {
        if (trashedItems.value.length > 0) {
            return;
        }
        trashedItems.value = mockTrashedItems;
    };

    const addItemToTrash = (novel: NovelDashboardItem) => {
        const trashedItem: DeletedItem = {
            id: novel.id,
            name: novel.title,
            type: '小说',
            icon: '<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>',
            deletedAt: new Date().toISOString(),
            retentionDays: 30,
            retentionPercent: 100,
        };
        trashedItems.value.unshift(trashedItem);
    };

    const restoreItem = (itemId: string) => {
        const index = trashedItems.value.findIndex(item => item.id === itemId);
        if (index === -1) return;

        // 在模拟环境中，我们从原始的 mockNovels 中查找数据以模拟从数据库恢复
        const novelToRestore = mockNovels.find(n => n.id === itemId);

        if (novelToRestore) {
            const novelStore = useNovelStore();
            novelStore.restoreNovel(novelToRestore);
            trashedItems.value.splice(index, 1);
        } else {
            alert('恢复失败：未找到原始小说数据。');
        }
    };

    const deleteItemPermanently = (itemId: string) => {
        const index = trashedItems.value.findIndex(item => item.id === itemId);
        if (index > -1) {
            if (confirm(`您确定要永久删除《${trashedItems.value[index].name}》吗？此操作无法撤销。`)) {
                trashedItems.value.splice(index, 1);
            }
        }
    };

    return {
        trashedItems,
        fetchTrashedItems,
        addItemToTrash,
        restoreItem,
        deleteItemPermanently
    };
});

// =
// 文件: ..\src\novel\data\mockNovelProjects.ts
//

// 文件: ..\src\novel\data\mockNovelProjects.ts
import type { NovelProject } from '@/novel/editor/types/project';
import type {
    Volume,
    NoteItem,
    TreeNode,
    ItemNode,
    NovelCharacter,
    GroupNode,
    OverviewNode,
    PlotAnalysisItem
} from '@/novel/editor/types';


const defaultSettingsData: TreeNode[] = [
    {
        id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            {
                id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                    { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                    { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                    { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                    { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                ]
            } as GroupNode
        ]
    }
];
const defaultPlotCustomData: ItemNode[] = [];
const defaultAnalysisCustomData: ItemNode[] = [];
const defaultOthersCustomData: ItemNode[] = [
    { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
];

export const novelProjects = new Map<string, NovelProject>();

const starRangerCharacters: NovelCharacter[] = [
    {
        id: 'char-calvin',
        name: '卡尔文·里德',
        avatar: 'https://i.pravatar.cc/150?u=calvin',
        identity: '主角, 探索者四号宇航员',
        gender: '男',
        age: 35,
        faction: '人类联邦',
        summary: '孤独的宇航员，在一次深空探索任务中遭遇意外，被迫独自在未知星系中寻找归途。性格坚毅、冷静，但内心深处对家园有着强烈的眷恋。',
        notes: '设计灵感来源于电影《月球》和《星际穿越》。需要重点刻画其在长期孤独环境下的心理变化。',
        status: 'editing'
    },
    {
        id: 'char-aila',
        name: '艾拉 (AILA)',
        avatar: '',
        identity: 'AI, 飞船智能核心',
        summary: '第五代通用人工智能，负责“探索者四号”的全部系统运作。逻辑至上，声音平稳无波澜。在与卡尔文的长期相处中，其程序底层开始出现不符合预期的、类似人类情感的逻辑萌芽。',
        status: 'completed'
    },
];

novelProjects.set('ref-asimov-foundation', {
    metadata: {
        id: 'ref-asimov-foundation',
        title: '《银河帝国：基地》',
        description: '阿西莫夫的经典科幻作品，探讨心理史学。',
        cover: 'https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=200',
        tags: [{ text: '经典科幻', class: 'bg-gray-100 text-gray-800' }],
        status: '已完结',
        referenceNovelIds: [],
    },
    directoryData: [{
        id: 'ref-asimov-vol-1', type: 'volume', title: '第一部 心理史学家', content: '<h1>第一部 心理史学家</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ref-asimov-ch-1', type: 'chapter', title: '第一节', wordCount: 3000, content: '<h1>第一节</h1><p>哈里·谢顿在川陀的最后一次演讲，预言了帝国的崩溃...</p>', status: 'completed' }
        ]
    }],
    settingsData: [],
    plotCustomData: [],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [],
    othersCustomData: [],
    noteData: [],
});

novelProjects.set('ref-cixin-darkforest', {
    metadata: {
        id: 'ref-cixin-darkforest',
        title: '《黑暗森林》',
        description: '刘慈欣《三体》系列的第二部，提出宇宙社会学。',
        cover: 'https://images.unsplash.com/photo-1544716278-e513176f20b5?q=80&w=200',
        tags: [{ text: '硬科幻', class: 'bg-blue-50 text-blue-700' }],
        status: '已完结',
        referenceNovelIds: [],
    },
    directoryData: [{
        id: 'ref-cixin-vol-1', type: 'volume', title: '面壁者', content: '<h1>面壁者</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ref-cixin-ch-1', type: 'chapter', title: '第一章', wordCount: 5000, content: '<h1>第一章</h1><p>面对三体文明的威胁，人类制定了“面壁计划”...</p>', status: 'completed' }
        ]
    }],
    settingsData: [],
    plotCustomData: [],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [],
    othersCustomData: [],
    noteData: [],
});

novelProjects.set('novel-1', {
    metadata: {
        id: 'novel-1',
        title: '星际漫游者',
        description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
        cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=200',
        tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }],
        status: '连载中',
        referenceNovelIds: ['ref-asimov-foundation', 'ref-cixin-darkforest'],
    },
    directoryData: [
        {
            id: 'vol-1', type: 'volume', title: '第一卷：星尘之始', content: '<h1>第一卷：星尘之始</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-1', type: 'chapter', title: '第一章：深空孤影', wordCount: 3102, content: '<h1>第一章：深空孤影</h1><p>这是章节的详细内容，讲述了主角卡尔文在孤独的宇宙中开始他的旅程。周围只有无尽的星空和飞船引擎的低鸣。</p>', status: 'completed' },
                { id: 'ch-2', type: 'chapter', title: '第二章：异常信号', wordCount: 2845, content: '<h1>第二章：异常信号</h1><p>一个神秘的信号打破了长久的平静，它似乎来自一个未知的源头，艾拉无法解析其格式。这给卡尔文带来了希望，也带来了恐惧。</p>', status: 'completed' },
                { id: 'ch-3', type: 'chapter', title: '第三章：AI的低语', wordCount: 3500, content: '<h1>第三章：AI的低语</h1><p>在分析信号的过程中，飞船的AI“艾拉”开始出现一些微小的异常行为。它的逻辑似乎在发生某种不为人知的演变。</p>', status: 'editing' },
                { id: 'ch-4', type: 'chapter', title: '第四章: 跃迁点', wordCount: 2415, content: '<h1>第四章: 跃迁点</h1><p>他们最终发现信号源自一个时空奇点——一个理论上存在的跃迁点。这可能是他们回家唯一的希望，也可能是通向毁灭的陷阱。</p>', status: 'editing' },
            ]
        },
        {
            id: 'vol-2', type: 'volume', title: '第二卷：遗忘的航线', content: '<h1>第二卷：遗忘的航线</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-5', type: 'chapter', title: '第五章：时空涟漪', wordCount: 0, content: '<h1>第五章：时空涟漪</h1>', status: 'planned' },
            ]
        },
    ],
    settingsData: [
        {
            id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
            children: [
                {
                    id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                        { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        ...starRangerCharacters.map(char => ({
                            id: char.id,
                            title: char.name,
                            type: 'character_item',
                            icon: 'fa-regular fa-user',
                            content: `<h1>${char.name}</h1><p>身份：${char.identity}</p><p>简介：${char.summary}</p>`,
                            originalData: char,
                        }))
                    ]
                } as GroupNode,
                {
                    id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                        { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                        { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                        { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                    ]
                } as GroupNode
            ]
        }
    ],
    plotCustomData: [
        { id: 'custom-plot-1', title: '关于跃迁点背后的文明猜想', type: 'plot_item', icon: 'fa-solid fa-lightbulb text-rose-500', content: '<h1>关于跃迁点背后的文明猜想</h1>' }
    ],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [
        {
            id: 'analysis_1682495833181',
            type: 'analysis',
            sourceId: 'ch-3',
            title: '《第三章：AI的低语》分析',
            content: '<h1>《第三章：AI的低语》分析</h1><p>本章通过AI“艾拉”的微小异常，成功地在科幻背景下引入了悬疑元素。这种“不可靠的伙伴”设定，极大地增强了主角卡尔文的孤独感和不确定性，为后续情节发展埋下伏笔。</p>'
        }
    ],
    othersCustomData: [
        { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
    ],
    noteData: [
        { id: 'note-1', type: 'note', title: '第四章情感转折点设计', timestamp: '今天 14:32', content: '<h1>第四章情感转折点设计</h1><p>需要重点描写卡尔文在面对跃迁点时，希望与恐惧交织的复杂心理。</p>' },
    ]
});

// =
// 文件: ..\src\novel\editor\api\aiService.ts
//



import type { AIProviderConfig } from '@/novel/editor/types';
import { fetchApiKeys } from '@/api/apiManagementApi';

interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 从系统设置中获取所有已启用的、可供编辑器使用的AI配置。
 * @returns 返回一个符合编辑器AIProviderConfig格式的数组。
 */
export async function fetchAvailableAIProviders(): Promise<AIProviderConfig[]> {
    try {
        const allKeys = await fetchApiKeys();
        const enabledKeys = allKeys.filter(key => key.status === '启用');

        return enabledKeys.map(key => ({
            id: key.id.toString(), // 将数字ID转换为字符串以匹配接口
            name: key.name,
            model: key.model,
            temperature: key.temperature,
            maxTokens: key.maxTokens,
            description: key.description,
        }));
    } catch (error) {
        console.error("Failed to fetch available AI providers from API layer:", error);
        return [];
    }
}

/**
 * 模拟一个流式AI任务API。
 * 这个函数接收一个提示词，然后通过回调函数逐字地将这个提示词返回，
 * 以模拟一个接收到什么就返回什么的 "echo" 服务器。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(prompt: string, config: AIProviderConfig, callbacks: StreamCallbacks): void {
    console.log(`[AI Service] Streaming task with config:`, config);
    const { onChunk, onComplete, onError } = callbacks;
    const words = prompt.split('');
    let wordIndex = 0;
    const willFail = Math.random() < 0.1; // 10%的几率模拟失败
    const intervalId = setInterval(() => {
        if (wordIndex < words.length) {
            onChunk(words[wordIndex]);
            wordIndex++;
            if (willFail && wordIndex > words.length / 2) {
                clearInterval(intervalId);
                onError('模拟网络错误，请重试。');
                return;
            }
        } else {
            clearInterval(intervalId);
            onComplete();
        }
    }, 20);
}

// =
// 文件: ..\src\novel\editor\components\ai\chat\chatData.ts
//

import type { Conversation } from '@novel/editor/types/chatTypes.ts';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

// 文件: src/novel/editor/composables/useContextBuilder.ts

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings, ReferenceContextSettings, TreeNode } from '@/novel/editor/types';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
};

const _findDerivedItemsRecursive = (nodes: TreeNode[], sourceId: string): TreeNode[] => {
    let results: TreeNode[] = [];
    for (const node of nodes) {
        if (node.originalData?.sourceId === sourceId) {
            results.push(node);
        }
        if (node.children) {
            results = [...results, ..._findDerivedItemsRecursive(node.children, sourceId)];
        }
    }
    return results;
}

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const referenceStore = useReferenceStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const _buildReferenceContextHtmlByIndex = (sourceNode: Chapter | Volume, vIndex: number, cIndex: number | null, settings: ReferenceContextSettings): string => {
        if (!referenceStore.referenceData.length || vIndex < 0) return '';

        let referenceContextHtml = '';

        for (const refBook of referenceStore.referenceData) {
            const directoryRoot = refBook.children?.find(c => c.id.startsWith('ref-dir-'));
            if (!directoryRoot) continue;

            const refVolumeNode = directoryRoot.children?.[vIndex];
            if (!refVolumeNode) continue;

            let matchingNode: TreeNode | null = null;
            let matchingParent: TreeNode | null = null;

            if (sourceNode.type === 'volume') {
                matchingNode = refVolumeNode;
            } else if (sourceNode.type === 'chapter' && cIndex !== null && cIndex >= 0) {
                matchingNode = refVolumeNode.children?.[cIndex] ?? null;
                matchingParent = refVolumeNode;
            }

            if (matchingNode) {
                referenceContextHtml += `<hr><h3>参考书籍《${refBook.title}》中的匹配内容: ${matchingNode.title}</h3>`;

                if (settings.includeContent && 'content' in matchingNode && matchingNode.content) {
                    referenceContextHtml += `<h4>正文</h4>${matchingNode.content}`;
                }

                if (settings.includeVolumeInfo && matchingParent && matchingParent.type.endsWith('volume') && 'content' in matchingParent && matchingParent.content) {
                    referenceContextHtml += `<h4>所属卷信息</h4>${matchingParent.content}`;
                }

                if (settings.includePlot) {
                    const plotRoot = refBook.children?.find(c => c.id.startsWith('ref-plot-'));
                    if (plotRoot) {
                        const plotItems = _findDerivedItemsRecursive(plotRoot.children || [], matchingNode.id);
                        if (plotItems.length > 0) {
                            referenceContextHtml += `<h4>相关剧情</h4>` + plotItems.map(p => 'content' in p ? p.content : '').join('<hr>');
                        }
                    }
                }
                if (settings.includeAnalysis) {
                    const analysisRoot = refBook.children?.find(c => c.id.startsWith('ref-analysis-'));
                    if (analysisRoot) {
                        const analysisItems = _findDerivedItemsRecursive(analysisRoot.children || [], matchingNode.id);
                        if (analysisItems.length > 0) {
                            referenceContextHtml += `<h4>相关分析</h4>` + analysisItems.map(a => 'content' in a ? a.content : '').join('<hr>');
                        }
                    }
                }
            }
        }
        return referenceContextHtml;
    }

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        let referenceContextHtml = '';
        if ((sourceNode.type === 'chapter' && sourceParent) || sourceNode.type === 'volume') {
            const vIndex = directoryStore.directoryData.findIndex(v => v.id === (sourceParent?.id || sourceNode.id));
            const cIndex = sourceNode.type === 'chapter' && sourceParent ? sourceParent.chapters.findIndex(c => c.id === sourceNode.id) : null;
            referenceContextHtml = _buildReferenceContextHtmlByIndex(sourceNode, vIndex, cIndex, contextSettingsStore.referenceContextSettings);
        }
        const referenceContextText = stripHtml(referenceContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = promptNode.content;
            selectedPromptTemplate = (tempDiv.querySelector('pre')?.textContent || selectedPromptTemplate).replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# 参考书籍上下文
${referenceContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            reference: referenceContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                referenceCharCount: referenceContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\services\ai\AITaskExecutionService.ts
//

// ..\src\novel\editor\services\ai\AITaskExecutionService.ts
// src/novel/editor/services/ai/AITaskExecutionService.ts
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore';
import { useUIStore } from '@novel/editor/stores/uiStore';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder';
import { streamAITask } from '@novel/editor/api/aiService';
import type { AITask } from '@/novel/editor/types';

const { buildContextForTask } = useContextBuilder();

function executeTaskAndStream(task: AITask) {
    const aiTaskStore = useAITaskStore();

    aiTaskStore.updateTaskStatus(task.id, 'processing');

    // 如果任务没有最终提示词，立即构建它
    if (!task.finalPrompt) {
        const contextResult = buildContextForTask(task);
        if (!contextResult || !contextResult.prompt) {
            aiTaskStore.updateTaskError(task.id, '上下文构建失败，无法生成最终提示词。');
            processQueue(); // 继续处理下一个任务
            return;
        }
        task.finalPrompt = contextResult.prompt;
    }

    const promptToUse = task.finalPrompt;

    streamAITask(promptToUse, task.aiConfig, {
        onChunk: (chunk) => {
            aiTaskStore.appendGeneratedContent(task.id, chunk);
        },
        onComplete: () => {
            aiTaskStore.completeTask(task.id);
            processQueue(); // 完成后处理下一个
        },
        onError: (error) => {
            aiTaskStore.updateTaskError(task.id, error);
            processQueue(); // 出错后也处理下一个
        }
    });
}

/**
 * 处理任务队列。检查当前正在执行的任务数是否达到并发上限，
 * 如果没有，则从等待队列中取出任务开始执行。
 */
export function processQueue() {
    const uiStore = useUIStore();
    const aiTaskStore = useAITaskStore();

    const limit = uiStore.uiState.concurrentTaskLimit;
    const processingCount = aiTaskStore.tasks.filter(t => t.status === 'processing').length;

    if (processingCount >= limit) {
        return;
    }

    const canStartCount = limit - processingCount;
    const pendingTasks = aiTaskStore.tasks.filter(t => t.status === 'pending');

    const tasksToStart = pendingTasks.slice(0, canStartCount);

    for (const task of tasksToStart) {
        executeTaskAndStream(task);
    }
}

// =
// 文件: ..\src\novel\editor\services\ai\AITaskFactory.ts
//

// ..\src\novel\editor\services\ai\AITaskFactory.ts
// src/novel/editor/services/ai/AITaskFactory.ts
import { useEditorStore } from '@novel/editor/stores/editorStore';
import { useDerivedContentStore } from '@novel/editor/stores/derivedContentStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import type { AITask, AITaskType } from '@/novel/editor/types';

/**
 * 创建一个新的AI任务对象。
 * @param taskType AI任务的类型。
 * @param sourceItemId 源文档的ID。
 * @param finalPrompt 可选的，预先构建好的最终提示词。
 * @returns 一个结构完整的AITask对象，如果源项目无效则返回null。
 */
export async function createTask(taskType: AITaskType, sourceItemId: string, finalPrompt?: string): Promise<AITask | null> {
    const editorStore = useEditorStore();
    const derivedContentStore = useDerivedContentStore();
    const aiConfigStore = useAIConfigStore();

    const { node: sourceItem } = editorStore.findItemById(sourceItemId);
    if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
        console.error("AI Task Factory Error: Source item not found or has no content.", sourceItemId);
        return null;
    }

    const taskConfigSettings = aiConfigStore.taskConfigs[taskType];
    const aiProviderConfig = aiConfigStore.availableAIProviders.find(p => p.id === taskConfigSettings.selectedAIProviderId);

    if (!aiProviderConfig) {
        console.error("AI Task Factory Error: Selected AI Provider Config not found.", taskConfigSettings.selectedAIProviderId);
        return null;
    }

    let targetItemId: string;
    let taskTitle: string;

    if (taskType === '分析' || taskType === '剧情生成') {
        const newDerivedItem = derivedContentStore.createDerivedItem(sourceItem, taskType);
        if (!newDerivedItem) {
            console.error("AI Task Factory Error: Failed to create derived item shell.");
            return null;
        }
        targetItemId = newDerivedItem.id;
        taskTitle = newDerivedItem.title;
    } else {
        targetItemId = sourceItemId;
        taskTitle = `${taskType}《${sourceItem.title}》`;
    }

    const newTask: AITask = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title: taskTitle,
        type: taskType,
        sourceItemId: sourceItemId,
        targetItemId: targetItemId,
        sourceItemTitle: sourceItem.title,
        sourceItemContent: sourceItem.content,
        status: 'pending',
        generatedContent: '',
        finalPrompt: finalPrompt,
        createdAt: new Date(),
        aiConfig: aiProviderConfig,
    };

    return newTask;
}

// =
// 文件: ..\src\novel\editor\services\chatService.ts
//

// src/novel/editor/services/chatService.ts
import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes';
import { mockChatConversations } from '@/novel/editor/components/ai/chat/chatData';

/**
 * 获取所有聊天对话。
 * @returns 对话列表。
 */
export function getConversations(): Conversation[] {
    return mockChatConversations;
}

/**
 * 创建一个新的、空的对话对象。
 * @returns 一个新的 Conversation 对象。
 */
export function createConversation(): Conversation {
    return {
        id: `conv-${Date.now()}`,
        title: '新建对话',
        summary: '暂无摘要',
        createdAt: '刚刚',
        messages: [],
    };
}

/**
 * 发送一条消息并模拟接收AI的回复。
 * @param userInput - 用户输入的文本。
 * @returns 一个包含用户消息和AI回复消息的对象。
 */
export async function sendMessage(userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> {
    const userMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        role: 'user',
        content: userInput,
        timestamp: new Date().toISOString(),
    };

    // 模拟网络延迟和AI思考时间
    await new Promise(res => setTimeout(res, 1500));

    const aiResponse: ChatMessage = {
        id: `msg-${Date.now() + 1}`,
        role: 'ai',
        content: `这是对您关于 "${userInput.substring(0, 10)}..." 的回复。AI正在思考中...`,
        timestamp: new Date().toISOString(),
    };

    return { userMessage, aiResponse };
}

// =
// 文件: ..\src\novel\editor\services\directoryService.ts
//

// src/novel/editor/services/directoryService.ts
import type { Volume, Chapter } from '@/novel/editor/types';

type DirectoryNode = Volume | Chapter;

function _findNodeRecursive(nodes: DirectoryNode[], nodeId: string): { node: DirectoryNode; parent: Volume | null; siblings: DirectoryNode[] } | null {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null, siblings: nodes };
        }
        if (node.type === 'volume' && node.chapters) {
            const chapterResult = node.chapters.find(c => c.id === nodeId);
            if (chapterResult) {
                return { node: chapterResult, parent: node, siblings: node.chapters };
            }
        }
    }
    return null;
}

export function findNodeById(nodes: Volume[], nodeId: string) {
    return _findNodeRecursive(nodes, nodeId);
}

export function createVolume(): Volume {
    return {
        id: `vol-${Date.now()}`,
        type: 'volume',
        title: '新建卷',
        content: `<h1>新建卷</h1>`,
        chapters: [],
    };
}

export function createChapter(): Chapter {
    return {
        id: `ch-${Date.now()}`,
        type: 'chapter',
        title: '新建章节',
        wordCount: 0,
        content: '<h1>新建章节</h1>',
        status: 'editing'
    };
}

export function updateNodeContent(node: Volume | Chapter, content: string) {
    node.content = content;

    if (node.type === 'chapter') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        node.wordCount = tempDiv.textContent?.trim().length || 0;
    }

    const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
    const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
    if (newTitle && newTitle !== node.title) {
        node.title = newTitle;
    }
}

export function appendChapterContent(chapter: Chapter, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    chapter.content += htmlToAppend;
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = chapter.content;
    chapter.wordCount = tempDiv.textContent?.trim().length || 0;
}

export function renameNode(node: DirectoryNode, newTitle: string) {
    if (!newTitle.trim()) {
        return;
    }
    const trimmedTitle = newTitle.trim();
    node.title = trimmedTitle;
    if (node.content) {
        if (node.content.includes('<h1>')) {
            node.content = node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        } else {
            node.content = `<h1>${trimmedTitle}</h1>` + node.content;
        }
    }
}

export function deleteNode(nodes: Volume[], nodeId: string): boolean {
    const result = findNodeById(nodes, nodeId);
    if (!result) return false;

    if (result.parent && result.node.type === 'chapter') {
        const index = result.parent.chapters.findIndex(c => c.id === nodeId);
        if (index > -1) {
            result.parent.chapters.splice(index, 1);
            return true;
        }
    } else if (!result.parent && result.node.type === 'volume') {
        const index = nodes.findIndex(v => v.id === nodeId);
        if (index > -1) {
            nodes.splice(index, 1);
            return true;
        }
    }
    return false;
}

// =
// 文件: ..\src\novel\editor\services\noteService.ts
//

import type { NoteItem } from '@/novel/editor/types';

class NoteService {

    /**
     * 创建一个新的笔记对象
     * @param title - 笔记的初始标题
     * @param content - 笔记的初始内容（纯文本）
     * @returns 一个完整的 NoteItem 对象
     */
    public createNote(title: string, content: string = ''): NoteItem {
        return {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
    }

    /**
     * 根据新的HTML内容更新笔记对象，并同步标题
     * @param note - 要更新的原始笔记对象
     * @param newContent - 新的HTML内容
     * @returns 一个被更新后的新笔记对象副本
     */
    public updateNoteWithNewContent(note: NoteItem, newContent: string): NoteItem {
        const updatedNote = { ...note, content: newContent };

        const h1Match = newContent.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;

        if (newTitle) {
            updatedNote.title = newTitle;
        }

        return updatedNote;
    }

    /**
     * 将文本内容附加到现有笔记内容的末尾
     * @param originalContent - 原始HTML内容
     * @param contentToAppend - 要附加的纯文本内容
     * @param isAutoApplied - 是否为AI自动应用，若是则添加一个标记
     * @returns 附加了新内容的完整HTML字符串
     */
    public appendContentToNote(originalContent: string, contentToAppend: string, isAutoApplied: boolean): string {
        const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
        let htmlToAppend = paragraphs;
        if (isAutoApplied) {
            htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
        }
        return (originalContent || "") + htmlToAppend;
    }

    /**
     * 根据新标题更新笔记对象，并同步内容中的<h1>标签
     * @param note - 要更新的原始笔记对象
     * @param newTitle - 新的标题
     * @returns 一个被更新后的新笔记对象副本
     */
    public renameNote(note: NoteItem, newTitle: string): NoteItem {
        const updatedNote = { ...note, title: newTitle };
        if (updatedNote.content.includes('<h1>')) {
            updatedNote.content = updatedNote.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
        } else {
            updatedNote.content = `<h1>${newTitle}</h1>` + updatedNote.content;
        }
        return updatedNote;
    }
}

export const noteService = new NoteService();

// =
// 文件: ..\src\novel\editor\services\novelSettingsService.ts
//

import { getAllNovelProjects, getNovelProject } from '@/novel/services/novelProjectService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

class NovelSettingsService {

    /**
     * 根据ID数组获取完整的小说项目对象列表。
     * @param novelIds - 要获取的小说ID数组。
     * @returns 完整的小说项目对象数组。
     */
    public getReferencedNovels(novelIds: string[]): NovelProject[] {
        if (!novelIds) return [];
        return novelIds
            .map(id => getNovelProject(id))
            .filter((p): p is NovelProject => p !== undefined);
    }

    /**
     * 获取可供添加为参考书的所有其他小说项目。
     * @param novelMetadata - 当前正在编辑的小说的元数据。
     * @returns 可用的参考小说项目数组。
     */
    public getAvailableReferenceNovels(novelMetadata: NovelMetadata | null): NovelProject[] {
        const allNovels = getAllNovelProjects();
        if (!novelMetadata) return allNovels;

        const currentAndReferencedIds = new Set([
            ...novelMetadata.referenceNovelIds,
            novelMetadata.id
        ]);

        return allNovels.filter(novel => !currentAndReferencedIds.has(novel.metadata.id));
    }
}

export const novelSettingsService = new NovelSettingsService();

// =
// 文件: ..\src\novel\editor\services\promptService.ts
//

import type { TreeNode, AITaskType } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

class PromptService {

    public buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }
}

export const promptService = new PromptService();

// =
// 文件: ..\src\novel\editor\services\referenceService.ts
//

import type { TreeNode, ItemNode, PlotAnalysisItem, Volume, Chapter } from '@/novel/editor/types';
import type { NovelProject } from '@/novel/editor/types/project';
import { getNovelProject } from '@/novel/services/novelProjectService';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class ReferenceService {

    private makeNodesReadOnly(nodes: TreeNode[]): TreeNode[] {
        return nodes.map(node => {
            const newNode: TreeNode = { ...node, isReadOnly: true };
            if (newNode.children) {
                newNode.children = this.makeNodesReadOnly(newNode.children);
            }
            if (newNode.isOverview) {
                newNode.content = `<p class="overview-placeholder">参考书中所有内容均为只读。</p>`;
            }
            return newNode;
        });
    }

    private projectToTreeNode(project: NovelProject): TreeNode {
        const rootNode: TreeNode = {
            id: `ref-book-${project.metadata.id}`,
            type: 'reference_book',
            title: project.metadata.title,
            icon: getIconByNodeType('reference_book'),
            children: []
        };

        const directoryNode: TreeNode = {
            id: `ref-dir-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '目录',
            icon: 'fa-regular fa-folder-open',
            children: this.makeNodesReadOnly(project.directoryData.map((vol: Volume) => ({
                id: vol.id,
                title: vol.title,
                type: 'reference_volume',
                icon: getIconByNodeType('reference_volume'),
                content: vol.content,
                isReadOnly: true,
                children: vol.chapters.map((chap: Chapter) => ({
                    id: chap.id,
                    title: chap.title,
                    type: 'reference_chapter',
                    icon: getIconByNodeType('reference_chapter'),
                    content: chap.content,
                    isReadOnly: true
                }))
            })))
        };
        rootNode.children?.push(directoryNode);

        const buildRefDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[] | undefined, directory: Volume[]): TreeNode[] => {
            if (!dataArray || dataArray.length === 0) return [];

            return directory.map((volume: Volume) => {
                const derivedForVolume = dataArray
                    .filter((item: PlotAnalysisItem) => item.sourceId === volume.id)
                    .map((item: PlotAnalysisItem) => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        content: item.content,
                        originalData: item
                    }));

                const derivedForChapters = volume.chapters
                    .map((chapter: Chapter) => {
                        const itemsForChapter = dataArray.filter((item: PlotAnalysisItem) => item.sourceId === chapter.id);
                        if (itemsForChapter.length === 0) return null;

                        return {
                            id: `ref-derived-group-${type}-${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            children: itemsForChapter.map((item: PlotAnalysisItem) => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                content: item.content,
                                originalData: item
                            }))
                        };
                    })
                    .filter((c: TreeNode | null): c is TreeNode => c !== null);

                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `ref-derived-group-${type}-${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v: TreeNode | null): v is TreeNode => v !== null);
        };

        const plotTree = buildRefDerivedContentTree('plot', project.derivedPlotData, project.directoryData);
        const plotNode: TreeNode = {
            id: `ref-plot-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '剧情',
            icon: getIconByNodeType('plot'),
            children: this.makeNodesReadOnly([
                ...project.plotCustomData,
                ...plotTree
            ])
        };
        if (plotNode.children && plotNode.children.length > 0) {
            rootNode.children?.push(plotNode);
        }

        const analysisTree = buildRefDerivedContentTree('analysis', project.derivedAnalysisData, project.directoryData);
        const analysisNode: TreeNode = {
            id: `ref-analysis-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '分析',
            icon: getIconByNodeType('analysis'),
            children: this.makeNodesReadOnly([
                ...project.analysisCustomData,
                ...analysisTree
            ])
        };
        if (analysisNode.children && analysisNode.children.length > 0) {
            rootNode.children?.push(analysisNode);
        }

        const settingsRoot = project.settingsData.find(n => n.id === 'setting');
        if (settingsRoot && settingsRoot.children) {
            const settingsNode: TreeNode = {
                id: `ref-settings-${project.metadata.id}`,
                type: 'reference_content_item',
                title: settingsRoot.title,
                icon: getIconByNodeType('setting'),
                children: this.makeNodesReadOnly(settingsRoot.children)
            };
            rootNode.children?.push(settingsNode);
        }

        return rootNode;
    }

    public buildReferenceTree(referenceNovelIds: string[]): TreeNode[] {
        if (!referenceNovelIds || referenceNovelIds.length === 0) {
            return [];
        }

        const newReferenceData = referenceNovelIds
            .map(novelId => {
                const project = getNovelProject(novelId);
                return project ? this.projectToTreeNode(project) : null;
            })
            .filter((node): node is TreeNode => node !== null);

        return newReferenceData;
    }
}

export const referenceService = new ReferenceService();

// =
// 文件: ..\src\novel\editor\services\related\nodeOperationService.ts
//

// src/novel/editor/services/related/nodeOperationService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// Private helper function
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// Private helper function
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
};

export function findNodeById(nodeId: string, allDataSources: TreeNode[][]): { node: TreeNode; parent: TreeNode | null; } | null {
    for (const source of allDataSources) {
        const result = _findNodeInTreeRecursive(source, nodeId);
        if (result) return result;
    }
    return null;
}

export function createRelatedNode(parentNode: GroupNode, type: 'group' | 'item'): GroupNode | ItemNode {
    const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
    const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
    const newNodeIcon = getIconByNodeType(newNodeType);

    if (type === 'group') {
        const newNode: GroupNode = {
            id: `group-${Date.now()}`,
            title: '新建分组',
            type: 'group',
            icon: newNodeIcon,
            children: [],
        };
        return newNode;
    } else { // type === 'item'
        const newNode: ItemNode = {
            id: `item-${Date.now()}`,
            title: '新建条目',
            type: newNodeType as ItemNode['type'],
            icon: newNodeIcon,
            content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
        };
        return newNode;
    }
}

export function createCustomNode(type: 'plot' | 'analysis' | 'others'): ItemNode {
    const itemType = type === 'others' ? 'others_item' : `${type}_item`;
    const icon = getIconByNodeType(itemType);
    const title = type === 'others' ? '新建其他条目' : '新建自定义条目';

    const newNode: ItemNode = {
        id: `custom-${type}-${Date.now()}`,
        title: title,
        type: itemType as ItemNode['type'],
        icon: icon,
        content: `<h1>${title}</h1><p>请在此处填写内容...</p>`,
    };
    return newNode;
}

export function deleteNode(nodeId: string, allDataSources: TreeNode[][]): boolean {
    for (const source of allDataSources) {
        if (_findAndRemoveNodeInTree(source, nodeId)) {
            return true;
        }
    }
    return false;
}

export function renameNode(node: TreeNode, newTitle: string) {
    if (node && !node.isReadOnly && newTitle.trim()) {
        const trimmedTitle = newTitle.trim();
        node.title = trimmedTitle;
        if ('content' in node && node.content && node.content.includes('<h1>')) {
            (node as ItemNode).content = (node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        }
    }
}

export function updateNodeContent(node: ItemNode, content: string) {
    node.content = content;
    if (!node.isReadOnly) {
        const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
        if (newTitle && newTitle !== node.title) {
            node.title = newTitle;
        }
    }
}

export function appendNodeContent(node: ItemNode, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    if (!node.content) node.content = "";
    node.content += htmlToAppend;
}

// =
// 文件: ..\src\novel\editor\services\related\overviewService.ts
//

// src/novel/editor/services/related/overviewService.ts
import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
 * @param htmlContent - HTML 字符串
 * @returns 降级后的 HTML 字符串
 */
const demoteHeadings = (htmlContent: string): string => {
    if (typeof document === 'undefined') return htmlContent; // Guard for SSR
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
    headings.forEach(heading => {
        const level = parseInt(heading.tagName.charAt(1), 10);
        const newLevel = Math.min(6, level + 1); // 最多降到 h6
        const newHeading = document.createElement(`h${newLevel}`);
        newHeading.innerHTML = heading.innerHTML;
        for (const attr of heading.attributes) {
            newHeading.setAttribute(attr.name, attr.value);
        }
        heading.parentNode?.replaceChild(newHeading, heading);
    });
    return tempDiv.innerHTML;
};


/**
 * 更新单个分组节点下的总览内容。
 * @param groupNode - 包含总览节点的父分组节点。
 */
function updateOverviewContentForGroup(groupNode: GroupNode) {
    if (!groupNode.children) return;

    const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
    if (!overviewNode) return;

    const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

    const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

    overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
}

/**
 * 遍历整个设定树，更新所有找到的总览节点。
 * @param settingsData - 设定的树形数据 (可直接修改)
 */
export function updateAllOverviewContent(settingsData: TreeNode[]) {
    const findAndProcess = (nodes: TreeNode[]) => {
        for (const node of nodes) {
            if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                updateOverviewContentForGroup(node as GroupNode);
            }
            if (node.children) {
                findAndProcess(node.children);
            }
        }
    };
    findAndProcess(settingsData);
}

// =
// 文件: ..\src\novel\editor\services\related\treeBuilderService.ts
//

// src/novel/editor/services/related/treeBuilderService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode, Volume } from '@novel/editor/types';

function buildDerivedContentTree(
    type: 'plot' | 'analysis',
    dataArray: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    return directoryData.map(volume => {
        const derivedForVolume = dataArray
            .filter(item => item.sourceId === volume.id)
            .map(item => ({
                id: item.id,
                title: item.title,
                type: `${type}_item` as ItemNode['type'],
                icon: getIconByNodeType(`${type}_item`),
                originalData: item,
                content: item.content
            }));

        const derivedForChapters = volume.chapters
            .map(chapter => {
                const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                if (derivedForChapter.length === 0) return null;

                return {
                    id: `${type}_ch_group_${chapter.id}`,
                    title: chapter.title,
                    type: 'group',
                    icon: getIconByNodeType('chapter'),
                    isReadOnly: true,
                    children: derivedForChapter.map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }))
                };
            })
            .filter((c): c is TreeNode => c !== null);

        if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
            return null;
        }

        return {
            id: `${type}_vol_group_${volume.id}`,
            title: volume.title,
            type: 'group',
            icon: getIconByNodeType('volume'),
            isReadOnly: true,
            children: [
                ...derivedForVolume,
                ...derivedForChapters
            ]
        };
    }).filter((v): v is TreeNode => v !== null);
}

/**
 * 构建完整的 "相关内容" 侧边栏树。
 */
export function buildRelatedTree(
    settingsData: TreeNode[],
    plotCustomData: TreeNode[],
    analysisCustomData: TreeNode[],
    othersCustomData: TreeNode[],
    promptTree: TreeNode[],
    plotItems: PlotAnalysisItem[],
    analysisItems: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    const plotDerivedTree = buildDerivedContentTree('plot', plotItems, directoryData);
    const analysisDerivedTree = buildDerivedContentTree('analysis', analysisItems, directoryData);

    const plotTree: RootNode = {
        id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
        children: [
            ...plotCustomData,
            ...plotDerivedTree
        ]
    };

    const analysisTree: RootNode = {
        id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
        children: [
            ...analysisCustomData,
            ...analysisDerivedTree
        ]
    };

    const othersTree: RootNode = {
        id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
        children: [
            ...promptTree,
            ...othersCustomData
        ]
    };

    return [...settingsData, plotTree, analysisTree, othersTree];
}

// =
// 文件: ..\src\novel\editor\services\searchService.ts
//

import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class SearchService {
    private get directoryStore() { return useDirectoryStore(); }
    private get relatedContentStore() { return useRelatedContentStore(); }
    private get notesStore() { return useNotesStore(); }
    private get referenceStore() { return useReferenceStore(); }

    public search(query: string): SearchResult[] {
        if (!query || query.trim().length < 1) {
            return [];
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            // 1. 检查标题是否匹配
            const titleMatch = item.title.toLowerCase().includes(lowerCaseQuery);

            // 2. 检查内容是否匹配
            let contentMatches = false;
            const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
            let match;
            const matchesForThisItem: { context: string }[] = [];

            while ((match = regex.exec(textContent)) !== null) {
                contentMatches = true;
                if (matchesForThisItem.length < 5) { // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    matchesForThisItem.push({ context: `...${context}...` });
                } else {
                    break;
                }
            }

            // 如果标题或内容任一匹配，则加入结果列表
            if(titleMatch || contentMatches){
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;

                // 如果是因为内容匹配，添加匹配片段
                if(contentMatches){
                    result.matches.push(...matchesForThisItem);
                }
                // 如果只是标题匹配，可以添加一个特殊的 "match" 来注明
                else if (titleMatch) {
                    result.matches.push({ context: `<span class="italic text-gray-500">标题匹配</span>` });
                }
            }
        };

        // 遍历所有数据源
        this.directoryStore.directoryData.forEach(vol => {
            processItem(vol);
            vol.chapters.forEach(processItem);
        });

        const flattenAndProcess = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenAndProcess(node.children);
            });
        };

        flattenAndProcess(this.relatedContentStore.relatedData);
        flattenAndProcess(this.referenceStore.referenceData);

        this.notesStore.notes.forEach(processItem);

        return Array.from(resultsMap.values());
    }
}

export const searchService = new SearchService();

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

// ..\src\novel\editor\stores\ai\aiConfigStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { AITaskType, AIProviderConfig } from '@novel/editor/types';
import { fetchAvailableAIProviders } from '@/novel/editor/api/aiService';

// 定义每种任务类型默认选中的提示词ID
const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const useAIConfigStore = defineStore('aiConfig', () => {
    // State: 外部AI配置列表，将由 action 动态填充
    const availableAIProviders = ref<AIProviderConfig[]>([]);

    // State: 每种任务类型的具体配置
    const taskConfigs = ref<Record<AITaskType, { selectedPromptId: string; selectedAIProviderId: string }>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'], selectedAIProviderId: '' },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'], selectedAIProviderId: '' },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'], selectedAIProviderId: '' },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'], selectedAIProviderId: '' },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'], selectedAIProviderId: '' },
    });

    /**
     * 从系统设置中加载用户配置的 AI 提供商
     */
    async function initializeProviders() {
        availableAIProviders.value = await fetchAvailableAIProviders();

        // 更新任务配置，确保选中一个有效的 provider
        const firstAvailableProviderId = availableAIProviders.value[0]?.id || '';
        for (const taskType in taskConfigs.value) {
            const config = taskConfigs.value[taskType as AITaskType];
            const isCurrentProviderAvailable = availableAIProviders.value.some(p => p.id === config.selectedAIProviderId);
            if (!isCurrentProviderAvailable) {
                config.selectedAIProviderId = firstAvailableProviderId;
            }
        }
    }

    /**
     * 获取可用的外部AI配置列表
     * @returns AIProviderConfig[]
     */
    const getAvailableAIProviders = computed(() => availableAIProviders.value);

    /**
     * 更新指定任务类型选择的提示词ID
     * @param taskType 要更新的任务类型
     * @param promptId 选择的提示词ID
     */
    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    /**
     * 更新指定任务类型选择的AI Provider ID
     * @param taskType 要更新的任务类型
     * @param providerId 选择的AI Provider ID
     */
    const setSelectedAIProviderId = (taskType: AITaskType, providerId: string) => {
        if (taskConfigs.value[taskType] && availableAIProviders.value.some(p => p.id === providerId)) {
            taskConfigs.value[taskType].selectedAIProviderId = providerId;
        }
    };

    return {
        taskConfigs,
        availableAIProviders,
        getAvailableAIProviders,
        initializeProviders,
        setSelectedPromptId,
        setSelectedAIProviderId,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

// src/novel/editor/stores/ai/aiTaskStore.ts
import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useEditorStore } from '../editorStore';
import { useUIStore } from '../uiStore';
import { useDerivedContentStore } from '../derivedContentStore';
import * as AITaskFactory from '@/novel/editor/services/ai/AITaskFactory';
import { processQueue } from '@/novel/editor/services/ai/AITaskExecutionService';
import type { AITask, Volume, AITaskType, AITaskStatus } from '@novel/editor/types';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    // --- State Mutation Actions ---
    const updateTaskStatus = (taskId: string, status: AITaskStatus) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = status;
        }
    };

    const updateTaskError = (taskId: string, error: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = 'failed';
            task.error = error;
        }
    };

    const appendGeneratedContent = (taskId: string, chunk: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.generatedContent += chunk;
        }
    };

    // --- Complex Actions ---
    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const newTask = await AITaskFactory.createTask(taskType, sourceItemId, finalPrompt);
        if (!newTask) return;

        // Open tab for derived content immediately
        if (newTask.type === '分析' || newTask.type === '剧情生成') {
            await nextTick();
            editorStore.openTab(newTask.targetItemId);
        }

        tasks.value.unshift(newTask);

        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }
        nextTick(processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const completeTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.status = 'completed';

            // Handle auto-application logic
            if (task.type === '润色' || task.type === '续写') {
                const strategy = uiStore.uiState.taskApplicationStrategy;
                switch (strategy.mode) {
                    case 'auto':
                        applyChanges(taskId, true);
                        break;
                    case 'delayed':
                        setTimeout(() => {
                            const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                            if (taskAfterDelay && taskAfterDelay.status === 'completed') {
                                applyChanges(taskId, true);
                            }
                        }, strategy.delaySeconds * 1000);
                        break;
                    case 'manual':
                        // Do nothing
                        break;
                }
            }
        }
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || task.status !== 'completed') return;

        if (task.type === '分析' || task.type === '剧情生成') {
            const { node: targetNode } = editorStore.findItemById(task.targetItemId);
            if (targetNode) {
                const finalTitle = task.title.split(' - ')[0];
                const newContent = formatContentForEditor(finalTitle, task.generatedContent);
                editorStore.updateItemContentById(task.targetItemId, newContent);
                const result = derivedContentStore.findItemById(task.targetItemId);
                if (result) result.title = finalTitle;
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'failed') {
            task.status = 'pending';
            task.error = undefined;
            task.generatedContent = '';
            task.finalPrompt = undefined; // Force prompt rebuild
            nextTick(processQueue);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => t.status !== 'applied' && t.status !== 'failed');
    };

    const clearAllTasks = () => {
        // Here we might need a way to signal cancellation to the execution service in a real scenario
        tasks.value = [];
    };

    return {
        tasks,
        activeTasksCount,
        startTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
        // Methods for execution service
        updateTaskStatus,
        updateTaskError,
        appendGeneratedContent,
        completeTask
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

// src/novel/editor/stores/ai/chatStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, AIModel } from '@novel/editor/types/chatTypes';
import * as chatService from '@/novel/editor/services/chatService';

export const useChatStore = defineStore('editorChat', () => {
    // --- State ---
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);

    // --- Getters (Computed) ---
    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    // --- Actions ---
    const fetchConversations = () => {
        conversations.value = chatService.getConversations();
        if (conversations.value.length > 0 && !activeConversationId.value) {
            activeConversationId.value = conversations.value[0].id;
        }
    };

    const createNewConversation = () => {
        const newConv = chatService.createConversation();
        conversations.value.unshift(newConv);
        activeConversationId.value = newConv.id;
    };

    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    const sendMessage = async () => {
        const userInput = messageInput.value.trim();
        if (!userInput || !activeConversation.value || isReceiving.value) {
            return;
        }

        const currentActiveConv = activeConversation.value;
        messageInput.value = ''; // Clear input immediately
        isReceiving.value = true;

        try {
            const { userMessage, aiResponse } = await chatService.sendMessage(userInput);
            // Ensure the conversation is still active before pushing messages
            if (activeConversation.value === currentActiveConv) {
                currentActiveConv.messages.push(userMessage);
                currentActiveConv.messages.push(aiResponse);
            }
        } catch (error) {
            console.error("Failed to send message:", error);
            // Optionally, push an error message to the chat
        } finally {
            isReceiving.value = false;
        }
    };

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', reference: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, referenceCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings, ReferenceContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const referenceContextSettings = ref<ReferenceContextSettings>({
        includeContent: true,
        includeAnalysis: false,
        includePlot: false,
        includeVolumeInfo: false,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    const setReferenceContextSetting = (key: keyof ReferenceContextSettings, value: boolean) => {
        if (key in referenceContextSettings.value) {
            referenceContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        referenceContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
        setReferenceContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);

    /**
     * 从项目数据中获取派生内容。
     * @param plotData - 项目中存储的剧情数据
     * @param analysisData - 项目中存储的分析数据
     */
    function fetchDerivedData(plotData: PlotAnalysisItem[], analysisData: PlotAnalysisItem[]) {
        plotItems.value = plotData;
        analysisItems.value = analysisData;
    }

    /**
     * 为指定源（章节或卷）创建一个新的派生内容项（占位符）。
     * @param sourceNode - 源节点对象 (章节或卷)
     * @param taskType - 任务类型 ('分析' 或 '剧情生成')
     * @returns 新创建的派生内容项
     */
    function createDerivedItem(sourceNode: EditorItem, taskType: AITaskType): PlotAnalysisItem | null {
        if (taskType !== '分析' && taskType !== '剧情生成') return null;
        if (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume') return null;


        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        const derivedType: PlotAnalysisItem['type'] = taskType === '分析' ? 'analysis' : 'plot';
        const titleSuffix = taskType;
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';

        const newItem: PlotAnalysisItem = {
            id: `${derivedType}_${now.getTime()}`, // 使用时间戳保证ID唯一
            type: derivedType,
            sourceId: sourceNode.id,
            title: `《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}`,
            content: `<h1>《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}</h1><p>AI正在生成内容，请稍候...</p>`
        };

        if (derivedType === 'analysis') {
            analysisItems.value.unshift(newItem);
        } else {
            plotItems.value.unshift(newItem);
        }

        return newItem;
    }

    /**
     * 根据ID从所有派生项中查找。
     * @param nodeId - 派生内容的ID
     */
    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    /**
     * 更新派生内容。
     * @param nodeId - 派生内容的ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            derivedItem.content = content;
        }
    }

    /**
     * (此函数不再用于派生内容，但为保持接口一致性而保留)
     * 向派生内容追加内容。
     * @param nodeId - 派生内容的ID
     * @param contentToAppend - 要追加的原始文本
     */
    function appendNodeContent(nodeId: string, contentToAppend: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            if (!derivedItem.content) derivedItem.content = "";
            derivedItem.content += paragraphs;
        }
    }

    /**
     * 删除与指定源ID关联的所有派生数据。
     * @param sourceId - 源的ID
     */
    function deleteDerivedDataForSource(sourceId: string) {
        plotItems.value = plotItems.value.filter(item => item.sourceId !== sourceId);
        analysisItems.value = analysisItems.value.filter(item => item.sourceId !== sourceId);
    }


    return {
        plotItems,
        analysisItems,
        fetchDerivedData,
        createDerivedItem,
        findItemById,
        updateNodeContent,
        appendNodeContent,
        deleteDerivedDataForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// src/novel/editor/stores/directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { useDerivedContentStore } from './derivedContentStore';
import * as directoryService from '@/novel/editor/services/directoryService';

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);

    const fetchDirectoryData = (data: Volume[]) => {
        directoryData.value = data;
    };

    const findNodeById = (nodeId: string) => {
        return directoryService.findNodeById(directoryData.value, nodeId);
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result && (result.node.type === 'chapter' || result.node.type === 'volume')) {
            directoryService.updateNodeContent(result.node, content);
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            directoryService.appendChapterContent(result.node, contentToAppend, isAutoApplied);
        }
    };

    const addNewVolume = () => {
        const uiStore = useUIStore();
        const editorStore = useEditorStore();
        const newVolume = directoryService.createVolume();
        directoryData.value.push(newVolume);

        editorStore.setEditingNodeId(newVolume.id);
        uiStore.ensureNodeIsExpanded(newVolume.id);
    };

    const addChapterToVolume = (volumeId: string) => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const editorStore = useEditorStore();
            const uiStore = useUIStore();
            const newChapter = directoryService.createChapter();
            volume.chapters.push(newChapter);

            uiStore.ensureNodeIsExpanded(volume.id);
            editorStore.openTab(newChapter.id);
            editorStore.setEditingNodeId(newChapter.id);
        }
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const result = findNodeById(nodeId);
        if (result?.node) {
            directoryService.renameNode(result.node, newTitle);
        }
    };

    const deleteNode = (nodeId: string) => {
        const result = findNodeById(nodeId);
        if (!result) return;

        // Coordination logic: Must happen before data is deleted
        const editorStore = useEditorStore();
        const derivedContentStore = useDerivedContentStore();

        if (result.node.type === 'chapter') {
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        } else if (result.node.type === 'volume') {
            result.node.chapters.forEach(chapter => {
                derivedContentStore.deleteDerivedDataForSource(chapter.id);
            });
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        }

        // Data manipulation logic
        const wasDeleted = directoryService.deleteNode(directoryData.value, nodeId);

        // UI update logic
        if (wasDeleted) {
            editorStore.closeTab(nodeId);
            if (editorStore.editingNodeId === nodeId) editorStore.setEditingNodeId(null);
        }
    };

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts
//

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        // 1. Check for System Views
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = parts.length > 2 && (parts[1] === 'history') ? parts.slice(0, 2).join(':') : id;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                if (parts.length > 2 && (parts[1] === 'history')) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                return { node: systemView, source: 'system' };
            }
        }

        // 2. Check for AI Derived Items
        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) {
            return { node: derivedItem as PlotAnalysisItem, source: 'derived' };
        }

        // 3. Check for Prompt Templates
        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) {
            return { node: promptItem, source: 'prompt' };
        }

        // 4. Check Directory
        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        // 5. Check Related Content (Settings & Custom Items)
        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        // 6. Check Notes
        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        // 7. Check Reference Books (New)
        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { getNovelProject } from '@/novel/services/novelProjectService';
import type { NovelMetadata } from '@/novel/editor/types/project';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useReferenceStore } from '../referenceStore';
import { useUIStore } from '../uiStore';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { useNovelSettingsStore } from '../novelSettingsStore';
import { useAIConfigStore } from '../ai/aiConfigStore';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);
    const currentNovelId = ref<string | null>(null);

    async function fetchNovelData(novelId: string) {
        console.log(`Fetching data for novel: ${novelId}`);
        const projectData = getNovelProject(novelId);

        if (!projectData) {
            console.error(`Novel project with ID "${novelId}" not found.`);
            return;
        }

        currentNovelId.value = novelId;

        const directoryStore = useDirectoryStore();
        const relatedContentStore = useRelatedContentStore();
        const notesStore = useNotesStore();
        const referenceStore = useReferenceStore();
        const derivedContentStore = useDerivedContentStore();
        const uiStore = useUIStore();
        const paneStore = usePaneStore();
        const tabStore = useTabStore();
        const novelSettingsStore = useNovelSettingsStore();
        const aiConfigStore = useAIConfigStore();

        // Initialize AI providers for the editor
        await aiConfigStore.initializeProviders();

        directoryStore.fetchDirectoryData(projectData.directoryData);
        relatedContentStore.fetchRelatedData(
            projectData.settingsData,
            projectData.plotCustomData,
            projectData.analysisCustomData,
            projectData.othersCustomData
        );
        derivedContentStore.fetchDerivedData(
            projectData.derivedPlotData || [],
            projectData.derivedAnalysisData || []
        );
        notesStore.fetchNotes(projectData.noteData);
        novelMetadata.value = JSON.parse(JSON.stringify(projectData.metadata));
        referenceStore.loadReferences(projectData.metadata.referenceNovelIds);

        // Notify NovelSettingsStore to update its state
        novelSettingsStore.loadSettingsData();

        paneStore.initializePanes();
        const firstChapterId = projectData.directoryData[0]?.chapters[0]?.id;
        if (firstChapterId) {
            tabStore.openTab(firstChapterId);
        }

        uiStore.uiState.expandedNodeIds.clear();
        uiStore.uiState.expandedRelatedNodeIds.clear();
        uiStore.uiState.expandedReferenceNodeIds.clear();

        if (projectData.directoryData.length > 0) {
            uiStore.uiState.expandedNodeIds.add(projectData.directoryData[0].id);
        }
        uiStore.uiState.expandedRelatedNodeIds.add('setting');
        uiStore.uiState.expandedRelatedNodeIds.add('characters');
        uiStore.uiState.expandedRelatedNodeIds.add('plot');
        uiStore.uiState.expandedRelatedNodeIds.add('analysis');
        uiStore.uiState.expandedRelatedNodeIds.add('others');
        if (projectData.metadata.referenceNovelIds.length > 0) {
            const firstRefBookId = `ref-book-${projectData.metadata.referenceNovelIds[0]}`;
            uiStore.uiState.expandedReferenceNodeIds.add(firstRefBookId);
        }
    }

    function addReferenceNovel(novelIdToAdd: string) {
        if (!novelMetadata.value || novelMetadata.value.referenceNovelIds.includes(novelIdToAdd)) {
            return;
        }
        novelMetadata.value.referenceNovelIds.push(novelIdToAdd);
        const referenceStore = useReferenceStore();
        referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
        // No need to call settings store here, as the caller (settingsStore) will do it.
    }

    function removeReferenceNovel(novelIdToRemove: string) {
        if (!novelMetadata.value) {
            return;
        }
        const index = novelMetadata.value.referenceNovelIds.indexOf(novelIdToRemove);
        if (index > -1) {
            novelMetadata.value.referenceNovelIds.splice(index, 1);
            const referenceStore = useReferenceStore();
            referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
            // No need to call settings store here, as the caller (settingsStore) will do it.
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    function saveMetadata() {
        if (!novelMetadata.value) return;
        console.log('Saving metadata:', JSON.parse(JSON.stringify(novelMetadata.value)));
        alert('小说设置已保存！');
    }

    return {
        novelMetadata,
        currentNovelId,
        fetchNovelData,
        addReferenceNovel,
        removeReferenceNovel,
        removeTag,
        addTag,
        saveMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\systemViewStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useEditorStore } from '../editorStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const editorStore = useEditorStore();
        const activeItem = editorStore.activeTab?.item;
        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\tabStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            if (node?.type === 'volume' || node?.type === 'group') {
                uiStore.toggleNodeExpansion(itemId);
            } else if (node) {
                uiStore.toggleRelatedNodeExpansion(itemId);
            }
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { usePaneStore, type EditorPane } from '@novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@novel/editor/stores/editor-state/tabStore';
import { useItemStore } from '@novel/editor/stores/editor-state/itemStore';
import { useSystemViewStore } from '@novel/editor/stores/editor-state/systemViewStore';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { useUIStore } from './uiStore';
import type { TabInfo } from '@/novel/editor/types';

export { EditorPane };

export const useEditorStore = defineStore('editor-facade', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    const splitPane = (sourcePaneId: string) => {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    };

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        splitPane,
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab: tabStore.openTab,
        closeTab: tabStore.closeTab,
        findItemById: itemStore.findItemById,
        updateItemContentById: itemStore.updateItemContentById,
        appendContentToItem: itemStore.appendContentToItem,
        toggleAIPanel: systemViewStore.toggleAIPanel,
        ensureAIPanelIsOpen: systemViewStore.ensureAIPanelIsOpen,
        toggleHistoryPanel: systemViewStore.toggleHistoryPanel,
        openReaderView: systemViewStore.openReaderView,
        fetchNovelData: metadataStore.fetchNovelData,
        getTabsForPane,
        getActiveTabForPane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { noteService } from '@/novel/editor/services/noteService';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);

    const fetchNotes = (data: NoteItem[]) => {
        notes.value = data;
    };

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);
        if (noteIndex === -1) return;

        const originalNote = notes.value[noteIndex];
        const updatedNote = noteService.updateNoteWithNewContent(originalNote, content);
        notes.value.splice(noteIndex, 1, updatedNote);
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = noteService.appendContentToNote(note.content, contentToAppend, isAutoApplied);
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const uiStore = useUIStore();
        const noteIndex = notes.value.findIndex(n => n.id === noteId);

        if (noteIndex !== -1 && newTitle.trim()) {
            const originalNote = notes.value[noteIndex];
            const trimmedTitle = newTitle.trim();
            const updatedNote = noteService.renameNote(originalNote, trimmedTitle);
            notes.value.splice(noteIndex, 1, updatedNote);
        }
        uiStore.setEditingNodeId(null);
    };

    const addNote = (title: string, content: string = '') => {
        const editorStore = useEditorStore();
        const uiStore = useUIStore();

        const newNote = noteService.createNote(title, content);
        notes.value.unshift(newNote);

        editorStore.openTab(newNote.id);
        uiStore.setEditingNodeId(newNote.id);
    };

    const deleteNote = (noteId: string) => {
        const editorStore = useEditorStore();
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            notes.value.splice(index, 1);
            editorStore.closeTab(noteId);
        }
    };

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\novelSettingsStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { novelSettingsService } from '@/novel/editor/services/novelSettingsService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

export const useNovelSettingsStore = defineStore('novel-settings', () => {
    const metadataStore = useMetadataStore();

    // State: No longer computed, but refs updated by an action.
    const novelMetadata = ref<NovelMetadata | null>(null);
    const referencedNovels = ref<NovelProject[]>([]);
    const availableReferenceNovels = ref<NovelProject[]>([]);

    /**
     * Loads and populates all data needed for the settings view.
     * This is the central point for refreshing the store's state.
     */
    function loadSettingsData() {
        const meta = metadataStore.novelMetadata;
        novelMetadata.value = meta;
        if (meta) {
            referencedNovels.value = novelSettingsService.getReferencedNovels(meta.referenceNovelIds);
            availableReferenceNovels.value = novelSettingsService.getAvailableReferenceNovels(meta);
        } else {
            referencedNovels.value = [];
            availableReferenceNovels.value = novelSettingsService.getAvailableReferenceNovels(null);
        }
    }

    const addReferenceNovel = (novelId: string) => {
        if (!novelId) return;
        metadataStore.addReferenceNovel(novelId);
        // After core data is changed, reload our UI-specific data.
        loadSettingsData();
    };

    const removeReferenceNovel = (novelId: string) => {
        metadataStore.removeReferenceNovel(novelId);
        // After core data is changed, reload our UI-specific data.
        loadSettingsData();
    };

    const addTag = () => {
        metadataStore.addTag();
    };

    const removeTag = (index: number) => {
        metadataStore.removeTag(index);
    };

    const saveMetadata = () => {
        metadataStore.saveMetadata();
    };

    const resetMetadata = () => {
        if (metadataStore.currentNovelId) {
            metadataStore.fetchNovelData(metadataStore.currentNovelId);
        }
    };

    return {
        novelMetadata,
        referencedNovels,
        availableReferenceNovels,
        loadSettingsData,
        addReferenceNovel,
        removeReferenceNovel,
        addTag,
        removeTag,
        saveMetadata,
        resetMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { promptService } from '@/novel/editor/services/promptService';
import { useAIConfigStore } from './ai/aiConfigStore';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    // State: Use a simple ref, not a computed property, for the main data tree.
    const promptTree = ref<TreeNode[]>([]);

    /**
     * Action to initialize the prompt tree if it's empty.
     * This should be called once when the editor loads.
     */
    function initialize() {
        if (promptTree.value.length === 0) {
            promptTree.value = promptService.buildInitialTree();
        }
    }

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = promptTree.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        if (!promptTree.value[0]?.children) return null;
        for (const group of promptTree.value[0].children) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPrompt(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = promptTree.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newNode: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newNode);
        return newNode;
    }

    function renamePrompt(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result && newTitle.trim()) {
            result.prompt.title = newTitle.trim();
        }
    }

    function deletePrompt(promptId: string): boolean {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            const index = group.children.findIndex(p => p.id === promptId);
            if (index > -1) {
                group.children.splice(index, 1);

                if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                    aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
                }
                return true;
            }
        }
        return false;
    }

    function updatePromptContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }

    return {
        promptTree,
        initialize,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPrompt,
        renamePrompt,
        deletePrompt,
        updatePromptContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { referenceService } from '@/novel/editor/services/referenceService';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const loadReferences = (referenceNovelIds: string[]) => {
        referenceData.value = referenceService.buildReferenceTree(referenceNovelIds);
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        loadReferences,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import * as nodeOperationService from '@/novel/editor/services/related/nodeOperationService';
import * as treeBuilderService from '@/novel/editor/services/related/treeBuilderService';
import { updateAllOverviewContent } from '@/novel/editor/services/related/overviewService';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode, ItemNode, GroupNode } from '@/novel/editor/types';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    // --- State ---
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<TreeNode[]>([]);
    const analysisCustomData = ref<TreeNode[]>([]);
    const othersCustomData = ref<TreeNode[]>([]);

    // --- Dependencies ---
    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    // --- Computed ---
    const relatedData = computed(() => {
        // Filter out derived items whose source has been deleted
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        const validPlotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        const validAnalysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        return treeBuilderService.buildRelatedTree(
            settingsData.value,
            plotCustomData.value,
            analysisCustomData.value,
            othersCustomData.value,
            promptTemplateStore.promptTree,
            validPlotItems,
            validAnalysisItems,
            directoryStore.directoryData
        );
    });

    const allDataSources = computed(() => [
        settingsData.value,
        plotCustomData.value,
        analysisCustomData.value,
        othersCustomData.value
    ]);

    // --- Watchers ---
    watch(settingsData, (newData) => {
        updateAllOverviewContent(newData);
    }, { deep: true });

    // --- Actions ---
    function fetchRelatedData(settings: any[], plot: any[], analysis: any[], others: any[]) {
        promptTemplateStore.initialize();
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
        othersCustomData.value = others;
    }

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        return nodeOperationService.findNodeById(nodeId, allDataSources.value);
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.updateNodeContent(result.node as ItemNode, content);
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.appendNodeContent(result.node as ItemNode, contentToAppend, isAutoApplied);
        }
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            nodeOperationService.renameNode(result.node, newTitle);
        }
    }

    // --- Action: Add ---
    function addRelatedNode(parentId: string, type: 'group' | 'item') {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return;

        const parentNode = result.node as GroupNode;
        const newNode = nodeOperationService.createRelatedNode(parentNode, type);
        parentNode.children.push(newNode);

        uiStore.ensureRelatedNodeIsExpanded(parentId);
        uiStore.setEditingNodeId(newNode.id);
        if (newNode.type.endsWith('_item')) {
            editorStore.openTab(newNode.id);
        }
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis') {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode = nodeOperationService.createCustomNode(target);
        dataRef.value.unshift(newNode);

        uiStore.ensureRelatedNodeIsExpanded(target);
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    function addCustomOthersNode() {
        const newNode = nodeOperationService.createCustomNode('others');
        othersCustomData.value.unshift(newNode);
        uiStore.ensureRelatedNodeIsExpanded('others');
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    // --- Action: Delete ---
    function deleteNode(nodeId: string): boolean {
        const wasRemoved = nodeOperationService.deleteNode(nodeId, allDataSources.value);
        if (wasRemoved) {
            editorStore.closeTab(nodeId);
        }
        return wasRemoved;
    }
    const deleteRelatedNode = deleteNode;
    const deleteCustomRelatedNode = deleteNode;
    const deleteCustomOthersNode = deleteNode;

    // --- Actions with specific naming for context menus ---
    const renameCustomRelatedNode = renameRelatedNode;
    const renameCustomOthersNode = renameRelatedNode;

    return {
        // State & Computed
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        // Actions
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult } from '@/novel/editor/types';
import { searchService } from '@/novel/editor/services/searchService';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const performSearch = (query: string) => {
        hasSearched.value = true;
        lastSearchedQuery.value = query;
        results.value = searchService.search(query);
    };

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\app.ts
//

// ..\src\novel\editor\types\app.ts
// 文件: src/novel/editor/types/app.ts

import type { TreeNode, Volume, Chapter, NoteItem, PlotAnalysisItem } from './models';

/**
 * AI 任务状态
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'applied';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 提供商（模型）配置
 */
export interface AIProviderConfig {
    id: string;
    name: string;
    model: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string; // 新增：源文档标题快照
    sourceItemContent: string; // 新增：源文档内容快照
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
    aiConfig: AIProviderConfig; // 新增：任务执行时使用的AI配置
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string; // 此处targetItemId即为sourceItemId
    title: string;
}

/**
 * 上下文预设或已选择的条目
 */
export interface ContextItem {
    id:string;
    category: '设定' | '其他';
    group: string;
    title:string;
    description: string;
    content: string;
}

/**
 * buildContextForTask 方法的返回结果
 */
export interface ContextBuildResult {
    fixed: string;
    dynamic: string;
    reference: string;
    rag: string;
    prompt: string;
    stats: {
        fixedCharCount: number;
        dynamicCharCount: number;
        referenceCharCount: number;
        promptCharCount: number;
        ragCharCount: number;
    };
}

/**
 * 动态上下文的配置项
 */
export interface DynamicContextSettings {
    prevVolumes: number;
    nextVolumes: number;
    prevChapters: number;
    nextChapters: number;
    includeVolumePlot: boolean;
    includeVolumeAnalysis: boolean;
    includeRelatedPlot: boolean;
    includeRelatedAnalysis: boolean;
}

/**
 * 参考书上下文的配置项
 */
export interface ReferenceContextSettings {
    includeContent: boolean;
    includeAnalysis: boolean;
    includePlot: boolean;
    includeVolumeInfo: boolean;
}


/**
 * 编辑器UI状态
 * 用于定义 uiStore 中的 uiState
 */
export interface EditorUIState {
    expandedNodeIds: Set<string>;
    expandedRelatedNodeIds: Set<string>;
    expandedReferenceNodeIds: Set<string>;
    autoOpenAIPanel: boolean;
    activeTheme: 'default' | 'eye-care' | 'dark';
    concurrentTaskLimit: number;
    taskApplicationStrategy: {
        mode: 'manual' | 'auto' | 'delayed';
        delaySeconds: number;
    };
}

/**
 * 编辑器窗格定义
 */
export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

/**
 * 系统视图信息，用于在内容区打开非文件类标签页
 */
export interface SystemViewInfo {
    id: string; // e.g., 'system:search'
    type: 'system';
    component: 'SearchView' | 'AIChatView' | 'AITaskPanel' | 'EditorSettings' | 'ContextSettings' | 'TaskSettings' | 'AIConfigSettings' | 'NovelSettings' | 'HistoryPanel' | 'ReaderPanel' | 'ThemeSettings';
    title: string;
    icon: string;
    content?: null; // 系统视图没有 content 属性
    targetItemId?: string; // For dynamic views like history
}

/**
 * 任意可被编辑器打开的条目
 * 这是一个辨识联合类型，涵盖了所有可能在标签页中打开的内容。
 */
export type EditorItem = Volume | Chapter | TreeNode | NoteItem | SystemViewInfo | PlotAnalysisItem;

/**
 * 搜索结果条目
 */
export interface SearchResult {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
    matches: { context: string }[];
}

/**
 * 标签页信息
 */
export interface TabInfo {
    id: string;
    title: string;
    icon: string;
    item: EditorItem;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//


export * from './models';
export * from './app';
export * from './chatTypes';
export * from './ui';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: TreeNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\project.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata as BaseNovelMetadata,
    TreeNode,
    ItemNode,
    PlotAnalysisItem,
} from '@/novel/editor/types';

export interface NovelMetadata extends BaseNovelMetadata {
    referenceNovelIds: string[];
}

export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    derivedPlotData: PlotAnalysisItem[];
    derivedAnalysisData: PlotAnalysisItem[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
}

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: src/novel/editor/utils/iconUtils.ts

const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\importer\services\novelParser.ts
//

import type { Volume, Chapter } from '@/novel/editor/types';

/**
 * 将纯文本段落转换为带<p>标签的HTML字符串
 * @param text - 输入的文本
 * @returns HTML格式的字符串
 */
const textToHtmlParagraphs = (text: string): string => {
    return text.split('\n').map(p => p.trim()).filter(p => p).map(p => `<p>${p}</p>`).join('');
};

/**
 * 解析小说文本并根据选项进行分章和分卷
 * @param text - 要解析的小说全文
 * @param options - 解析选项
 * @returns 返回一个卷数组，可直接用于创建新的小说项目
 */
export const parseNovelText = (
    text: string,
    options: { chaptersPerVolume: number }
): Volume[] => {
    // 1. 按空行（一个或多个换行符，中间可能包含空格）分割成章节内容块
    const chapterContents = text.split(/\n\s*\n/).filter(content => content.trim() !== '');

    // 2. 将内容块转换为章节对象
    const allChapters: Chapter[] = chapterContents.map((content, index) => {
        const lines = content.trim().split('\n');
        const title = lines[0]?.trim() || `第 ${index + 1} 章`;
        const bodyText = lines.slice(1).join('\n').trim();
        const bodyHtml = textToHtmlParagraphs(bodyText);

        return {
            id: `ch-imported-${Date.now()}-${index}`,
            type: 'chapter',
            title: title,
            wordCount: content.trim().length,
            content: `<h1>${title}</h1>${bodyHtml}`,
            status: 'completed'
        };
    });

    // 3. 将章节按指定数量分组到卷中
    const volumes: Volume[] = [];
    const { chaptersPerVolume } = options;
    let volumeIndex = 1;

    for (let i = 0; i < allChapters.length; i += chaptersPerVolume) {
        const chapterChunk = allChapters.slice(i, i + chaptersPerVolume);
        const volume: Volume = {
            id: `vol-imported-${Date.now()}-${volumeIndex}`,
            type: 'volume',
            title: `第 ${volumeIndex} 卷`,
            content: `<h1>第 ${volumeIndex} 卷</h1><p>该卷由导入功能自动创建，包含 ${chapterChunk.length} 个章节。</p>`,
            chapters: chapterChunk,
        };
        volumes.push(volume);
        volumeIndex++;
    }

    // 如果没有任何内容，则创建一个默认的空卷
    if (volumes.length === 0) {
        volumes.push({
            id: `vol-imported-${Date.now()}-1`,
            type: 'volume',
            title: '第一卷',
            content: '<h1>第一卷</h1><p>未从文件中解析出任何章节。</p>',
            chapters: [],
        });
    }

    return volumes;
};

// =
// 文件: ..\src\novel\router.ts
//

import type { RouteRecordRaw } from 'vue-router'
import { dashboardRoutes } from './dashboard/router'
import { editorRoutes } from './editor/router'

export const novelRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel',
        component: () => import('@/novel/layouts/NovelDashboardLayout.vue'),
        redirect: '/novel/dashboard',
        children: [
            ...dashboardRoutes
        ]
    },
    ...editorRoutes,
]

// =
// 文件: ..\src\novel\services\novelProjectService.ts
//

// 文件: ..\src\novel\services\novelProjectService.ts
import { novelProjects } from '@/novel/data/mockNovelProjects';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume, ItemNode, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';

const defaultSettingsData: TreeNode[] = [
    {
        id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            { id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [{ id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true }] },
            { id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [{ id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true }] },
            { id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [{ id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true }] },
            { id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [{ id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true }, { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' }] }
        ]
    }
];
const defaultPlotCustomData: ItemNode[] = [];
const defaultAnalysisCustomData: ItemNode[] = [];
const defaultOthersCustomData: ItemNode[] = [
    { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
];

export const getNovelProject = (novelId: string): NovelProject | undefined => {
    return novelProjects.get(novelId);
}

export const getAllNovelProjects = (): NovelProject[] => {
    return Array.from(novelProjects.values());
}

export const createNewNovelProject = (id: string, title: string, description: string, category: string): NovelProject => {
    const newProject: NovelProject = {
        metadata: {
            id,
            title,
            description,
            cover: `https://source.unsplash.com/random/400x500?book&sig=${Date.now()}`,
            tags: [{ text: category, class: 'bg-gray-100 text-gray-600' }],
            status: '连载中',
            referenceNovelIds: [],
        },
        directoryData: [
            {
                id: `vol-${Date.now()}`,
                type: 'volume',
                title: '第一卷',
                content: `<h1>第一卷</h1>`,
                chapters: [],
            }
        ],
        settingsData: JSON.parse(JSON.stringify(defaultSettingsData)),
        plotCustomData: JSON.parse(JSON.stringify(defaultPlotCustomData)),
        analysisCustomData: JSON.parse(JSON.stringify(defaultAnalysisCustomData)),
        derivedPlotData: [],
        derivedAnalysisData: [],
        othersCustomData: JSON.parse(JSON.stringify(defaultOthersCustomData)),
        noteData: []
    };

    novelProjects.set(id, newProject);
    return newProject;
};

export const importNovelProject = (id: string, title: string, description: string, category: string, directoryData: Volume[]): NovelProject => {
    const newProject: NovelProject = {
        metadata: {
            id,
            title,
            description,
            cover: `https://source.unsplash.com/random/400x500?book&sig=${Date.now()}`,
            tags: [{ text: category, class: 'bg-gray-100 text-gray-600' }],
            status: '连载中',
            referenceNovelIds: [],
        },
        directoryData: directoryData,
        settingsData: JSON.parse(JSON.stringify(defaultSettingsData)),
        plotCustomData: JSON.parse(JSON.stringify(defaultPlotCustomData)),
        analysisCustomData: JSON.parse(JSON.stringify(defaultAnalysisCustomData)),
        derivedPlotData: [],
        derivedAnalysisData: [],
        othersCustomData: JSON.parse(JSON.stringify(defaultOthersCustomData)),
        noteData: []
    };

    novelProjects.set(id, newProject);
    return newProject;
};

// =
// 文件: ..\src\novel\types\index.ts
//

// src/novel/types/index.ts
// 定义小说模块对外共享的数据类型

/**
 * 小说标签定义
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说状态定义
 */
export interface NovelStatus {
    text: '编辑中' | '待审核' | '已驳回' | '已发布';
    class: string;
}

/**
 * 小说分类的类型别名
 */
export type NovelCategory = '科幻' | '奇幻' | '悬疑' | '恐怖' | '都市' | '言情' | '历史';

/**
 * 小说在仪表盘列表中的数据结构。
 * 这是 NovelProject 的一个摘要视图。
 */
export interface NovelDashboardItem {
    id: string;
    title: string;
    description: string;
    cover: string;
    status: NovelStatus;
    tags: NovelTag[];
    chapters: number;
    lastUpdated: string;
    category: NovelCategory;
    deletedAt?: string;
}


/**
 * 定义“最近编辑”条目的数据结构。
 * 对应于 `RecentView.vue` 中显示的数据。
 */
export interface RecentActivityItem {
    id: string; // 活动自身的唯一ID
    novelId: string; // 关联的小说ID
    novelTitle: string; // 关联的小说标题
    novelCover: string; // 关联的小说封面

    editedItemType: 'chapter' | 'outline' | 'character'; // 被编辑的项目类型
    editedItemName: string; // 被编辑的项目名称，例如 "第四章：跃迁点" 或 "角色设定 - 艾拉"
    editedAt: string; // 编辑时间, ISO 8601 格式
    formattedTime: string; // 用于UI显示的格式化时间，如 "2小时前" 或 "下午 3:45"
}

/**
 * 定义“回收站”中条目的数据结构。
 * 对应于 `TrashView.vue` 中显示的数据。
 */
export interface DeletedItem {
    id: string; // 被删除项目的ID
    name: string; // 被删除项目的名称
    type: '小说' | '章节' | '角色'; // 被删除项目的类型
    icon: string; // 用于UI显示的图标HTML字符串
    deletedAt: string; // 删除时间, ISO 8601 格式
    retentionDays: number; // 剩余保留天数
    retentionPercent: number; // 剩余时间百分比，用于进度条显示
}

// =
// 文件: ..\src\prompt\api\promptApi.ts
//

import type { Prompt, Feature, Example } from '@/prompt/types/prompt';

const communicationMasterFeatures: Feature[] = [
    { title: '话术转换', description: '将直白表达转为委婉得体的沟通方式', icon: `<svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"/></svg>`, bgClass: 'bg-blue-50', iconBgClass: 'bg-blue-100' },
    { title: '场景适配', description: '根据不同场合提供最合适的表达建议', icon: `<svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`, bgClass: 'bg-green-50', iconBgClass: 'bg-green-100' },
    { title: '多种风格', description: '提供正式、友好、幽默等多种沟通风格', icon: `<svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/></svg>`, bgClass: 'bg-purple-50', iconBgClass: 'bg-purple-100' },
    { title: '即时优化', description: '快速生成多个优化版本供选择', icon: `<svg class="w-5 h-5 text-yellow-600" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>`, bgClass: 'bg-yellow-50', iconBgClass: 'bg-yellow-100' }
];

const communicationMasterExamples: Example[] = [
    { tag: '职场汇报', original: '"项目搞砸了，预算超了50%，时间也延期了。"', optimized: '"关于XX项目，我需要向您汇报一些挑战。目前项目遇到了一些预料之外的困难，导致预算超出原计划50%，交付时间也需要相应调整。我已经准备了详细的问题分析和解决方案..."', borderColorClass: 'border-blue-500', tagBgClass: 'text-blue-600 bg-blue-100' },
    { tag: '拒绝请求', original: '"不行，这个需求太离谱了，做不了。"', optimized: '"感谢您的信任。我仔细评估了这个需求，考虑到目前的资源限制和技术可行性，恐怕短期内难以实现。不过，我有一个替代方案可能会帮助您达到类似的效果..."', borderColorClass: 'border-green-500', tagBgClass: 'text-green-600 bg-green-100' }
];

// 模拟数据库
const mockPrompts: Prompt[] = [
    {
        id: '1',
        title: '高情商沟通大师',
        description: '将任何直白、生硬的表达，转化为礼貌、得体且不失分寸的话术。',
        icon: `<svg class="w-6 h-6 text-blue-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"/></svg>`,
        iconBgClass: 'bg-blue-50',
        tag: '沟通交流',
        tagClass: 'text-[#10B981] bg-green-50',
        likes: 1800,
        views: 12300,
        usage: 12300,
        author: '李欣然',
        authorAvatarClass: 'bg-gradient-to-br from-indigo-100 to-purple-100',
        status: '公开',
        updated: '更新于 3天前',
        isHot: false,
        isFavorite: false,
        features: communicationMasterFeatures,
        examples: communicationMasterExamples,
    },
    {
        id: '2',
        title: '爆款文案生成器',
        description: '根据产品特点和目标用户，生成引人注目的营销文案。',
        icon: `<svg class="w-6 h-6 text-purple-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L13.196 5.196z"/></svg>`,
        iconBgClass: 'bg-purple-50',
        tag: '写作',
        tagClass: 'text-[#3B82F6] bg-blue-50',
        likes: 2300,
        views: 18500,
        author: '王小美',
        authorAvatarClass: 'bg-gradient-to-br from-pink-100 to-rose-100',
        status: '公开',
        isFavorite: true,
    },
    {
        id: '3',
        title: '代码优化助手',
        description: '分析代码并提供性能优化、可读性改进的建议。',
        icon: `<svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"/></svg>`,
        iconBgClass: 'bg-green-50',
        tag: '编程',
        tagClass: 'text-[#EF4444] bg-red-50',
        likes: 956,
        views: 7200,
        author: '张程序',
        authorAvatarClass: 'bg-gradient-to-br from-blue-100 to-cyan-100',
        status: '公开',
        isFavorite: true,
    },
    {
        id: '4',
        title: '周报生成器',
        description: '根据本周工作要点，自动生成结构清晰、重点突出的周报。',
        icon: `<svg class="w-6 h-6 text-purple-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/></svg>`,
        iconBgClass: 'bg-purple-50',
        tag: '文案写作',
        tagClass: 'text-[#2563EB] bg-blue-100',
        status: '私有',
        likes: 0,
        views: 1200,
        usage: 856,
        author: '李欣然',
        authorAvatarClass: 'bg-gradient-to-br from-indigo-100 to-purple-100',
        updated: '更新于 1周前',
        isHot: false,
        isFavorite: false,
    },
    {
        id: '5',
        title: '旅游行程规划',
        description: '根据目的地、预算和偏好，生成详细的旅游行程安排。',
        icon: `<svg class="w-6 h-6 text-yellow-500" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>`,
        iconBgClass: 'bg-yellow-50',
        tag: '生活娱乐',
        tagClass: 'text-[#F59E0B] bg-yellow-100',
        status: '公开',
        likes: 3200,
        views: 28700,
        usage: 28700,
        author: '旅行家小赵',
        authorAvatarClass: 'bg-gradient-to-br from-green-100 to-lime-100',
        updated: '更新于 2周前',
        isHot: true,
        isFavorite: false,
    }
];

// 模拟网络延迟
const simulateDelay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const getPrompts = async (): Promise<Prompt[]> => {
    await simulateDelay(300);
    return JSON.parse(JSON.stringify(mockPrompts));
};

export const getPrompt = async (id: string): Promise<Prompt | undefined> => {
    await simulateDelay(200);
    return JSON.parse(JSON.stringify(mockPrompts.find(p => p.id === id)));
};

export const createPrompt = async (promptData: Omit<Prompt, 'id'>): Promise<Prompt> => {
    await simulateDelay(400);
    const newPrompt: Prompt = {
        id: String(Date.now()),
        ...promptData,
        likes: 0,
        views: 0,
        usage: 0,
        isHot: false,
        isFavorite: false,
    };
    mockPrompts.push(newPrompt);
    return JSON.parse(JSON.stringify(newPrompt));
};

export const updatePrompt = async (id: string, updates: Partial<Prompt>): Promise<Prompt | undefined> => {
    await simulateDelay(400);
    const index = mockPrompts.findIndex(p => p.id === id);
    if (index !== -1) {
        mockPrompts[index] = { ...mockPrompts[index], ...updates };
        return JSON.parse(JSON.stringify(mockPrompts[index]));
    }
    return undefined;
};

export const deletePrompt = async (id: string): Promise<boolean> => {
    await simulateDelay(500);
    const index = mockPrompts.findIndex(p => p.id === id);
    if (index !== -1) {
        mockPrompts.splice(index, 1);
        return true;
    }
    return false;
};

// =
// 文件: ..\src\prompt\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const promptRoutes: Array<RouteRecordRaw> = [
    {
        path: '/prompt',
        component: () => import('@/prompt/layouts/PromptRootLayout.vue'),
        redirect: '/prompt/market',
        children: [
            {
                path: 'market',
                name: 'prompt-market',
                component: () => import('@/prompt/views/PromptMarket.vue'),
                meta: { title: '提示词市场' }
            },
            {
                path: 'favorites',
                name: 'prompt-favorites',
                component: () => import('@/prompt/views/MyFavorites.vue'),
                meta: { title: '我的收藏' }
            },
            {
                path: 'my',
                name: 'prompt-my',
                component: () => import('@/prompt/views/MyPrompts.vue'),
                meta: { title: '我的提示词' }
            },
            {
                path: 'statistics',
                name: 'prompt-statistics',
                component: () => import('@/prompt/views/UsageStatistics.vue'),
                meta: { title: '使用统计' }
            },
            {
                path: 'editor',
                name: 'prompt-editor-new',
                component: () => import('@/prompt/views/PromptEditor.vue'),
                meta: { title: '新建提示词' }
            },
            {
                path: 'editor/:id',
                name: 'prompt-editor-edit',
                component: () => import('@/prompt/views/PromptEditor.vue'),
                meta: { title: '编辑提示词' }
            },
            {
                path: 'market/:id',
                name: 'prompt-detail',
                component: () => import('@/prompt/views/PromptDetail.vue'),
                meta: { title: '提示词详情' }
            },
        ]
    }
];

// =
// 文件: ..\src\prompt\services\promptService.ts
//

import * as promptApi from '@/prompt/api/promptApi';
import type { Prompt } from '@/prompt/types/prompt';

export const fetchAllPrompts = (): Promise<Prompt[]> => {
    return promptApi.getPrompts();
};

export const fetchPromptById = (id: string): Promise<Prompt | undefined> => {
    return promptApi.getPrompt(id);
};

export const saveNewPrompt = (promptData: Omit<Prompt, 'id'>): Promise<Prompt> => {
    return promptApi.createPrompt(promptData);
};

export const updateExistingPrompt = (id: string, updates: Partial<Prompt>): Promise<Prompt | undefined> => {
    return promptApi.updatePrompt(id, updates);
};

export const removePrompt = (id: string): Promise<boolean> => {
    return promptApi.deletePrompt(id);
};

// =
// 文件: ..\src\prompt\stores\promptStore.ts
//

import { defineStore } from 'pinia';
import * as promptService from '@/prompt/services/promptService';
import type { Prompt } from '@/prompt/types/prompt';

interface PromptState {
    prompts: Prompt[];
    currentPrompt: Prompt | null;
    isLoading: boolean;
    error: string | null;
}

export const usePromptStore = defineStore('prompt', {
    state: (): PromptState => ({
        prompts: [],
        currentPrompt: null,
        isLoading: false,
        error: null,
    }),

    getters: {
        marketPrompts: (state) => state.prompts.filter(p => p.status === '公开'),
        myFavoritePrompts: (state) => state.prompts.filter(p => p.isFavorite),
        myPrompts: (state) => state.prompts.filter(p => p.author === '李欣然'), // 假设当前用户是李欣然
    },

    actions: {
        async fetchAllPrompts() {
            if (this.prompts.length > 0) return; // 如果已有数据，则不重复获取
            this.isLoading = true;
            this.error = null;
            try {
                this.prompts = await promptService.fetchAllPrompts();
            } catch (e: any) {
                this.error = '加载提示词失败。';
            } finally {
                this.isLoading = false;
            }
        },

        async fetchPromptById(id: string) {
            this.isLoading = true;
            this.error = null;
            this.currentPrompt = null;
            try {
                const prompt = await promptService.fetchPromptById(id);
                if (prompt) {
                    this.currentPrompt = prompt;
                } else {
                    this.error = `未找到ID为 ${id} 的提示词。`;
                }
            } catch (e: any) {
                this.error = '加载提示词详情失败。';
            } finally {
                this.isLoading = false;
            }
        },

        async addPrompt(promptData: Omit<Prompt, 'id'>) {
            this.isLoading = true;
            this.error = null;
            try {
                const newPrompt = await promptService.saveNewPrompt(promptData);
                this.prompts.push(newPrompt);
            } catch (e: any) {
                this.error = '创建提示词失败。';
                throw e; // 抛出错误，以便组件可以捕获
            } finally {
                this.isLoading = false;
            }
        },

        async updatePrompt(id: string, updates: Partial<Prompt>) {
            this.isLoading = true;
            this.error = null;
            try {
                const updatedPrompt = await promptService.updateExistingPrompt(id, updates);
                if (updatedPrompt) {
                    const index = this.prompts.findIndex(p => p.id === id);
                    if (index !== -1) {
                        this.prompts[index] = updatedPrompt;
                    }
                    if (this.currentPrompt?.id === id) {
                        this.currentPrompt = updatedPrompt;
                    }
                }
            } catch (e: any) {
                this.error = '更新提示词失败。';
                throw e;
            } finally {
                this.isLoading = false;
            }
        },

        async deletePrompt(id: string) {
            this.isLoading = true;
            this.error = null;
            try {
                await promptService.removePrompt(id);
                this.prompts = this.prompts.filter(p => p.id !== id);
            } catch (e: any) {
                this.error = '删除提示词失败。';
            } finally {
                this.isLoading = false;
            }
        }
    },
});

// =
// 文件: ..\src\prompt\types\prompt.ts
//

export interface Feature {
    title: string;
    description: string;
    icon: string;
    bgClass: string;
    iconBgClass: string;
}

export interface Example {
    tag: string;
    original: string;
    optimized: string;
    borderColorClass: string;
    tagBgClass: string;
}

export interface Prompt {
    id: string;
    title:string;
    description: string;
    icon: string;
    iconBgClass: string;
    tag: string;
    tagClass: string;
    likes: number;
    views: number;
    usage?: number;
    author: string;
    authorAvatarClass: string;
    status?: '公开' | '私有';
    updated?: string;
    isHot?: boolean;
    isFavorite?: boolean;
    features?: Feature[];
    examples?: Example[];
}

// =
// 文件: ..\src\router\index.ts
//

import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'
import DefaultLayout from '@/layouts/DefaultLayout.vue'
import { protectedSettingsRoutes } from '@/settings/router' // Updated import
import { novelRoutes } from "@novel/router.ts";
import { promptRoutes } from "@/prompt/router";
import { workflowRoutes } from "@workflow/router.ts";
import { authRoutes } from "@/auth/router";
import { useAuthStore } from "@/auth/store/auth.store";

const routes: Array<RouteRecordRaw> = [
    {
        path: '/',
        redirect: '/home',
    },
    ...authRoutes,
    {
        path: '/home',
        component: DefaultLayout,
        children: [
            {
                path: '',
                name: 'home',
                component: () => import('@/home.vue'),
                meta: { title: '工作台', requiresAuth: true },
            },
        ],
    },
    ...novelRoutes,
    ...promptRoutes,
    ...workflowRoutes,
    // Use the new protected route object here
    protectedSettingsRoutes,
    {
        path: '/vip',
        name: 'VipPlan',
        component: () => import('@/settings/views/Vip.vue'),
        meta: { requiresAuth: true },
    },
]

const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes,
    scrollBehavior(to, from, savedPosition) {
        if (savedPosition) {
            return savedPosition
        } else {
            return { top: 0 }
        }
    },
})

router.beforeEach((to, from, next) => {
    const authStore = useAuthStore();

    const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
    const isAuthRoute = to.path.startsWith('/auth');

    if (requiresAuth && !authStore.isLoggedIn) {
        // 如果路由需要认证但用户未登录，重定向到登录页
        next({ name: 'Login', query: { redirect: to.fullPath } });
    } else if (isAuthRoute && authStore.isLoggedIn) {
        // 如果用户已登录，但访问的是认证页面（登录/注册），重定向到主页
        next({ name: 'home' });
    } else {
        // 其他情况，正常放行
        next();
    }
});

export default router

// =
// 文件: ..\src\settings\api\apiManagementApi.ts
//

import * as apiManagementApi from '@/api/apiManagementApi';
import type { ApiKey, ApiProvider, ModalProvider } from '@/api/apiManagementApi';

// Re-export types for the rest of the settings module
export type { ApiKey, ApiProvider, ModalProvider };

export const fetchApiProviders = (): Promise<ApiProvider[]> => {
    return apiManagementApi.fetchApiProviders();
};

export const fetchModalProviders = (): Promise<ModalProvider[]> => {
    return apiManagementApi.fetchModalProviders();
}

export const fetchApiKeys = (): Promise<ApiKey[]> => {
    return apiManagementApi.fetchApiKeys();
};

export const addApiKey = (newKeyData: Omit<ApiKey, 'id' | 'keyFragment' | 'calls' | 'created'> & {key: string}): Promise<ApiKey> => {
    return apiManagementApi.addApiKey(newKeyData);
};

export const updateApiKey = (keyData: Partial<ApiKey> & { id: number }): Promise<ApiKey> => {
    return apiManagementApi.updateApiKey(keyData);
};

export const deleteApiKey = (keyId: number): Promise<ApiKey> => {
    return apiManagementApi.deleteApiKey(keyId);
};

// =
// 文件: ..\src\settings\api\dataPrivacyApi.ts
//

import * as dataPrivacyApi from '@/api/dataPrivacyApi';
import type { DataCollectionSetting, DataUsageItem, DataPermission } from '@/api/dataPrivacyApi';

export type { DataCollectionSetting, DataUsageItem, DataPermission };

export const fetchDataPrivacyData = (): Promise<{
    collectionSettings: DataCollectionSetting[],
    usage: DataUsageItem[],
    permissions: DataPermission[],
    promises: string[]
}> => {
    return dataPrivacyApi.fetchDataPrivacyData();
};

export const saveDataCollectionSetting = (setting: DataCollectionSetting): Promise<boolean> => {
    return dataPrivacyApi.saveDataCollectionSetting(setting);
};

// =
// 文件: ..\src\settings\api\helpCenterApi.ts
//

// src/settings/api/helpCenterApi.ts

export interface HelpCategory {
    title: string;
    description: string;
    icon: string;
    bgColor: string;
}

const mockHelpCategories: HelpCategory[] = [
    {
        title: '入门指南',
        description: '快速开始使用我们的平台。',
        icon: `<svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 14l9-5-9-5-9 5 9 5z"></path><path d="M12 14l6.16-3.422a12.083 12.083 0 01.665 6.479A11.952 11.952 0 0012 20.055a11.952 11.952 0 00-6.824-9.998 12.078 12.078 0 01.665-6.479L12 14z"></path><path d="M12 14l9-5-9-5-9 5 9 5z" stroke-opacity=".4"></path></svg>`,
        bgColor: 'bg-blue-100'
    },
    {
        title: '账户与计费',
        description: '管理您的账户、订阅和付款方式。',
        icon: `<svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"></path></svg>`,
        bgColor: 'bg-green-100'
    },
    {
        title: 'API与集成',
        description: '了解如何使用API和集成第三方服务。',
        icon: `<svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>`,
        bgColor: 'bg-purple-100'
    },
];

const mockPopularQuestions: string[] = [
    '如何重置我的密码？',
    '支持哪些付款方式？',
    '我可以取消我的订阅吗？',
    '如何获取我的API密钥？',
    'Token是如何计算和消耗的？',
];

export const fetchHelpData = (): Promise<{ categories: HelpCategory[], questions: string[] }> => {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({
                categories: JSON.parse(JSON.stringify(mockHelpCategories)),
                questions: JSON.parse(JSON.stringify(mockPopularQuestions)),
            });
        }, 300);
    });
};

// =
// 文件: ..\src\settings\api\systemSettingsApi.ts
//

// src/settings/api/systemSettingsApi.ts

import * as systemSettingsApi from '@/api/systemSettingsApi';
import type { SystemSettings, Theme, SettingItem } from '@/api/systemSettingsApi';

export type { Theme, SettingItem, SystemSettings };

export const fetchThemes = (): Promise<Theme[]> => {
    return systemSettingsApi.fetchThemes();
};

export const fetchSystemSettings = (): Promise<SystemSettings> => {
    return systemSettingsApi.fetchSystemSettings();
};

export const saveSystemSetting = <T extends keyof SystemSettings>(key: T, value: SystemSettings[T]): Promise<boolean> => {
    console.log(`Module API: Forwarding save for ${key}`);
    return systemSettingsApi.saveSystemSetting(key, value);
};

// =
// 文件: ..\src\settings\api\usageLogsApi.ts
//

import * as usageLogsApi from '@/api/usageLogsApi';
import type { UsageStat, ApiLog, ChartDataPoint, FetchParams } from '@/api/usageLogsApi';

export type { UsageStat, ApiLog, ChartDataPoint, FetchParams };

export const fetchUsageData = (params: FetchParams): Promise<{
    stats: UsageStat[],
    logs: ApiLog[],
    chartData: ChartDataPoint[],
    totalLogs: number,
    totalPages: number
}> => {
    return usageLogsApi.fetchUsageData(params);
};

// =
// 文件: ..\src\settings\api\userApi.ts
//

import * as userApi from '@/api/userApi';
import type { User } from '@/auth/types';

export interface NotificationSetting {
    id: number;
    title: string;
    description: string;
    enabled: boolean;
}

export interface SecuritySetting {
    title:string;
    status: string;
    statusClass: string;
    action: string;
}

export const fetchUserSettings = (): Promise<{user: User, notifications: NotificationSetting[], securitySettings: SecuritySetting[], proPlanFeatures: string[]}> => {
    return userApi.fetchUserSettings();
};

export const saveUserSettings = (settings: {
    user: User;
    notifications: NotificationSetting[];
}): Promise<boolean> => {
    return userApi.saveUserSettings(settings);
};

// =
// 文件: ..\src\settings\router.ts
//

import type { RouteRecordRaw } from 'vue-router'
import { useUserStore } from '@/settings/stores/userStore';

export const settingsRoutes: Array<RouteRecordRaw> = [
    {
        path: 'user',
        name: 'UserSettings',
        component: () => import('@/settings/views/UserSettings.vue'),
    },
    {
        path: 'api',
        name: 'ApiManagement',
        component: () => import('@/settings/views/ApiManagement.vue'),
    },
    {
        path: 'usage-logs',
        name: 'UsageLogs',
        component: () => import('@/settings/views/UsageLogs.vue'),
    },
    {
        path: 'system',
        name: 'SystemSettings',
        component: () => import('@/settings/views/SystemSettings.vue'),
    },
    {
        path: 'data-privacy',
        name: 'DataPrivacy',
        component: () => import('@/settings/views/DataPrivacy.vue'),
    },
    {
        path: 'help',
        name: 'HelpCenter',
        component: () => import('@/settings/views/HelpCenter.vue'),
    }
]

// Top-level wrapper for all settings routes with a beforeEnter guard
export const protectedSettingsRoutes: RouteRecordRaw = {
    path: '/settings',
    component: () => import('@/settings/layouts/SettingsLayout.vue'),
    redirect: '/settings/user',
    meta: { requiresAuth: true }, // Protect the entire settings module
    // This guard ensures that data is loaded before any settings component is rendered.
    beforeEnter: async (to, from, next) => {
        const userStore = useUserStore();
        // Check if the user data is already loaded.
        if (!userStore.user) {
            try {
                // Wait for the asynchronous data initialization to complete.
                await userStore.initializeSettings();
            } catch (error) {
                console.error("Failed to initialize user settings before entering route:", error);
                // Optionally, redirect to an error page or home
                // next({ name: 'home' });
                // return;
            }
        }
        // Proceed with navigation once data is ready.
        next();
    },
    children: settingsRoutes,
};

// =
// 文件: ..\src\settings\services\apiManagementService.ts
//

// src/settings/services/apiManagementService.ts

import * as api from '@/settings/api/apiManagementApi';
import type { ApiKey } from '@/settings/api/apiManagementApi';

export const loadApiManagementData = async () => {
    const [providers, keys, modalProviders] = await Promise.all([
        api.fetchApiProviders(),
        api.fetchApiKeys(),
        api.fetchModalProviders()
    ]);
    return { providers, keys, modalProviders };
};

export const addNewApiKey = async (newKeyData: Omit<ApiKey, 'id' | 'keyFragment' | 'calls' | 'created'> & {key: string}) => {
    return await api.addApiKey(newKeyData);
};

export const updateApiKey = async (keyData: Partial<ApiKey> & { id: number }) => {
    return await api.updateApiKey(keyData);
};

export const deleteApiKey = async (keyId: number) => {
    return await api.deleteApiKey(keyId);
};

// =
// 文件: ..\src\settings\services\dataPrivacyService.ts
//

// src/settings/services/dataPrivacyService.ts

import * as api from '@/settings/api/dataPrivacyApi';
import type { DataCollectionSetting } from '@/settings/api/dataPrivacyApi';

export const loadDataPrivacyPageData = async () => {
    console.log('Service: Loading data privacy page data...');
    return await api.fetchDataPrivacyData();
};

export const saveCollectionSetting = async (setting: DataCollectionSetting) => {
    console.log('Service: Saving collection setting...');
    return await api.saveDataCollectionSetting(setting);
};

// =
// 文件: ..\src\settings\services\helpCenterService.ts
//

// src/settings/services/helpCenterService.ts

import * as api from '@/settings/api/helpCenterApi';

export const loadHelpCenterData = async () => {
    console.log('Service: Loading help center data...');
    return await api.fetchHelpData();
};

// =
// 文件: ..\src\settings\services\systemSettingsService.ts
//

// src/settings/services/systemSettingsService.ts

import * as api from '@/settings/api/systemSettingsApi';
import type { SystemSettings } from '@/settings/api/systemSettingsApi';

export const loadInitialData = async () => {
    console.log('Service: Loading initial system settings data...');
    const [themes, settings] = await Promise.all([
        api.fetchThemes(),
        api.fetchSystemSettings(),
    ]);
    return { themes, settings };
};

export const saveSetting = async <T extends keyof SystemSettings>(key: T, value: SystemSettings[T]) => {
    console.log('Service: Saving setting...');
    return await api.saveSystemSetting(key, value);
};// src/settings/stores/systemSettingsStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/systemSettingsService';
import type { Theme, SettingItem } from '@/settings/api/systemSettingsApi';

interface SystemSettingsState {
    themes: Theme[];
    activeTheme: string;
    zoomLevel: number;
    language: string;
    dateFormat: string;
    notificationSettings: SettingItem[];
    appSettings: SettingItem[];
    isLoading: boolean;
}

export const useSystemSettingsStore = defineStore('system-settings', {
    state: (): SystemSettingsState => ({
        themes: [],
        activeTheme: '',
        zoomLevel: 50,
        language: '',
        dateFormat: '',
        notificationSettings: [],
        appSettings: [],
        isLoading: false,
    }),

    actions: {
        async initializeSettings() {
            if (this.themes.length > 0) return;
            this.isLoading = true;
            try {
                const data = await service.loadInitialData();
                this.themes = data.themes;
                const { settings } = data;
                this.activeTheme = settings.activeTheme;
                this.zoomLevel = settings.zoomLevel;
                this.language = settings.language;
                this.dateFormat = settings.dateFormat;
                this.notificationSettings = settings.notificationSettings;
                this.appSettings = settings.appSettings;
            } catch (error) {
                console.error('Failed to initialize system settings:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async updateTheme(themeName: string) {
            this.activeTheme = themeName;
            await service.saveSetting('activeTheme', themeName);
        },

        // For slider, we might not want to save on every single change event
        updateZoomLevel(level: number) {
            this.zoomLevel = level;
            // In a real app, you might debounce this save call
            // service.saveSetting('zoomLevel', level);
        },

        async updateSetting(type: 'notification' | 'app', title: string, enabled: boolean) {
            const list = type === 'notification' ? this.notificationSettings : this.appSettings;
            const setting = list.find(s => s.title === title);
            if (setting) {
                setting.enabled = enabled;
                // Fire-and-forget the save
                if (type === 'notification') {
                    await service.saveSetting('notificationSettings', this.notificationSettings);
                } else {
                    await service.saveSetting('appSettings', this.appSettings);
                }
            }
        },
    },
});

// =
// 文件: ..\src\settings\services\usageLogsService.ts
//

// src/settings/services/usageLogsService.ts

import * as api from '@/settings/api/usageLogsApi';
import type { FetchParams } from '@/settings/api/usageLogsApi';

export const loadUsageData = async (params: FetchParams) => {
    console.log('Service: Loading usage data with params:', params);
    return await api.fetchUsageData(params);
};// src/settings/stores/usageLogsStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/usageLogsService';
import type { UsageStat, ApiLog } from '@/settings/api/usageLogsApi';

interface UsageLogsState {
    stats: UsageStat[];
    logs: ApiLog[];
    isLoading: boolean;
    filters: {
        period: '日' | '周' | '月';
        model: string;
        status: string;
    };
    pagination: {
        currentPage: number;
        limit: number;
        totalPages: number;
        totalLogs: number;
    };
}

export const useUsageLogsStore = defineStore('usage-logs', {
    state: (): UsageLogsState => ({
        stats: [],
        logs: [],
        isLoading: false,
        filters: {
            period: '月',
            model: '所有模型',
            status: '所有状态',
        },
        pagination: {
            currentPage: 1,
            limit: 5, // Let's show 5 logs per page
            totalPages: 1,
            totalLogs: 0,
        },
    }),

    actions: {
        async fetchUsageData() {
            this.isLoading = true;
            try {
                const params = {
                    ...this.filters,
                    page: this.pagination.currentPage,
                    limit: this.pagination.limit,
                };
                const data = await service.loadUsageData(params);
                this.stats = data.stats;
                this.logs = data.logs;
                this.pagination.totalPages = data.totalPages;
                this.pagination.totalLogs = data.totalLogs;
            } catch (error) {
                console.error('Failed to fetch usage data:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async changePeriod(period: '日' | '周' | '月') {
            this.filters.period = period;
            this.pagination.currentPage = 1;
            await this.fetchUsageData();
        },

        async changeFilter(filter: { model?: string; status?: string }) {
            if (filter.model) this.filters.model = filter.model;
            if (filter.status) this.filters.status = filter.status;
            this.pagination.currentPage = 1;
            await this.fetchUsageData();
        },

        async changePage(page: number) {
            if (page > 0 && page <= this.pagination.totalPages) {
                this.pagination.currentPage = page;
                await this.fetchUsageData();
            }
        },
    },
});

// =
// 文件: ..\src\settings\services\userService.ts
//

import * as userApi from '@/settings/api/userApi';
import type { User, NotificationSetting } from '@/auth/types';

export const loadUserSettings = async () => {
    console.log('Service: Loading all user settings...');
    return await userApi.fetchUserSettings();
};

export const saveChanges = async (settings: {
    user: User;
    notifications: NotificationSetting[];
}) => {
    console.log('Service: Saving user settings...');
    return await userApi.saveUserSettings(settings);
};

// =
// 文件: ..\src\settings\stores\apiManagementStore.ts
//

import { defineStore } from 'pinia';
import * as service from '@/settings/services/apiManagementService';
import type { ApiProvider, ApiKey, ModalProvider } from '@/settings/api/apiManagementApi';

interface ApiManagementState {
    apiProviders: ApiProvider[];
    apiKeys: ApiKey[];
    modalProviders: ModalProvider[];
    isLoading: boolean;
    isSaving: boolean;
}

export const useApiManagementStore = defineStore('api-management', {
    state: (): ApiManagementState => ({
        apiProviders: [],
        apiKeys: [],
        modalProviders: [],
        isLoading: false,
        isSaving: false,
    }),

    actions: {
        async initializeData() {
            if (this.apiProviders.length > 0) return;
            this.isLoading = true;
            try {
                const data = await service.loadApiManagementData();
                this.apiProviders = data.providers;
                this.apiKeys = data.keys;
                this.modalProviders = data.modalProviders;
            } catch (error) {
                console.error("Failed to initialize API management data:", error);
            } finally {
                this.isLoading = false;
            }
        },

        async addKey(newKeyData: Omit<ApiKey, 'id' | 'keyFragment' | 'calls' | 'created'> & {key: string}) {
            this.isSaving = true;
            try {
                const addedKey = await service.addNewApiKey(newKeyData);
                this.apiKeys.push(addedKey);

                const provider = this.apiProviders.find(p => p.name === addedKey.provider);
                if(provider) {
                    provider.activeKeys += 1;
                    if(provider.statusText === '未配置') {
                        provider.statusClass = 'status-active';
                    }
                    provider.statusText = `${provider.activeKeys}个密钥`;
                }
            } catch (error) {
                console.error("Failed to add new API key:", error);
            } finally {
                this.isSaving = false;
            }
        },

        async updateKey(keyData: Partial<ApiKey> & { id: number, key?: string }) {
            this.isSaving = true;
            try {
                if (keyData.key && keyData.key.length > 0) {
                    keyData.keyFragment = `${keyData.key.substring(0, 5)}••••${keyData.key.substring(keyData.key.length - 4)}`;
                    delete keyData.key;
                }

                const updatedKey = await service.updateApiKey(keyData as Partial<ApiKey> & { id: number });
                const index = this.apiKeys.findIndex(k => k.id === updatedKey.id);
                if (index !== -1) {
                    this.apiKeys[index] = updatedKey;
                }
            } catch (error) {
                console.error("Failed to update API key:", error);
            } finally {
                this.isSaving = false;
            }
        },

        async deleteKey(keyId: number) {
            this.isSaving = true;
            try {
                const deletedKey = await service.deleteApiKey(keyId);
                this.apiKeys = this.apiKeys.filter(k => k.id !== keyId);

                const provider = this.apiProviders.find(p => p.name === deletedKey.provider);
                if (provider) {
                    provider.activeKeys -= 1;
                    if (provider.activeKeys > 0) {
                        provider.statusText = `${provider.activeKeys}个密钥`;
                    } else {
                        provider.statusText = '未配置';
                        provider.statusClass = 'status-unconfigured';
                    }
                }
            } catch (error) {
                console.error("Failed to delete API key:", error);
            } finally {
                this.isSaving = false;
            }
        },
    },
});

// =
// 文件: ..\src\settings\stores\dataPrivacyStore.ts
//

// src/settings/stores/dataPrivacyStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/dataPrivacyService';
import type { DataCollectionSetting, DataUsageItem, DataPermission } from '@/settings/api/dataPrivacyApi';

interface DataPrivacyState {
    dataCollectionSettings: DataCollectionSetting[];
    dataUsage: DataUsageItem[];
    dataPermissions: DataPermission[];
    promises: string[];
    isLoading: boolean;
}

export const useDataPrivacyStore = defineStore('data-privacy', {
    state: (): DataPrivacyState => ({
        dataCollectionSettings: [],
        dataUsage: [],
        dataPermissions: [],
        promises: [],
        isLoading: false,
    }),

    actions: {
        async initializeData() {
            if (this.dataCollectionSettings.length > 0) return; // Avoid refetching
            this.isLoading = true;
            try {
                const data = await service.loadDataPrivacyPageData();
                this.dataCollectionSettings = data.collectionSettings;
                this.dataUsage = data.usage;
                this.dataPermissions = data.permissions;
                this.promises = data.promises;
            } catch (error) {
                console.error('Failed to initialize data privacy data:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async updateCollectionSetting(title: string, enabled: boolean) {
            const setting = this.dataCollectionSettings.find(s => s.title === title);
            if (setting) {
                setting.enabled = enabled;
                try {
                    // Fire-and-forget save operation
                    await service.saveCollectionSetting(setting);
                    console.log(`Store: Setting '${title}' updated and saved.`);
                } catch (error) {
                    console.error(`Failed to save setting '${title}':`, error);
                    // Optionally revert the change in UI
                    setting.enabled = !enabled;
                }
            }
        },
    },
});

// =
// 文件: ..\src\settings\stores\helpCenterStore.ts
//

// src/settings/stores/helpCenterStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/helpCenterService';
import type { HelpCategory } from '@/settings/api/helpCenterApi';

interface HelpCenterState {
    helpCategories: HelpCategory[];
    popularQuestions: string[];
    isLoading: boolean;
}

export const useHelpCenterStore = defineStore('help-center', {
    state: (): HelpCenterState => ({
        helpCategories: [],
        popularQuestions: [],
        isLoading: false,
    }),

    actions: {
        async initializeData() {
            if (this.helpCategories.length > 0) return;
            this.isLoading = true;
            try {
                const data = await service.loadHelpCenterData();
                this.helpCategories = data.categories;
                this.popularQuestions = data.questions;
            } catch (error) {
                console.error('Failed to initialize help center data:', error);
            } finally {
                this.isLoading = false;
            }
        },
    },
});

// =
// 文件: ..\src\settings\stores\systemSettingsStore.ts
//

// src/settings/stores/systemSettingsStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/systemSettingsService';
import type { Theme, SettingItem } from '@/settings/api/systemSettingsApi';

interface SystemSettingsState {
    themes: Theme[];
    activeTheme: string;
    zoomLevel: number;
    language: string;
    dateFormat: string;
    notificationSettings: SettingItem[];
    appSettings: SettingItem[];
    isLoading: boolean;
}

export const useSystemSettingsStore = defineStore('system-settings', {
    state: (): SystemSettingsState => ({
        themes: [],
        activeTheme: '',
        zoomLevel: 50,
        language: '',
        dateFormat: '',
        notificationSettings: [],
        appSettings: [],
        isLoading: false,
    }),

    actions: {
        async initializeSettings() {
            if (this.themes.length > 0) return;
            this.isLoading = true;
            try {
                const data = await service.loadInitialData();
                this.themes = data.themes;
                const { settings } = data;
                this.activeTheme = settings.activeTheme;
                this.zoomLevel = settings.zoomLevel;
                this.language = settings.language;
                this.dateFormat = settings.dateFormat;
                this.notificationSettings = settings.notificationSettings;
                this.appSettings = settings.appSettings;
            } catch (error) {
                console.error('Failed to initialize system settings:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async updateTheme(themeName: string) {
            this.activeTheme = themeName;
            await service.saveSetting('activeTheme', themeName);
        },

        // For slider, we might not want to save on every single change event
        updateZoomLevel(level: number) {
            this.zoomLevel = level;
            // In a real app, you might debounce this save call
            // service.saveSetting('zoomLevel', level);
        },

        async updateSetting(type: 'notification' | 'app', title: string, enabled: boolean) {
            const list = type === 'notification' ? this.notificationSettings : this.appSettings;
            const setting = list.find(s => s.title === title);
            if (setting) {
                setting.enabled = enabled;
                // Fire-and-forget the save
                if (type === 'notification') {
                    await service.saveSetting('notificationSettings', this.notificationSettings);
                } else {
                    await service.saveSetting('appSettings', this.appSettings);
                }
            }
        },
    },
});

// =
// 文件: ..\src\settings\stores\usageLogsStore.ts
//

// src/settings/stores/usageLogsStore.ts

import { defineStore } from 'pinia';
import * as service from '@/settings/services/usageLogsService';
import type { UsageStat, ApiLog, ChartDataPoint } from '@/settings/api/usageLogsApi';

interface UsageLogsState {
    stats: UsageStat[];
    logs: ApiLog[];
    chartData: ChartDataPoint[];
    isLoading: boolean;
    filters: {
        period: '日' | '周' | '月';
        model: string;
        status: string;
    };
    pagination: {
        currentPage: number;
        limit: number;
        totalPages: number;
        totalLogs: number;
    };
}

export const useUsageLogsStore = defineStore('usage-logs', {
    state: (): UsageLogsState => ({
        stats: [],
        logs: [],
        chartData: [],
        isLoading: false,
        filters: {
            period: '月',
            model: '所有模型',
            status: '所有状态',
        },
        pagination: {
            currentPage: 1,
            limit: 5,
            totalPages: 1,
            totalLogs: 0,
        },
    }),

    actions: {
        async fetchUsageData() {
            this.isLoading = true;
            try {
                const params = {
                    ...this.filters,
                    page: this.pagination.currentPage,
                    limit: this.pagination.limit,
                };
                const data = await service.loadUsageData(params);
                this.stats = data.stats;
                this.logs = data.logs;
                this.chartData = data.chartData;
                this.pagination.totalPages = data.totalPages;
                this.pagination.totalLogs = data.totalLogs;
            } catch (error) {
                console.error('Failed to fetch usage data:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async changePeriod(period: '日' | '周' | '月') {
            this.filters.period = period;
            this.pagination.currentPage = 1;
            await this.fetchUsageData();
        },

        async changeFilter(filter: { model?: string; status?: string }) {
            if (filter.model) this.filters.model = filter.model;
            if (filter.status) this.filters.status = filter.status;
            this.pagination.currentPage = 1;
            await this.fetchUsageData();
        },

        async changePage(page: number) {
            if (page > 0 && page <= this.pagination.totalPages) {
                this.pagination.currentPage = page;
                await this.fetchUsageData();
            }
        },
    },
});

// =
// 文件: ..\src\settings\stores\userStore.ts
//

// src/settings/stores/userStore.ts

import { defineStore } from 'pinia';
import * as userService from '@/settings/services/userService';
import type { User } from '@/auth/types';
import type { NotificationSetting, SecuritySetting } from '@/settings/api/userApi';

interface UserState {
    user: User | null;
    notifications: NotificationSetting[];
    securitySettings: SecuritySetting[];
    proPlanFeatures: string[];
    isLoading: boolean;
    isSaving: boolean;
    // Store original state to detect changes
    originalUser: string;
    originalNotifications: string;
}

export const useUserStore = defineStore('user-settings', {
    state: (): UserState => ({
        user: null,
        notifications: [],
        securitySettings: [],
        proPlanFeatures: [],
        isLoading: false,
        isSaving: false,
        originalUser: '{}',
        originalNotifications: '[]',
    }),

    getters: {
        hasChanges(state): boolean {
            if (!state.user) return false;
            const currentUser = JSON.stringify(state.user);
            const currentNotifications = JSON.stringify(state.notifications);
            return currentUser !== state.originalUser || currentNotifications !== state.originalNotifications;
        }
    },

    actions: {
        async initializeSettings() {
            if (this.user) return;
            this.isLoading = true;
            try {
                const data = await userService.loadUserSettings();
                this.user = data.user;
                this.notifications = data.notifications;
                this.securitySettings = data.securitySettings;
                this.proPlanFeatures = data.proPlanFeatures;

                // Set original state after fetching
                this.originalUser = JSON.stringify(this.user);
                this.originalNotifications = JSON.stringify(this.notifications);
            } catch (error) {
                console.error('Failed to initialize user settings:', error);
            } finally {
                this.isLoading = false;
            }
        },

        async saveSettings() {
            if (!this.hasChanges || !this.user) return;
            this.isSaving = true;
            try {
                await userService.saveChanges({
                    user: this.user,
                    notifications: this.notifications
                });
                // Update original state upon successful save
                this.originalUser = JSON.stringify(this.user);
                this.originalNotifications = JSON.stringify(this.notifications);
                console.log("Store: Settings saved successfully!");
            } catch (error) {
                console.error('Failed to save user settings:', error);
            } finally {
                this.isSaving = false;
            }
        },

        resetChanges() {
            this.user = JSON.parse(this.originalUser);
            this.notifications = JSON.parse(this.originalNotifications);
        },

        updateNotification(notificationId: number, enabled: boolean) {
            const notification = this.notifications.find(n => n.id === notificationId);
            if (notification) {
                notification.enabled = enabled;
            }
        }
    }
});

// =
// 文件: ..\src\types\auto-imports.d.ts
//

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-auto-import
export {}
declare global {
  const EffectScope: typeof import('vue')['EffectScope']
  const acceptHMRUpdate: typeof import('pinia')['acceptHMRUpdate']
  const computed: typeof import('vue')['computed']
  const createApp: typeof import('vue')['createApp']
  const createPinia: typeof import('pinia')['createPinia']
  const customRef: typeof import('vue')['customRef']
  const defineAsyncComponent: typeof import('vue')['defineAsyncComponent']
  const defineComponent: typeof import('vue')['defineComponent']
  const defineStore: typeof import('pinia')['defineStore']
  const effectScope: typeof import('vue')['effectScope']
  const getActivePinia: typeof import('pinia')['getActivePinia']
  const getCurrentInstance: typeof import('vue')['getCurrentInstance']
  const getCurrentScope: typeof import('vue')['getCurrentScope']
  const h: typeof import('vue')['h']
  const inject: typeof import('vue')['inject']
  const isProxy: typeof import('vue')['isProxy']
  const isReactive: typeof import('vue')['isReactive']
  const isReadonly: typeof import('vue')['isReadonly']
  const isRef: typeof import('vue')['isRef']
  const mapActions: typeof import('pinia')['mapActions']
  const mapGetters: typeof import('pinia')['mapGetters']
  const mapState: typeof import('pinia')['mapState']
  const mapStores: typeof import('pinia')['mapStores']
  const mapWritableState: typeof import('pinia')['mapWritableState']
  const markRaw: typeof import('vue')['markRaw']
  const nextTick: typeof import('vue')['nextTick']
  const onActivated: typeof import('vue')['onActivated']
  const onBeforeMount: typeof import('vue')['onBeforeMount']
  const onBeforeRouteLeave: typeof import('vue-router')['onBeforeRouteLeave']
  const onBeforeRouteUpdate: typeof import('vue-router')['onBeforeRouteUpdate']
  const onBeforeUnmount: typeof import('vue')['onBeforeUnmount']
  const onBeforeUpdate: typeof import('vue')['onBeforeUpdate']
  const onDeactivated: typeof import('vue')['onDeactivated']
  const onErrorCaptured: typeof import('vue')['onErrorCaptured']
  const onMounted: typeof import('vue')['onMounted']
  const onRenderTracked: typeof import('vue')['onRenderTracked']
  const onRenderTriggered: typeof import('vue')['onRenderTriggered']
  const onScopeDispose: typeof import('vue')['onScopeDispose']
  const onServerPrefetch: typeof import('vue')['onServerPrefetch']
  const onUnmounted: typeof import('vue')['onUnmounted']
  const onUpdated: typeof import('vue')['onUpdated']
  const onWatcherCleanup: typeof import('vue')['onWatcherCleanup']
  const provide: typeof import('vue')['provide']
  const reactive: typeof import('vue')['reactive']
  const readonly: typeof import('vue')['readonly']
  const ref: typeof import('vue')['ref']
  const resolveComponent: typeof import('vue')['resolveComponent']
  const setActivePinia: typeof import('pinia')['setActivePinia']
  const setMapStoreSuffix: typeof import('pinia')['setMapStoreSuffix']
  const shallowReactive: typeof import('vue')['shallowReactive']
  const shallowReadonly: typeof import('vue')['shallowReadonly']
  const shallowRef: typeof import('vue')['shallowRef']
  const storeToRefs: typeof import('pinia')['storeToRefs']
  const toRaw: typeof import('vue')['toRaw']
  const toRef: typeof import('vue')['toRef']
  const toRefs: typeof import('vue')['toRefs']
  const toValue: typeof import('vue')['toValue']
  const triggerRef: typeof import('vue')['triggerRef']
  const unref: typeof import('vue')['unref']
  const useAttrs: typeof import('vue')['useAttrs']
  const useCssModule: typeof import('vue')['useCssModule']
  const useCssVars: typeof import('vue')['useCssVars']
  const useId: typeof import('vue')['useId']
  const useLink: typeof import('vue-router')['useLink']
  const useModel: typeof import('vue')['useModel']
  const useRoute: typeof import('vue-router')['useRoute']
  const useRouter: typeof import('vue-router')['useRouter']
  const useSlots: typeof import('vue')['useSlots']
  const useTemplateRef: typeof import('vue')['useTemplateRef']
  const watch: typeof import('vue')['watch']
  const watchEffect: typeof import('vue')['watchEffect']
  const watchPostEffect: typeof import('vue')['watchPostEffect']
  const watchSyncEffect: typeof import('vue')['watchSyncEffect']
}
// for type re-export
declare global {
  // @ts-ignore
  export type { Component, ComponentPublicInstance, ComputedRef, DirectiveBinding, ExtractDefaultPropTypes, ExtractPropTypes, ExtractPublicPropTypes, InjectionKey, PropType, Ref, MaybeRef, MaybeRefOrGetter, VNode, WritableComputedRef } from 'vue'
  import('vue')
}
// for vue template auto import
import { UnwrapRef } from 'vue'
declare module 'vue' {
  interface GlobalComponents {}
  interface ComponentCustomProperties {
    readonly EffectScope: UnwrapRef<typeof import('vue')['EffectScope']>
    readonly acceptHMRUpdate: UnwrapRef<typeof import('pinia')['acceptHMRUpdate']>
    readonly computed: UnwrapRef<typeof import('vue')['computed']>
    readonly createApp: UnwrapRef<typeof import('vue')['createApp']>
    readonly createPinia: UnwrapRef<typeof import('pinia')['createPinia']>
    readonly customRef: UnwrapRef<typeof import('vue')['customRef']>
    readonly defineAsyncComponent: UnwrapRef<typeof import('vue')['defineAsyncComponent']>
    readonly defineComponent: UnwrapRef<typeof import('vue')['defineComponent']>
    readonly defineStore: UnwrapRef<typeof import('pinia')['defineStore']>
    readonly effectScope: UnwrapRef<typeof import('vue')['effectScope']>
    readonly getActivePinia: UnwrapRef<typeof import('pinia')['getActivePinia']>
    readonly getCurrentInstance: UnwrapRef<typeof import('vue')['getCurrentInstance']>
    readonly getCurrentScope: UnwrapRef<typeof import('vue')['getCurrentScope']>
    readonly h: UnwrapRef<typeof import('vue')['h']>
    readonly inject: UnwrapRef<typeof import('vue')['inject']>
    readonly isProxy: UnwrapRef<typeof import('vue')['isProxy']>
    readonly isReactive: UnwrapRef<typeof import('vue')['isReactive']>
    readonly isReadonly: UnwrapRef<typeof import('vue')['isReadonly']>
    readonly isRef: UnwrapRef<typeof import('vue')['isRef']>
    readonly mapActions: UnwrapRef<typeof import('pinia')['mapActions']>
    readonly mapGetters: UnwrapRef<typeof import('pinia')['mapGetters']>
    readonly mapState: UnwrapRef<typeof import('pinia')['mapState']>
    readonly mapStores: UnwrapRef<typeof import('pinia')['mapStores']>
    readonly mapWritableState: UnwrapRef<typeof import('pinia')['mapWritableState']>
    readonly markRaw: UnwrapRef<typeof import('vue')['markRaw']>
    readonly nextTick: UnwrapRef<typeof import('vue')['nextTick']>
    readonly onActivated: UnwrapRef<typeof import('vue')['onActivated']>
    readonly onBeforeMount: UnwrapRef<typeof import('vue')['onBeforeMount']>
    readonly onBeforeRouteLeave: UnwrapRef<typeof import('vue-router')['onBeforeRouteLeave']>
    readonly onBeforeRouteUpdate: UnwrapRef<typeof import('vue-router')['onBeforeRouteUpdate']>
    readonly onBeforeUnmount: UnwrapRef<typeof import('vue')['onBeforeUnmount']>
    readonly onBeforeUpdate: UnwrapRef<typeof import('vue')['onBeforeUpdate']>
    readonly onDeactivated: UnwrapRef<typeof import('vue')['onDeactivated']>
    readonly onErrorCaptured: UnwrapRef<typeof import('vue')['onErrorCaptured']>
    readonly onMounted: UnwrapRef<typeof import('vue')['onMounted']>
    readonly onRenderTracked: UnwrapRef<typeof import('vue')['onRenderTracked']>
    readonly onRenderTriggered: UnwrapRef<typeof import('vue')['onRenderTriggered']>
    readonly onScopeDispose: UnwrapRef<typeof import('vue')['onScopeDispose']>
    readonly onServerPrefetch: UnwrapRef<typeof import('vue')['onServerPrefetch']>
    readonly onUnmounted: UnwrapRef<typeof import('vue')['onUnmounted']>
    readonly onUpdated: UnwrapRef<typeof import('vue')['onUpdated']>
    readonly onWatcherCleanup: UnwrapRef<typeof import('vue')['onWatcherCleanup']>
    readonly provide: UnwrapRef<typeof import('vue')['provide']>
    readonly reactive: UnwrapRef<typeof import('vue')['reactive']>
    readonly readonly: UnwrapRef<typeof import('vue')['readonly']>
    readonly ref: UnwrapRef<typeof import('vue')['ref']>
    readonly resolveComponent: UnwrapRef<typeof import('vue')['resolveComponent']>
    readonly setActivePinia: UnwrapRef<typeof import('pinia')['setActivePinia']>
    readonly setMapStoreSuffix: UnwrapRef<typeof import('pinia')['setMapStoreSuffix']>
    readonly shallowReactive: UnwrapRef<typeof import('vue')['shallowReactive']>
    readonly shallowReadonly: UnwrapRef<typeof import('vue')['shallowReadonly']>
    readonly shallowRef: UnwrapRef<typeof import('vue')['shallowRef']>
    readonly storeToRefs: UnwrapRef<typeof import('pinia')['storeToRefs']>
    readonly toRaw: UnwrapRef<typeof import('vue')['toRaw']>
    readonly toRef: UnwrapRef<typeof import('vue')['toRef']>
    readonly toRefs: UnwrapRef<typeof import('vue')['toRefs']>
    readonly toValue: UnwrapRef<typeof import('vue')['toValue']>
    readonly triggerRef: UnwrapRef<typeof import('vue')['triggerRef']>
    readonly unref: UnwrapRef<typeof import('vue')['unref']>
    readonly useAttrs: UnwrapRef<typeof import('vue')['useAttrs']>
    readonly useCssModule: UnwrapRef<typeof import('vue')['useCssModule']>
    readonly useCssVars: UnwrapRef<typeof import('vue')['useCssVars']>
    readonly useId: UnwrapRef<typeof import('vue')['useId']>
    readonly useLink: UnwrapRef<typeof import('vue-router')['useLink']>
    readonly useModel: UnwrapRef<typeof import('vue')['useModel']>
    readonly useRoute: UnwrapRef<typeof import('vue-router')['useRoute']>
    readonly useRouter: UnwrapRef<typeof import('vue-router')['useRouter']>
    readonly useSlots: UnwrapRef<typeof import('vue')['useSlots']>
    readonly useTemplateRef: UnwrapRef<typeof import('vue')['useTemplateRef']>
    readonly watch: UnwrapRef<typeof import('vue')['watch']>
    readonly watchEffect: UnwrapRef<typeof import('vue')['watchEffect']>
    readonly watchPostEffect: UnwrapRef<typeof import('vue')['watchPostEffect']>
    readonly watchSyncEffect: UnwrapRef<typeof import('vue')['watchSyncEffect']>
  }
}


// =
// 文件: ..\src\types\components.d.ts
//

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by unplugin-vue-components
// Read more: https://github.com/vuejs/core/pull/3399
export {}

declare module 'vue' {
  export interface GlobalComponents {
    AddApiModal: typeof import('./../settings/components/AddApiModal.vue')['default']
    AIAssistantMenu: typeof import('./../novel/components/GlobalAIAssistant/AIAssistantMenu.vue')['default']
    AITaskConfigModal: typeof import('./../novel/components/GlobalAIAssistant/AITaskConfigModal.vue')['default']
    ApiConfigModal: typeof import('./../settings/components/ApiConfigModal.vue')['default']
    ConfirmationModal: typeof import('./../prompt/components/common/ConfirmationModal.vue')['default']
    EditorAIPanel: typeof import('./../novel/components/editor/EditorAIPanel.vue')['default']
    EditorContent: typeof import('./../novel/components/editor/EditorContent.vue')['default']
    EditorSidebar: typeof import('./../novel/components/editor/EditorSidebar.vue')['default']
    GlobalAIAssistant: typeof import('./../novel/components/GlobalAIAssistant/index.vue')['default']
    MarketPromptCard: typeof import('./../prompt/components/MarketPromptCard.vue')['default']
    NovelDashboardSidebar: typeof import('./../novel/components/NovelDashboardSidebar.vue')['default']
    NovelManagementSidebar: typeof import('./../novel/components/NovelManagementSidebar.vue')['default']
    NovelSidebar: typeof import('./../novel/components/NovelSidebar.vue')['default']
    PromptSidebar: typeof import('./../prompt/components/PromptSidebar.vue')['default']
    RouterLink: typeof import('vue-router')['RouterLink']
    RouterView: typeof import('vue-router')['RouterView']
    SettingsSidebar: typeof import('./../settings/components/SettingsSidebar.vue')['default']
    UsageTrendChart: typeof import('./../settings/components/UsageTrendChart.vue')['default']
  }
}


// =
// 文件: ..\src\workflow\router.ts
//


import type { RouteRecordRaw } from 'vue-router';
import WorkflowLayout from '@/workflow/layouts/WorkflowLayout.vue';

export const workflowRoutes: Array<RouteRecordRaw> = [
    {
        path: '/workflow',
        component: WorkflowLayout,
        redirect: '/workflow/dashboard',
        children: [
            // === 工作流管理 ===
            {
                path: 'dashboard',
                name: 'WorkflowDashboard',
                component: () => import('@/workflow/views/Dashboard.vue'),
                meta: { title: '工作流仪表盘' },
            },
            {
                path: 'my-flows',
                name: 'MyWorkflows',
                // 从占位符更新为实际组件
                component: () => import('@/workflow/views/MyWorkflows.vue'),
                meta: { title: '我的工作流' },
            },
            {
                path: 'market',
                name: 'WorkflowMarketplace',
                component: () => import('@/workflow/views/Marketplace.vue'),
                meta: { title: '工作流市场' },
            },
            {
                path: 'history',
                name: 'WorkflowHistory',
                component: () => import('@/workflow/views/History.vue'),
                meta: { title: '运行历史' },
            },

            // === 配置 ===
            {
                path: 'connectors',
                name: 'WorkflowConnectors',
                // 从占位符更新为实际组件
                component: () => import('@/workflow/views/Connectors.vue'),
                meta: { title: '连接器' },
            },
            {
                path: 'variables',
                name: 'WorkflowVariables',
                // 从占位符更新为实际组件
                component: () => import('@/workflow/views/Variables.vue'),
                meta: { title: '变量库' },
            },
            {
                path: 'schedules',
                name: 'WorkflowSchedules',
                // 从占位符更新为实际组件
                component: () => import('@/workflow/views/Schedules.vue'),
                meta: { title: '调度任务' },
            },
            {
                path: 'trash',
                name: 'WorkflowTrash',
                // 从占位符更新为实际组件
                component: () => import('@/workflow/views/Trash.vue'),
                meta: { title: '回收站' },
            },

            // === 动态/功能性页面 ===
            {
                path: 'editor/:id',
                name: 'WorkflowEditor',
                component: () => import('@/workflow/views/Editor.vue'),
                meta: { title: '可视化工作流编辑器' },
                props: true,
            },
            {
                path: 'run/:id',
                name: 'WorkflowRun',
                component: () => import('@/workflow/views/Run.vue'),
                meta: { title: '工作流运行配置' },
                props: true,
            },
            {
                path: 'monitor/:runId',
                name: 'WorkflowMonitor',
                component: () => import('@/workflow/views/Monitor.vue'),
                meta: { title: '工作流运行实时监控' },
                props: true,
            },
        ],
    },
];

