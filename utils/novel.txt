// == 扫描摘要 ==
//
// == 文件内容 ==

// =
// 文件: ..\src\novel\editor\api\aiApi.ts
//

// 文件: ..\src\novel\editor\api\aiApi.ts
import { useAuthStore } from '@/auth/store/auth.store';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';

export const streamAITask = async (
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: {
        onChunk: (chunk: string) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    const { onChunk, onComplete, onError } = callbacks;
    let reader: ReadableStreamDefaultReader<string> | undefined;

    try {
        const authStore = useAuthStore();
        const token = authStore.token;
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch('/api/ai/tasks/stream', {
            method: 'POST',
            headers,
            body: JSON.stringify({ prompt, config, taskType, sourceItemTitle })
        });

        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        if (!response.body) throw new Error('Response body is null.');

        reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
        let buffer = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += value;
            let boundaryIndex;
            while ((boundaryIndex = buffer.indexOf('\n\n')) >= 0) {
                const messageBlock = buffer.substring(0, boundaryIndex);
                buffer = buffer.substring(boundaryIndex + 2);

                if (messageBlock) {
                    const eventData = messageBlock.split('\n')
                        .find(line => line.startsWith('data:'))
                        ?.substring(5).trim();

                    if (eventData) {
                        try {
                            const parsedData = JSON.parse(eventData);
                            if (parsedData.event === 'chunk' && parsedData.content) onChunk(parsedData.content);
                            else if (parsedData.event === 'done') { onComplete(); return; }
                            else if (parsedData.event === 'error') { onError(parsedData.error || 'Unknown error'); return; }
                        } catch (e) { console.error("Failed to parse SSE data JSON:", eventData, e); }
                    }
                }
            }
        }
        onComplete();
    } catch (error) {
        onError(error instanceof Error ? error.message : 'An unknown streaming error occurred.');
    } finally {
        if (reader && !reader.closed) reader.cancel();
    }
};

// =
// 文件: ..\src\novel\editor\api\aiProviderApi.ts
//

import apiClient from '@/api/client';
import type { AIProviderConfig } from '@novel/editor/types';

/**
 * Fetches the list of available AI providers from the backend.
 * These are the configurations that can be used for AI tasks.
 * @returns A promise that resolves to an array of AI provider configurations.
 */
export const fetchAIProviders = async (): Promise<AIProviderConfig[]> => {
    const response = await apiClient.get('/ai/providers');
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\chapterApi.ts
//

import apiClient from '@/api/client';
import type { Chapter } from '@/novel/editor/types';

/**
 * 获取指定小说的所有章节（扁平列表）。
 * @param novelId - 小说的ID。
 * @returns 返回该小说下所有章节的数组。
 */
export const getChaptersForNovel = async (novelId: string): Promise<Chapter[]> => {
    const response = await apiClient.get(`/novels/${novelId}/chapters`);
    return response.data;
};

/**
 * 获取单个章节的详细信息，包括正文内容。
 * @param chapterId - 章节的ID。
 * @returns 返回完整的章节对象。
 */
export const getChapter = async (chapterId: string): Promise<Chapter> => {
    const response = await apiClient.get(`/chapters/${chapterId}`);
    return response.data;
};

/**
 * 在指定卷下创建一个新的章节。
 * @param volumeId - 章节所属的卷的ID。
 * @param chapterData - 创建章节所需的数据（如标题）。
 * @returns 返回新创建的章节对象。
 */
export const createChapter = async (volumeId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    const response = await apiClient.post(`/volumes/${volumeId}/chapters`, chapterData);
    return response.data;
};

/**
 * 更新指定章节的信息（如标题、内容、状态）。
 * @param chapterId - 要更新的章节的ID。
 * @param chapterData - 包含更新字段的对象。
 * @returns 返回更新后的章节对象。
 */
export const updateChapter = async (chapterId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    const response = await apiClient.patch(`/chapters/${chapterId}`, chapterData);
    return response.data;
};

/**
 * 删除一个章节。
 * @param chapterId - 要删除的章节的ID。
 */
export const deleteChapter = async (chapterId: string): Promise<void> => {
    await apiClient.delete(`/chapters/${chapterId}`);
};

/**
 * 更新一个卷下所有章节的排序。
 * @param volumeId - 卷的ID。
 * @param orderedChapterIds - 按新顺序排列的章节ID数组。
 */
export const updateChapterOrder = async (volumeId: string, orderedChapterIds: string[]): Promise<void> => {
    await apiClient.put(`/volumes/${volumeId}/chapters/order`, { orderedChapterIds });
};

// =
// 文件: ..\src\novel\editor\api\chatApi.ts
//

// 文件: ..\src\novel\editor\api\chatApi.ts
import apiClient from '@/api/client';
import type { Conversation, BackendChatMessage, StreamResponseChunk } from '@novel/editor/types/chatTypes.ts';
import { useAuthStore } from '@/auth/store/auth.store';

export const fetchConversations = async (): Promise<Conversation[]> => {
    const response = await apiClient.get('/ai/chat/conversations');
    return response.data;
};

export const createConversation = async (): Promise<Conversation> => {
    const response = await apiClient.post('/ai/chat/conversations');
    return response.data;
};

export const streamChat = async (
    apiKeyId: number,
    messages: BackendChatMessage[],
    callbacks: {
        onChunk: (chunk: StreamResponseChunk) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    try {
        const authStore = useAuthStore();
        const token = authStore.token;
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            'Accept': 'text/event-stream',
        };
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch('/api/ai/stream-chat', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                api_key_id: apiKeyId,
                messages: messages,
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.msg || `HTTP error! status: ${response.status}`);
        }

        const reader = response.body?.getReader();
        if (!reader) throw new Error('Failed to get response reader');

        const decoder = new TextDecoder();
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const rawChunk = decoder.decode(value);
            const lines = rawChunk.split('\n\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const jsonData = line.substring(6);
                    if (jsonData) {
                        try {
                            const parsedChunk: StreamResponseChunk = JSON.parse(jsonData);
                            callbacks.onChunk(parsedChunk);
                        } catch (e) {
                            console.error('Failed to parse stream chunk:', jsonData);
                        }
                    }
                }
            }
        }
        callbacks.onComplete();
    } catch (error) {
        callbacks.onError(error instanceof Error ? error.message : String(error));
    }
};

// =
// 文件: ..\src\novel\editor\api\customAnalysisApi.ts
//

// ..\src\novel\editor\api\customAnalysisApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义分析数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义分析条目数组。
 */
export const getAnalysisCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-analysis`);
    return response.data;
};

/**
 * 更新指定小শনের自定义分析数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义分析数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updateAnalysisCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-analysis`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\customOthersApi.ts
//

// 文件: ..\src\novel\editor\api\customOthersApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义“其他”数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义“其他”条目数组。
 */
export const getOthersCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-others`);
    return response.data;
};

/**
 * 更新指定小说的自定义“其他”数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义“其他”数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updateOthersCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-others`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\customPlotApi.ts
//

// 文件: ..\src\novel\editor\api\customPlotApi.ts
import apiClient from '@/api/client';
import type { ItemNode } from '@/novel/editor/types';

/**
 * 获取指定小说的自定义剧情数据。
 * @param novelId - 小说的ID。
 * @returns 返回自定义剧情条目数组。
 */
export const getPlotCustomData = async (novelId: string): Promise<ItemNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/custom-plot`);
    return response.data;
};

/**
 * 更新指定小说的自定义剧情数据。
 * @param novelId - 小说的ID。
 * @param data - 包含自定义剧情数据的条目数组。
 * @returns 返回更新后的数据。
 */
export const updatePlotCustomData = async (novelId: string, data: ItemNode[]): Promise<ItemNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/custom-plot`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\derivedContentApi.ts
//

import apiClient from '@/api/client';
import type { PlotAnalysisItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有派生内容（剧情和分析）。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有派生内容条目的数组。
 */
export const getDerivedItemsForNovel = async (novelId: string): Promise<PlotAnalysisItem[]> => {
    const response = await apiClient.get(`/novels/${novelId}/derived-content`);
    return response.data;
};

/**
 * 创建一个新的派生内容条目。
 * @param itemData - 创建条目所需的数据（类型、源ID、标题、内容）。
 * @returns 返回新创建的派生内容条目。
 */
export const createDerivedItem = async (itemData: Omit<PlotAnalysisItem, 'id'>): Promise<PlotAnalysisItem> => {
    const response = await apiClient.post(`/derived-content`, itemData);
    return response.data;
};

/**
 * 更新一个派生内容条目。
 * @param itemId - 要更新的条目的ID。
 * @param itemData - 包含更新字段的对象。
 * @returns 返回更新后的派生内容条目。
 */
export const updateDerivedItem = async (itemId: string, itemData: Partial<Omit<PlotAnalysisItem, 'id'>>): Promise<PlotAnalysisItem> => {
    const response = await apiClient.patch(`/derived-content/${itemId}`, itemData);
    return response.data;
};

/**
 * 删除一个派生内容条目。
 * @param itemId - 要删除的条目的ID。
 */
export const deleteDerivedItem = async (itemId: string): Promise<void> => {
    await apiClient.delete(`/derived-content/${itemId}`);
};

// =
// 文件: ..\src\novel\editor\api\historyApi.ts
//

// ..\src\novel\editor\api\historyApi.ts
import apiClient from '@/api/client';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';

/**
 * 根据文档ID获取其历史版本列表。
 * @param documentId - 文档的ID (例如章节ID, 卷ID等)
 * @returns 返回历史版本快照列表。
 */
export const fetchHistoryForDocument = async (documentId: string): Promise<HistoryVersion[]> => {
    const response = await apiClient.get(`/documents/${documentId}/history`);
    return response.data;
};

/**
 * 将指定文档恢复到某个历史版本。
 * @param documentId - 要恢复的文档ID。
 * @param versionId - 要恢复到的版本ID。
 */
export const restoreVersion = async (documentId: string, versionId: string): Promise<void> => {
    await apiClient.post(`/documents/${documentId}/history/${versionId}/restore`);
};

// =
// 文件: ..\src\novel\editor\api\metadataApi.ts
//

import apiClient from '@/api/client';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * 根据小说ID获取元数据
 * @param novelId - 小说ID
 * @returns 返回小说元数据
 */
export const getNovelMetadata = async (novelId: string): Promise<NovelMetadata> => {
    const response = await apiClient.get(`/novels/${novelId}/metadata`);
    return response.data;
};

/**
 * 更新小说元数据
 * @param novelId - 小说ID
 * @param metadata - 更新后的元数据
 * @returns 返回更新后的元数据
 */
export const updateNovelMetadata = async (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    const response = await apiClient.patch(`/novels/${novelId}/metadata`, metadata);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\noteApi.ts
//

import apiClient from '@/api/client';
import type { NoteItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有笔记。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有笔记条目的数组。
 */
export const getNotesForNovel = async (novelId: string): Promise<NoteItem[]> => {
    const response = await apiClient.get(`/novels/${novelId}/notes`);
    return response.data;
};

/**
 * 为指定小说创建一个新的笔记。
 * @param novelId - 小说的ID。
 * @param noteData - 创建笔记所需的数据（如标题、内容）。
 * @returns 返回新创建的笔记对象。
 */
export const createNote = async (novelId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    const response = await apiClient.post(`/novels/${novelId}/notes`, noteData);
    return response.data;
};

/**
 * 更新指定笔记的信息。
 * @param noteId - 要更新的笔记的ID。
 * @param noteData - 包含更新字段的对象。
 * @returns 返回更新后的笔记对象。
 */
export const updateNote = async (noteId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    const response = await apiClient.patch(`/notes/${noteId}`, noteData);
    return response.data;
};

/**
 * 删除一个笔记。
 * @param noteId - 要删除的笔记的ID。
 */
export const deleteNote = async (noteId: string): Promise<void> => {
    await apiClient.delete(`/notes/${noteId}`);
};

// =
// 文件: ..\src\novel\editor\api\novelProjectApi.ts
//

import apiClient from '@/api/client';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume } from '@/novel/editor/types';

/**
 * 根据ID获取一个完整的小说项目。
 * @param novelId - 小说的ID。
 * @returns 返回一个完整的小说项目。
 */
export const getNovelProject = async (novelId: string): Promise<NovelProject> => {
    const response = await apiClient.get(`/novels/projects/${novelId}`);
    return response.data;
};

/**
 * 从解析后的数据导入一本新小说。
 * @param data - 包含标题、描述和章节数据等。
 * @returns 返回新创建的完整小说项目。
 */
export const importNovelProject = async (data: {
    title: string;
    description: string;
    category: string;
    directoryData: Volume[];
}): Promise<NovelProject> => {
    const response = await apiClient.post('/novels/import', data);
    return response.data;
};

/**
 * 获取所有小说项目，用于参考书选择等场景。
 * @returns 返回所有小说项目的数组。
 */
export const fetchAllNovelProjects = async (): Promise<NovelProject[]> => {
    const response = await apiClient.get('/novels/projects');
    return response.data;
};

/**
 * 永久删除一个小说项目（非移入回收站）。
 * @param novelId - 小说ID。
 */
export const deleteNovelProject = async (novelId: string): Promise<void> => {
    await apiClient.delete(`/novels/${novelId}/permanent`);
};

// =
// 文件: ..\src\novel\editor\api\settingsApi.ts
//

// 文件: ..\src\novel\editor\api\settingsApi.ts
import apiClient from '@/api/client';
import type { TreeNode } from '@/novel/editor/types';

/**
 * 获取指定小说的设定数据。
 * @param novelId - 小说的ID。
 * @returns 返回设定数据的树形节点数组。
 */
export const getSettingsData = async (novelId: string): Promise<TreeNode[]> => {
    const response = await apiClient.get(`/novels/${novelId}/settings`);
    return response.data;
};

/**
 * 更新指定小说的设定数据。
 * @param novelId - 小说的ID。
 * @param data - 包含设定数据的树形节点数组。
 * @returns 返回更新后的数据。
 */
export const updateSettingsData = async (novelId: string, data: TreeNode[]): Promise<TreeNode[]> => {
    const response = await apiClient.put(`/novels/${novelId}/settings`, data);
    return response.data;
};

// =
// 文件: ..\src\novel\editor\api\volumeApi.ts
//

import apiClient from '@/api/client';
import type { Volume } from '@/novel/editor/types';

/**
 * 获取指定小说的所有卷（不含章节内容）。
 * @param novelId - 小说的ID。
 * @returns 返回该小说下所有卷的数组。
 */
export const getVolumes = async (novelId: string): Promise<Volume[]> => {
    const response = await apiClient.get(`/novels/${novelId}/volumes`);
    return response.data;
};

/**
 * 为指定小说创建一个新的卷。
 * @param novelId - 小说的ID。
 * @param volumeData - 创建卷所需的数据（如标题、大纲）。
 * @returns 返回新创建的卷对象。
 */
export const createVolume = async (novelId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    const response = await apiClient.post(`/novels/${novelId}/volumes`, volumeData);
    return response.data;
};

/**
 * 更新指定卷的信息（如标题、大纲）。
 * @param volumeId - 要更新的卷的ID。
 * @param volumeData - 包含更新字段的对象。
 * @returns 返回更新后的卷对象。
 */
export const updateVolume = async (volumeId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    const response = await apiClient.patch(`/volumes/${volumeId}`, volumeData);
    return response.data;
};

/**
 * 删除一个卷。
 * @param volumeId - 要删除的卷的ID。
 */
export const deleteVolume = async (volumeId: string): Promise<void> => {
    await apiClient.delete(`/volumes/${volumeId}`);
};

/**
 * 更新一个小说下所有卷的排序。
 * @param novelId - 小说的ID。
 * @param orderedVolumeIds - 按新顺序排列的卷ID数组。
 */
export const updateVolumeOrder = async (novelId: string, orderedVolumeIds: string[]): Promise<void> => {
    await apiClient.put(`/novels/${novelId}/volumes/order`, { orderedVolumeIds });
};

// =
// 文件: ..\src\novel\editor\components\ai\chat\chatData.ts
//

import type { Conversation } from '@novel/editor/types/chatTypes.ts';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings, ReferenceContextSettings, TreeNode } from '@/novel/editor/types';

const stripHtml = (html: string): string => {
    // 使用正则表达式替换，避免依赖DOM环境
    if (!html) return '';
    return html.replace(/<[^>]*>?/gm, '');
};

const _findDerivedItemsRecursive = (nodes: TreeNode[], sourceId: string): TreeNode[] => {
    let results: TreeNode[] = [];
    for (const node of nodes) {
        if (node.originalData?.sourceId === sourceId) {
            results.push(node);
        }
        if (node.children) {
            results = [...results, ..._findDerivedItemsRecursive(node.children, sourceId)];
        }
    }
    return results;
}

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const referenceStore = useReferenceStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const _buildReferenceContextHtmlByIndex = (sourceNode: Chapter | Volume, vIndex: number, cIndex: number | null, settings: ReferenceContextSettings): string => {
        // BUG: This index-based matching is fragile and likely to produce incorrect context.
        // It assumes the reference book has the exact same structure.
        // This should be replaced with a more robust matching logic (e.g., title similarity)
        // or a user-driven manual mapping feature.
        // For now, returning an empty string to prevent context pollution.
        if (true) { // Temporarily disabling this feature
            return '<!-- Reference context matching is disabled due to known bugs. -->';
        }

        if (!referenceStore.referenceData.length || vIndex < 0) return '';

        let referenceContextHtml = '';

        for (const refBook of referenceStore.referenceData) {
            const directoryRoot = refBook.children?.find(c => c.id.startsWith('ref-dir-'));
            if (!directoryRoot) continue;

            const refVolumeNode = directoryRoot.children?.[vIndex];
            if (!refVolumeNode) continue;

            let matchingNode: TreeNode | null = null;
            let matchingParent: TreeNode | null = null;

            if (sourceNode.type === 'volume') {
                matchingNode = refVolumeNode;
            } else if (sourceNode.type === 'chapter' && cIndex !== null && cIndex >= 0) {
                matchingNode = refVolumeNode.children?.[cIndex] ?? null;
                matchingParent = refVolumeNode;
            }

            if (matchingNode) {
                referenceContextHtml += `<hr><h3>参考书籍《${refBook.title}》中的匹配内容: ${matchingNode.title}</h3>`;

                if (settings.includeContent && 'content' in matchingNode && matchingNode.content) {
                    referenceContextHtml += `<h4>正文</h4>${matchingNode.content}`;
                }

                if (settings.includeVolumeInfo && matchingParent && matchingParent.type.endsWith('volume') && 'content' in matchingParent && matchingParent.content) {
                    referenceContextHtml += `<h4>所属卷信息</h4>${matchingParent.content}`;
                }

                if (settings.includePlot) {
                    const plotRoot = refBook.children?.find(c => c.id.startsWith('ref-plot-'));
                    if (plotRoot) {
                        const plotItems = _findDerivedItemsRecursive(plotRoot.children || [], matchingNode.id);
                        if (plotItems.length > 0) {
                            referenceContextHtml += `<h4>相关剧情</h4>` + plotItems.map(p => 'content' in p ? p.content : '').join('<hr>');
                        }
                    }
                }
                if (settings.includeAnalysis) {
                    const analysisRoot = refBook.children?.find(c => c.id.startsWith('ref-analysis-'));
                    if (analysisRoot) {
                        const analysisItems = _findDerivedItemsRecursive(analysisRoot.children || [], matchingNode.id);
                        if (analysisItems.length > 0) {
                            referenceContextHtml += `<h4>相关分析</h4>` + analysisItems.map(a => 'content' in a ? a.content : '').join('<hr>');
                        }
                    }
                }
            }
        }
        return referenceContextHtml;
    }

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        let referenceContextHtml = '';
        if ((sourceNode.type === 'chapter' && sourceParent) || sourceNode.type === 'volume') {
            const vIndex = directoryStore.directoryData.findIndex(v => v.id === (sourceParent?.id || sourceNode.id));
            const cIndex = sourceNode.type === 'chapter' && sourceParent ? sourceParent.chapters.findIndex(c => c.id === sourceNode.id) : null;
            referenceContextHtml = _buildReferenceContextHtmlByIndex(sourceNode, vIndex, cIndex, contextSettingsStore.referenceContextSettings);
        }
        const referenceContextText = stripHtml(referenceContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            // 使用正则表达式从<pre>标签中提取模板，更安全
            const match = promptNode.content.match(/<pre[^>]*>([\s\S]*)<\/pre>/);
            const template = match ? match[1] : selectedPromptTemplate;
            selectedPromptTemplate = template.replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# 参考书籍上下文
${referenceContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            reference: referenceContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                referenceCharCount: referenceContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\services\ai\AITaskExecutionService.ts
//


import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore';
import { useUIStore } from '@novel/editor/stores/uiStore';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder';
import { streamAITask } from '@novel/editor/services/ai/aiService.ts';
import type { AITask } from '@/novel/editor/types';

const { buildContextForTask } = useContextBuilder();

function executeTaskAndStream(task: AITask) {
    const aiTaskStore = useAITaskStore();

    aiTaskStore.updateTaskStatus(task.id, 'processing');

    // 如果任务没有最终提示词，立即构建它
    if (!task.finalPrompt) {
        const contextResult = buildContextForTask(task);
        if (!contextResult || !contextResult.prompt) {
            aiTaskStore.updateTaskError(task.id, '上下文构建失败，无法生成最终提示词。');
            processQueue(); // 继续处理下一个任务
            return;
        }
        task.finalPrompt = contextResult.prompt;
    }

    const promptToUse = task.finalPrompt;

    streamAITask(promptToUse, task.aiConfig, task.type, task.sourceItemTitle, {
        onChunk: (chunk) => {
            aiTaskStore.appendGeneratedContent(task.id, chunk);
        },
        onComplete: () => {
            aiTaskStore.completeTask(task.id);
            processQueue(); // 完成后处理下一个
        },
        onError: (error) => {
            aiTaskStore.updateTaskError(task.id, error);
            processQueue(); // 出错后也处理下一个
        }
    });
}

/**
 * 处理任务队列。检查当前正在执行的任务数是否达到并发上限，
 * 如果没有，则从等待队列中取出任务开始执行。
 */
export function processQueue() {
    const uiStore = useUIStore();
    const aiTaskStore = useAITaskStore();

    const limit = uiStore.uiState.concurrentTaskLimit;
    const processingCount = aiTaskStore.tasks.filter(t => t.status === 'processing').length;

    if (processingCount >= limit) {
        return;
    }

    const canStartCount = limit - processingCount;
    const pendingTasks = aiTaskStore.tasks.filter(t => t.status === 'pending');

    const tasksToStart = pendingTasks.slice(0, canStartCount);

    for (const task of tasksToStart) {
        executeTaskAndStream(task);
    }
}

// =
// 文件: ..\src\novel\editor\services\ai\AITaskFactory.ts
//

import { useEditorStore } from '@novel/editor/stores/editorStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import type { AITask, AITaskType } from '@/novel/editor/types';

/**
 * 创建一个新的AI任务对象。
 * @param taskType AI任务的类型。
 * @param sourceItemId 源文档的ID。
 * @param finalPrompt 可选的，预先构建好的最终提示词。
 * @returns 一个结构完整的AITask对象，如果源项目无效则返回null。
 */
export async function createTask(taskType: AITaskType, sourceItemId: string, finalPrompt?: string): Promise<AITask | null> {
    const editorStore = useEditorStore();
    const aiConfigStore = useAIConfigStore();

    const { node: sourceItem } = editorStore.findItemById(sourceItemId);
    if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
        console.error("AI Task Factory Error: Source item not found or has no content.", sourceItemId);
        return null;
    }

    // --- 核心Bug修复：版本控制 ---
    // 为源对象打上一个时间戳作为版本号
    // 如果已有，则更新它
    (sourceItem as any)._lastModified = Date.now();
    const sourceItemVersion = (sourceItem as any)._lastModified;
    // --- 核心Bug修复结束 ---

    const taskConfigSettings = aiConfigStore.taskConfigs[taskType];
    const baseAIProviderConfig = aiConfigStore.availableAIProviders.find(p => p.id === taskConfigSettings.selectedAIProviderId);

    if (!baseAIProviderConfig) {
        console.error("AI Task Factory Error: Selected AI Provider Config not found.", taskConfigSettings.selectedAIProviderId);
        alert(`未找到ID为 "${taskConfigSettings.selectedAIProviderId}" 的AI配置，请在设置中检查。`);
        return null;
    }

    const finalAIConfig = {
        ...baseAIProviderConfig,
        temperature: taskConfigSettings.temperature,
    };

    // 对于所有任务，目标ID最初都指向源ID。
    // 应用时，将根据任务类型决定是修改此ID的项，还是基于此ID创建新项。
    const targetItemId = sourceItemId;
    const taskTitle = `${taskType}《${sourceItem.title}》`;

    const newTask: AITask = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title: taskTitle,
        type: taskType,
        sourceItemId: sourceItemId,
        targetItemId: targetItemId,
        sourceItemTitle: sourceItem.title,
        sourceItemContent: sourceItem.content,
        sourceItemVersion: sourceItemVersion, // 存储版本快照
        status: 'pending',
        generatedContent: '',
        finalPrompt: finalPrompt,
        createdAt: new Date(),
        aiConfig: finalAIConfig,
    };

    return newTask;
}

// =
// 文件: ..\src\novel\editor\services\ai\aiService.ts
//

import * as aiProviderApi from '@novel/editor/api/aiProviderApi';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';
import { streamAITask as streamAITaskFromApi } from '@novel/editor/api/aiApi';

interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 从系统设置中获取所有已启用的、可供编辑器使用的AI配置。
 * @returns 返回一个符合编辑器AIProviderConfig格式的数组。
 */
export async function fetchAvailableAIProviders(): Promise<AIProviderConfig[]> {
    try {
        return await aiProviderApi.fetchAIProviders();
    } catch (error) {
        console.error("Failed to fetch available AI providers from API layer:", error);
        return [];
    }
}

/**
 * 通过API层执行一个流式AI任务。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param taskType - 任务的类型 ('润色', '续写' 等).
 * @param sourceItemTitle - 任务源文档的标题.
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: StreamCallbacks
): void {
    console.log(`[AI Service] Delegating task to API layer. Type: ${taskType}, Title: ${sourceItemTitle}`);
    streamAITaskFromApi(prompt, config, taskType, sourceItemTitle, callbacks);
}

// =
// 文件: ..\src\novel\editor\services\ai\chatService.ts
//

import * as chatApi from '@/novel/editor/api/chatApi';
import type { BackendChatMessage, Conversation, StreamResponseChunk } from '@novel/editor/types/chatTypes.ts';

export const streamMessage = (
    apiKeyId: number,
    messages: BackendChatMessage[],
    callbacks: {
        onChunk: (chunk: StreamResponseChunk) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    return chatApi.streamChat(apiKeyId, messages, callbacks);
};

// 模拟函数，保持UI可运行
export async function getConversations(): Promise<Conversation[]> {
    return await chatApi.fetchConversations();
}

export async function createConversation(): Promise<Conversation> {
    return await chatApi.createConversation();
}

// =
// 文件: ..\src\novel\editor\services\derivedContentService.ts
//

import * as derivedContentApi from '@/novel/editor/api/derivedContentApi';
import type { PlotAnalysisItem } from '@/novel/editor/types';

/**
 * 获取指定小说的所有派生内容（剧情和分析）。
 * @param novelId - 小说的ID。
 * @returns 返回一个包含所有派生内容条目的数组。
 */
export const getDerivedItemsForNovel = (novelId: string): Promise<PlotAnalysisItem[]> => {
    return derivedContentApi.getDerivedItemsForNovel(novelId);
};

/**
 * 创建一个新的派生内容条目。
 * @param itemData - 创建条目所需的数据。
 * @returns 返回新创建的派生内容条目。
 */
export const createDerivedItem = (itemData: Omit<PlotAnalysisItem, 'id'>): Promise<PlotAnalysisItem> => {
    return derivedContentApi.createDerivedItem(itemData);
};

/**
 * 更新一个派生内容条目。
 * @param itemId - 要更新的条目的ID。
 * @param itemData - 包含更新字段的对象。
 * @returns 返回更新后的派生内容条目。
 */
export const updateDerivedItem = (itemId: string, itemData: Partial<Omit<PlotAnalysisItem, 'id'>>): Promise<PlotAnalysisItem> => {
    return derivedContentApi.updateDerivedItem(itemId, itemData);
};

/**
 * 删除一个派生内容条目。
 * @param itemId - 要删除的条目的ID。
 */
export const deleteDerivedItem = (itemId: string): Promise<void> => {
    return derivedContentApi.deleteDerivedItem(itemId);
};

// =
// 文件: ..\src\novel\editor\services\diffService.ts
//

// 文件: ..\src\novel\editor\services\diffService.ts

import HtmlDiff from 'htmldiff-js';

/**
 * 计算两个HTML字符串之间的差异。
 * @param oldHtml - 旧版本的HTML内容。
 * @param newHtml - 新版本的HTML内容。
 * @returns 一个包含 <ins> 和 <del> 标签来高亮差异的HTML字符串。
 */
export const calculateHtmlDiff = (oldHtml: string, newHtml: string): string => {
    const differ = new HtmlDiff();

    // 调用 build 方法计算差异
    const diffResult = differ.build(oldHtml, newHtml);

    return diffResult;
};

// =
// 文件: ..\src\novel\editor\services\directoryService.ts
//

import * as volumeApi from '@/novel/editor/api/volumeApi';
import * as chapterApi from '@/novel/editor/api/chapterApi';
import type { Volume, Chapter } from '@/novel/editor/types';

export const getDirectoryData = async (novelId: string): Promise<Volume[]> => {
    const [volumes, chapters] = await Promise.all([
        volumeApi.getVolumes(novelId),
        chapterApi.getChaptersForNovel(novelId),
    ]);

    const volumeMap = new Map(volumes.map(v => [v.id, { ...v, chapters: [] as Chapter[] }]));
    chapters.forEach(chapter => {
        const volume = volumeMap.get(chapter.volumeId);
        if (volume) {
            volume.chapters.push(chapter);
        }
    });

    const sortedVolumes = Array.from(volumeMap.values()).sort((a, b) => a.order - b.order);
    sortedVolumes.forEach(volume => {
        volume.chapters.sort((a, b) => a.order - b.order);
    });

    return sortedVolumes;
};

export const saveDirectoryData = async (novelId: string, volumes: Volume[]): Promise<void> => {
    const savePromises: Promise<any>[] = [];

    const orderedVolumeIds = volumes.map((v, index) => {
        savePromises.push(volumeApi.updateVolume(v.id, { title: v.title, content: v.content, order: index }));
        v.chapters.forEach((c, cIndex) => {
            savePromises.push(chapterApi.updateChapter(c.id, { title: c.title, content: c.content, status: c.status, order: cIndex }));
        });
        const orderedChapterIds = v.chapters.map(c => c.id);
        savePromises.push(chapterApi.updateChapterOrder(v.id, orderedChapterIds));
        return v.id;
    });

    savePromises.push(volumeApi.updateVolumeOrder(novelId, orderedVolumeIds));

    await Promise.all(savePromises);
};

export const createVolume = (novelId: string, volumeData: Partial<Omit<Volume, 'id' | 'chapters'>>): Promise<Volume> => {
    return volumeApi.createVolume(novelId, volumeData);
};

export const deleteVolume = (volumeId: string): Promise<void> => {
    return volumeApi.deleteVolume(volumeId);
};

export const createChapter = (volumeId: string, chapterData: Partial<Omit<Chapter, 'id'>>): Promise<Chapter> => {
    return chapterApi.createChapter(volumeId, chapterData);
};

export const deleteChapter = (chapterId: string): Promise<void> => {
    return chapterApi.deleteChapter(chapterId);
};

// =
// 文件: ..\src\novel\editor\services\historyService.ts
//

import * as historyApi from '@/novel/editor/api/historyApi';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';
import { useEditorStore } from '@novel/editor/stores/editorStore';
;

/**
 * 获取指定文档的历史版本列表。
 */
export const getHistoryVersions = async (documentId: string): Promise<HistoryVersion[]> => {
    return await historyApi.fetchHistoryForDocument(documentId);
};

/**
 * 将指定文档恢复到某个历史版本。
 * @param documentId - 要恢复的文档ID。
 * @param versionId - 要恢复到的版本ID。
 */
export const restoreVersion = async (documentId: string, versionId: string): Promise<void> => {
    const editorStore = useEditorStore();
    const novelId = editorStore.novelMetadata?.id;

    if (!novelId) {
        console.error('无法恢复版本：未找到当前小说ID。');
        alert('恢复失败，缺少小说上下文。');
        return;
    }

    await historyApi.restoreVersion(documentId, versionId);

    // 恢复成功后，重新加载整个项目以确保数据一致性
    const { loadProject } = useProjectManager();
    await loadProject(novelId);
};

// =
// 文件: ..\src\novel\editor\services\metadataService.ts
//

// 文件: ..\src\novel\editor\services\metadataService.ts
import * as metadataApi from '@/novel/editor/api/metadataApi';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * 根据小说ID获取元数据
 * @param novelId - 小说ID
 * @returns 返回小说元数据
 */
export const getNovelMetadata = (novelId: string): Promise<NovelMetadata> => {
    return metadataApi.getNovelMetadata(novelId);
};

/**
 * 更新小说元数据
 * @param novelId - 小说ID
 * @param metadata - 更新后的元数据
 * @returns 返回更新后的元数据
 */
export const updateNovelMetadata = (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    return metadataApi.updateNovelMetadata(novelId, metadata);
};

// =
// 文件: ..\src\novel\editor\services\noteService.ts
//

import * as noteApi from '@/novel/editor/api/noteApi';
import type { NoteItem } from '@/novel/editor/types';

// --- API Facade ---

export const getNotesForNovel = (novelId: string): Promise<NoteItem[]> => {
    return noteApi.getNotesForNovel(novelId);
};

export const createNoteApi = (novelId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    return noteApi.createNote(novelId, noteData);
};

export const updateNoteApi = (noteId: string, noteData: Partial<Omit<NoteItem, 'id'>>): Promise<NoteItem> => {
    return noteApi.updateNote(noteId, noteData);
};

export const deleteNoteApi = (noteId: string): Promise<void> => {
    return noteApi.deleteNote(noteId);
};


// --- Client-side Logic ---

/**
 * 根据新的HTML内容更新笔记对象，并同步标题
 * @param note - 要更新的原始笔记对象
 * @param newContent - 新的HTML内容
 * @returns 一个被更新后的新笔记对象副本
 */
export const updateNoteWithNewContent = (note: NoteItem, newContent: string): NoteItem => {
    const updatedNote = { ...note, content: newContent };

    const h1Match = newContent.match(/<h1[^>]*>(.*?)<\/h1>/);
    const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;

    if (newTitle) {
        updatedNote.title = newTitle;
    }

    return updatedNote;
};

/**
 * 将文本内容附加到现有笔记内容的末尾
 * @param originalContent - 原始HTML内容
 * @param contentToAppend - 要附加的纯文本内容
 * @param isAutoApplied - 是否为AI自动应用，若是则添加一个标记
 * @returns 附加了新内容的完整HTML字符串
 */
export const appendContentToNote = (originalContent: string, contentToAppend: string, isAutoApplied: boolean): string => {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    return (originalContent || "") + htmlToAppend;
};

/**
 * 根据新标题更新笔记对象，并同步内容中的<h1>标签
 * @param note - 要更新的原始笔记对象
 * @param newTitle - 新的标题
 * @returns 一个被更新后的新笔记对象副本
 */
export const renameNote = (note: NoteItem, newTitle: string): NoteItem => {
    const updatedNote = { ...note, title: newTitle };
    if (updatedNote.content.includes('<h1>')) {
        updatedNote.content = updatedNote.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
    } else {
        updatedNote.content = `<h1>${newTitle}</h1>` + updatedNote.content;
    }
    return updatedNote;
};

// =
// 文件: ..\src\novel\editor\services\novelSettingsService.ts
//


import * as novelProjectService from '@/novel/services/novelProjectService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

class NovelSettingsService {

    /**
     * 根据ID数组异步获取完整的小说项目对象列表。
     * @param novelIds - 要获取的小说ID数组。
     * @returns 完整的小说项目对象数组。
     */
    public async getReferencedNovels(novelIds: string[]): Promise<NovelProject[]> {
        if (!novelIds || novelIds.length === 0) return [];

        const projects = await Promise.all(
            novelIds.map(id => novelProjectService.getNovelProject(id).catch(() => undefined))
        );

        return projects.filter((p): p is NovelProject => p !== undefined);
    }

    /**
     * 异步获取可供添加为参考书的所有其他小说项目。
     * @param novelMetadata - 当前正在编辑的小说的元数据。
     * @returns 可用的参考小说项目数组。
     */
    public async getAvailableReferenceNovels(novelMetadata: NovelMetadata | null): Promise<NovelProject[]> {
        const allNovels = await novelProjectService.fetchAllNovelProjects();
        if (!novelMetadata) return allNovels;

        const currentAndReferencedIds = new Set([
            ...(novelMetadata.referenceNovelIds || []),
            novelMetadata.id
        ]);

        return allNovels.filter(novel => !currentAndReferencedIds.has(novel.metadata.id));
    }
}

export const novelSettingsService = new NovelSettingsService();

// =
// 文件: ..\src\novel\editor\services\promptService.ts
//

import type { TreeNode, AITaskType } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

class PromptService {

    public buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }
}

export const promptService = new PromptService();

// =
// 文件: ..\src\novel\editor\services\referenceService.ts
//

import type { TreeNode, ItemNode, PlotAnalysisItem, Volume, Chapter } from '@/novel/editor/types';
import type { NovelProject } from '@/novel/editor/types/project';
import { getNovelProject } from '@/novel/editor/api/novelProjectApi.ts';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class ReferenceService {

    private makeNodesReadOnly(nodes: TreeNode[]): TreeNode[] {
        return nodes.map(node => {
            const newNode: TreeNode = { ...node, isReadOnly: true };
            if (newNode.children) {
                newNode.children = this.makeNodesReadOnly(newNode.children);
            }
            if (newNode.isOverview) {
                newNode.content = `<p class="overview-placeholder">参考书中所有内容均为只读。</p>`;
            }
            return newNode;
        });
    }

    private projectToTreeNode(project: NovelProject): TreeNode {
        const rootNode: TreeNode = {
            id: `ref-book-${project.metadata.id}`,
            type: 'reference_book',
            title: project.metadata.title,
            icon: getIconByNodeType('reference_book'),
            children: []
        };

        const directoryNode: TreeNode = {
            id: `ref-dir-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '目录',
            icon: 'fa-regular fa-folder-open',
            children: this.makeNodesReadOnly(project.directoryData.map((vol: Volume) => ({
                id: vol.id,
                title: vol.title,
                type: 'reference_volume',
                icon: getIconByNodeType('reference_volume'),
                content: vol.content,
                isReadOnly: true,
                children: vol.chapters.map((chap: Chapter) => ({
                    id: chap.id,
                    title: chap.title,
                    type: 'reference_chapter',
                    icon: getIconByNodeType('reference_chapter'),
                    content: chap.content,
                    isReadOnly: true
                }))
            })))
        };
        rootNode.children?.push(directoryNode);

        const buildRefDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[] | undefined, directory: Volume[]): TreeNode[] => {
            if (!dataArray || dataArray.length === 0) return [];

            return directory.map((volume: Volume) => {
                const derivedForVolume = dataArray
                    .filter((item: PlotAnalysisItem) => item.sourceId === volume.id)
                    .map((item: PlotAnalysisItem) => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        content: item.content,
                        originalData: item
                    }));

                const derivedForChapters = volume.chapters
                    .map((chapter: Chapter) => {
                        const itemsForChapter = dataArray.filter((item: PlotAnalysisItem) => item.sourceId === chapter.id);
                        if (itemsForChapter.length === 0) return null;

                        return {
                            id: `ref-derived-group-${type}-${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            children: itemsForChapter.map((item: PlotAnalysisItem) => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                content: item.content,
                                originalData: item
                            }))
                        };
                    })
                    .filter((c: TreeNode | null): c is TreeNode => c !== null);

                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `ref-derived-group-${type}-${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v: TreeNode | null): v is TreeNode => v !== null);
        };

        const plotTree = buildRefDerivedContentTree('plot', project.derivedPlotData, project.directoryData);
        const plotNode: TreeNode = {
            id: `ref-plot-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '剧情',
            icon: getIconByNodeType('plot'),
            children: this.makeNodesReadOnly([
                ...project.plotCustomData,
                ...plotTree
            ])
        };
        if (plotNode.children && plotNode.children.length > 0) {
            rootNode.children?.push(plotNode);
        }

        const analysisTree = buildRefDerivedContentTree('analysis', project.derivedAnalysisData, project.directoryData);
        const analysisNode: TreeNode = {
            id: `ref-analysis-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '分析',
            icon: getIconByNodeType('analysis'),
            children: this.makeNodesReadOnly([
                ...project.analysisCustomData,
                ...analysisTree
            ])
        };
        if (analysisNode.children && analysisNode.children.length > 0) {
            rootNode.children?.push(analysisNode);
        }

        const settingsRoot = project.settingsData.find(n => n.id === 'setting');
        if (settingsRoot && settingsRoot.children) {
            const settingsNode: TreeNode = {
                id: `ref-settings-${project.metadata.id}`,
                type: 'reference_content_item',
                title: settingsRoot.title,
                icon: getIconByNodeType('setting'),
                children: this.makeNodesReadOnly(settingsRoot.children)
            };
            rootNode.children?.push(settingsNode);
        }

        return rootNode;
    }

    public async buildReferenceTree(referenceNovelIds: string[]): Promise<TreeNode[]> {
        if (!referenceNovelIds || referenceNovelIds.length === 0) {
            return [];
        }

        const projects = await Promise.all(
            referenceNovelIds.map(id => getNovelProject(id))
        );

        const validProjects = projects.filter((p): p is NovelProject => p !== undefined);

        return validProjects.map(project => this.projectToTreeNode(project));
    }
}

export const referenceService = new ReferenceService();

// =
// 文件: ..\src\novel\editor\services\related\nodeOperationService.ts
//

// src/novel/editor/services/related/nodeOperationService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// Private helper function
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// Private helper function
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
};

export function findNodeById(nodeId: string, allDataSources: TreeNode[][]): { node: TreeNode; parent: TreeNode | null; } | null {
    for (const source of allDataSources) {
        const result = _findNodeInTreeRecursive(source, nodeId);
        if (result) return result;
    }
    return null;
}

export function createRelatedNode(parentNode: GroupNode, type: 'group' | 'item'): GroupNode | ItemNode {
    const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
    const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
    const newNodeIcon = getIconByNodeType(newNodeType);

    if (type === 'group') {
        const newNode: GroupNode = {
            id: `group-${Date.now()}`,
            title: '新建分组',
            type: 'group',
            icon: newNodeIcon,
            children: [],
        };
        return newNode;
    } else { // type === 'item'
        const newNode: ItemNode = {
            id: `item-${Date.now()}`,
            title: '新建条目',
            type: newNodeType as ItemNode['type'],
            icon: newNodeIcon,
            content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
        };
        return newNode;
    }
}

export function createCustomNode(type: 'plot' | 'analysis' | 'others'): ItemNode {
    const itemType = type === 'others' ? 'others_item' : `${type}_item`;
    const icon = getIconByNodeType(itemType);
    const title = type === 'others' ? '新建其他条目' : '新建自定义条目';

    const newNode: ItemNode = {
        id: `custom-${type}-${Date.now()}`,
        title: title,
        type: itemType as ItemNode['type'],
        icon: icon,
        content: `<h1>${title}</h1><p>请在此处填写内容...</p>`,
    };
    return newNode;
}

export function deleteNode(nodeId: string, allDataSources: TreeNode[][]): boolean {
    for (const source of allDataSources) {
        if (_findAndRemoveNodeInTree(source, nodeId)) {
            return true;
        }
    }
    return false;
}

export function renameNode(node: TreeNode, newTitle: string) {
    if (node && !node.isReadOnly && newTitle.trim()) {
        const trimmedTitle = newTitle.trim();
        node.title = trimmedTitle;
        if ('content' in node && node.content && node.content.includes('<h1>')) {
            (node as ItemNode).content = (node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        }
        (node as any)._lastModified = Date.now(); // Update version timestamp
    }
}

export function updateNodeContent(node: ItemNode, content: string) {
    node.content = content;
    (node as any)._lastModified = Date.now(); // Update version timestamp
    if (!node.isReadOnly) {
        const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
        if (newTitle && newTitle !== node.title) {
            node.title = newTitle;
        }
    }
}

export function appendNodeContent(node: ItemNode, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    if (!node.content) node.content = "";
    node.content += htmlToAppend;
    (node as any)._lastModified = Date.now(); // Update version timestamp
}

// =
// 文件: ..\src\novel\editor\services\related\overviewService.ts
//


import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
 * @param htmlContent - HTML 字符串
 * @returns 降级后的 HTML 字符串
 */
const demoteHeadings = (htmlContent: string): string => {
    if (typeof document === 'undefined') return htmlContent; // Guard for SSR
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
    headings.forEach(heading => {
        const level = parseInt(heading.tagName.charAt(1), 10);
        const newLevel = Math.min(6, level + 1); // 最多降到 h6
        const newHeading = document.createElement(`h${newLevel}`);
        newHeading.innerHTML = heading.innerHTML;
        for (const attr of heading.attributes) {
            newHeading.setAttribute(attr.name, attr.value);
        }
        heading.parentNode?.replaceChild(newHeading, heading);
    });
    return tempDiv.innerHTML;
};


/**
 * 更新单个分组节点下的总览内容。
 * @param groupNode - 包含总览节点的父分组节点。
 */
function updateOverviewContentForGroup(groupNode: GroupNode) {
    if (!groupNode.children) return;

    const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
    if (!overviewNode) return;

    const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

    const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

    overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
}

/**
 * 遍历整个设定树，更新所有找到的总览节点。
 * @param settingsData - 设定的树形数据 (可直接修改)
 */
export function updateAllOverviewContent(settingsData: TreeNode[]) {
    const findAndProcess = (nodes: TreeNode[]) => {
        for (const node of nodes) {
            if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                updateOverviewContentForGroup(node as GroupNode);
            }
            if (node.children) {
                findAndProcess(node.children);
            }
        }
    };
    findAndProcess(settingsData);
}

// =
// 文件: ..\src\novel\editor\services\related\treeBuilderService.ts
//

// src/novel/editor/services/related/treeBuilderService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode, Volume } from '@novel/editor/types';

function buildDerivedContentTree(
    type: 'plot' | 'analysis',
    dataArray: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    return directoryData.map(volume => {
        const derivedForVolume = dataArray
            .filter(item => item.sourceId === volume.id)
            .map(item => ({
                id: item.id,
                title: item.title,
                type: `${type}_item` as ItemNode['type'],
                icon: getIconByNodeType(`${type}_item`),
                originalData: item,
                content: item.content
            }));

        const derivedForChapters = volume.chapters
            .map(chapter => {
                const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                if (derivedForChapter.length === 0) return null;

                return {
                    id: `${type}_ch_group_${chapter.id}`,
                    title: chapter.title,
                    type: 'group',
                    icon: getIconByNodeType('chapter'),
                    isReadOnly: true,
                    children: derivedForChapter.map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }))
                };
            })
            .filter((c): c is TreeNode => c !== null);

        if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
            return null;
        }

        return {
            id: `${type}_vol_group_${volume.id}`,
            title: volume.title,
            type: 'group',
            icon: getIconByNodeType('volume'),
            isReadOnly: true,
            children: [
                ...derivedForVolume,
                ...derivedForChapters
            ]
        };
    }).filter((v): v is TreeNode => v !== null);
}

/**
 * 构建完整的 "相关内容" 侧边栏树。
 */
export function buildRelatedTree(
    settingsData: TreeNode[],
    plotCustomData: TreeNode[],
    analysisCustomData: TreeNode[],
    othersCustomData: TreeNode[],
    promptTree: TreeNode[],
    plotItems: PlotAnalysisItem[],
    analysisItems: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    const plotDerivedTree = buildDerivedContentTree('plot', plotItems, directoryData);
    const analysisDerivedTree = buildDerivedContentTree('analysis', analysisItems, directoryData);

    const plotTree: RootNode = {
        id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
        children: [
            ...plotCustomData,
            ...plotDerivedTree
        ]
    };

    const analysisTree: RootNode = {
        id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
        children: [
            ...analysisCustomData,
            ...analysisDerivedTree
        ]
    };

    const othersTree: RootNode = {
        id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
        children: [
            ...promptTree,
            ...othersCustomData
        ]
    };

    return [...settingsData, plotTree, analysisTree, othersTree];
}

// =
// 文件: ..\src\novel\editor\services\relatedContentService.ts
//

// 文件: ..\src\novel\editor\services\relatedContentService.ts
import * as settingsApi from '@/novel/editor/api/settingsApi';
import * as customPlotApi from '@/novel/editor/api/customPlotApi';
import * as customAnalysisApi from '@/novel/editor/api/customAnalysisApi';
import * as customOthersApi from '@/novel/editor/api/customOthersApi';
import type { TreeNode, ItemNode } from '@/novel/editor/types';

export interface RelatedContentData {
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    othersCustomData: ItemNode[];
}

class RelatedContentService {
    public async getRelatedContent(novelId: string): Promise<RelatedContentData> {
        const [
            settingsData,
            plotCustomData,
            analysisCustomData,
            othersCustomData
        ] = await Promise.all([
            settingsApi.getSettingsData(novelId),
            customPlotApi.getPlotCustomData(novelId),
            customAnalysisApi.getAnalysisCustomData(novelId),
            customOthersApi.getOthersCustomData(novelId),
        ]);

        return {
            settingsData,
            plotCustomData,
            analysisCustomData,
            othersCustomData
        };
    }

    public async saveRelatedContent(novelId: string, data: RelatedContentData): Promise<void> {
        await Promise.all([
            settingsApi.updateSettingsData(novelId, data.settingsData),
            customPlotApi.updatePlotCustomData(novelId, data.plotCustomData),
            customAnalysisApi.updateAnalysisCustomData(novelId, data.analysisCustomData),
            customOthersApi.updateOthersCustomData(novelId, data.othersCustomData),
        ]);
    }
}

export const relatedContentService = new RelatedContentService();

// =
// 文件: ..\src\novel\editor\services\searchService.ts
//

import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class SearchService {
    private get directoryStore() { return useDirectoryStore(); }
    private get relatedContentStore() { return useRelatedContentStore(); }
    private get notesStore() { return useNotesStore(); }
    private get referenceStore() { return useReferenceStore(); }

    public search(query: string): SearchResult[] {
        if (!query || query.trim().length < 1) {
            return [];
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            // 1. 检查标题是否匹配
            const titleMatch = item.title.toLowerCase().includes(lowerCaseQuery);

            // 2. 检查内容是否匹配
            let contentMatches = false;
            const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
            let match;
            const matchesForThisItem: { context: string }[] = [];

            while ((match = regex.exec(textContent)) !== null) {
                contentMatches = true;
                if (matchesForThisItem.length < 5) { // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    matchesForThisItem.push({ context: `...${context}...` });
                } else {
                    break;
                }
            }

            // 如果标题或内容任一匹配，则加入结果列表
            if(titleMatch || contentMatches){
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;

                // 如果是因为内容匹配，添加匹配片段
                if(contentMatches){
                    result.matches.push(...matchesForThisItem);
                }
                // 如果只是标题匹配，可以添加一个特殊的 "match" 来注明
                else if (titleMatch) {
                    result.matches.push({ context: `<span class="italic text-gray-500">标题匹配</span>` });
                }
            }
        };

        // 遍历所有数据源
        this.directoryStore.directoryData.forEach(vol => {
            processItem(vol);
            vol.chapters.forEach(processItem);
        });

        const flattenAndProcess = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenAndProcess(node.children);
            });
        };

        flattenAndProcess(this.relatedContentStore.relatedData);
        flattenAndProcess(this.referenceStore.referenceData);

        this.notesStore.notes.forEach(processItem);

        return Array.from(resultsMap.values());
    }
}

export const searchService = new SearchService();

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { AITaskType, AIProviderConfig } from '@novel/editor/types';
import { fetchAvailableAIProviders } from '@novel/editor/services/ai/aiService';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

interface TaskConfig {
    selectedPromptId: string;
    selectedAIProviderId: string | null;
    temperature: number;
}

export const useAIConfigStore = defineStore('aiConfig', () => {
    const availableAIProviders = ref<AIProviderConfig[]>([]);
    const selectedChatProviderId = ref<string | null>(null);

    const taskConfigs = ref<Record<AITaskType, TaskConfig>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'], selectedAIProviderId: null, temperature: 0.7 },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'], selectedAIProviderId: null, temperature: 0.8 },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'], selectedAIProviderId: null, temperature: 0.5 },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'], selectedAIProviderId: null, temperature: 0.9 },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'], selectedAIProviderId: null, temperature: 0.7 },
    });

    const selectedChatProviderConfig = computed(() => {
        return availableAIProviders.value.find(p => p.id === selectedChatProviderId.value) || null;
    });

    async function initializeProviders() {
        if (availableAIProviders.value.length > 0) return;

        availableAIProviders.value = await fetchAvailableAIProviders();

        const firstAvailableProviderId = availableAIProviders.value[0]?.id || null;

        if (!selectedChatProviderId.value) {
            selectedChatProviderId.value = firstAvailableProviderId;
        }

        for (const taskType in taskConfigs.value) {
            const config = taskConfigs.value[taskType as AITaskType];
            const isCurrentProviderAvailable = availableAIProviders.value.some(p => p.id === config.selectedAIProviderId);
            if (!isCurrentProviderAvailable) {
                config.selectedAIProviderId = firstAvailableProviderId;
            }
        }
    }

    const selectChatProvider = (id: string) => {
        if (availableAIProviders.value.some(p => p.id === id)) {
            selectedChatProviderId.value = id;
        }
    }

    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    const setSelectedAIProviderId = (taskType: AITaskType, providerId: string) => {
        if (taskConfigs.value[taskType] && availableAIProviders.value.some(p => p.id === providerId)) {
            taskConfigs.value[taskType].selectedAIProviderId = providerId;
        }
    };

    const setTaskTemperature = (taskType: AITaskType, temperature: number) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].temperature = Number(temperature.toFixed(2));
        }
    }

    return {
        availableAIProviders,
        selectedChatProviderId,
        taskConfigs,
        selectedChatProviderConfig,
        initializeProviders,
        selectChatProvider,
        setSelectedPromptId,
        setSelectedAIProviderId,
        setTaskTemperature,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

// 文件: src/novel/editor/stores/ai/aiTaskStore.ts

import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useEditorStore } from '../editorStore';
import { useUIStore } from '../uiStore';
import { useDerivedContentStore } from '../derivedContentStore';
import * as AITaskFactory from '@/novel/editor/services/ai/AITaskFactory';
import { processQueue } from '@/novel/editor/services/ai/AITaskExecutionService';
import type { AITask, Volume, AITaskType, AITaskStatus } from '@novel/editor/types';

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const previewTaskId = ref<string | null>(null);

    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    const previewTask = computed((): AITask | null => {
        if (!previewTaskId.value) return null;
        return tasks.value.find(t => t.id === previewTaskId.value) ?? null;
    });

    const updateTaskStatus = (taskId: string, status: AITaskStatus) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = status;
        }
    };

    const updateTaskError = (taskId: string, error: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = 'failed';
            task.error = error;
        }
    };

    const appendGeneratedContent = (taskId: string, chunk: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.generatedContent += chunk;
        }
    };

    const setPreviewTask = (taskId: string | null) => {
        previewTaskId.value = taskId;

        if (taskId) {
            const task = tasks.value.find(t => t.id === taskId);
            if (task) {
                // 当设置预览任务时，自动打开对应的源文件标签页
                editorStore.openTab(task.sourceItemId);
            }
        }
    };

    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const newTask = await AITaskFactory.createTask(taskType, sourceItemId, finalPrompt);
        if (!newTask) return;

        tasks.value.unshift(newTask);

        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }

        // 如果当前没有正在预览的任务，则自动将新任务设为预览对象
        if (!previewTaskId.value) {
            setPreviewTask(newTask.id);
        }
        nextTick(processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const completeTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.status = 'completed';

            const strategy = uiStore.uiState.taskApplicationStrategy;
            if (strategy.mode === 'auto') {
                applyChanges(taskId, true);
            } else if (strategy.mode === 'delayed') {
                task.applyAt = Date.now() + strategy.delaySeconds * 1000;
                setTimeout(() => {
                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                    if (taskAfterDelay?.status === 'completed') {
                        applyChanges(taskId, true);
                    }
                }, strategy.delaySeconds * 1000);
            }
        }
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || !['completed', 'completed_with_conflict'].includes(task.status)) return;

        const { node: sourceItem } = editorStore.findItemById(task.targetItemId);
        if (!sourceItem) {
            task.status = 'failed';
            task.error = '目标文档不存在。';
            return;
        }

        // 核心修复：仅在自动应用时才进行版本冲突检查
        if (isAutoApplied) {
            const currentVersion = (sourceItem as any)._lastModified || 0;
            if (task.sourceItemVersion < currentVersion) {
                task.status = 'completed_with_conflict';
                task.error = `内容已被修改，AI结果无法自动应用。请手动处理。`;
                console.warn(`AI Task Conflict: Task for "${task.sourceItemTitle}" cannot be applied automatically. Task version: ${task.sourceItemVersion}, Current version: ${currentVersion}`);
                return;
            }
        }

        if (task.type === '分析' || task.type === '剧情生成') {
            const newItem = derivedContentStore.createAndAddDerivedItem(
                sourceItem,
                task.type,
                task.generatedContent
            );
            if (newItem) {
                editorStore.openTab(newItem.id);
            }
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
        task.error = undefined; // 清除可能存在的冲突错误信息

        // 如果应用的是当前正在预览的任务，则清空预览
        if (previewTaskId.value === taskId) {
            setPreviewTask(null);
        }
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && (task.status === 'failed' || task.status === 'completed_with_conflict')) {
            // 从任务列表中移除旧的失败/冲突任务
            const taskIndex = tasks.value.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                tasks.value.splice(taskIndex, 1);
            }
            // 重新创建并开始一个新任务
            startTask(task.type, task.sourceItemId, task.finalPrompt);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => !['applied', 'failed', 'completed_with_conflict'].includes(t.status));
    };

    const clearAllTasks = () => {
        tasks.value = [];
        setPreviewTask(null);
    };

    return {
        tasks,
        activeTasksCount,
        previewTask,
        previewTaskId,
        startTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
        updateTaskStatus,
        updateTaskError,
        appendGeneratedContent,
        completeTask,
        setPreviewTask
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, ChatMessage, BackendChatMessage } from '@novel/editor/types/chatTypes';
import * as chatService from '@/novel/editor/services/ai/chatService';
import { useAIConfigStore } from './aiConfigStore';
import { marked } from 'marked';

export const useChatStore = defineStore('editorChat', () => {
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);
    const isLoading = ref<boolean>(false);

    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    const fetchConversations = async () => {
        isLoading.value = true;
        try {
            const fetchedConvs = await chatService.getConversations();
            conversations.value = fetchedConvs.length > 0 ? fetchedConvs : [await chatService.createConversation()];
            if (!activeConversationId.value || !conversations.value.find(c => c.id === activeConversationId.value)) {
                activeConversationId.value = conversations.value[0].id;
            }
        } catch (error) {
            console.error("Failed to fetch conversations:", error);
            if (conversations.value.length === 0) {
                conversations.value.push(await chatService.createConversation());
                activeConversationId.value = conversations.value[0].id;
            }
        } finally {
            isLoading.value = false;
        }
    };

    const createNewConversation = async () => {
        try {
            const newConv = await chatService.createConversation();
            conversations.value.unshift(newConv);
            activeConversationId.value = newConv.id;
        } catch (error) {
            console.error("Failed to create new conversation:", error);
        }
    };

    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    const sendMessage = async () => {
        const aiConfigStore = useAIConfigStore();
        const userInput = messageInput.value.trim();

        if (!userInput || !activeConversation.value || isReceiving.value) return;

        const providerIdStr = aiConfigStore.selectedChatProviderId;
        if (!providerIdStr) {
            alert("请先在顶部选择一个API配置！");
            return;
        }

        const providerIdNum = parseInt(providerIdStr, 10);
        if (isNaN(providerIdNum)) {
            alert("选择的API配置ID无效！");
            return;
        }

        isReceiving.value = true;
        const currentConv = activeConversation.value;

        const userMessage: ChatMessage = {
            id: `msg-${Date.now()}`,
            role: 'user',
            content: userInput,
            timestamp: new Date().toISOString(),
        };
        currentConv.messages.push(userMessage);
        messageInput.value = '';

        const backendMessages: BackendChatMessage[] = currentConv.messages.map(m => ({
            role: m.role,
            content: m.content,
        }));

        const aiResponsePlaceholder: ChatMessage = {
            id: `msg-${Date.now() + 1}`,
            role: 'ai',
            content: '',
            timestamp: new Date().toISOString(),
        };
        currentConv.messages.push(aiResponsePlaceholder);

        await chatService.streamMessage(
            providerIdNum,
            backendMessages,
            {
                onChunk: (chunk) => {
                    if (chunk.content) {
                        aiResponsePlaceholder.content += chunk.content;
                    }
                    if(chunk.error) {
                        aiResponsePlaceholder.content += `\n\n**错误:** ${chunk.error}`;
                    }
                },
                onComplete: () => {
                    isReceiving.value = false;
                    aiResponsePlaceholder.content = marked.parse(aiResponsePlaceholder.content) as string;
                },
                onError: (error) => {
                    isReceiving.value = false;
                    aiResponsePlaceholder.content += `\n\n**请求失败:** ${error}`;
                    aiResponsePlaceholder.content = marked.parse(aiResponsePlaceholder.content) as string;
                }
            }
        );
    };

    return {
        conversations,
        activeConversationId,
        messageInput,
        isReceiving,
        isLoading,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', reference: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, referenceCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings, ReferenceContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const referenceContextSettings = ref<ReferenceContextSettings>({
        includeContent: true,
        includeAnalysis: false,
        includePlot: false,
        includeVolumeInfo: false,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    const setReferenceContextSetting = (key: keyof ReferenceContextSettings, value: boolean) => {
        if (key in referenceContextSettings.value) {
            referenceContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        referenceContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
        setReferenceContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';
import * as derivedContentService from '@/novel/editor/services/derivedContentService';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);
    const novelId = ref<string | null>(null);

    function _setDerivedData(items: PlotAnalysisItem[]) {
        plotItems.value = items.filter(item => item.type === 'plot');
        analysisItems.value = items.filter(item => item.type === 'analysis');
    }

    async function fetchDerivedContent(id: string) {
        novelId.value = id;
        try {
            const allItems = await derivedContentService.getDerivedItemsForNovel(id);
            _setDerivedData(allItems);
        } catch (error) {
            console.error("Failed to fetch derived content:", error);
            _setDerivedData([]);
        }
    }

    async function saveDerivedContent() {
        const allItems = [...plotItems.value, ...analysisItems.value];
        const updatePromises = allItems.map(item =>
            derivedContentService.updateDerivedItem(item.id, {
                title: item.title,
                content: item.content,
                sourceId: item.sourceId
            })
        );
        await Promise.all(updatePromises);
    }

    function getDerivedItemsForSource(sourceId: string, type: 'plot' | 'analysis'): PlotAnalysisItem[] {
        const sourceArray = type === 'plot' ? plotItems.value : analysisItems.value;
        return sourceArray.filter(item => item.sourceId === sourceId);
    }

    async function createAndAddDerivedItem(sourceNode: EditorItem, taskType: AITaskType, generatedContent: string): Promise<PlotAnalysisItem | null> {
        if (!novelId.value || (taskType !== '分析' && taskType !== '剧情生成') || (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume')) {
            return null;
        }

        const derivedType = taskType === '分析' ? 'analysis' : 'plot';
        const newItem = await createManualDerivedItem(sourceNode, derivedType, generatedContent, true);
        return newItem;
    }

    async function createManualDerivedItem(sourceNode: EditorItem, derivedType: 'plot' | 'analysis', content: string = '', isFromAI: boolean = false): Promise<PlotAnalysisItem | null> {
        if (!novelId.value || (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume')) return null;

        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const typeName = derivedType === 'plot' ? '剧情' : '分析';
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';

        const finalTitle = isFromAI
            ? `《${titlePrefix}${sourceNode.title}》${typeName} - ${timestamp} (AI)`
            : `《${titlePrefix}${sourceNode.title}》${typeName} - ${timestamp}`;

        const finalContent = content
            ? formatContentForEditor(finalTitle, content)
            : `<h1>${finalTitle}</h1><p>请在这里编写${typeName}内容...</p>`;

        const itemData: Omit<PlotAnalysisItem, 'id'> = {
            type: derivedType,
            sourceId: sourceNode.id,
            title: finalTitle,
            content: finalContent
        };

        const newItem = await derivedContentService.createDerivedItem(itemData);

        const targetArray = derivedType === 'plot' ? plotItems : analysisItems;
        targetArray.value.unshift(newItem);

        return newItem;
    }

    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    function updateNodeContent(nodeId: string, content: string) {
        const item = findItemById(nodeId);
        if (item) {
            item.content = content;
            const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
            const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
            if (newTitle && newTitle !== item.title) {
                item.title = newTitle;
            }
        }
    }

    async function deleteDerivedItem(itemId: string): Promise<boolean> {
        try {
            await derivedContentService.deleteDerivedItem(itemId);
            let index = plotItems.value.findIndex(i => i.id === itemId);
            if (index > -1) plotItems.value.splice(index, 1);

            index = analysisItems.value.findIndex(i => i.id === itemId);
            if (index > -1) analysisItems.value.splice(index, 1);
            return true;
        } catch (error) {
            console.error('Failed to delete derived item:', error);
            return false;
        }
    }

    async function deleteDerivedDataForSource(sourceId: string) {
        const itemsToDelete = [
            ...plotItems.value.filter(item => item.sourceId === sourceId),
            ...analysisItems.value.filter(item => item.sourceId === sourceId)
        ];

        const deletePromises = itemsToDelete.map(item => deleteDerivedItem(item.id));
        await Promise.all(deletePromises);
    }

    function updateTitlesForSource(sourceId: string, newSourceTitle: string) {
        const itemsToUpdate = [
            ...plotItems.value.filter(item => item.sourceId === sourceId),
            ...analysisItems.value.filter(item => item.sourceId === sourceId)
        ];

        itemsToUpdate.forEach(item => {
            // Regex to find the part of the title to replace, e.g., "《...》"
            const oldTitlePattern = /《(.*?)》/;
            const match = item.title.match(oldTitlePattern);

            if (match) {
                const titlePrefix = item.sourceId.startsWith('vol-') ? '卷' : '';
                const newTitlePart = `《${titlePrefix}${newSourceTitle}》`;
                const newTitle = item.title.replace(oldTitlePattern, newTitlePart);

                item.title = newTitle;
                if (item.content.includes('<h1>')) {
                    item.content = item.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
                }
            }
        });
    }

    return {
        plotItems,
        analysisItems,
        fetchDerivedContent,
        saveDerivedContent,
        getDerivedItemsForSource,
        createAndAddDerivedItem,
        createManualDerivedItem,
        findItemById,
        updateNodeContent,
        deleteDerivedItem,
        deleteDerivedDataForSource,
        updateTitlesForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedViewStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedViewStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useDerivedContentStore } from './derivedContentStore';
import type { PlotAnalysisItem, EditorItem } from '@/novel/editor/types';

export const useDerivedViewStore = defineStore('derived-view', () => {
    // State
    const sourceItem = ref<EditorItem | null>(null);
    const derivedType = ref<'plot' | 'analysis' | null>(null);
    const items = ref<PlotAnalysisItem[]>([]);
    const currentIndex = ref(0);

    // Getters
    const currentItem = computed(() => items.value[currentIndex.value] || null);
    const viewTitle = computed(() => {
        if (!sourceItem.value || !derivedType.value) return '派生内容';
        const typeName = derivedType.value === 'plot' ? '剧情' : '分析';
        return `《${sourceItem.value.title}》的${typeName}`;
    });

    // Actions
    async function loadItems(source: EditorItem, type: 'plot' | 'analysis') {
        const derivedContentStore = useDerivedContentStore();
        sourceItem.value = source;
        derivedType.value = type;
        items.value = derivedContentStore.getDerivedItemsForSource(source.id, type);

        // If no items exist, create one to start with
        if (items.value.length === 0) {
            const newItem = await derivedContentStore.createManualDerivedItem(source, type);
            if (newItem) {
                items.value = [newItem];
            }
        }

        currentIndex.value = 0;
    }

    async function createNewItem() {
        if (!sourceItem.value || !derivedType.value) return;
        const derivedContentStore = useDerivedContentStore();
        const newItem = await derivedContentStore.createManualDerivedItem(sourceItem.value, derivedType.value);
        if (newItem) {
            // Reload to get the updated list and navigate to the new item
            items.value = derivedContentStore.getDerivedItemsForSource(sourceItem.value.id, derivedType.value);
            currentIndex.value = items.value.findIndex(i => i.id === newItem.id);
        }
    }

    function goToIndex(index: number) {
        if (index >= 0 && index < items.value.length) {
            currentIndex.value = index;
        }
    }

    function nextItem() {
        if (currentIndex.value < items.value.length - 1) {
            currentIndex.value++;
        }
    }

    function prevItem() {
        if (currentIndex.value > 0) {
            currentIndex.value--;
        }
    }

    return {
        sourceItem,
        derivedType,
        items,
        currentIndex,
        currentItem,
        viewTitle,
        loadItems,
        createNewItem,
        goToIndex,
        nextItem,
        prevItem
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// 文件: ..\src\novel\editor\stores\directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useDerivedContentStore } from './derivedContentStore';
import * as directoryService from '@/novel/editor/services/directoryService';

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);
    const novelId = ref<string | null>(null);

    async function fetchDirectory(id: string) {
        novelId.value = id;
        try {
            directoryData.value = await directoryService.getDirectoryData(id);
        } catch (error) {
            console.error(`Failed to fetch directory for novel ${id}:`, error);
            directoryData.value = [];
        }
    }

    async function saveDirectory() {
        if (!novelId.value) return;
        await directoryService.saveDirectoryData(novelId.value, directoryData.value);
    }

    const findNodeById = (nodeId: string): { node: Volume | Chapter; parent: Volume | null } | null => {
        for (const volume of directoryData.value) {
            if (volume.id === nodeId) return { node: volume, parent: null };
            for (const chapter of volume.chapters) {
                if (chapter.id === nodeId) return { node: chapter, parent: volume };
            }
        }
        return null;
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            result.node.content = content;
            if(result.node.type === 'volume') {
                const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
                if (h1Match && h1Match[1]) result.node.title = h1Match[1].replace(/<[^>]+>/g, '').trim();
            } else {
                const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
                if (h1Match && h1Match[1]) result.node.title = h1Match[1].replace(/<[^>]+>/g, '').trim();
            }
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            let htmlToAppend = paragraphs;
            if(isAutoApplied) {
                htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
            }
            if(!result.node.content) result.node.content = "";
            result.node.content += htmlToAppend;
        }
    };

    const addNewVolume = async (): Promise<Volume | null> => {
        if (!novelId.value) return null;
        try {
            const newVolume = await directoryService.createVolume(novelId.value, { title: '新卷', chapters: [] });
            directoryData.value = [...directoryData.value, newVolume];
            return newVolume;
        } catch (error) {
            console.error('Failed to add new volume:', error);
            return null;
        }
    };

    const addChapterToVolume = async (volumeId: string): Promise<Chapter | null> => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            try {
                const newChapter = await directoryService.createChapter(volume.id, { title: '新章节' });
                volume.chapters = [...volume.chapters, newChapter];
                return newChapter;
            } catch (error) {
                console.error('Failed to add new chapter:', error);
                return null;
            }
        }
        return null;
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const result = findNodeById(nodeId);
        if (result?.node && newTitle.trim()) {
            const trimmedTitle = newTitle.trim();
            result.node.title = trimmedTitle;

            // Propagate title change to derived content
            const derivedContentStore = useDerivedContentStore();
            derivedContentStore.updateTitlesForSource(nodeId, trimmedTitle);
        }
    };

    const deleteNode = async (nodeId: string): Promise<boolean> => {
        const result = findNodeById(nodeId);
        if (!result) return false;

        const derivedContentStore = useDerivedContentStore();

        try {
            if (result.node.type === 'chapter') {
                await directoryService.deleteChapter(nodeId);
                if(result.parent) {
                    result.parent.chapters = result.parent.chapters.filter(c => c.id !== nodeId);
                }
                await derivedContentStore.deleteDerivedDataForSource(result.node.id);
            } else if (result.node.type === 'volume') {
                await directoryService.deleteVolume(nodeId);
                directoryData.value = directoryData.value.filter(v => v.id !== nodeId);
                const chapterIds = result.node.chapters.map(c => c.id);
                for (const chapId of chapterIds) {
                    await derivedContentStore.deleteDerivedDataForSource(chapId);
                }
                await derivedContentStore.deleteDerivedDataForSource(result.node.id);
            }
            return true;
        } catch (error) {
            console.error('Failed to delete node:', error);
            return false;
        }
    };

    return {
        directoryData,
        fetchDirectory,
        saveDirectory,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts
//

// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';
import { useDerivedViewStore } from '../derivedViewStore';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
    'system:derived_view': { id: 'system:derived_view', type: 'system', component: 'DerivedContentView', title: '派生内容', icon: 'fa-solid fa-clone' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore();
    const derivedViewStore = useDerivedViewStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = `system:${parts[1]}`;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                // Handle dynamic title for history panel
                if (baseId === 'system:history' && parts.length === 3) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                // Handle dynamic title for derived view panel
                if (baseId === 'system:derived_view') {
                    return {
                        node: { ...systemView, id, title: derivedViewStore.viewTitle },
                        source: 'system'
                    }
                }
                return { node: { ...systemView, id }, source: 'system' };
            }
        }

        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) return { node: derivedItem as PlotAnalysisItem, source: 'derived' };

        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) return { node: promptItem, source: 'prompt' };

        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NovelMetadata } from '@/novel/editor/types/project';
import * as metadataService from '@novel/editor/services/metadataService';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);
    const currentNovelId = ref<string | null>(null);

    function reset() {
        novelMetadata.value = null;
        currentNovelId.value = null;
    }

    async function fetchNovelData(novelId: string) {
        try {
            const data = await metadataService.getNovelMetadata(novelId);
            novelMetadata.value = data;
            currentNovelId.value = novelId;
        } catch (error) {
            console.error(`[MetadataStore] Failed to fetch metadata for novel ${novelId}:`, error);
            reset();
            throw error; // Re-throw to be caught by the project loader
        }
    }

    // This is kept for manual saving from the settings page
    async function saveMetadata() {
        if (!currentNovelId.value || !novelMetadata.value) {
            console.error("保存失败：未加载小说。");
            alert('保存失败，请查看控制台获取更多信息。');
            return;
        }
        try {
            await metadataService.updateNovelMetadata(currentNovelId.value, novelMetadata.value);
            alert('小说设置已保存！');
        } catch (error) {
            console.error("保存元数据失败:", error);
            alert('保存失败，请稍后重试。');
        }
    }

    function addReferenceNovel(novelIdToAdd: string) {
        if (!novelMetadata.value || novelMetadata.value.referenceNovelIds.includes(novelIdToAdd)) return;
        novelMetadata.value.referenceNovelIds.push(novelIdToAdd);
    }

    function removeReferenceNovel(novelIdToRemove: string) {
        if (!novelMetadata.value) return;
        const index = novelMetadata.value.referenceNovelIds.indexOf(novelIdToRemove);
        if (index > -1) {
            novelMetadata.value.referenceNovelIds.splice(index, 1);
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) novelMetadata.value.tags.splice(tagIndex, 1);
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    return {
        novelMetadata,
        currentNovelId,
        fetchNovelData,
        saveMetadata,
        addReferenceNovel,
        removeReferenceNovel,
        removeTag,
        addTag,
        reset,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\systemViewStore.ts
//

// src/novel/editor/stores/editor-state/systemViewStore.ts
import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const activePane = paneStore.panes.find(p => p.id === paneStore.activePaneId);
        if (!activePane || !activePane.activeTabId) {
            console.warn('Cannot open reader mode: no active tab.');
            return;
        }
        const { node: activeItem } = itemStore.findItemById(activePane.activeTabId);

        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\tabStore.ts
//

// src/novel/editor/stores/editor-state/tabStore.ts
import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            console.warn(`Attempted to open a non-tab item: ${itemId}. This should be handled by the calling UI component (e.g., for tree expansion).`);
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import type { EditorPane, TabInfo } from '@novel/editor/types';

// State Stores
import { usePaneStore } from '@novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@novel/editor/stores/editor-state/tabStore';
import { useItemStore } from '@novel/editor/stores/editor-state/itemStore';
import { useSystemViewStore } from '@novel/editor/stores/editor-state/systemViewStore';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';

// Data Stores & UI
import { useDirectoryStore } from './directoryStore';
import { useRelatedContentStore } from './relatedContentStore';
import { useNotesStore } from './notesStore';
import { useDerivedContentStore } from './derivedContentStore';
import { useReferenceStore } from './referenceStore';
import { useAIConfigStore } from './ai/aiConfigStore';
import { useNovelSettingsStore } from './novelSettingsStore';
import { useUIStore } from './uiStore';
import { useDerivedViewStore } from './derivedViewStore';

export { EditorPane };

const initializeEditorUI = (novelId: string) => {
    const directoryStore = useDirectoryStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();
    const paneStore = usePaneStore();
    const tabStore = useTabStore();

    paneStore.initializePanes();

    if (directoryStore.directoryData.length > 0) {
        uiStore.ensureNodeIsExpanded(directoryStore.directoryData[0].id);
        const firstChapterId = directoryStore.directoryData[0]?.chapters[0]?.id;
        if (firstChapterId) {
            tabStore.openTab(firstChapterId);
        }
    }

    uiStore.ensureRelatedNodeIsExpanded('setting');
    uiStore.ensureRelatedNodeIsExpanded('plot');
    uiStore.ensureRelatedNodeIsExpanded('analysis');
    uiStore.ensureRelatedNodeIsExpanded('others');

    if (metadataStore.novelMetadata && metadataStore.novelMetadata.referenceNovelIds.length > 0) {
        const firstRefBookId = `ref-book-${metadataStore.novelMetadata.referenceNovelIds[0]}`;
        uiStore.ensureReferenceNodeIsExpanded(firstRefBookId);
    }
};

export const useEditorStore = defineStore('editor-facade', () => {
    // State Stores
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();
    const derivedViewStore = useDerivedViewStore();

    // Data Stores
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const derivedContentStore = useDerivedContentStore();
    const notesStore = useNotesStore();
    const referenceStore = useReferenceStore();
    const novelSettingsStore = useNovelSettingsStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    async function loadProject(novelId: string): Promise<boolean> {
        // 1. Reset all states
        metadataStore.reset();
        // You might need to add reset functions to other stores if they cache data

        try {
            console.log(`[EditorStore] Coordinating load for novel: ${novelId}`);

            // 2. Fetch metadata first, as other fetches might depend on it
            await metadataStore.fetchNovelData(novelId);

            const referenceIds = metadataStore.novelMetadata?.referenceNovelIds || [];

            // 3. Fetch all main content data in parallel
            await Promise.all([
                directoryStore.fetchDirectory(novelId),
                relatedContentStore.fetchRelatedContent(novelId),
                derivedContentStore.fetchDerivedContent(novelId),
                notesStore.fetchNotes(novelId),
                useAIConfigStore().initializeProviders(),
                referenceStore.loadReferences(referenceIds)
            ]);

            // 4. Load dependent data
            await novelSettingsStore.loadSettingsData();

            // 5. Initialize UI state now that all data is loaded
            initializeEditorUI(novelId);

            return true;
        } catch (error) {
            console.error(`[EditorStore] Failed to load project ${novelId}:`, error);
            metadataStore.reset(); // Ensure clean state on failure
            return false;
        }
    }

    function splitPane(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    }

    function updateItemContentById(id: string, content: string) {
        itemStore.updateItemContentById(id, content);
        const { node } = itemStore.findItemById(id);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        itemStore.appendContentToItem(itemId, content, auto);
        const { node } = itemStore.findItemById(itemId);
        if (node) {
            (node as any)._lastModified = Date.now();
        }
    }

    function openDerivedItemView(type: 'plot' | 'analysis') {
        const sourceItem = activeTab.value?.item;
        if (!sourceItem || (sourceItem.type !== 'chapter' && sourceItem.type !== 'volume')) return;

        const viewId = `system:derived_view:${type}:${sourceItem.id}`;

        const existingPane = panes.value.find(p => p.openTabIds.includes(viewId));
        if (existingPane) {
            paneStore.setActivePane(existingPane.id);
            return;
        }

        derivedViewStore.loadItems(sourceItem, type);

        const sourcePaneId = activePaneId.value;
        if (!sourcePaneId) return;

        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (newPaneId) {
            tabStore.openTab(viewId, newPaneId);
        }
    }

    function openPlotForActiveItem() {
        openDerivedItemView('plot');
    }

    function openAnalysisForActiveItem() {
        openDerivedItemView('analysis');
    }

    // Explicit actions that delegate to other stores
    const openTab = (itemId: string, targetPaneId?: string) => tabStore.openTab(itemId, targetPaneId);
    const closeTab = (itemId: string, paneId?: string) => tabStore.closeTab(itemId, paneId);
    const toggleAIPanel = (sourcePaneId: string) => systemViewStore.toggleAIPanel(sourcePaneId);
    const ensureAIPanelIsOpen = (sourcePaneId: string) => systemViewStore.ensureAIPanelIsOpen(sourcePaneId);
    const toggleHistoryPanel = (sourcePaneId: string) => systemViewStore.toggleHistoryPanel(sourcePaneId);
    const openReaderView = () => systemViewStore.openReaderView();

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        getTabsForPane,
        getActiveTabForPane,
        splitPane,
        updateItemContentById,
        appendContentToItem,
        openPlotForActiveItem,
        openAnalysisForActiveItem,
        // Delegated actions
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab,
        closeTab,
        findItemById: itemStore.findItemById,
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
        loadProject,
    };
});

// =
// 文件: ..\src\novel\editor\stores\historyStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useEditorStore } from './editorStore';
import * as historyService from '@/novel/editor/services/historyService';
import { calculateHtmlDiff } from '@/novel/editor/services/diffService';
import type { HistoryVersion } from '@novel/editor/types/historyTypes';
import type { EditorItem } from '@/novel/editor/types';

export const useHistoryStore = defineStore('history', () => {
    const isLoading = ref(false);
    const targetDocument = ref<EditorItem | null>(null);
    const versions = ref<HistoryVersion[]>([]);
    const selectedVersionId = ref<string | null>(null);
    const diffHtml = ref<string>('');

    const headerTitle = computed(() => {
        if (!targetDocument.value) return '版本对比';
        return `《${targetDocument.value.title}》版本对比`;
    });

    const selectedVersion = computed(() => {
        return versions.value.find(v => v.id === selectedVersionId.value) || null;
    });

    async function loadHistory(documentId: string) {
        isLoading.value = true;
        diffHtml.value = '';
        versions.value = [];

        const editorStore = useEditorStore();
        const { node } = editorStore.findItemById(documentId);
        targetDocument.value = node;

        if (!node) {
            console.error("History Store: Target document not found.");
            isLoading.value = false;
            return;
        }

        versions.value = await historyService.getHistoryVersions(documentId);

        if (versions.value.length > 0) {
            await selectVersion(versions.value[0].id);
        }

        isLoading.value = false;
    }

    async function selectVersion(versionId: string) {
        if (!targetDocument.value || !('content' in targetDocument.value)) return;

        selectedVersionId.value = versionId;
        const versionToCompare = selectedVersion.value;

        if (!versionToCompare) {
            diffHtml.value = '<p>错误：找不到选中的历史版本。</p>';
            return;
        }

        const currentContent = targetDocument.value.content;
        const historicalContent = versionToCompare.content;

        diffHtml.value = calculateHtmlDiff(historicalContent, currentContent);
    }

    async function restoreSelectedVersion() {
        if (!targetDocument.value || !selectedVersion.value) {
            alert('恢复失败：未找到目标文档或选中版本。');
            return;
        }

        isLoading.value = true;
        try {
            await historyService.restoreVersion(targetDocument.value.id, selectedVersion.value.id);
            // 成功信息由 service 层显示
            // 重新加载历史记录以反映最新状态
            await loadHistory(targetDocument.value.id);
        } catch (error) {
            console.error('Failed to restore version:', error);
            alert('恢复失败，请查看控制台获取更多信息。');
        } finally {
            isLoading.value = false;
        }
    }

    return {
        isLoading,
        targetDocument,
        versions,
        selectedVersionId,
        diffHtml,
        headerTitle,
        selectedVersion,
        loadHistory,
        selectVersion,
        restoreSelectedVersion,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

// 文件: ..\src\novel\editor\stores\notesStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import * as noteService from '@/novel/editor/services/noteService';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);
    const novelId = ref<string | null>(null);

    async function fetchNotes(id: string) {
        novelId.value = id;
        try {
            notes.value = await noteService.getNotesForNovel(id);
        } catch (error) {
            console.error("Failed to fetch notes:", error);
            notes.value = [];
        }
    }

    async function saveNotes() {
        const updatePromises = notes.value.map(note =>
            noteService.updateNoteApi(note.id, { title: note.title, content: note.content })
        );
        await Promise.all(updatePromises);
    }

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);
        if (noteIndex === -1) return;

        const originalNote = notes.value[noteIndex];
        const updatedNote = noteService.updateNoteWithNewContent(originalNote, content);
        notes.value[noteIndex] = updatedNote;
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = noteService.appendContentToNote(note.content, contentToAppend, isAutoApplied);
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);

        if (noteIndex !== -1 && newTitle.trim()) {
            const originalNote = notes.value[noteIndex];
            const trimmedTitle = newTitle.trim();
            const updatedNote = noteService.renameNote(originalNote, trimmedTitle);
            notes.value[noteIndex] = updatedNote;
        }
    };

    const addNote = async (title: string): Promise<NoteItem | null> => {
        if (!novelId.value) return null;

        const newNoteData: Partial<Omit<NoteItem, 'id'>> = {
            title,
            content: `<h1>${title}</h1><p></p>`,
        };

        try {
            const newNote = await noteService.createNoteApi(novelId.value, newNoteData);
            notes.value.unshift(newNote);
            return newNote;
        } catch (error) {
            console.error('Failed to add note:', error);
            return null;
        }
    };

    const deleteNote = async (noteId: string): Promise<boolean> => {
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            try {
                await noteService.deleteNoteApi(noteId);
                notes.value.splice(index, 1);
                return true;
            } catch (error) {
                console.error('Failed to delete note:', error);
                return false;
            }
        }
        return false;
    };

    return {
        notes,
        fetchNotes,
        saveNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\novelSettingsStore.ts
//

// 文件: ..\src/novel\editor\stores\novelSettingsStore.ts
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { novelSettingsService } from '@/novel/editor/services/novelSettingsService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';
import { useReferenceStore } from './referenceStore';

export const useNovelSettingsStore = defineStore('novel-settings', () => {
    const metadataStore = useMetadataStore();

    const novelMetadata = computed<NovelMetadata | null>(() => metadataStore.novelMetadata);
    const referencedNovels = ref<NovelProject[]>([]);
    const availableReferenceNovels = ref<NovelProject[]>([]);

    async function loadSettingsData() {
        const meta = metadataStore.novelMetadata;
        if (meta) {
            referencedNovels.value = await novelSettingsService.getReferencedNovels(meta.referenceNovelIds);
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(meta);
        } else {
            referencedNovels.value = [];
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(null);
        }
    }

    const addReferenceNovel = async (novelId: string) => {
        if (!novelId) return;
        metadataStore.addReferenceNovel(novelId);
        await loadSettingsData();
        if(metadataStore.novelMetadata) {
            await useReferenceStore().loadReferences(metadataStore.novelMetadata.referenceNovelIds);
        }
    };

    const removeReferenceNovel = async (novelId: string) => {
        metadataStore.removeReferenceNovel(novelId);
        await loadSettingsData();
        if(metadataStore.novelMetadata) {
            await useReferenceStore().loadReferences(metadataStore.novelMetadata.referenceNovelIds);
        }
    };

    const addTag = () => {
        metadataStore.addTag();
    };

    const removeTag = (index: number) => {
        metadataStore.removeTag(index);
    };

    const saveMetadata = () => {
        metadataStore.saveMetadata();
    };

    const resetMetadata = async () => {
        if (metadataStore.currentNovelId) {
            await metadataStore.fetchNovelData(metadataStore.currentNovelId);
        }
    };

    return {
        novelMetadata,
        referencedNovels,
        availableReferenceNovels,
        loadSettingsData,
        addReferenceNovel,
        removeReferenceNovel,
        addTag,
        removeTag,
        saveMetadata,
        resetMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { promptService } from '@/novel/editor/services/promptService';
import { useAIConfigStore } from './ai/aiConfigStore';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    // State: Use a simple ref, not a computed property, for the main data tree.
    const promptTree = ref<TreeNode[]>([]);

    /**
     * Action to initialize the prompt tree if it's empty.
     * This should be called once when the editor loads.
     */
    function initialize() {
        if (promptTree.value.length === 0) {
            promptTree.value = promptService.buildInitialTree();
        }
    }

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = promptTree.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        if (!promptTree.value[0]?.children) return null;
        for (const group of promptTree.value[0].children) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPrompt(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = promptTree.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newNode: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newNode);
        return newNode;
    }

    function renamePrompt(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result && newTitle.trim()) {
            result.prompt.title = newTitle.trim();
        }
    }

    function deletePrompt(promptId: string): boolean {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            const index = group.children.findIndex(p => p.id === promptId);
            if (index > -1) {
                group.children.splice(index, 1);

                if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                    aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
                }
                return true;
            }
        }
        return false;
    }

    function updatePromptContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }

    return {
        promptTree,
        initialize,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPrompt,
        renamePrompt,
        deletePrompt,
        updatePromptContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { referenceService } from '@/novel/editor/services/referenceService';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const loadReferences = async (referenceNovelIds: string[]) => {
        referenceData.value = await referenceService.buildReferenceTree(referenceNovelIds);
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        loadReferences,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import * as nodeOperationService from '@/novel/editor/services/related/nodeOperationService';
import * as treeBuilderService from '@/novel/editor/services/related/treeBuilderService';
import { updateAllOverviewContent } from '@/novel/editor/services/related/overviewService';
import * as relatedContentService from '@/novel/editor/services/relatedContentService';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { TreeNode, ItemNode, GroupNode } from '@/novel/editor/types';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<ItemNode[]>([]);
    const analysisCustomData = ref<ItemNode[]>([]);
    const othersCustomData = ref<ItemNode[]>([]);
    const novelId = ref<string | null>(null);

    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();

    const relatedData = computed(() => {
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        const validPlotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        const validAnalysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        return treeBuilderService.buildRelatedTree(
            settingsData.value,
            plotCustomData.value,
            analysisCustomData.value,
            othersCustomData.value,
            promptTemplateStore.promptTree,
            validPlotItems,
            validAnalysisItems,
            directoryStore.directoryData
        );
    });

    const allDataSources = computed(() => [
        settingsData.value,
        plotCustomData.value,
        analysisCustomData.value,
        othersCustomData.value
    ]);

    watch(settingsData, (newData) => {
        updateAllOverviewContent(newData);
    }, { deep: true });

    async function fetchRelatedContent(id: string) {
        novelId.value = id;
        promptTemplateStore.initialize();
        try {
            const data = await relatedContentService.getRelatedContent(id);
            settingsData.value = data.settingsData;
            plotCustomData.value = data.plotCustomData;
            analysisCustomData.value = data.analysisCustomData;
            othersCustomData.value = data.othersCustomData;
        } catch (error) {
            console.error(`Failed to fetch related content for novel ${id}:`, error);
        }
    }

    async function saveRelatedContent() {
        if (!novelId.value) return;
        await relatedContentService.saveRelatedContent(novelId.value, {
            settingsData: settingsData.value,
            plotCustomData: plotCustomData.value,
            analysisCustomData: analysisCustomData.value,
            othersCustomData: othersCustomData.value
        });
    }

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        return nodeOperationService.findNodeById(nodeId, allDataSources.value);
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.updateNodeContent(result.node as ItemNode, content);
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.appendNodeContent(result.node as ItemNode, contentToAppend, isAutoApplied);
        }
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            nodeOperationService.renameNode(result.node, newTitle);
        }
    }

    function addRelatedNode(parentId: string, type: 'group' | 'item'): ItemNode | GroupNode | null {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return null;

        const parentNode = result.node as GroupNode;
        const newNode = nodeOperationService.createRelatedNode(parentNode, type);
        parentNode.children = [...parentNode.children, newNode];
        return newNode;
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis'): ItemNode {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode = nodeOperationService.createCustomNode(target);
        dataRef.value = [newNode, ...dataRef.value];
        return newNode;
    }

    function addCustomOthersNode(): ItemNode {
        const newNode = nodeOperationService.createCustomNode('others');
        othersCustomData.value = [newNode, ...othersCustomData.value];
        return newNode;
    }

    function deleteNode(nodeId: string): boolean {
        return nodeOperationService.deleteNode(nodeId, allDataSources.value);
    }
    const deleteRelatedNode = deleteNode;
    const deleteCustomRelatedNode = deleteNode;
    const deleteCustomOthersNode = deleteNode;

    const renameCustomRelatedNode = renameRelatedNode;
    const renameCustomOthersNode = renameRelatedNode;

    return {
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        fetchRelatedContent,
        saveRelatedContent,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult } from '@/novel/editor/types';
import { searchService } from '@/novel/editor/services/searchService';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const performSearch = (query: string) => {
        hasSearched.value = true;
        lastSearchedQuery.value = query;
        results.value = searchService.search(query);
    };

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\ai.ts
//

/**
 * AI 任务状态
 * - pending: 等待执行
 * - processing: 正在执行
 * - completed: 已完成，等待应用
 * - completed_with_conflict: 已完成，但源文档已被修改，等待用户处理
 * - applied: 已应用
 * - failed: 执行失败
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'completed_with_conflict' | 'applied' | 'failed';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 提供商（模型）配置
 */
export interface AIProviderConfig {
    id: string;
    name: string;
    model: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string;
    sourceItemContent: string;
    sourceItemVersion: number;
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
    applyAt?: number;
    aiConfig: AIProviderConfig;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string;
    title: string;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义 - 用于UI展示
 */
export interface ChatMessage {
    id: string; // 前端专用，用于v-for的key
    role: 'user' | 'ai';
    content: string;
    timestamp: string; // 前端专用
}

/**
 * 发送到后端的聊天消息格式
 */
export interface BackendChatMessage {
    role: 'user' | 'ai' | 'system';
    content: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

/**
 * 从后端流式接口返回的数据块结构
 */
export interface StreamResponseChunk {
    content?: string;
    done: boolean;
    error?: string;
}

// =
// 文件: ..\src\novel\editor\types\historyTypes.ts
//

// 文件: ..\src\novel\editor\types\historyTypes.ts

/**
 * 代表一个文档的历史版本快照。
 */
export interface HistoryVersion {
    id: string;          // 版本的唯一ID
    label: string;       // 版本的显示名称 (例如 "AI 润色", "手动保存")
    timestamp: string;   // 版本创建的时间戳 (例如 "1小时前", "2023-10-27 15:30")
    content: string;     // 该版本的完整HTML内容 (用于恢复)
}

/**
 * 代表两个版本之间的差异。
 */
export interface VersionDiff {
    fromVersionId: string; // 对比的起始版本ID ('current' 代表当前版本)
    toVersionId: string;   // 对比的目标版本ID
    diffHtml: string;      // 包含 <ins> 和 <del> 标签的HTML字符串
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//

export * from './models';
export * from './chatTypes';
export * from './ui';
export * from './ai';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
    order: number; // 用于排序
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    volumeId: string; // 所属卷的ID
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
    order: number; // 用于排序
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: TreeNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\project.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata as BaseNovelMetadata,
    TreeNode,
    ItemNode,
    PlotAnalysisItem,
} from '@/novel/editor/types';

export interface NovelMetadata extends BaseNovelMetadata {
    referenceNovelIds: string[];
}

export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    derivedPlotData: PlotAnalysisItem[];
    derivedAnalysisData: PlotAnalysisItem[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
}

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: ..\src/novel\editor\utils\iconUtils.ts
const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    if (!type) return ICON_MAP['default'];

    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

