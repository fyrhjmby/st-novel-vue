// == 扫描摘要 ==
//
// 跳过的目录 (共 6 个):
//   - ..\src\auth
//   - ..\src\novel\editor\components\system\settings
//   - ..\src\prompt
//   - ..\src\settings
//   - ..\src\ui
//   - ..\src\workflow
//
// 跳过的特定文件 (共 2 个):
//   - ..\src\types\auto-imports.d.ts
//   - ..\src\types\components.d.ts
//
// == 文件内容 ==

// =
// 文件: ..\src\api\apiManagementApi.ts
//

import apiClient from './client';
import type { ApiProvider, ApiKey, ModalProvider } from '@/types/apiManagement';

// --- API Functions ---
export const fetchApiProviders = async (): Promise<ApiProvider[]> => {
    const response = await apiClient.get('/api-providers');
    return response.data;
};

export const fetchModalProviders = async (): Promise<ModalProvider[]> => {
    // 假设有一个专门为模态框提供简化数据的端点
    const response = await apiClient.get('/api-providers/modal');
    return response.data;
};

export const fetchApiKeys = async (): Promise<ApiKey[]> => {
    const response = await apiClient.get('/api-keys');
    return response.data;
};

export const addApiKey = async (newKeyData: Omit<ApiKey, 'id' | 'keyFragment' | 'calls' | 'created' | 'providerShort'> & { key: string }): Promise<ApiKey> => {
    const response = await apiClient.post('/api-keys', newKeyData);
    return response.data;
};

export const updateApiKey = async (keyData: Partial<ApiKey> & { id: number }): Promise<ApiKey> => {
    const response = await apiClient.put(`/api-keys/${keyData.id}`, keyData);
    return response.data;
};

export const deleteApiKey = async (keyId: number): Promise<ApiKey> => {
    const response = await apiClient.delete(`/api-keys/${keyId}`);
    return response.data; // 返回被删除的密钥信息以供store更新状态
};

// =
// 文件: ..\src\api\authApi.ts
//

// src/api/authApi.ts
import apiClient from './client';
import type { LoginCredentials, User, RegistrationData } from '@/types/auth';

export const login = async (credentials: LoginCredentials): Promise<{ user: User, token: string }> => {
    const response = await apiClient.post('/auth/login', credentials);
    // 假设后端在登录成功后返回 { user: User, token: string }
    return response.data;
};

export const register = async (data: RegistrationData): Promise<{ user: User, token: string }> => {
    const response = await apiClient.post('/auth/register', data);
    // 假设后端在注册成功后返回 { user: User, token: string }
    return response.data;
};

// =
// 文件: ..\src\api\client.ts
//

import axios from 'axios';
import { useAuthStore } from '@/auth/store/auth.store';

const apiClient = axios.create({
    baseURL: '/api',
    headers: {
        'Content-Type': 'application/json',
    },
});

// 请求拦截器
apiClient.interceptors.request.use(
    (config) => {
        const authStore = useAuthStore();
        const token = authStore.token;

        if (token) {
            // 在每个需要认证的请求头中添加 Bearer Token
            config.headers.Authorization = `Bearer ${token}`;
        }

        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

export default apiClient;

// =
// 文件: ..\src\api\dataPrivacyApi.ts
//

// src/api/dataPrivacyApi.ts
import apiClient from './client';
import type { DataCollectionSetting, DataUsageItem, DataPermission } from '@/types/dataPrivacy';

export const fetchDataPrivacyData = async (): Promise<{
    collectionSettings: DataCollectionSetting[],
    usage: DataUsageItem[],
    permissions: DataPermission[],
    promises: string[]
}> => {
    const response = await apiClient.get('/privacy/settings');
    return response.data;
};

export const saveDataCollectionSetting = async (setting: DataCollectionSetting): Promise<boolean> => {
    // 使用 PUT 或 PATCH 来更新单个设置项
    await apiClient.put('/privacy/collection-settings', setting);
    return true;
};

// =
// 文件: ..\src\api\novel\dashboardApi.ts
//

// src/api/novel/dashboardApi.ts
import apiClient from '@/api/client';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';

/**
 * 从后端获取小说仪表盘列表
 * @returns 返回小说项目摘要列表
 */
export const fetchNovels = async (): Promise<NovelDashboardItem[]> => {
    const response = await apiClient.get('/novels');
    return response.data;
};

/**
 * 创建一本新的小说
 * @param data - 创建小说所需的数据
 * @returns 返回新创建的小说项目摘要
 */
export const createNovel = async (data: { title: string; synopsis: string; category: NovelCategory }): Promise<NovelDashboardItem> => {
    const response = await apiClient.post('/novels', data);
    return response.data;
};

/**
 * 获取所有可用的小说分类
 * @returns 返回分类名称数组
 */
export const fetchAvailableCategories = async (): Promise<NovelCategory[]> => {
    const response = await apiClient.get('/novels/categories');
    return response.data;
};

// =
// 文件: ..\src\api\novel\editorApi.ts
//

import apiClient from '@/api/client';
import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes.ts';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';
import { useAuthStore } from '@/auth/store/auth.store';

/**
 * 获取所有聊天对话。
 */
export const fetchConversations = async (): Promise<Conversation[]> => {
    const response = await apiClient.get('/ai/chat/conversations');
    return response.data;
};

/**
 * 创建一个新的、空的对话。
 */
export const createConversation = async (): Promise<Conversation> => {
    const response = await apiClient.post('/ai/chat/conversations');
    return response.data;
};

/**
 * 发送一条消息并获取AI的回复。
 * @param conversationId - 对话ID
 * @param userInput - 用户输入的文本。
 * @returns 返回一个包含用户消息和AI回复消息的对象。
 */
export const sendMessage = async (conversationId: string, userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> => {
    const response = await apiClient.post(`/ai/chat/conversations/${conversationId}/messages`, { content: userInput });
    // 假设后端返回包含用户消息和AI响应的结构
    return response.data;
};


/**
 * 调用后端API执行一个流式AI任务。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param taskType - 任务的类型 ('润色', '续写' 等).
 * @param sourceItemTitle - 任务源文档的标题.
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export const streamAITask = async (
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: {
        onChunk: (chunk: string) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    const { onChunk, onComplete, onError } = callbacks;

    try {
        const authStore = useAuthStore();
        const token = authStore.token;
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
        };
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch('/api/ai/tasks/stream', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                prompt,
                config,
                taskType,
                sourceItemTitle
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        if (!response.body) {
            throw new Error('Response body is null.');
        }

        const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
        const sseRegex = /data: (.*)\n\n/g;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            let match;
            while((match = sseRegex.exec(value)) !== null) {
                const data = match[1];
                if (data) onChunk(data);
            }
        }
        onComplete();
    } catch (error) {
        onError(error instanceof Error ? error.message : 'An unknown streaming error occurred.');
    }
};

// =
// 文件: ..\src\api\novel\metadataApi.ts
//

import apiClient from '@/api/client';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * 根据小说ID获取元数据
 * @param novelId - 小说ID
 * @returns 返回小说元数据
 */
export const getNovelMetadata = async (novelId: string): Promise<NovelMetadata> => {
    const response = await apiClient.get(`/novels/${novelId}/metadata`);
    return response.data;
};

/**
 * 更新小说元数据
 * @param novelId - 小说ID
 * @param metadata - 更新后的元数据
 * @returns 返回更新后的元数据
 */
export const updateNovelMetadata = async (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    const response = await apiClient.patch(`/novels/${novelId}/metadata`, metadata);
    return response.data;
};

// =
// 文件: ..\src\api\novel\projectApi.ts
//

import apiClient from '@/api/client';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume } from '@/novel/editor/types';

/**
 * 根据ID获取完整的小说项目数据
 * @param novelId - 小说ID
 * @returns 返回完整的小说项目对象
 */
export const getNovelProject = async (novelId: string): Promise<NovelProject> => {
    const response = await apiClient.get(`/novels/${novelId}/project`);
    return response.data;
};

/**
 * 更新一个小说项目的内容结构（目录、设定、笔记等）
 * @param novelId - 小说ID
 * @param projectData - 仅包含需要更新的内容结构数据
 * @returns 返回更新后的小说项目
 */
export const updateNovelProjectContent = async (novelId: string, projectData: Omit<NovelProject, 'metadata'>): Promise<NovelProject> => {
    const response = await apiClient.put(`/novels/${novelId}/project-content`, projectData);
    return response.data;
};

/**
 * 从解析后的数据导入一本新小说
 * @param data - 包含标题、描述和章节数据等
 * @returns 返回新创建的完整小说项目
 */
export const importNovelProject = async (data: {
    title: string;
    description: string;
    category: string;
    directoryData: Volume[];
}): Promise<NovelProject> => {
    const response = await apiClient.post('/novels/import', data);
    return response.data;
};

/**
 * 获取所有小说项目，用于参考书选择等场景
 * @returns 返回所有小说项目的数组
 */
export const fetchAllNovelProjects = async (): Promise<NovelProject[]> => {
    const response = await apiClient.get('/novels/projects');
    return response.data;
};

/**
 * 永久删除一个小说项目（非移入回收站）
 * @param novelId - 小说ID
 */
export const deleteNovelProject = async (novelId: string): Promise<void> => {
    await apiClient.delete(`/novels/${novelId}/permanent`);
};

// =
// 文件: ..\src\api\novel\recentApi.ts
//

// src/api/novel/recentApi.ts
import apiClient from '@/api/client';
import type { RecentActivityItem } from '@/novel/types';

/**
 * 获取最近活动列表
 * @returns 返回最近活动项目列表
 */
export const fetchRecentItems = async (): Promise<RecentActivityItem[]> => {
    const response = await apiClient.get('/recent-items');
    return response.data;
};

/**
 * 记录一次小说访问活动
 * @param novelId - 被访问的小说ID
 * @returns 返回新创建的活动记录
 */
export const logRecentAccess = async (novelId: string): Promise<RecentActivityItem> => {
    const response = await apiClient.post('/recent-items', { novelId });
    return response.data;
};

// =
// 文件: ..\src\api\novel\trashApi.ts
//

// src/api/novel/trashApi.ts
import apiClient from '@/api/client';
import type { DeletedItem, NovelDashboardItem } from '@/novel/types';

/**
 * 将指定ID的小说移至回收站
 * @param novelId - 要删除的小说ID
 */
export const moveToTrash = async (novelId: string): Promise<void> => {
    await apiClient.delete(`/novels/${novelId}`);
};

/**
 * 获取回收站中的项目列表
 * @returns 返回已删除项目列表
 */
export const fetchTrashedItems = async (): Promise<DeletedItem[]> => {
    const response = await apiClient.get('/trash/novels');
    return response.data;
};

/**
 * 从回收站恢复指定的项目
 * @param itemId - 要恢复的项目ID
 * @returns 返回恢复后的小说摘要信息
 */
export const restoreItem = async (itemId: string): Promise<NovelDashboardItem> => {
    const response = await apiClient.post(`/trash/novels/${itemId}/restore`);
    return response.data;
};

/**
 * 从回收站永久删除指定的项目
 * @param itemId - 要永久删除的项目ID
 */
export const deleteItemPermanently = async (itemId: string): Promise<void> => {
    await apiClient.delete(`/trash/novels/${itemId}`);
};

// =
// 文件: ..\src\api\systemSettingsApi.ts
//

import apiClient from './client';
import type { Theme, SystemSettings } from '@/types/systemSettings';

export const fetchThemes = async (): Promise<Theme[]> => {
    const response = await apiClient.get('/system/themes');
    return response.data;
};

export const fetchSystemSettings = async (): Promise<SystemSettings> => {
    const response = await apiClient.get('/system/settings');
    return response.data;
};

export const saveSystemSetting = async <T extends keyof SystemSettings>(key: T, value: SystemSettings[T]): Promise<boolean> => {
    // 使用 PATCH 请求来更新部分设置
    await apiClient.patch('/system/settings', { [key]: value });
    return true;
};

// =
// 文件: ..\src\api\usageLogsApi.ts
//

// src/api/usageLogsApi.ts
import apiClient from './client';
import type { UsageStat, ApiLog, ChartDataPoint, FetchParams } from '@/types/usageLogs';

export const fetchUsageData = async (params: FetchParams): Promise<{
    stats: UsageStat[],
    logs: ApiLog[],
    chartData: ChartDataPoint[],
    totalLogs: number,
    totalPages: number
}> => {
    const response = await apiClient.get('/usage-logs', { params });
    return response.data;
};

// =
// 文件: ..\src\api\userApi.ts
//

import apiClient from './client';
import type { User } from '@/types/auth';
import type { NotificationSetting, SecuritySetting } from '@/types/user';

export const fetchCurrentUser = async (): Promise<User> => {
    const response = await apiClient.get('/users/me');
    return response.data;
};

export const fetchUserSettings = async (): Promise<{user: User, notifications: NotificationSetting[], securitySettings: SecuritySetting[], proPlanFeatures: string[]}> => {
    const response = await apiClient.get('/users/settings');
    return response.data;
};

export const saveUserSettings = async (settings: {
    user: User;
    notifications: NotificationSetting[];
}): Promise<boolean> => {
    await apiClient.put('/users/settings', settings);
    return true;
};

// =
// 文件: ..\src\home\api\mockDashboardApi.ts
//

import type { Stat, QuickStartAction, RecentProject } from '@/home/types';

const statsData: Stat[] = [
    { label: '作品总数', value: '24', trend: '+12%', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>` },
    { label: '总字数', value: '128.5k', trend: '+8%', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 20L12 10"/><path d="M18 20L18 4"/><path d="M6 20L6 16"/></svg>` },
    { label: 'AI 使用次数', value: '856', trend: '进行中', trendClass: 'text-[#3B82F6] bg-blue-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>` },
    { label: '获得赞赏', value: '342', trend: '+24', trendClass: 'text-[#10B981] bg-green-50', icon: `<svg class="w-5 h-5 text-[#4B5563]" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20.84 4.61C20.3 4.07 19.5 3.87 18.75 4.12L5.23 8.62C4.34 8.91 3.75 9.76 3.75 10.72C3.75 11.68 4.34 12.53 5.23 12.82L10.5 14.53L12.21 19.8C12.5 20.69 13.35 21.28 14.31 21.28C15.27 21.28 16.12 20.69 16.41 19.8L20.91 6.28C21.16 5.53 20.96 4.73 20.42 4.19L20.84 4.61Z"/></svg>` },
];

const quickStartActionsData: QuickStartAction[] = [
    { title: '创建新作品', description: '开始全新的创作之旅', icon: `<svg class="text-white" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M12 5V19M5 12H19"/></svg>`, iconBgClass: 'bg-[#4B5563]' },
    { title: 'AI 助手', description: '智能创作伴侣', icon: `<svg class="text-[#4B5563]" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M13 2L3 14H12L11 22L21 10H12L13 2Z"/></svg>`, iconBgClass: 'bg-[#F3F4F6]' },
    { title: '导入文档', description: '继续未完成的创作', icon: `<svg class="text-[#4B5563]" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><path d="M7 18C4.5 18 3 16.5 3 14C3 11.5 5 10 7 10C7.3 10 7.5 10 7.8 10.1C8.5 7.2 11 5 14 5C17.3 5 20 7.7 20 11C20 11.3 20 11.7 19.9 12C21.1 12.5 22 13.6 22 15C22 16.9 20.4 18.5 18.5 18.5"/><path d="M12 13V21M15 16L12 13L9 16"/></svg>`, iconBgClass: 'bg-[#F3F4F6]' }
];

const recentProjectsData: RecentProject[] = [
    { title: '星际漫游者', details: '科幻冒险 · 24章 · 2小时前', status: '编辑中', bgClass: 'bg-gradient-to-br from-indigo-100 to-purple-100' },
    { title: '月光下的约定', details: '现代言情 · 18章 · 昨天', status: '暂停', bgClass: 'bg-gradient-to-br from-pink-100 to-rose-100' }
];

export const fetchMockDashboardData = async () => {
    // 模拟网络延迟
    await new Promise(resolve => setTimeout(resolve, 200));
    return Promise.resolve({
        stats: statsData,
        quickStartActions: quickStartActionsData,
        recentProjects: recentProjectsData,
    });
};

// =
// 文件: ..\src\home\services\dashboardService.ts
//

import { fetchMockDashboardData } from '@/home/api/mockDashboardApi';

const getDashboardData = async () => {
    try {
        const data = await fetchMockDashboardData();
        return data;
    } catch (error) {
        console.error("Failed to fetch dashboard data:", error);
        // 返回空状态或默认值，以便UI可以优雅地处理错误
        return {
            stats: [],
            quickStartActions: [],
            recentProjects: [],
        };
    }
}

export const dashboardService = {
    getDashboardData,
}

// =
// 文件: ..\src\home\stores\homeStore.ts
//

// src/home/stores/homeStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Stat, QuickStartAction, RecentProject } from '@/home/types';
import { dashboardService } from '@/home/services/dashboardService';

export const useDashboardStore = defineStore('dashboard', () => {
    // State
    const stats = ref<Stat[]>([]);
    const quickStartActions = ref<QuickStartAction[]>([]);
    const recentProjects = ref<RecentProject[]>([]);
    const isLoading = ref(false);

    // Actions
    async function fetchDashboardData() {
        isLoading.value = true;
        try {
            const data = await dashboardService.getDashboardData();
            stats.value = data.stats;
            quickStartActions.value = data.quickStartActions;
            recentProjects.value = data.recentProjects;
        } catch (error) {
            console.error("Error in store while fetching dashboard data:", error);
            // 在这里可以设置错误状态
        } finally {
            isLoading.value = false;
        }
    }

    return {
        stats,
        quickStartActions,
        recentProjects,
        isLoading,
        fetchDashboardData,
    };
});

// =
// 文件: ..\src\home\types\index.ts
//

// src/home/types/index.ts
// 定义 Home 模块（工作台仪表盘）相关的数据类型

export interface Stat {
    label: string;
    value: string;
    trend: string;
    trendClass: string;
    icon: string;
}

export interface QuickStartAction {
    title: string;
    description: string;
    icon: string;
    iconBgClass: string;
}

export interface RecentProject {
    title: string;
    details: string;
    status: '编辑中' | '暂停';
    bgClass: string;
}

// =
// 文件: ..\src\main.ts
//

import { createApp } from 'vue'
import { createPinia } from 'pinia'

import './styles/main.css'

import App from './App.vue'
import router from './router'
import { useAuthService } from './auth/services/auth.service'

const app = createApp(App)

app.use(createPinia())

// 应用初始化函数
async function initializeApp() {
    const { initializeAuth } = useAuthService();

    // 在挂载应用前，先完成认证状态的初始化
    await initializeAuth();

    // 认证状态确定后再使用路由和挂载应用
    app.use(router)
    app.mount('#app')
}

initializeApp();

// =
// 文件: ..\src\novel\dashboard\api\dashboardApi.ts
//

import * as dashboardApi from '@/api/novel/dashboardApi';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';

/**
 * 从后端获取小说仪表盘列表
 * @returns 返回小说项目摘要列表
 */
export const fetchNovels = (): Promise<NovelDashboardItem[]> => {
    return dashboardApi.fetchNovels();
};

/**
 * 创建一本新的小说
 * @param data - 创建小说所需的数据
 * @returns 返回新创建的小说项目摘要
 */
export const createNovel = (data: { title: string; synopsis: string; category: NovelCategory }): Promise<NovelDashboardItem> => {
    return dashboardApi.createNovel(data);
};

/**
 * 获取所有可用的小说分类
 * @returns 返回分类名称数组
 */
export const fetchAvailableCategories = (): Promise<NovelCategory[]> => {
    return dashboardApi.fetchAvailableCategories();
};

// =
// 文件: ..\src\novel\dashboard\config\sidebar.config.ts
//


export interface NavItem {
    name: string;
    path: string;
    icon: string;
}

export const mainNavItems: NavItem[] = [
    {
        name: '我的小说',
        path: '/novel/dashboard',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="5" y="3" width="14" height="18" rx="2"/><path d="M9 7H15M9 11H15M9 15H13"/></svg>`
    },
    {
        name: '最近编辑',
        path: '/novel/recent',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6V12L16 16"/></svg>`
    },
    {
        name: '回收站',
        path: '/novel/trash',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 6h18M5 6V20a2 2 0 002 2h10a2 2 0 002-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6"/></svg>`
    },
    {
        name: '导出小说',
        path: '/novel/export',
        icon: `<svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>`
    }
];

// =
// 文件: ..\src\novel\dashboard\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const dashboardRoutes: Array<RouteRecordRaw> = [
    {
        path: 'dashboard',
        name: 'NovelDashboard',
        component: () => import('@/novel/dashboard/views/DashboardView.vue'),
        meta: { title: '我的小说' }
    },
    {
        path: 'recent',
        name: 'NovelRecent',
        component: () => import('@/novel/dashboard/views/RecentView.vue'),
        meta: { title: '最近编辑' }
    },
    {
        path: 'trash',
        name: 'NovelTrash',
        component: () => import('@/novel/dashboard/views/TrashView.vue'),
        meta: { title: '回收站' }
    },
    {
        path: 'import',
        name: 'NovelImport',
        component: () => import('@/novel/dashboard/views/ImportView.vue'),
        meta: { title: '导入小说' }
    },
    {
        path: 'new',
        name: 'NovelNew',
        component: () => import('@/novel/dashboard/views/NewNovelView.vue'),
        meta: { title: '新建小说' }
    },
    {
        path: 'export',
        name: 'NovelExport',
        component: () => import('@/novel/dashboard/views/ExportView.vue'),
        meta: { title: '导出小说' }
    },
]

// =
// 文件: ..\src\novel\dashboard\services\dashboardService.ts
//

import * as dashboardApi from '../api/dashboardApi';
import * as recentApi from '@/api/novel/recentApi'; // 假设 recent 和 trash 暂时没有模块代理
import * as trashApi from '@/api/novel/trashApi';
import type { DeletedItem, NovelCategory, NovelDashboardItem, RecentActivityItem } from '@/novel/types';

// --- Novel List Functions ---
export const fetchNovels = (): Promise<NovelDashboardItem[]> => {
    return dashboardApi.fetchNovels();
};

export const createNovel = (data: { title: string; synopsis: string; category: NovelCategory }): Promise<NovelDashboardItem> => {
    return dashboardApi.createNovel(data);
};

export const fetchAvailableCategories = (): Promise<NovelCategory[]> => {
    return dashboardApi.fetchAvailableCategories();
};

// --- Recent Activity Functions ---
export const fetchRecentItems = (): Promise<RecentActivityItem[]> => {
    return recentApi.fetchRecentItems();
};

export const logRecentAccess = (novelId: string): Promise<RecentActivityItem> => {
    return recentApi.logRecentAccess(novelId);
};

// --- Trash Functions ---
export const moveToTrash = (novelId: string): Promise<void> => {
    return trashApi.moveToTrash(novelId);
};

export const fetchTrashedItems = (): Promise<DeletedItem[]> => {
    return trashApi.fetchTrashedItems();
};

export const restoreItem = (itemId: string): Promise<NovelDashboardItem> => {
    return trashApi.restoreItem(itemId);
};

export const deleteItemPermanently = (itemId: string): Promise<void> => {
    // 此处调用的是 trashApi 的永久删除，它会调用 /trash/novels/:id
    // 这与 projectApi 中的 /novels/:id/permanent 是不同的，前者是从回收站删除
    return trashApi.deleteItemPermanently(itemId);
};

// =
// 文件: ..\src\novel\dashboard\stores\novelStore.ts
//

// src/novel/dashboard/stores/novelStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, NovelCategory } from '@/novel/types';
import * as dashboardService from '@/novel/dashboard/services/dashboardService';

export const useNovelStore = defineStore('novel-dashboard-novels', () => {
    const novels = ref<NovelDashboardItem[]>([]);
    const availableCategories = ref<NovelCategory[]>([]);
    const searchQuery = ref('');
    const selectedCategory = ref<NovelCategory | '全部类型'>('全部类型');
    const isLoading = ref(false);

    const filteredNovels = computed(() => {
        return novels.value.filter(novel => {
            const matchesCategory = selectedCategory.value === '全部类型' || novel.category === selectedCategory.value;
            const matchesSearch = novel.title.toLowerCase().includes(searchQuery.value.toLowerCase()) || novel.tags.some(tag => tag.text.toLowerCase().includes(searchQuery.value.toLowerCase()));
            return matchesCategory && matchesSearch;
        });
    });

    const fetchNovels = async () => {
        isLoading.value = true;
        try {
            novels.value = await dashboardService.fetchNovels();
        } catch (error) {
            console.error('Failed to fetch novels:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const fetchCategories = async () => {
        try {
            availableCategories.value = await dashboardService.fetchAvailableCategories();
        } catch (error) {
            console.error('Failed to fetch categories:', error);
        }
    };

    const initializeDashboard = () => {
        fetchNovels();
        fetchCategories();
    };

    const addNovel = (newNovel: NovelDashboardItem) => {
        novels.value.unshift(newNovel);
    };

    const createNovel = async (data: { title: string; synopsis: string; category: NovelCategory }) => {
        try {
            const newNovel = await dashboardService.createNovel(data);
            addNovel(newNovel);
        } catch (error) {
            console.error('Failed to create novel:', error);
            // 这里可以添加用户反馈，例如弹窗提示
        }
    };

    const deleteNovel = async (novelId: string) => {
        try {
            await dashboardService.moveToTrash(novelId);
            const index = novels.value.findIndex(n => n.id === novelId);
            if (index !== -1) {
                novels.value.splice(index, 1);
            }
        } catch (error) {
            console.error('Failed to delete novel:', error);
        }
    };

    return {
        novels,
        searchQuery,
        selectedCategory,
        filteredNovels,
        availableCategories,
        isLoading,
        initializeDashboard,
        fetchNovels,
        addNovel,
        createNovel,
        deleteNovel,
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\recentStore.ts
//

// src/novel/dashboard/stores/recentStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { NovelDashboardItem, RecentActivityItem } from '@/novel/types';
import * as dashboardService from '@/novel/dashboard/services/dashboardService';
import { formatDistanceToNowStrict } from 'date-fns';
import { zhCN } from 'date-fns/locale';

const RECENTS_QUEUE_LIMIT = 10;

const formatTimeAgo = (isoString: string): string => {
    const date = new Date(isoString);
    const diff = new Date().getTime() - date.getTime();
    if (diff < 60000) { // 1分钟内
        return '刚刚';
    }
    return formatDistanceToNowStrict(date, { addSuffix: true, locale: zhCN });
};

export const useRecentStore = defineStore('novel-dashboard-recent', () => {
    const recentItems = ref<RecentActivityItem[]>([]);
    const isLoading = ref(false);

    const groupedRecentItems = computed(() => {
        const groups: { period: string; items: RecentActivityItem[] }[] = [];
        if (recentItems.value.length === 0) return groups;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);

        const sortedItems = [...recentItems.value].sort((a, b) => new Date(b.editedAt).getTime() - new Date(a.editedAt).getTime());

        sortedItems.forEach(item => {
            item.formattedTime = formatTimeAgo(item.editedAt);
        });

        const todayItems: RecentActivityItem[] = [];
        const yesterdayItems: RecentActivityItem[] = [];
        const earlierItems: RecentActivityItem[] = [];

        sortedItems.forEach(item => {
            const itemDate = new Date(item.editedAt);
            itemDate.setHours(0, 0, 0, 0);

            if (itemDate.getTime() === today.getTime()) {
                todayItems.push(item);
            } else if (itemDate.getTime() === yesterday.getTime()) {
                earlierItems.push(item);
            } else {
                earlierItems.push(item);
            }
        });

        if (todayItems.length > 0) groups.push({ period: '今天', items: todayItems });
        if (yesterdayItems.length > 0) groups.push({ period: '昨天', items: yesterdayItems });
        if (earlierItems.length > 0) groups.push({ period: '更早', items: earlierItems });

        return groups;
    });

    const fetchRecentItems = async () => {
        isLoading.value = true;
        try {
            recentItems.value = await dashboardService.fetchRecentItems();
        } catch (error) {
            console.error('Failed to fetch recent items:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const logRecentAccess = async (novel: NovelDashboardItem) => {
        try {
            // 先从列表中移除旧的记录（如果存在）
            const existingIndex = recentItems.value.findIndex(item => item.novelId === novel.id);
            if (existingIndex !== -1) {
                recentItems.value.splice(existingIndex, 1);
            }

            // 调用Service记录访问，并获取最新的活动项
            const newActivity = await dashboardService.logRecentAccess(novel.id);

            // 将新活动添加到列表顶部
            recentItems.value.unshift(newActivity);

            // 保持列表长度限制
            if (recentItems.value.length > RECENTS_QUEUE_LIMIT) {
                recentItems.value.pop();
            }
        } catch (error) {
            console.error('Failed to log recent access:', error);
        }
    };

    return {
        recentItems,
        isLoading,
        groupedRecentItems,
        fetchRecentItems,
        logRecentAccess,
    };
});

// =
// 文件: ..\src\novel\dashboard\stores\trashStore.ts
//

// src/novel/dashboard/stores/trashStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { DeletedItem } from '@/novel/types';
import * as dashboardService from '@/novel/dashboard/services/dashboardService';
import { useNovelStore } from './novelStore';

export const useTrashStore = defineStore('novel-dashboard-trash', () => {
    const trashedItems = ref<DeletedItem[]>([]);
    const isLoading = ref(false);

    const fetchTrashedItems = async () => {
        isLoading.value = true;
        try {
            trashedItems.value = await dashboardService.fetchTrashedItems();
        } catch (error) {
            console.error('Failed to fetch trashed items:', error);
        } finally {
            isLoading.value = false;
        }
    };

    const restoreItem = async (itemId: string) => {
        try {
            const restoredNovel = await dashboardService.restoreItem(itemId);

            // 从回收站列表中移除
            const index = trashedItems.value.findIndex(item => item.id === itemId);
            if (index !== -1) {
                trashedItems.value.splice(index, 1);
            }

            // 将恢复的小说添加回主列表
            const novelStore = useNovelStore();
            novelStore.addNovel(restoredNovel);

        } catch (error){
        console.error('Failed to restore item:', error);
        alert('恢复失败，请稍后重试。');
    }
};

const deleteItemPermanently = async (itemId: string) => {
    if (confirm(`您确定要永久删除这个项目吗？此操作无法撤销。`)) {
        try {
            await dashboardService.deleteItemPermanently(itemId);
            const index = trashedItems.value.findIndex(item => item.id === itemId);
            if (index > -1) {
                trashedItems.value.splice(index, 1);
            }
        } catch (error) {
            console.error('Failed to permanently delete item:', error);
            alert('永久删除失败，请稍后重试。');
        }
    }
};

return {
    trashedItems,
    isLoading,
    fetchTrashedItems,
    restoreItem,
    deleteItemPermanently
    };
});

// =
// 文件: ..\src\novel\data\mockNovelProjects.ts
//

import type { NovelProject } from '@/novel/editor/types/project';
import type {
    Volume,
    NoteItem,
    TreeNode,
    ItemNode,
    NovelCharacter,
    GroupNode,
    OverviewNode,
    PlotAnalysisItem
} from '@/novel/editor/types';


const defaultSettingsData: TreeNode[] = [
    {
        id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
        children: [
            {
                id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                    { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                    { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                    { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                ]
            } as GroupNode,
            {
                id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                    { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                ]
            } as GroupNode
        ]
    }
];
const defaultPlotCustomData: ItemNode[] = [];
const defaultAnalysisCustomData: ItemNode[] = [];
const defaultOthersCustomData: ItemNode[] = [
    { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
];

export const novelProjects = new Map<string, NovelProject>();

const starRangerCharacters: NovelCharacter[] = [
    {
        id: 'char-calvin',
        name: '卡尔文·里德',
        avatar: 'https://i.pravatar.cc/150?u=calvin',
        identity: '主角, 探索者四号宇航员',
        gender: '男',
        age: 35,
        faction: '人类联邦',
        summary: '孤独的宇航员，在一次深空探索任务中遭遇意外，被迫独自在未知星系中寻找归途。性格坚毅、冷静，但内心深处对家园有着强烈的眷恋。',
        notes: '设计灵感来源于电影《月球》和《星际穿越》。需要重点刻画其在长期孤独环境下的心理变化。',
        status: 'editing'
    },
    {
        id: 'char-aila',
        name: '艾拉 (AILA)',
        avatar: '',
        identity: 'AI, 飞船智能核心',
        summary: '第五代通用人工智能，负责“探索者四号”的全部系统运作。逻辑至上，声音平稳无波澜。在与卡尔文的长期相处中，其程序底层开始出现不符合预期的、类似人类情感的逻辑萌芽。',
        status: 'completed'
    },
];

novelProjects.set('ref-asimov-foundation', {
    metadata: {
        id: 'ref-asimov-foundation',
        title: '《银河帝国：基地》',
        description: '阿西莫夫的经典科幻作品，探讨心理史学。',
        cover: 'https://images.unsplash.com/photo-1532012197267-da84d127e765?q=80&w=200',
        tags: [{ text: '经典科幻', class: 'bg-gray-100 text-gray-800' }],
        status: '已完结',
        referenceNovelIds: [],
    },
    directoryData: [{
        id: 'ref-asimov-vol-1', type: 'volume', title: '第一部 心理史学家', content: '<h1>第一部 心理史学家</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ref-asimov-ch-1', type: 'chapter', title: '第一节', wordCount: 3000, content: '<h1>第一节</h1><p>哈里·谢顿在川陀的最后一次演讲，预言了帝国的崩溃...</p>', status: 'completed' }
        ]
    }],
    settingsData: [],
    plotCustomData: [],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [],
    othersCustomData: [],
    noteData: [],
});

novelProjects.set('ref-cixin-darkforest', {
    metadata: {
        id: 'ref-cixin-darkforest',
        title: '《黑暗森林》',
        description: '刘慈欣《三体》系列的第二部，提出宇宙社会学。',
        cover: 'https://images.unsplash.com/photo-1544716278-e513176f20b5?q=80&w=200',
        tags: [{ text: '硬科幻', class: 'bg-blue-50 text-blue-700' }],
        status: '已完结',
        referenceNovelIds: [],
    },
    directoryData: [{
        id: 'ref-cixin-vol-1', type: 'volume', title: '面壁者', content: '<h1>面壁者</h1><p>本卷大纲...</p>', chapters: [
            { id: 'ref-cixin-ch-1', type: 'chapter', title: '第一章', wordCount: 5000, content: '<h1>第一章</h1><p>面对三体文明的威胁，人类制定了“面壁计划”...</p>', status: 'completed' }
        ]
    }],
    settingsData: [],
    plotCustomData: [],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [],
    othersCustomData: [],
    noteData: [],
});

novelProjects.set('novel-1', {
    metadata: {
        id: 'novel-1',
        title: '星际漫游者',
        description: '一部关于孤独宇航员在未知星系中寻找回家之路的科幻史诗。',
        cover: 'https://images.unsplash.com/photo-1589998059171-988d887df646?q=80&w=200',
        tags: [{ text: '科幻', class: 'bg-blue-50 text-blue-700' }],
        status: '连载中',
        referenceNovelIds: ['ref-asimov-foundation', 'ref-cixin-darkforest'],
    },
    directoryData: [
        {
            id: 'vol-1', type: 'volume', title: '第一卷：星尘之始', content: '<h1>第一卷：星尘之始</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-1', type: 'chapter', title: '第一章：深空孤影', wordCount: 3102, content: '<h1>第一章：深空孤影</h1><p>这是章节的详细内容，讲述了主角卡尔文在孤独的宇宙中开始他的旅程。周围只有无尽的星空和飞船引擎的低鸣。</p>', status: 'completed' },
                { id: 'ch-2', type: 'chapter', title: '第二章：异常信号', wordCount: 2845, content: '<h1>第二章：异常信号</h1><p>一个神秘的信号打破了长久的平静，它似乎来自一个未知的源头，艾拉无法解析其格式。这给卡尔文带来了希望，也带来了恐惧。</p>', status: 'completed' },
                { id: 'ch-3', type: 'chapter', title: '第三章：AI的低语', wordCount: 3500, content: '<h1>第三章：AI的低语</h1><p>在分析信号的过程中，飞船的AI“艾拉”开始出现一些微小的异常行为。它的逻辑似乎在发生某种不为人知的演变。</p>', status: 'editing' },
                { id: 'ch-4', type: 'chapter', title: '第四章: 跃迁点', wordCount: 2415, content: '<h1>第四章: 跃迁点</h1><p>他们最终发现信号源自一个时空奇点——一个理论上存在的跃迁点。这可能是他们回家唯一的希望，也可能是通向毁灭的陷阱。</p>', status: 'editing' },
            ]
        },
        {
            id: 'vol-2', type: 'volume', title: '第二卷：遗忘的航线', content: '<h1>第二卷：遗忘的航线</h1><p>本卷大纲...</p>', chapters: [
                { id: 'ch-5', type: 'chapter', title: '第五章：时空涟漪', wordCount: 0, content: '<h1>第五章：时空涟漪</h1>', status: 'planned' },
            ]
        },
    ],
    settingsData: [
        {
            id: 'setting', title: '设定', type: 'root', icon: 'fa-solid fa-book-journal-whills',
            children: [
                {
                    id: 'characters', title: '角色', type: 'group', icon: 'fa-solid fa-users text-teal-500', children: [
                        { id: 'characters-overview', title: '角色总览', type: 'characters_overview', icon: 'fa-solid fa-users', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        ...starRangerCharacters.map(char => ({
                            id: char.id,
                            title: char.name,
                            type: 'character_item',
                            icon: 'fa-regular fa-user',
                            content: `<h1>${char.name}</h1><p>身份：${char.identity}</p><p>简介：${char.summary}</p>`,
                            originalData: char,
                        }))
                    ]
                } as GroupNode,
                {
                    id: 'locations', title: '地点', type: 'group', icon: 'fa-solid fa-map-location-dot text-green-500', children: [
                        { id: 'locations-overview', title: '地点总览', type: 'locations_overview', icon: 'fa-solid fa-map-location-dot', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'items', title: '物品', type: 'group', icon: 'fa-solid fa-box-archive text-amber-600', children: [
                        { id: 'items-overview', title: '物品总览', type: 'items_overview', icon: 'fa-solid fa-box-archive', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                    ]
                } as GroupNode,
                {
                    id: 'worldview', title: '世界观', type: 'group', icon: 'fa-solid fa-earth-americas text-sky-500', children: [
                        { id: 'worldview-overview', title: '世界观总览', type: 'worldview_overview', icon: 'fa-solid fa-book-atlas', content: '', isOverview: true, isReadOnly: true } as OverviewNode,
                        { id: 'world-overview-item', title: '世界观细则', type: 'worldview_item', icon: 'fa-solid fa-book-atlas', content: '<h1>世界观总览</h1><p>23世纪，人类掌握了亚光速航行技术，开始探索临近星系。</p>' } as ItemNode,
                    ]
                } as GroupNode
            ]
        }
    ],
    plotCustomData: [
        { id: 'custom-plot-1', title: '关于跃迁点背后的文明猜想', type: 'plot_item', icon: 'fa-solid fa-lightbulb text-rose-500', content: '<h1>关于跃迁点背后的文明猜想</h1>' }
    ],
    analysisCustomData: [],
    derivedPlotData: [],
    derivedAnalysisData: [
        {
            id: 'analysis_1682495833181',
            type: 'analysis',
            sourceId: 'ch-3',
            title: '《第三章：AI的低语》分析',
            content: '<h1>《第三章：AI的低语》分析</h1><p>本章通过AI“艾拉”的微小异常，成功地在科幻背景下引入了悬疑元素。这种“不可靠的伙伴”设定，极大地增强了主角卡尔文的孤独感和不确定性，为后续情节发展埋下伏笔。</p>'
        }
    ],
    othersCustomData: [
        { id: 'custom-others-1', title: '写作风格参考', type: 'others_item', icon: 'fa-regular fa-file-zipper', content: '<h1>写作风格参考</h1><p>参考阿西莫夫《基地》系列的宏大叙事风格，同时融合《黑暗森林》的悬疑氛围。' }
    ],
    noteData: [
        { id: 'note-1', type: 'note', title: '第四章情感转折点设计', timestamp: '今天 14:32', content: '<h1>第四章情感转折点设计</h1><p>需要重点描写卡尔文在面对跃迁点时，希望与恐惧交织的复杂心理。</p>' },
    ]
});

// =
// 文件: ..\src\novel\editor\api\apiManagementApi.ts
//

import { fetchApiKeys as globalFetchApiKeys } from '@/api/apiManagementApi';
import type { ApiKey } from '@/types/apiManagement';

export const fetchApiKeys = (): Promise<ApiKey[]> => {
    return globalFetchApiKeys();
};

// =
// 文件: ..\src\novel\editor\api\chatApi.ts
//

import * as editorApi from '@/api/novel/editorApi';
import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes.ts';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';

export const fetchConversations = (): Promise<Conversation[]> => {
    return editorApi.fetchConversations();
};

export const createConversation = (): Promise<Conversation> => {
    return editorApi.createConversation();
};

export const sendMessage = (conversationId: string, userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> => {
    return editorApi.sendMessage(conversationId, userInput);
};

export const streamAITask = (
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: {
        onChunk: (chunk: string) => void;
        onComplete: () => void;
        onError: (error: string) => void;
    }
): Promise<void> => {
    return editorApi.streamAITask(prompt, config, taskType, sourceItemTitle, callbacks);
};

// =
// 文件: ..\src\novel\editor\api\metadataApi.ts
//

import {
    getNovelMetadata as globalGetNovelMetadata,
    updateNovelMetadata as globalUpdateNovelMetadata,
} from '@/api/novel/metadataApi';
import type { NovelMetadata } from '@/novel/editor/types/project';

/**
 * [Proxy] 根据小说ID获取元数据
 */
export const getNovelMetadata = (novelId: string): Promise<NovelMetadata> => {
    return globalGetNovelMetadata(novelId);
};

/**
 * [Proxy] 更新小说元数据
 */
export const updateNovelMetadata = (novelId: string, metadata: Partial<NovelMetadata>): Promise<NovelMetadata> => {
    return globalUpdateNovelMetadata(novelId, metadata);
};

// =
// 文件: ..\src\novel\editor\api\projectApi.ts
//

import * as projectApi from '@/api/novel/projectApi';
import type { NovelProject } from '@/novel/editor/types/project';

/**
 * [Proxy] 根据ID获取完整的小说项目数据
 */
export const getNovelProject = (novelId: string): Promise<NovelProject> => {
    return projectApi.getNovelProject(novelId);
};

/**
 * [Proxy] 获取所有小说项目，用于参考书选择等场景
 */
export const fetchAllNovelProjects = (): Promise<NovelProject[]> => {
    return projectApi.fetchAllNovelProjects();
};

/**
 * [Proxy] 更新一个小说项目的内容结构
 */
export const updateNovelProjectContent = (novelId: string, projectData: Omit<NovelProject, 'metadata'>): Promise<NovelProject> => {
    return projectApi.updateNovelProjectContent(novelId, projectData);
};

// =
// 文件: ..\src\novel\editor\components\ai\chat\chatData.ts
//

import type { Conversation } from '@novel/editor/types/chatTypes.ts';

export const mockChatConversations: Conversation[] = [
    {
        id: 'conv-1',
        title: '角色性格讨论',
        summary: '关于卡尔文的内心世界...',
        createdAt: '2小时前',
        messages: [
            {
                id: 'msg-1',
                role: 'user',
                content: '我想讨论一下卡尔文这个角色的内心世界。在面对跃迁点时，他应该有什么样的心理活动？',
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
            },
            {
                id: 'msg-2',
                role: 'ai',
                content: `<p class="mb-3">当然，这是一个很好的切入点。卡尔文在面对跃迁点时的心理活动可以从多个层面展现：</p><ol class="list-decimal list-inside space-y-2"><li><strong>希望与恐惧的交织</strong>：跃迁点代表着回家的可能，但也意味着巨大的未知风险。可以描写他手心出汗，但眼神却异常明亮。</li><li><strong>孤独感的顶峰</strong>：在做出这个重大决定时，他比任何时候都更加意识到自己的孤独。没有战友，只有AI。</li><li><strong>对过去的眷恋</strong>："回家"这个词会触发他的记忆闸门，可以闪回一些与家人或恋人的片段。</li></ol>`,
                timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000 + 1000).toISOString(),
            }
        ]
    },
    {
        id: 'conv-2',
        title: '情节灵感',
        summary: '跃迁点的科学原理...',
        createdAt: '昨天',
        messages: []
    }
];

// =
// 文件: ..\src\novel\editor\composables\useAITaskExecutor.ts
//

// 文件: src/novel/editor/composables/useAITaskExecutor.ts

import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useContextPreviewStore } from '@/novel/editor/stores/contextPreviewStore';
import type { AITaskType, EditorItem } from '@/novel/editor/types';

/**
 * AI 任务的源信息, 从核心 EditorItem 类型派生
 */
type TaskSource = Pick<EditorItem, 'id' | 'title'>;

/**
 * 提供一个统一的函数来执行 AI 任务。
 * 它会自动处理是否需要显示预览窗口的逻辑。
 */
export function useAITaskExecutor() {
    const aiTaskStore = useAITaskStore();
    const contextSettingsStore = useContextSettingsStore();
    const contextPreviewStore = useContextPreviewStore();

    /**
     * 执行 AI 任务。
     * @param taskType 要执行的任务类型 ('续写', '润色' 等)
     * @param source 任务的源对象，必须包含 id 和 title
     */
    const executeAITask = (taskType: AITaskType, source: TaskSource) => {
        if (!source || !source.id) {
            console.error("无法执行AI任务：缺少源信息。");
            return;
        }

        // 根据 context settings store 的状态，决定是直接开始任务还是显示预览
        if (contextSettingsStore.needsPreview) {
            contextPreviewStore.show({
                type: taskType,
                targetItemId: source.id,
                title: source.title,
            });
        } else {
            aiTaskStore.startTask(taskType, source.id);
        }
    };

    return { executeAITask };
}

// =
// 文件: ..\src\novel\editor\composables\useContextBuilder.ts
//

import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useContextSettingsStore } from '@/novel/editor/stores/contextSettingsStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore.ts';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import type { AITask, ContextBuildResult, Volume, Chapter, DynamicContextSettings, ReferenceContextSettings, TreeNode } from '@/novel/editor/types';

const stripHtml = (html: string): string => {
    // 使用正则表达式替换，避免依赖DOM环境
    if (!html) return '';
    return html.replace(/<[^>]*>?/gm, '');
};

const _findDerivedItemsRecursive = (nodes: TreeNode[], sourceId: string): TreeNode[] => {
    let results: TreeNode[] = [];
    for (const node of nodes) {
        if (node.originalData?.sourceId === sourceId) {
            results.push(node);
        }
        if (node.children) {
            results = [...results, ..._findDerivedItemsRecursive(node.children, sourceId)];
        }
    }
    return results;
}

export function useContextBuilder() {
    const directoryStore = useDirectoryStore();
    const contextSettingsStore = useContextSettingsStore();
    const derivedContentStore = useDerivedContentStore();
    const referenceStore = useReferenceStore();
    const aiConfigStore = useAIConfigStore();
    const promptTemplateStore = usePromptTemplateStore();

    const _getVolumeOutlineHtml = (vol: Volume): string => {
        return `<hr><h3>相关卷大纲: ${vol.title}</h3>${vol.content}`;
    };

    const _getVolumeFullContextHtml = (vol: Volume, settings: DynamicContextSettings): string => {
        let html = `<hr><h3>相关卷: ${vol.title}</h3>${vol.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === vol.id);
            if (plot) html += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === vol.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }
        return html;
    };

    const _buildContextForChapterTask = (sourceChapter: Chapter, sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';

        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);
        const currentChapterIndex = sourceVolume.chapters.findIndex(c => c.id === sourceChapter.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        dynamicContextHtml += `<hr><h3>当前卷: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) html += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        if (currentChapterIndex > -1) {
            const chapters = sourceVolume.chapters;
            const prevChapStart = Math.max(0, currentChapterIndex - settings.prevChapters);
            for (let i = prevChapStart; i < currentChapterIndex; i++) {
                dynamicContextHtml += `<hr><h3>前文章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
            const nextChapEnd = Math.min(chapters.length, currentChapterIndex + 1 + settings.nextChapters);
            for (let i = currentChapterIndex + 1; i < nextChapEnd; i++) {
                dynamicContextHtml += `<hr><h3>后续章节: ${chapters[i].title}</h3>${chapters[i].content}`;
            }
        }

        if (settings.includeRelatedPlot) {
            derivedContentStore.plotItems.filter(p => p.sourceId === sourceChapter.id).forEach(plot => {
                dynamicContextHtml += `<hr><h3>与本章相关的剧情</h3>${plot.content}`;
            });
        }
        if (settings.includeRelatedAnalysis) {
            derivedContentStore.analysisItems.filter(a => a.sourceId === sourceChapter.id).forEach(analysis => {
                dynamicContextHtml += `<hr><h3>与本章相关的分析</h3>${analysis.content}`;
            });
        }

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeOutlineHtml(allVolumes[i]);
        }

        return dynamicContextHtml;
    };

    const _buildContextForVolumeTask = (sourceVolume: Volume): string => {
        const settings = contextSettingsStore.dynamicContextSettings;
        const allVolumes = directoryStore.directoryData;
        let dynamicContextHtml = '';
        const currentVolumeIndex = allVolumes.findIndex(v => v.id === sourceVolume.id);

        const prevVolStart = Math.max(0, currentVolumeIndex - settings.prevVolumes);
        for (let i = prevVolStart; i < currentVolumeIndex; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        dynamicContextHtml += `<hr><h3>当前卷大纲: ${sourceVolume.title}</h3>${sourceVolume.content}`;
        if (settings.includeVolumePlot) {
            const plot = derivedContentStore.plotItems.find(p => p.sourceId === sourceVolume.id);
            if (plot) dynamicContextHtml += `<h4>卷剧情: ${plot.title}</h4>${plot.content}`;
        }
        if (settings.includeVolumeAnalysis) {
            const analysis = derivedContentStore.analysisItems.find(a => a.sourceId === sourceVolume.id);
            if (analysis) dynamicContextHtml += `<h4>卷分析: ${analysis.title}</h4>${analysis.content}`;
        }

        sourceVolume.chapters.forEach(chapter => {
            let chapterDerivedHtml = '';
            if (settings.includeRelatedPlot) {
                derivedContentStore.plotItems
                    .filter(p => p.sourceId === chapter.id)
                    .forEach(plot => { chapterDerivedHtml += `<h4>剧情: ${plot.title}</h4>${plot.content}`; });
            }
            if (settings.includeRelatedAnalysis) {
                derivedContentStore.analysisItems
                    .filter(a => a.sourceId === chapter.id)
                    .forEach(analysis => { chapterDerivedHtml += `<h4>分析: ${analysis.title}</h4>${analysis.content}`; });
            }
            if (chapterDerivedHtml) {
                dynamicContextHtml += `<hr><h3>章节派生内容 (${chapter.title})</h3>${chapterDerivedHtml}`;
            }
        });

        const nextVolEnd = Math.min(allVolumes.length, currentVolumeIndex + 1 + settings.nextVolumes);
        for (let i = currentVolumeIndex + 1; i < nextVolEnd; i++) {
            dynamicContextHtml += _getVolumeFullContextHtml(allVolumes[i], settings);
        }

        return dynamicContextHtml;
    };

    const _buildReferenceContextHtmlByIndex = (sourceNode: Chapter | Volume, vIndex: number, cIndex: number | null, settings: ReferenceContextSettings): string => {
        // BUG: This index-based matching is fragile and likely to produce incorrect context.
        // It assumes the reference book has the exact same structure.
        // This should be replaced with a more robust matching logic (e.g., title similarity)
        // or a user-driven manual mapping feature.
        // For now, returning an empty string to prevent context pollution.
        if (true) { // Temporarily disabling this feature
            return '<!-- Reference context matching is disabled due to known bugs. -->';
        }

        if (!referenceStore.referenceData.length || vIndex < 0) return '';

        let referenceContextHtml = '';

        for (const refBook of referenceStore.referenceData) {
            const directoryRoot = refBook.children?.find(c => c.id.startsWith('ref-dir-'));
            if (!directoryRoot) continue;

            const refVolumeNode = directoryRoot.children?.[vIndex];
            if (!refVolumeNode) continue;

            let matchingNode: TreeNode | null = null;
            let matchingParent: TreeNode | null = null;

            if (sourceNode.type === 'volume') {
                matchingNode = refVolumeNode;
            } else if (sourceNode.type === 'chapter' && cIndex !== null && cIndex >= 0) {
                matchingNode = refVolumeNode.children?.[cIndex] ?? null;
                matchingParent = refVolumeNode;
            }

            if (matchingNode) {
                referenceContextHtml += `<hr><h3>参考书籍《${refBook.title}》中的匹配内容: ${matchingNode.title}</h3>`;

                if (settings.includeContent && 'content' in matchingNode && matchingNode.content) {
                    referenceContextHtml += `<h4>正文</h4>${matchingNode.content}`;
                }

                if (settings.includeVolumeInfo && matchingParent && matchingParent.type.endsWith('volume') && 'content' in matchingParent && matchingParent.content) {
                    referenceContextHtml += `<h4>所属卷信息</h4>${matchingParent.content}`;
                }

                if (settings.includePlot) {
                    const plotRoot = refBook.children?.find(c => c.id.startsWith('ref-plot-'));
                    if (plotRoot) {
                        const plotItems = _findDerivedItemsRecursive(plotRoot.children || [], matchingNode.id);
                        if (plotItems.length > 0) {
                            referenceContextHtml += `<h4>相关剧情</h4>` + plotItems.map(p => 'content' in p ? p.content : '').join('<hr>');
                        }
                    }
                }
                if (settings.includeAnalysis) {
                    const analysisRoot = refBook.children?.find(c => c.id.startsWith('ref-analysis-'));
                    if (analysisRoot) {
                        const analysisItems = _findDerivedItemsRecursive(analysisRoot.children || [], matchingNode.id);
                        if (analysisItems.length > 0) {
                            referenceContextHtml += `<h4>相关分析</h4>` + analysisItems.map(a => 'content' in a ? a.content : '').join('<hr>');
                        }
                    }
                }
            }
        }
        return referenceContextHtml;
    }

    const buildContextForTask = (task: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'>): ContextBuildResult | null => {
        const { type: taskType, sourceItemId, sourceItemTitle, sourceItemContent } = task;
        const mainContentText = stripHtml(sourceItemContent);

        let fixedContextHtml = '';
        contextSettingsStore.selectedContextItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.group} - ${item.title}</h3>${item.content}`;
        });
        contextSettingsStore.selectedOthersItems.forEach(item => {
            if (item.content) fixedContextHtml += `<hr><h3>相关${item.category}: ${item.title}</h3>${item.content}`;
        });
        if (contextSettingsStore.customContextContent.trim()) {
            fixedContextHtml += `<hr><h3>自定义固定内容</h3><p>${contextSettingsStore.customContextContent.trim().replace(/\n/g, '<br>')}</p>`;
        }
        const fixedContextText = stripHtml(fixedContextHtml);

        let dynamicContextHtml = '';
        const sourceItemResult = directoryStore.findNodeById(sourceItemId);
        if (!sourceItemResult) return null;

        const { node: sourceNode, parent: sourceParent } = sourceItemResult;

        if (sourceNode.type === 'chapter' && sourceParent) {
            dynamicContextHtml = _buildContextForChapterTask(sourceNode, sourceParent);
        } else if (sourceNode.type === 'volume') {
            dynamicContextHtml = _buildContextForVolumeTask(sourceNode);
        }
        const dynamicContextText = stripHtml(dynamicContextHtml);

        let referenceContextHtml = '';
        if ((sourceNode.type === 'chapter' && sourceParent) || sourceNode.type === 'volume') {
            const vIndex = directoryStore.directoryData.findIndex(v => v.id === (sourceParent?.id || sourceNode.id));
            const cIndex = sourceNode.type === 'chapter' && sourceParent ? sourceParent.chapters.findIndex(c => c.id === sourceNode.id) : null;
            referenceContextHtml = _buildReferenceContextHtmlByIndex(sourceNode, vIndex, cIndex, contextSettingsStore.referenceContextSettings);
        }
        const referenceContextText = stripHtml(referenceContextHtml);

        const ragContext = contextSettingsStore.isRagEnabled ? '【RAG智能检索功能已开启，将根据任务内容自动查询知识库...】' : 'RAG检索已禁用或未返回任何结果。';
        const taskConfig = aiConfigStore.taskConfigs[taskType];
        const promptNode = promptTemplateStore.findPromptById(taskConfig.selectedPromptId);
        let selectedPromptTemplate = `请为《${sourceItemTitle}》执行“${taskType}”任务。`;
        if (promptNode?.content) {
            // 使用正则表达式从<pre>标签中提取模板，更安全
            const match = promptNode.content.match(/<pre[^>]*>([\s\S]*)<\/pre>/);
            const template = match ? match[1] : selectedPromptTemplate;
            selectedPromptTemplate = template.replace(/{{sourceItemTitle}}/g, sourceItemTitle);
        }

        const prompt = `[任务提示词]
${selectedPromptTemplate}

--------
[附加上下文]

# 固定上下文
${fixedContextText.trim() || '无'}

# 动态上下文
${dynamicContextText.trim() || '无'}

# 参考书籍上下文
${referenceContextText.trim() || '无'}

# RAG检索信息
${ragContext.trim() || '无'}

# 待处理内容
${mainContentText.trim() || '无'}

--------
请严格按照任务提示词的要求开始执行：`;

        return {
            fixed: fixedContextHtml.trim(),
            dynamic: dynamicContextHtml.trim(),
            reference: referenceContextHtml.trim(),
            rag: ragContext,
            prompt: prompt,
            stats: {
                fixedCharCount: fixedContextText.trim().length,
                dynamicCharCount: dynamicContextText.trim().length,
                referenceCharCount: referenceContextText.trim().length,
                ragCharCount: ragContext.trim().length,
                promptCharCount: prompt.trim().length
            }
        };
    };

    return { buildContextForTask };
}

// =
// 文件: ..\src\novel\editor\router.ts
//

import type { RouteRecordRaw } from 'vue-router'

export const editorRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel/editor',
        component: () => import('@/novel/editor/layouts/NovelEditorLayout.vue'),
        children: [
            {
                path: '',
                name: 'NovelEditorWorkspace',
                component: () => import('@/novel/editor/views/EditorWorkspaceView.vue'),
                meta: { title: '小说编辑器' }
            }
        ]
    }
]

// =
// 文件: ..\src\novel\editor\services\ai\AITaskExecutionService.ts
//


import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore';
import { useUIStore } from '@novel/editor/stores/uiStore';
import { useContextBuilder } from '@novel/editor/composables/useContextBuilder';
import { streamAITask } from '@novel/editor/services/ai/aiService.ts';
import type { AITask } from '@/novel/editor/types';

const { buildContextForTask } = useContextBuilder();

function executeTaskAndStream(task: AITask) {
    const aiTaskStore = useAITaskStore();

    aiTaskStore.updateTaskStatus(task.id, 'processing');

    // 如果任务没有最终提示词，立即构建它
    if (!task.finalPrompt) {
        const contextResult = buildContextForTask(task);
        if (!contextResult || !contextResult.prompt) {
            aiTaskStore.updateTaskError(task.id, '上下文构建失败，无法生成最终提示词。');
            processQueue(); // 继续处理下一个任务
            return;
        }
        task.finalPrompt = contextResult.prompt;
    }

    const promptToUse = task.finalPrompt;

    streamAITask(promptToUse, task.aiConfig, task.type, task.sourceItemTitle, {
        onChunk: (chunk) => {
            aiTaskStore.appendGeneratedContent(task.id, chunk);
        },
        onComplete: () => {
            aiTaskStore.completeTask(task.id);
            processQueue(); // 完成后处理下一个
        },
        onError: (error) => {
            aiTaskStore.updateTaskError(task.id, error);
            processQueue(); // 出错后也处理下一个
        }
    });
}

/**
 * 处理任务队列。检查当前正在执行的任务数是否达到并发上限，
 * 如果没有，则从等待队列中取出任务开始执行。
 */
export function processQueue() {
    const uiStore = useUIStore();
    const aiTaskStore = useAITaskStore();

    const limit = uiStore.uiState.concurrentTaskLimit;
    const processingCount = aiTaskStore.tasks.filter(t => t.status === 'processing').length;

    if (processingCount >= limit) {
        return;
    }

    const canStartCount = limit - processingCount;
    const pendingTasks = aiTaskStore.tasks.filter(t => t.status === 'pending');

    const tasksToStart = pendingTasks.slice(0, canStartCount);

    for (const task of tasksToStart) {
        executeTaskAndStream(task);
    }
}

// =
// 文件: ..\src\novel\editor\services\ai\AITaskFactory.ts
//

import { useEditorStore } from '@novel/editor/stores/editorStore';
import { useDerivedContentStore } from '@novel/editor/stores/derivedContentStore';
import { useAIConfigStore } from '@novel/editor/stores/ai/aiConfigStore';
import type { AITask, AITaskType } from '@/novel/editor/types';

/**
 * 创建一个新的AI任务对象。
 * @param taskType AI任务的类型。
 * @param sourceItemId 源文档的ID。
 * @param finalPrompt 可选的，预先构建好的最终提示词。
 * @returns 一个结构完整的AITask对象，如果源项目无效则返回null。
 */
export async function createTask(taskType: AITaskType, sourceItemId: string, finalPrompt?: string): Promise<AITask | null> {
    const editorStore = useEditorStore();
    const derivedContentStore = useDerivedContentStore();
    const aiConfigStore = useAIConfigStore();

    const { node: sourceItem } = editorStore.findItemById(sourceItemId);
    if (!sourceItem || !('content' in sourceItem) || typeof sourceItem.content !== 'string') {
        console.error("AI Task Factory Error: Source item not found or has no content.", sourceItemId);
        return null;
    }

    // --- 核心Bug修复：版本控制 ---
    // 为源对象打上一个时间戳作为版本号
    // 如果已有，则更新它
    (sourceItem as any)._lastModified = Date.now();
    const sourceItemVersion = (sourceItem as any)._lastModified;
    // --- 核心Bug修复结束 ---

    const taskConfigSettings = aiConfigStore.taskConfigs[taskType];
    const baseAIProviderConfig = aiConfigStore.availableAIProviders.find(p => p.id === taskConfigSettings.selectedAIProviderId);

    if (!baseAIProviderConfig) {
        console.error("AI Task Factory Error: Selected AI Provider Config not found.", taskConfigSettings.selectedAIProviderId);
        alert(`未找到ID为 "${taskConfigSettings.selectedAIProviderId}" 的AI配置，请在设置中检查。`);
        return null;
    }

    const finalAIConfig = {
        ...baseAIProviderConfig,
        temperature: taskConfigSettings.temperature,
    };

    let targetItemId: string;
    let taskTitle: string;

    if (taskType === '分析' || taskType === '剧情生成') {
        const newDerivedItem = derivedContentStore.createDerivedItem(sourceItem, taskType);
        if (!newDerivedItem) {
            console.error("AI Task Factory Error: Failed to create derived item shell.");
            return null;
        }
        targetItemId = newDerivedItem.id;
        taskTitle = newDerivedItem.title;
    } else {
        targetItemId = sourceItemId;
        taskTitle = `${taskType}《${sourceItem.title}》`;
    }

    const newTask: AITask = {
        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        title: taskTitle,
        type: taskType,
        sourceItemId: sourceItemId,
        targetItemId: targetItemId,
        sourceItemTitle: sourceItem.title,
        sourceItemContent: sourceItem.content,
        sourceItemVersion: sourceItemVersion, // 存储版本快照
        status: 'pending',
        generatedContent: '',
        finalPrompt: finalPrompt,
        createdAt: new Date(),
        aiConfig: finalAIConfig,
    };

    return newTask;
}

// =
// 文件: ..\src\novel\editor\services\ai\aiService.ts
//

import { fetchApiKeys } from '../../api/apiManagementApi.ts';
import type { AIProviderConfig, AITaskType } from '@novel/editor/types';
import { streamAITask as streamAITaskFromApi } from '@novel/editor/api/chatApi';

interface StreamCallbacks {
    onChunk: (chunk: string) => void;
    onComplete: () => void;
    onError: (error: string) => void;
}

/**
 * 从系统设置中获取所有已启用的、可供编辑器使用的AI配置。
 * @returns 返回一个符合编辑器AIProviderConfig格式的数组。
 */
export async function fetchAvailableAIProviders(): Promise<AIProviderConfig[]> {
    try {
        const allKeys = await fetchApiKeys();
        const enabledKeys = allKeys.filter(key => key.status === '启用');

        return enabledKeys.map(key => ({
            id: key.id.toString(), // 将数字ID转换为字符串以匹配接口
            name: key.name,
            model: key.model,
            temperature: key.temperature,
            maxTokens: key.maxTokens,
            description: key.description,
        }));
    } catch (error) {
        console.error("Failed to fetch available AI providers from API layer:", error);
        return [];
    }
}

/**
 * 通过API层执行一个流式AI任务。
 * @param prompt - 发送给AI的最终提示词。
 * @param config - AI配置，如模型、温度等。
 * @param taskType - 任务的类型 ('润色', '续写' 等).
 * @param sourceItemTitle - 任务源文档的标题.
 * @param callbacks - 用于处理数据流、完成和错误事件的回调对象。
 */
export function streamAITask(
    prompt: string,
    config: AIProviderConfig,
    taskType: AITaskType,
    sourceItemTitle: string,
    callbacks: StreamCallbacks
): void {
    console.log(`[AI Service] Delegating task to API layer. Type: ${taskType}, Title: ${sourceItemTitle}`);
    streamAITaskFromApi(prompt, config, taskType, sourceItemTitle, callbacks);
}

// =
// 文件: ..\src\novel\editor\services\ai\chatService.ts
//

import type { Conversation, ChatMessage } from '@novel/editor/types/chatTypes.ts';
import * as chatApi from '@/novel/editor/api/chatApi';

/**
 * 从API获取所有聊天对话。
 * @returns 对话列表。
 */
export async function getConversations(): Promise<Conversation[]> {
    return await chatApi.fetchConversations();
}

/**
 * 通过API创建一个新的、空的对话对象。
 * @returns 一个新的 Conversation 对象。
 */
export async function createConversation(): Promise<Conversation> {
    return await chatApi.createConversation();
}

/**
 * 发送一条消息到API并接收AI的回复。
 * @param conversationId - 当前对话的ID
 * @param userInput - 用户输入的文本。
 * @returns 一个包含用户消息和AI回复消息的对象。
 */
export async function sendMessage(conversationId: string, userInput: string): Promise<{ userMessage: ChatMessage; aiResponse: ChatMessage }> {
    return await chatApi.sendMessage(conversationId, userInput);
}

// =
// 文件: ..\src\novel\editor\services\directoryService.ts
//

// src/novel/editor/services/directoryService.ts
import type { Volume, Chapter } from '@/novel/editor/types';

type DirectoryNode = Volume | Chapter;

function _findNodeRecursive(nodes: DirectoryNode[], nodeId: string): { node: DirectoryNode; parent: Volume | null; siblings: DirectoryNode[] } | null {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null, siblings: nodes };
        }
        if (node.type === 'volume' && node.chapters) {
            const chapterResult = node.chapters.find(c => c.id === nodeId);
            if (chapterResult) {
                return { node: chapterResult, parent: node, siblings: node.chapters };
            }
        }
    }
    return null;
}

export function findNodeById(nodes: Volume[], nodeId: string) {
    return _findNodeRecursive(nodes, nodeId);
}

export function createVolume(): Volume {
    return {
        id: `vol-${Date.now()}`,
        type: 'volume',
        title: '新建卷',
        content: `<h1>新建卷</h1>`,
        chapters: [],
    };
}

export function createChapter(): Chapter {
    return {
        id: `ch-${Date.now()}`,
        type: 'chapter',
        title: '新建章节',
        wordCount: 0,
        content: '<h1>新建章节</h1>',
        status: 'editing'
    };
}

export function updateNodeContent(node: Volume | Chapter, content: string) {
    node.content = content;

    if (node.type === 'chapter') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        node.wordCount = tempDiv.textContent?.trim().length || 0;
    }

    const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
    const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
    if (newTitle && newTitle !== node.title) {
        node.title = newTitle;
    }
}

export function appendChapterContent(chapter: Chapter, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    chapter.content += htmlToAppend;
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = chapter.content;
    chapter.wordCount = tempDiv.textContent?.trim().length || 0;
}

export function renameNode(node: DirectoryNode, newTitle: string) {
    if (!newTitle.trim()) {
        return;
    }
    const trimmedTitle = newTitle.trim();
    node.title = trimmedTitle;
    if (node.content) {
        if (node.content.includes('<h1>')) {
            node.content = node.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        } else {
            node.content = `<h1>${trimmedTitle}</h1>` + node.content;
        }
    }
}

export function deleteNode(nodes: Volume[], nodeId: string): boolean {
    const result = findNodeById(nodes, nodeId);
    if (!result) return false;

    if (result.parent && result.node.type === 'chapter') {
        const index = result.parent.chapters.findIndex(c => c.id === nodeId);
        if (index > -1) {
            result.parent.chapters.splice(index, 1);
            return true;
        }
    } else if (!result.parent && result.node.type === 'volume') {
        const index = nodes.findIndex(v => v.id === nodeId);
        if (index > -1) {
            nodes.splice(index, 1);
            return true;
        }
    }
    return false;
}

// =
// 文件: ..\src\novel\editor\services\noteService.ts
//

import type { NoteItem } from '@/novel/editor/types';

class NoteService {

    /**
     * 创建一个新的笔记对象
     * @param title - 笔记的初始标题
     * @param content - 笔记的初始内容（纯文本）
     * @returns 一个完整的 NoteItem 对象
     */
    public createNote(title: string, content: string = ''): NoteItem {
        return {
            id: `note-${Date.now()}`,
            type: 'note',
            title: title,
            content: `<h1>${title}</h1><p>${content}</p>`,
            timestamp: new Date().toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' })
        };
    }

    /**
     * 根据新的HTML内容更新笔记对象，并同步标题
     * @param note - 要更新的原始笔记对象
     * @param newContent - 新的HTML内容
     * @returns 一个被更新后的新笔记对象副本
     */
    public updateNoteWithNewContent(note: NoteItem, newContent: string): NoteItem {
        const updatedNote = { ...note, content: newContent };

        const h1Match = newContent.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : note.title;

        if (newTitle) {
            updatedNote.title = newTitle;
        }

        return updatedNote;
    }

    /**
     * 将文本内容附加到现有笔记内容的末尾
     * @param originalContent - 原始HTML内容
     * @param contentToAppend - 要附加的纯文本内容
     * @param isAutoApplied - 是否为AI自动应用，若是则添加一个标记
     * @returns 附加了新内容的完整HTML字符串
     */
    public appendContentToNote(originalContent: string, contentToAppend: string, isAutoApplied: boolean): string {
        const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
        let htmlToAppend = paragraphs;
        if (isAutoApplied) {
            htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
        }
        return (originalContent || "") + htmlToAppend;
    }

    /**
     * 根据新标题更新笔记对象，并同步内容中的<h1>标签
     * @param note - 要更新的原始笔记对象
     * @param newTitle - 新的标题
     * @returns 一个被更新后的新笔记对象副本
     */
    public renameNote(note: NoteItem, newTitle: string): NoteItem {
        const updatedNote = { ...note, title: newTitle };
        if (updatedNote.content.includes('<h1>')) {
            updatedNote.content = updatedNote.content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${newTitle}</h1>`);
        } else {
            updatedNote.content = `<h1>${newTitle}</h1>` + updatedNote.content;
        }
        return updatedNote;
    }
}

export const noteService = new NoteService();

// =
// 文件: ..\src\novel\editor\services\novelLoaderService.ts
//

import { getNovelProject, updateNovelProjectContent } from '../api/projectApi';
import { useMetadataStore } from '@/novel/editor/stores/editor-state/metadataStore';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { useNovelSettingsStore } from '@/novel/editor/stores/novelSettingsStore';
import { useAIConfigStore } from '@/novel/editor/stores/ai/aiConfigStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import { usePaneStore } from '@/novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@/novel/editor/stores/editor-state/tabStore';
import type { NovelProject } from '../types/project';

class NovelLoaderService {
    private resetAllStores() {
        useMetadataStore().$reset();
        useDirectoryStore().$reset();
        useRelatedContentStore().$reset();
        useNotesStore().$reset();
        useReferenceStore().$reset();
        useDerivedContentStore().$reset();
        useNovelSettingsStore().$reset();
        useAIConfigStore().$reset();
        usePaneStore().$reset();
        useTabStore().$reset(); // Assuming tabs are managed inside panes or have their own reset
    }

    public async loadProjectIntoEditor(novelId: string): Promise<boolean> {
        // Temporary holders for fetched data
        let projectData: NovelProject | undefined;
        let referenceTree: any[] | undefined; // Adjust type as needed

        try {
            console.log(`[Service] Fetching data for novel: ${novelId}`);

            // 1. Fetch all data into temporary variables
            projectData = await getNovelProject(novelId);
            if (!projectData) {
                throw new Error(`Novel project with ID "${novelId}" not found.`);
            }

            // Assuming referenceStore.loadReferences internally fetches data
            // To make this transactional, the fetch needs to be extracted.
            // For now, we'll proceed assuming it can fail.
            const referenceStore = useReferenceStore();
            await referenceStore.loadReferences(projectData.metadata.referenceNovelIds);

            // 2. If all fetches are successful, commit to stores
            const metadataStore = useMetadataStore();
            const directoryStore = useDirectoryStore();
            const relatedContentStore = useRelatedContentStore();
            const notesStore = useNotesStore();
            const derivedContentStore = useDerivedContentStore();
            const novelSettingsStore = useNovelSettingsStore();
            const aiConfigStore = useAIConfigStore();
            const uiStore = useUIStore();
            const paneStore = usePaneStore();
            const tabStore = useTabStore();

            metadataStore._setCurrentNovelId(novelId);
            metadataStore._setNovelMetadata(projectData.metadata);

            await aiConfigStore.initializeProviders();
            directoryStore.fetchDirectoryData(projectData.directoryData);
            relatedContentStore.fetchRelatedData(
                projectData.settingsData,
                projectData.plotCustomData,
                projectData.analysisCustomData,
                projectData.othersCustomData
            );
            derivedContentStore.fetchDerivedData(
                projectData.derivedPlotData || [],
                projectData.derivedAnalysisData || []
            );
            notesStore.fetchNotes(projectData.noteData);

            await novelSettingsStore.loadSettingsData();

            paneStore.initializePanes();
            uiStore.uiState.expandedNodeIds.clear();
            uiStore.uiState.expandedRelatedNodeIds.clear();
            uiStore.uiState.expandedReferenceNodeIds.clear();

            if (projectData.directoryData.length > 0) {
                uiStore.ensureNodeIsExpanded(projectData.directoryData[0].id);
            }
            uiStore.ensureRelatedNodeIsExpanded('setting');
            uiStore.ensureRelatedNodeIsExpanded('characters');
            uiStore.ensureRelatedNodeIsExpanded('plot');
            uiStore.ensureRelatedNodeIsExpanded('analysis');
            uiStore.ensureRelatedNodeIsExpanded('others');
            if (projectData.metadata.referenceNovelIds.length > 0) {
                const firstRefBookId = `ref-book-${projectData.metadata.referenceNovelIds[0]}`;
                uiStore.ensureReferenceNodeIsExpanded(firstRefBookId);
            }

            const firstChapterId = projectData.directoryData[0]?.chapters[0]?.id;
            if (firstChapterId) {
                tabStore.openTab(firstChapterId);
            }

            return true;
        } catch (error) {
            console.error(`[Service] Failed to load project ${novelId}:`, error);
            // 3. On failure, reset all stores to ensure clean state
            this.resetAllStores();
            return false;
        }
    }

    public async saveCurrentProject(): Promise<boolean> {
        const metadataStore = useMetadataStore();
        const novelId = metadataStore.currentNovelId;

        if (!novelId) {
            console.error("[Service] Cannot save: No current novel loaded.");
            return false;
        }

        try {
            console.log(`[Service] Saving project content for: ${novelId}`);

            const directoryStore = useDirectoryStore();
            const relatedContentStore = useRelatedContentStore();
            const derivedContentStore = useDerivedContentStore();
            const notesStore = useNotesStore();

            const projectContentToSave: Omit<NovelProject, 'metadata'> = {
                directoryData: directoryStore.directoryData,
                settingsData: relatedContentStore.settingsData,
                plotCustomData: relatedContentStore.plotCustomData,
                analysisCustomData: relatedContentStore.analysisCustomData,
                othersCustomData: relatedContentStore.othersCustomData,
                derivedPlotData: derivedContentStore.plotItems,
                derivedAnalysisData: derivedContentStore.analysisItems,
                noteData: notesStore.notes,
            };
            await updateNovelProjectContent(novelId, projectContentToSave);

            await metadataStore.saveMetadata();

            console.log(`[Service] Project ${novelId} saved successfully.`);
            return true;
        } catch (error) {
            console.error(`[Service] Failed to save project ${novelId}:`, error);
            return false;
        }
    }
}

export const projectLoaderService = new NovelLoaderService();

// =
// 文件: ..\src\novel\editor\services\novelSettingsService.ts
//

import { fetchAllNovelProjects, getNovelProject } from '../api/projectApi';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

class NovelSettingsService {

    /**
     * 根据ID数组异步获取完整的小说项目对象列表。
     * @param novelIds - 要获取的小说ID数组。
     * @returns 完整的小说项目对象数组。
     */
    public async getReferencedNovels(novelIds: string[]): Promise<NovelProject[]> {
        if (!novelIds || novelIds.length === 0) return [];

        const projects = await Promise.all(
            novelIds.map(id => getNovelProject(id))
        );

        return projects.filter((p): p is NovelProject => p !== undefined);
    }

    /**
     * 异步获取可供添加为参考书的所有其他小说项目。
     * @param novelMetadata - 当前正在编辑的小说的元数据。
     * @returns 可用的参考小说项目数组。
     */
    public async getAvailableReferenceNovels(novelMetadata: NovelMetadata | null): Promise<NovelProject[]> {
        const allNovels = await fetchAllNovelProjects();
        if (!novelMetadata) return allNovels;

        const currentAndReferencedIds = new Set([
            ...novelMetadata.referenceNovelIds,
            novelMetadata.id
        ]);

        return allNovels.filter(novel => !currentAndReferencedIds.has(novel.metadata.id));
    }
}

export const novelSettingsService = new NovelSettingsService();

// =
// 文件: ..\src\novel\editor\services\promptService.ts
//

import type { TreeNode, AITaskType } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';

const DEFAULT_PROMPTS: Record<AITaskType, { id: string, name: string, template: string }[]> = {
    '润色': [
        { id: 'prompt-polish-default', name: '默认润色', template: '你是一名专业的小说编辑，请根据上下文，对以下“待处理内容”进行润色，使其更具文采和表现力。' },
        { id: 'prompt-polish-creative', name: '增强创造性', template: '你是一名富有想象力的作家，请跳出常规，用更具创造性和独特风格的语言重写以下“待处理内容”，可以适度偏离原文。' }
    ],
    '续写': [
        { id: 'prompt-continue-default', name: '默认续写', template: '你是一名小说家，请根据所有上下文信息，紧接着“待处理内容”的结尾，自然地续写接下来的故事情节。' },
        { id: 'prompt-continue-dramatic', name: '增强戏剧性', template: '你是一名顶尖的剧本编剧，请在续写时增加戏剧性冲突或意外转折，让故事更有张力。' }
    ],
    '分析': [
        { id: 'prompt-analyze-default', name: '默认分析', template: '请作为一个文学评论家，分析以下“待处理内容”的结构、角色动态、潜在主题和写作风格。' },
        { id: 'prompt-analyze-deep', name: '深度结构分析', template: '请从叙事技巧、象征意义和读者情感引导等角度，深度剖析以下“待处理内容”，并提出改进建议。' }
    ],
    '剧情生成': [
        { id: 'prompt-plot-default', name: '默认剧情生成', template: '你是一名创意编剧，请根据“待处理内容”中描写的场景或事件，生成一段相关的、有趣的后续剧情大纲。' },
        { id: 'prompt-plot-twist', name: '生成反转剧情', template: '你是一名擅长制造悬念的编剧，请根据“待处理内容”，构思一个包含意外反转的后续剧情大纲。' }
    ],
    '创作': [
        { id: 'prompt-create-default', name: '默认创作', template: '你是一位小说家，请根据“动态上下文”（其中可能包含剧情大纲和分析）以及“固定上下文”，为标题为《{{sourceItemTitle}}》的章节创作完整的正文内容。“待处理内容”是旧版或草稿，可作为参考，但你的主要任务是生成全新的、完整的章节。' },
    ],
};

class PromptService {

    public buildInitialTree(): TreeNode[] {
        const root: TreeNode = {
            id: 'prompt-root',
            title: '提示词模板',
            type: 'prompt_root',
            icon: getIconByNodeType('prompt_root'),
            children: (Object.keys(DEFAULT_PROMPTS) as AITaskType[]).map(taskType => {
                const groupNode: TreeNode = {
                    id: `prompt-group-${taskType}`,
                    title: `${taskType}提示词`,
                    type: 'prompt_group',
                    icon: getIconByNodeType(taskType),
                    isReadOnly: true,
                    originalData: { taskType },
                    children: DEFAULT_PROMPTS[taskType].map(prompt => ({
                        id: prompt.id,
                        title: prompt.name,
                        type: 'prompt_item',
                        icon: getIconByNodeType('prompt_item'),
                        content: `<pre>${prompt.template}</pre>`,
                        originalData: { taskType },
                    }))
                };
                return groupNode;
            })
        };
        return [root];
    }
}

export const promptService = new PromptService();

// =
// 文件: ..\src\novel\editor\services\referenceService.ts
//

import type { TreeNode, ItemNode, PlotAnalysisItem, Volume, Chapter } from '@/novel/editor/types';
import type { NovelProject } from '@/novel/editor/types/project';
import { getNovelProject } from '../api/projectApi';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class ReferenceService {

    private makeNodesReadOnly(nodes: TreeNode[]): TreeNode[] {
        return nodes.map(node => {
            const newNode: TreeNode = { ...node, isReadOnly: true };
            if (newNode.children) {
                newNode.children = this.makeNodesReadOnly(newNode.children);
            }
            if (newNode.isOverview) {
                newNode.content = `<p class="overview-placeholder">参考书中所有内容均为只读。</p>`;
            }
            return newNode;
        });
    }

    private projectToTreeNode(project: NovelProject): TreeNode {
        const rootNode: TreeNode = {
            id: `ref-book-${project.metadata.id}`,
            type: 'reference_book',
            title: project.metadata.title,
            icon: getIconByNodeType('reference_book'),
            children: []
        };

        const directoryNode: TreeNode = {
            id: `ref-dir-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '目录',
            icon: 'fa-regular fa-folder-open',
            children: this.makeNodesReadOnly(project.directoryData.map((vol: Volume) => ({
                id: vol.id,
                title: vol.title,
                type: 'reference_volume',
                icon: getIconByNodeType('reference_volume'),
                content: vol.content,
                isReadOnly: true,
                children: vol.chapters.map((chap: Chapter) => ({
                    id: chap.id,
                    title: chap.title,
                    type: 'reference_chapter',
                    icon: getIconByNodeType('reference_chapter'),
                    content: chap.content,
                    isReadOnly: true
                }))
            })))
        };
        rootNode.children?.push(directoryNode);

        const buildRefDerivedContentTree = (type: 'plot' | 'analysis', dataArray: PlotAnalysisItem[] | undefined, directory: Volume[]): TreeNode[] => {
            if (!dataArray || dataArray.length === 0) return [];

            return directory.map((volume: Volume) => {
                const derivedForVolume = dataArray
                    .filter((item: PlotAnalysisItem) => item.sourceId === volume.id)
                    .map((item: PlotAnalysisItem) => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        content: item.content,
                        originalData: item
                    }));

                const derivedForChapters = volume.chapters
                    .map((chapter: Chapter) => {
                        const itemsForChapter = dataArray.filter((item: PlotAnalysisItem) => item.sourceId === chapter.id);
                        if (itemsForChapter.length === 0) return null;

                        return {
                            id: `ref-derived-group-${type}-${chapter.id}`,
                            title: chapter.title,
                            type: 'group',
                            icon: getIconByNodeType('chapter'),
                            children: itemsForChapter.map((item: PlotAnalysisItem) => ({
                                id: item.id,
                                title: item.title,
                                type: `${type}_item` as ItemNode['type'],
                                icon: getIconByNodeType(`${type}_item`),
                                content: item.content,
                                originalData: item
                            }))
                        };
                    })
                    .filter((c: TreeNode | null): c is TreeNode => c !== null);

                if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
                    return null;
                }

                return {
                    id: `ref-derived-group-${type}-${volume.id}`,
                    title: volume.title,
                    type: 'group',
                    icon: getIconByNodeType('volume'),
                    children: [
                        ...derivedForVolume,
                        ...derivedForChapters
                    ]
                };
            }).filter((v: TreeNode | null): v is TreeNode => v !== null);
        };

        const plotTree = buildRefDerivedContentTree('plot', project.derivedPlotData, project.directoryData);
        const plotNode: TreeNode = {
            id: `ref-plot-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '剧情',
            icon: getIconByNodeType('plot'),
            children: this.makeNodesReadOnly([
                ...project.plotCustomData,
                ...plotTree
            ])
        };
        if (plotNode.children && plotNode.children.length > 0) {
            rootNode.children?.push(plotNode);
        }

        const analysisTree = buildRefDerivedContentTree('analysis', project.derivedAnalysisData, project.directoryData);
        const analysisNode: TreeNode = {
            id: `ref-analysis-${project.metadata.id}`,
            type: 'reference_content_item',
            title: '分析',
            icon: getIconByNodeType('analysis'),
            children: this.makeNodesReadOnly([
                ...project.analysisCustomData,
                ...analysisTree
            ])
        };
        if (analysisNode.children && analysisNode.children.length > 0) {
            rootNode.children?.push(analysisNode);
        }

        const settingsRoot = project.settingsData.find(n => n.id === 'setting');
        if (settingsRoot && settingsRoot.children) {
            const settingsNode: TreeNode = {
                id: `ref-settings-${project.metadata.id}`,
                type: 'reference_content_item',
                title: settingsRoot.title,
                icon: getIconByNodeType('setting'),
                children: this.makeNodesReadOnly(settingsRoot.children)
            };
            rootNode.children?.push(settingsNode);
        }

        return rootNode;
    }

    public async buildReferenceTree(referenceNovelIds: string[]): Promise<TreeNode[]> {
        if (!referenceNovelIds || referenceNovelIds.length === 0) {
            return [];
        }

        const projects = await Promise.all(
            referenceNovelIds.map(id => getNovelProject(id))
        );

        const validProjects = projects.filter((p): p is NovelProject => p !== undefined);

        return validProjects.map(project => this.projectToTreeNode(project));
    }
}

export const referenceService = new ReferenceService();

// =
// 文件: ..\src\novel\editor\services\related\nodeOperationService.ts
//

// src/novel/editor/services/related/nodeOperationService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, ItemNode, GroupNode } from '@novel/editor/types';

// Private helper function
const _findNodeInTreeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeInTreeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

// Private helper function
const _findAndRemoveNodeInTree = (nodes: TreeNode[], nodeId: string): boolean => {
    for (let i = 0; i < nodes.length; i++) {
        if (nodes[i].id === nodeId) {
            nodes.splice(i, 1);
            return true;
        }
        if (nodes[i].children && _findAndRemoveNodeInTree(nodes[i].children, nodeId)) {
            return true;
        }
    }
    return false;
};

export function findNodeById(nodeId: string, allDataSources: TreeNode[][]): { node: TreeNode; parent: TreeNode | null; } | null {
    for (const source of allDataSources) {
        const result = _findNodeInTreeRecursive(source, nodeId);
        if (result) return result;
    }
    return null;
}

export function createRelatedNode(parentNode: GroupNode, type: 'group' | 'item'): GroupNode | ItemNode {
    const itemTypePrefix = parentNode.id.endsWith('s') ? parentNode.id.slice(0, -1) : parentNode.id;
    const newNodeType = type === 'group' ? 'group' : `${itemTypePrefix}_item`;
    const newNodeIcon = getIconByNodeType(newNodeType);

    if (type === 'group') {
        const newNode: GroupNode = {
            id: `group-${Date.now()}`,
            title: '新建分组',
            type: 'group',
            icon: newNodeIcon,
            children: [],
        };
        return newNode;
    } else { // type === 'item'
        const newNode: ItemNode = {
            id: `item-${Date.now()}`,
            title: '新建条目',
            type: newNodeType as ItemNode['type'],
            icon: newNodeIcon,
            content: '<h1>新建条目</h1><p>请在此处填写内容...</p>',
        };
        return newNode;
    }
}

export function createCustomNode(type: 'plot' | 'analysis' | 'others'): ItemNode {
    const itemType = type === 'others' ? 'others_item' : `${type}_item`;
    const icon = getIconByNodeType(itemType);
    const title = type === 'others' ? '新建其他条目' : '新建自定义条目';

    const newNode: ItemNode = {
        id: `custom-${type}-${Date.now()}`,
        title: title,
        type: itemType as ItemNode['type'],
        icon: icon,
        content: `<h1>${title}</h1><p>请在此处填写内容...</p>`,
    };
    return newNode;
}

export function deleteNode(nodeId: string, allDataSources: TreeNode[][]): boolean {
    for (const source of allDataSources) {
        if (_findAndRemoveNodeInTree(source, nodeId)) {
            return true;
        }
    }
    return false;
}

export function renameNode(node: TreeNode, newTitle: string) {
    if (node && !node.isReadOnly && newTitle.trim()) {
        const trimmedTitle = newTitle.trim();
        node.title = trimmedTitle;
        if ('content' in node && node.content && node.content.includes('<h1>')) {
            (node as ItemNode).content = (node as ItemNode).content.replace(/<h1[^>]*>.*?<\/h1>/, `<h1>${trimmedTitle}</h1>`);
        }
    }
}

export function updateNodeContent(node: ItemNode, content: string) {
    node.content = content;
    if (!node.isReadOnly) {
        const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/);
        const newTitle = h1Match ? h1Match[1].replace(/<[^>]+>/g, '').trim() : '';
        if (newTitle && newTitle !== node.title) {
            node.title = newTitle;
        }
    }
}

export function appendNodeContent(node: ItemNode, contentToAppend: string, isAutoApplied: boolean) {
    const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
    let htmlToAppend = paragraphs;
    if (isAutoApplied) {
        htmlToAppend += `<p style="font-size:0.8em; color: #9ca3af; text-align:center; margin: 1.5em 0;">--- AI生成内容已应用 ---</p>`;
    }
    if (!node.content) node.content = "";
    node.content += htmlToAppend;
}

// =
// 文件: ..\src\novel\editor\services\related\overviewService.ts
//


import type { TreeNode, GroupNode, ItemNode, OverviewNode } from '@novel/editor/types';

/**
 * 辅助函数，用于降低内容中标题的级别 (e.g., h1 -> h2)
 * @param htmlContent - HTML 字符串
 * @returns 降级后的 HTML 字符串
 */
const demoteHeadings = (htmlContent: string): string => {
    if (typeof document === 'undefined') return htmlContent; // Guard for SSR
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5');
    headings.forEach(heading => {
        const level = parseInt(heading.tagName.charAt(1), 10);
        const newLevel = Math.min(6, level + 1); // 最多降到 h6
        const newHeading = document.createElement(`h${newLevel}`);
        newHeading.innerHTML = heading.innerHTML;
        for (const attr of heading.attributes) {
            newHeading.setAttribute(attr.name, attr.value);
        }
        heading.parentNode?.replaceChild(newHeading, heading);
    });
    return tempDiv.innerHTML;
};


/**
 * 更新单个分组节点下的总览内容。
 * @param groupNode - 包含总览节点的父分组节点。
 */
function updateOverviewContentForGroup(groupNode: GroupNode) {
    if (!groupNode.children) return;

    const overviewNode = groupNode.children.find(child => child.isOverview) as OverviewNode | undefined;
    if (!overviewNode) return;

    const itemsToSummarize = groupNode.children.filter(child => child.type.endsWith('_item') && !child.isOverview) as ItemNode[];

    const itemContents = itemsToSummarize.map(item => item.content ? demoteHeadings(item.content) : '').filter(Boolean);

    overviewNode.content = `<h1>${overviewNode.title}</h1>` + (itemContents.length > 0 ? itemContents.join('<hr>') : `<p class="overview-placeholder">此分类下暂无内容，请添加条目。</p>`);
}

/**
 * 遍历整个设定树，更新所有找到的总览节点。
 * @param settingsData - 设定的树形数据 (可直接修改)
 */
export function updateAllOverviewContent(settingsData: TreeNode[]) {
    const findAndProcess = (nodes: TreeNode[]) => {
        for (const node of nodes) {
            if (node.type === 'group' && node.children?.some(c => c.isOverview)) {
                updateOverviewContentForGroup(node as GroupNode);
            }
            if (node.children) {
                findAndProcess(node.children);
            }
        }
    };
    findAndProcess(settingsData);
}

// =
// 文件: ..\src\novel\editor\services\related\treeBuilderService.ts
//

// src/novel/editor/services/related/treeBuilderService.ts
import { getIconByNodeType } from '@novel/editor/utils/iconUtils.ts';
import type { TreeNode, RootNode, PlotAnalysisItem, ItemNode, Volume } from '@novel/editor/types';

function buildDerivedContentTree(
    type: 'plot' | 'analysis',
    dataArray: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    return directoryData.map(volume => {
        const derivedForVolume = dataArray
            .filter(item => item.sourceId === volume.id)
            .map(item => ({
                id: item.id,
                title: item.title,
                type: `${type}_item` as ItemNode['type'],
                icon: getIconByNodeType(`${type}_item`),
                originalData: item,
                content: item.content
            }));

        const derivedForChapters = volume.chapters
            .map(chapter => {
                const derivedForChapter = dataArray.filter(item => item.sourceId === chapter.id);
                if (derivedForChapter.length === 0) return null;

                return {
                    id: `${type}_ch_group_${chapter.id}`,
                    title: chapter.title,
                    type: 'group',
                    icon: getIconByNodeType('chapter'),
                    isReadOnly: true,
                    children: derivedForChapter.map(item => ({
                        id: item.id,
                        title: item.title,
                        type: `${type}_item` as ItemNode['type'],
                        icon: getIconByNodeType(`${type}_item`),
                        originalData: item,
                        content: item.content
                    }))
                };
            })
            .filter((c): c is TreeNode => c !== null);

        if (derivedForVolume.length === 0 && derivedForChapters.length === 0) {
            return null;
        }

        return {
            id: `${type}_vol_group_${volume.id}`,
            title: volume.title,
            type: 'group',
            icon: getIconByNodeType('volume'),
            isReadOnly: true,
            children: [
                ...derivedForVolume,
                ...derivedForChapters
            ]
        };
    }).filter((v): v is TreeNode => v !== null);
}

/**
 * 构建完整的 "相关内容" 侧边栏树。
 */
export function buildRelatedTree(
    settingsData: TreeNode[],
    plotCustomData: TreeNode[],
    analysisCustomData: TreeNode[],
    othersCustomData: TreeNode[],
    promptTree: TreeNode[],
    plotItems: PlotAnalysisItem[],
    analysisItems: PlotAnalysisItem[],
    directoryData: Volume[]
): TreeNode[] {
    const plotDerivedTree = buildDerivedContentTree('plot', plotItems, directoryData);
    const analysisDerivedTree = buildDerivedContentTree('analysis', analysisItems, directoryData);

    const plotTree: RootNode = {
        id: 'plot', title: '剧情', type: 'root', icon: getIconByNodeType('plot'),
        children: [
            ...plotCustomData,
            ...plotDerivedTree
        ]
    };

    const analysisTree: RootNode = {
        id: 'analysis', title: '分析', type: 'root', icon: getIconByNodeType('analysis'),
        children: [
            ...analysisCustomData,
            ...analysisDerivedTree
        ]
    };

    const othersTree: RootNode = {
        id: 'others', title: '其他', type: 'root', icon: getIconByNodeType('others'),
        children: [
            ...promptTree,
            ...othersCustomData
        ]
    };

    return [...settingsData, plotTree, analysisTree, othersTree];
}

// =
// 文件: ..\src\novel\editor\services\searchService.ts
//

import type { SearchResult, EditorItem, TreeNode } from '@/novel/editor/types';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useRelatedContentStore } from '@/novel/editor/stores/relatedContentStore';
import { useNotesStore } from '@/novel/editor/stores/notesStore';
import { useReferenceStore } from '@/novel/editor/stores/referenceStore';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

class SearchService {
    private get directoryStore() { return useDirectoryStore(); }
    private get relatedContentStore() { return useRelatedContentStore(); }
    private get notesStore() { return useNotesStore(); }
    private get referenceStore() { return useReferenceStore(); }

    public search(query: string): SearchResult[] {
        if (!query || query.trim().length < 1) {
            return [];
        }

        const lowerCaseQuery = query.toLowerCase();
        const resultsMap = new Map<string, SearchResult>();
        const tempDiv = document.createElement('div');

        const processItem = (item: EditorItem) => {
            if (item.type === 'system' || !('content' in item) || !item.content) return;

            tempDiv.innerHTML = item.content;
            const textContent = tempDiv.textContent || '';
            const lowerCaseText = textContent.toLowerCase();

            // 1. 检查标题是否匹配
            const titleMatch = item.title.toLowerCase().includes(lowerCaseQuery);

            // 2. 检查内容是否匹配
            let contentMatches = false;
            const regex = new RegExp(`(.{0,30})(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(.{0,30})`, 'gi');
            let match;
            const matchesForThisItem: { context: string }[] = [];

            while ((match = regex.exec(textContent)) !== null) {
                contentMatches = true;
                if (matchesForThisItem.length < 5) { // Limit matches per item
                    const context = `${match[1]}<mark>${match[2]}</mark>${match[3]}`;
                    matchesForThisItem.push({ context: `...${context}...` });
                } else {
                    break;
                }
            }

            // 如果标题或内容任一匹配，则加入结果列表
            if(titleMatch || contentMatches){
                if (!resultsMap.has(item.id)) {
                    resultsMap.set(item.id, {
                        id: item.id,
                        title: item.title,
                        icon: getIconByNodeType(item.type),
                        item: item,
                        matches: []
                    });
                }
                const result = resultsMap.get(item.id)!;

                // 如果是因为内容匹配，添加匹配片段
                if(contentMatches){
                    result.matches.push(...matchesForThisItem);
                }
                // 如果只是标题匹配，可以添加一个特殊的 "match" 来注明
                else if (titleMatch) {
                    result.matches.push({ context: `<span class="italic text-gray-500">标题匹配</span>` });
                }
            }
        };

        // 遍历所有数据源
        this.directoryStore.directoryData.forEach(vol => {
            processItem(vol);
            vol.chapters.forEach(processItem);
        });

        const flattenAndProcess = (nodes: TreeNode[]) => {
            nodes.forEach(node => {
                if ('content' in node && node.content) {
                    processItem(node as EditorItem);
                }
                if (node.children) flattenAndProcess(node.children);
            });
        };

        flattenAndProcess(this.relatedContentStore.relatedData);
        flattenAndProcess(this.referenceStore.referenceData);

        this.notesStore.notes.forEach(processItem);

        return Array.from(resultsMap.values());
    }
}

export const searchService = new SearchService();

// =
// 文件: ..\src\novel\editor\stores\ai\aiConfigStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { AITaskType, AIProviderConfig } from '@novel/editor/types';
import { fetchAvailableAIProviders } from '@novel/editor/services/ai/aiService.ts';

// 定义每种任务类型默认选中的提示词ID
const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

// 定义任务配置的接口
interface TaskConfig {
    selectedPromptId: string;
    selectedAIProviderId: string;
    temperature: number;
}

export const useAIConfigStore = defineStore('aiConfig', () => {
    // State: 外部AI配置列表
    const availableAIProviders = ref<AIProviderConfig[]>([]);

    // State: 每种任务类型的具体配置，现在包含温度
    const taskConfigs = ref<Record<AITaskType, TaskConfig>>({
        '润色': { selectedPromptId: defaultSelectedPromptIds['润色'], selectedAIProviderId: '', temperature: 0.7 },
        '续写': { selectedPromptId: defaultSelectedPromptIds['续写'], selectedAIProviderId: '', temperature: 0.8 },
        '分析': { selectedPromptId: defaultSelectedPromptIds['分析'], selectedAIProviderId: '', temperature: 0.5 },
        '剧情生成': { selectedPromptId: defaultSelectedPromptIds['剧情生成'], selectedAIProviderId: '', temperature: 0.9 },
        '创作': { selectedPromptId: defaultSelectedPromptIds['创作'], selectedAIProviderId: '', temperature: 0.7 },
    });

    /**
     * 从系统设置中加载用户配置的 AI 提供商
     */
    async function initializeProviders() {
        if(availableAIProviders.value.length > 0) return;

        availableAIProviders.value = await fetchAvailableAIProviders();

        const firstAvailableProviderId = availableAIProviders.value[0]?.id || '';
        for (const taskType in taskConfigs.value) {
            const config = taskConfigs.value[taskType as AITaskType];
            const isCurrentProviderAvailable = availableAIProviders.value.some(p => p.id === config.selectedAIProviderId);
            if (!isCurrentProviderAvailable) {
                config.selectedAIProviderId = firstAvailableProviderId;
            }
        }
    }

    /**
     * 更新指定任务类型选择的提示词ID
     */
    const setSelectedPromptId = (taskType: AITaskType, promptId: string) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].selectedPromptId = promptId;
        }
    };

    /**
     * 更新指定任务类型选择的AI Provider ID
     */
    const setSelectedAIProviderId = (taskType: AITaskType, providerId: string) => {
        if (taskConfigs.value[taskType] && availableAIProviders.value.some(p => p.id === providerId)) {
            taskConfigs.value[taskType].selectedAIProviderId = providerId;
        }
    };

    /**
     * 更新指定任务类型的创作温度
     */
    const setTaskTemperature = (taskType: AITaskType, temperature: number) => {
        if (taskConfigs.value[taskType]) {
            taskConfigs.value[taskType].temperature = Number(temperature.toFixed(2));
        }
    }

    return {
        taskConfigs,
        availableAIProviders,
        initializeProviders,
        setSelectedPromptId,
        setSelectedAIProviderId,
        setTaskTemperature,
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\aiTaskStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, nextTick } from 'vue';
import { useEditorStore } from '../editorStore';
import { useUIStore } from '../uiStore';
import { useDerivedContentStore } from '../derivedContentStore';
import * as AITaskFactory from '@/novel/editor/services/ai/AITaskFactory';
import { processQueue } from '@/novel/editor/services/ai/AITaskExecutionService';
import type { AITask, Volume, AITaskType, AITaskStatus } from '@novel/editor/types';

const formatContentForEditor = (title: string, rawContent: string): string => {
    const body = rawContent.split('\n').filter(p => p.trim() !== '').map(p => `<p>${p}</p>`).join('');
    return `<h1>${title}</h1>${body}`;
};

export const useAITaskStore = defineStore('aiTask', () => {
    const tasks = ref<AITask[]>([]);
    const editorStore = useEditorStore();
    const uiStore = useUIStore();
    const derivedContentStore = useDerivedContentStore();

    const activeTasksCount = computed(() => {
        return tasks.value.filter(t => t.status === 'processing' || t.status === 'pending').length;
    });

    // --- State Mutation Actions ---
    const updateTaskStatus = (taskId: string, status: AITaskStatus) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = status;
        }
    };

    const updateTaskError = (taskId: string, error: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task) {
            task.status = 'failed';
            task.error = error;
        }
    };

    const appendGeneratedContent = (taskId: string, chunk: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.generatedContent += chunk;
        }
    };

    // --- Complex Actions ---
    const startTask = async (taskType: AITaskType, sourceItemId: string, finalPrompt?: string) => {
        const newTask = await AITaskFactory.createTask(taskType, sourceItemId, finalPrompt);
        if (!newTask) return;

        if (newTask.type === '分析' || newTask.type === '剧情生成') {
            await nextTick();
            editorStore.openTab(newTask.targetItemId);
        }

        tasks.value.unshift(newTask);

        if (uiStore.uiState.autoOpenAIPanel && editorStore.activePaneId) {
            editorStore.ensureAIPanelIsOpen(editorStore.activePaneId);
        }
        nextTick(processQueue);
    };

    const startBatchTaskForVolume = (taskType: AITaskType, volume: Volume) => {
        if (!volume || !volume.chapters) return;
        volume.chapters.forEach(chapter => {
            startTask(taskType, chapter.id, undefined);
        });
    };

    const completeTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && task.status === 'processing') {
            task.status = 'completed';

            const strategy = uiStore.uiState.taskApplicationStrategy;
            if (strategy.mode === 'auto') {
                applyChanges(taskId, true);
            } else if (strategy.mode === 'delayed') {
                task.applyAt = Date.now() + strategy.delaySeconds * 1000;
                setTimeout(() => {
                    const taskAfterDelay = tasks.value.find(t => t.id === taskId);
                    if (taskAfterDelay?.status === 'completed') {
                        applyChanges(taskId, true);
                    }
                }, strategy.delaySeconds * 1000);
            }
        }
    };

    const applyChanges = (taskId: string, isAutoApplied: boolean = false) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (!task || (task.status !== 'completed' && task.status !== 'completed_with_conflict')) return;

        const { node: targetItem } = editorStore.findItemById(task.targetItemId);
        if (!targetItem) {
            task.status = 'failed';
            task.error = '目标文档不存在。';
            return;
        }

        // --- 核心Bug修复：版本冲突检查 ---
        const currentVersion = (targetItem as any)._lastModified || 0;
        if (task.sourceItemVersion < currentVersion) {
            task.status = 'completed_with_conflict';
            task.error = `内容已被修改，AI结果无法自动应用。请手动处理。`;
            console.warn(`AI Task Conflict: Task for "${task.sourceItemTitle}" cannot be applied automatically. Task version: ${task.sourceItemVersion}, Current version: ${currentVersion}`);
            return;
        }
        // --- 核心Bug修复结束 ---

        if (task.type === '分析' || task.type === '剧情生成') {
            const finalTitle = task.title.split(' - ')[0];
            const newContent = formatContentForEditor(finalTitle, task.generatedContent);
            editorStore.updateItemContentById(task.targetItemId, newContent, true); // Pass true to update version
            const result = derivedContentStore.findItemById(task.targetItemId);
            if (result) result.title = finalTitle;
        } else {
            editorStore.appendContentToItem(task.targetItemId, task.generatedContent, isAutoApplied);
        }

        task.status = 'applied';
    };

    const retryTask = (taskId: string) => {
        const task = tasks.value.find(t => t.id === taskId);
        if (task && (task.status === 'failed' || task.status === 'completed_with_conflict')) {
            // Re-create the task to get fresh content and a new version stamp
            startTask(task.type, task.sourceItemId, task.finalPrompt);
            // Remove the old, failed task
            tasks.value = tasks.value.filter(t => t.id !== taskId);
        }
    };

    const clearCompletedTasks = () => {
        tasks.value = tasks.value.filter(t => !['applied', 'failed', 'completed_with_conflict'].includes(t.status));
    };

    const clearAllTasks = () => {
        tasks.value = [];
    };

    return {
        tasks,
        activeTasksCount,
        startTask,
        startBatchTaskForVolume,
        applyChanges,
        retryTask,
        clearCompletedTasks,
        clearAllTasks,
        updateTaskStatus,
        updateTaskError,
        appendGeneratedContent,
        completeTask
    };
});

// =
// 文件: ..\src\novel\editor\stores\ai\chatStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Conversation, AIModel } from '@novel/editor/types/chatTypes';
import * as chatService from '@/novel/editor/services/ai/chatService';

export const useChatStore = defineStore('editorChat', () => {
    // --- State ---
    const conversations = ref<Conversation[]>([]);
    const activeConversationId = ref<string | null>(null);
    const currentModel = ref<AIModel>({ id: 'gpt-4o', name: 'GPT-4o', status: 'online' });
    const messageInput = ref<string>('');
    const isReceiving = ref<boolean>(false);
    const isLoading = ref<boolean>(false);

    // --- Getters (Computed) ---
    const activeConversation = computed(() => {
        if (!activeConversationId.value) return null;
        return conversations.value.find(c => c.id === activeConversationId.value) ?? null;
    });

    const currentTokenCount = computed(() => {
        if (!activeConversation.value) return 0;
        return activeConversation.value.messages.reduce((acc, msg) => acc + msg.content.length, 0);
    });

    // --- Actions ---
    const fetchConversations = async () => {
        isLoading.value = true;
        try {
            conversations.value = await chatService.getConversations();
            if (conversations.value.length > 0 && !activeConversationId.value) {
                activeConversationId.value = conversations.value[0].id;
            }
        } catch (error) {
            console.error("Failed to fetch conversations:", error);
            conversations.value = [];
        } finally {
            isLoading.value = false;
        }
    };

    const createNewConversation = async () => {
        try {
            const newConv = await chatService.createConversation();
            conversations.value.unshift(newConv);
            activeConversationId.value = newConv.id;
        } catch (error) {
            console.error("Failed to create new conversation:", error);
        }
    };

    const selectConversation = (conversationId: string) => {
        activeConversationId.value = conversationId;
    };

    const sendMessage = async () => {
        const userInput = messageInput.value.trim();
        if (!userInput || !activeConversation.value || isReceiving.value) {
            return;
        }

        const currentActiveConv = activeConversation.value;
        const conversationId = currentActiveConv.id;
        messageInput.value = '';
        isReceiving.value = true;

        try {
            const { userMessage, aiResponse } = await chatService.sendMessage(conversationId, userInput);
            if (activeConversation.value?.id === conversationId) {
                currentActiveConv.messages.push(userMessage);
                currentActiveConv.messages.push(aiResponse);
            }
        } catch (error) {
            console.error("Failed to send message:", error);
        } finally {
            isReceiving.value = false;
        }
    };

    return {
        conversations,
        activeConversationId,
        currentModel,
        messageInput,
        isReceiving,
        isLoading,
        activeConversation,
        currentTokenCount,
        fetchConversations,
        createNewConversation,
        selectConversation,
        sendMessage,
    };
});

// =
// 文件: ..\src\novel\editor\stores\contextPreviewStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useAITaskStore } from '@novel/editor/stores/ai/aiTaskStore.ts';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import type { AITask, AITaskPreview, ContextBuildResult} from '@/novel/editor/types';
import { useContextBuilder } from '@/novel/editor/composables/useContextBuilder';

export const useContextPreviewStore = defineStore('contextPreview', () => {
    const isVisible = ref(false);
    const task = ref<AITaskPreview | null>(null);
    const isLoading = ref(false);
    const previewContent = ref<ContextBuildResult | null>(null);

    const editorStore = useEditorStore();
    const { buildContextForTask } = useContextBuilder();

    const show = async (previewTask: AITaskPreview) => {
        task.value = previewTask;
        isVisible.value = true;
        isLoading.value = true;
        previewContent.value = null; // Reset previous content

        // Short delay for UI to mount
        await new Promise(res => setTimeout(res, 50));

        // Delegate context building to the context builder composable
        const { node: targetItem } = editorStore.findItemById(previewTask.targetItemId);

        if (targetItem && 'content' in targetItem && typeof targetItem.content === 'string') {
            // Create a temporary task-like object (snapshot) for the context builder
            const taskSnapshot: Pick<AITask, 'type' | 'sourceItemId' | 'sourceItemTitle' | 'sourceItemContent'> = {
                type: previewTask.type,
                sourceItemId: previewTask.targetItemId,
                sourceItemTitle: previewTask.title,
                sourceItemContent: targetItem.content, // Use the live content from the editor
            };
            previewContent.value = buildContextForTask(taskSnapshot);
        } else {
            console.error('Context Preview Error: Could not find target item or item has no content.', previewTask.targetItemId);
            // Handle the error state in the UI
            previewContent.value = {
                fixed: '', dynamic: '', reference: '', rag: '', prompt: '错误：无法加载上下文。目标文档不存在或无内容。',
                stats: { fixedCharCount: 0, dynamicCharCount: 0, referenceCharCount: 0, ragCharCount: 0, promptCharCount: 0 }
            };
        }

        // Short delay to show loading state
        await new Promise(res => setTimeout(res, 200));
        isLoading.value = false;
    };

    const hide = () => {
        isVisible.value = false;
        task.value = null;
        isLoading.value = false;
        previewContent.value = null;
    };

    const execute = () => {
        if (!task.value || isLoading.value || !previewContent.value?.prompt) return;

        const aiTaskStore = useAITaskStore();
        // 将预览时生成的最终提示词，在开始任务时一并传递过去
        aiTaskStore.startTask(task.value.type, task.value.targetItemId, previewContent.value.prompt);
        hide();
    };

    return { isVisible, task, previewContent, isLoading, show, hide, execute };
});

// =
// 文件: ..\src\novel\editor\stores\contextSettingsStore.ts
//

// 文件: src/novel/editor/stores/contextSettingsStore.ts

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { ContextItem, TreeNode, DynamicContextSettings, ReferenceContextSettings } from '@/novel/editor/types';
import { useRelatedContentStore } from './relatedContentStore';

const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html;
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
}

export const useContextSettingsStore = defineStore('contextSettings', () => {
    const needsPreview = ref(true);
    const selectedContextItems = ref<ContextItem[]>([]);
    const selectedOthersItems = ref<ContextItem[]>([]);
    const customContextContent = ref('');
    const dynamicContextSettings = ref<DynamicContextSettings>({
        prevVolumes: 0,
        nextVolumes: 0,
        prevChapters: 1,
        nextChapters: 0,
        includeVolumePlot: false,
        includeVolumeAnalysis: false,
        includeRelatedPlot: true,
        includeRelatedAnalysis: true,
    });
    const referenceContextSettings = ref<ReferenceContextSettings>({
        includeContent: true,
        includeAnalysis: false,
        includePlot: false,
        includeVolumeInfo: false,
    });
    const isRagEnabled = ref(false);

    const fixedContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode, group: string) => {
            if (node.type.endsWith('_item') && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '设定',
                    group,
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child, node.id === 'setting' ? child.title : group));
            }
        };

        if (relatedStore.settingsData.length > 0) {
            relatedStore.settingsData.forEach(rootNode => processNode(rootNode, '设定'));
        }
        return presets;
    });

    const othersContextPresets = computed((): ContextItem[] => {
        const relatedStore = useRelatedContentStore();
        const presets: ContextItem[] = [];

        const processNode = (node: TreeNode) => {
            if (node.type === 'others_item' && 'content' in node && node.content) {
                presets.push({
                    id: node.id,
                    category: '其他',
                    group: '其他',
                    title: node.title,
                    description: stripHtml(node.content).substring(0, 100) + '...',
                    content: node.content,
                });
            }
            if (node.children) {
                node.children.forEach(child => processNode(child));
            }
        };

        const othersRoot = relatedStore.relatedData.find(n => n.id === 'others');
        if (othersRoot && othersRoot.children) {
            processNode(othersRoot);
        }

        return presets;
    });

    const addFixedContextItem = (item: ContextItem) => {
        if (!selectedContextItems.value.some(i => i.id === item.id)) {
            selectedContextItems.value.push(item);
        }
    };

    const removeFixedContextItem = (id: string) => {
        selectedContextItems.value = selectedContextItems.value.filter(i => i.id !== id);
    };

    const addOthersContextItem = (item: ContextItem) => {
        if (!selectedOthersItems.value.some(i => i.id === item.id)) {
            selectedOthersItems.value.push(item);
        }
    };

    const removeOthersContextItem = (id: string) => {
        selectedOthersItems.value = selectedOthersItems.value.filter(i => i.id !== id);
    };

    const setCustomContextContent = (content: string) => {
        customContextContent.value = content;
    };

    const setDynamicContextSetting = (key: keyof DynamicContextSettings, value: number | boolean) => {
        if (key in dynamicContextSettings.value) {
            dynamicContextSettings.value[key] = value as never;
        }
    };

    const setReferenceContextSetting = (key: keyof ReferenceContextSettings, value: boolean) => {
        if (key in referenceContextSettings.value) {
            referenceContextSettings.value[key] = value as never;
        }
    };

    return {
        needsPreview,
        fixedContextPresets,
        othersContextPresets,
        selectedContextItems,
        selectedOthersItems,
        customContextContent,
        dynamicContextSettings,
        referenceContextSettings,
        isRagEnabled,
        addFixedContextItem,
        removeFixedContextItem,
        addOthersContextItem,
        removeOthersContextItem,
        setCustomContextContent,
        setDynamicContextSetting,
        setReferenceContextSetting,
    };
});

// =
// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
//

// 文件: ..\src\novel\editor\stores\derivedContentStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { PlotAnalysisItem, AITaskType, EditorItem } from '@/novel/editor/types';

export const useDerivedContentStore = defineStore('derivedContent', () => {
    const plotItems = ref<PlotAnalysisItem[]>([]);
    const analysisItems = ref<PlotAnalysisItem[]>([]);

    /**
     * 从项目数据中获取派生内容。
     * @param plotData - 项目中存储的剧情数据
     * @param analysisData - 项目中存储的分析数据
     */
    function fetchDerivedData(plotData: PlotAnalysisItem[], analysisData: PlotAnalysisItem[]) {
        plotItems.value = plotData;
        analysisItems.value = analysisData;
    }

    /**
     * 为指定源（章节或卷）创建一个新的派生内容项（占位符）。
     * @param sourceNode - 源节点对象 (章节或卷)
     * @param taskType - 任务类型 ('分析' 或 '剧情生成')
     * @returns 新创建的派生内容项
     */
    function createDerivedItem(sourceNode: EditorItem, taskType: AITaskType): PlotAnalysisItem | null {
        if (taskType !== '分析' && taskType !== '剧情生成') return null;
        if (sourceNode.type !== 'chapter' && sourceNode.type !== 'volume') return null;


        const now = new Date();
        const timestamp = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

        const derivedType: PlotAnalysisItem['type'] = taskType === '分析' ? 'analysis' : 'plot';
        const titleSuffix = taskType;
        const titlePrefix = sourceNode.type === 'volume' ? '卷' : '';

        const newItem: PlotAnalysisItem = {
            id: `${derivedType}_${now.getTime()}`, // 使用时间戳保证ID唯一
            type: derivedType,
            sourceId: sourceNode.id,
            title: `《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}`,
            content: `<h1>《${titlePrefix}${sourceNode.title}》${titleSuffix} - ${timestamp}</h1><p>AI正在生成内容，请稍候...</p>`
        };

        if (derivedType === 'analysis') {
            analysisItems.value.unshift(newItem);
        } else {
            plotItems.value.unshift(newItem);
        }

        return newItem;
    }

    /**
     * 根据ID从所有派生项中查找。
     * @param nodeId - 派生内容的ID
     */
    function findItemById(nodeId: string): PlotAnalysisItem | null {
        return [...plotItems.value, ...analysisItems.value].find(item => item.id === nodeId) || null;
    }

    /**
     * 更新派生内容。
     * @param nodeId - 派生内容的ID
     * @param content - 新的HTML内容
     */
    function updateNodeContent(nodeId: string, content: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            derivedItem.content = content;
        }
    }

    /**
     * (此函数不再用于派生内容，但为保持接口一致性而保留)
     * 向派生内容追加内容。
     * @param nodeId - 派生内容的ID
     * @param contentToAppend - 要追加的原始文本
     */
    function appendNodeContent(nodeId: string, contentToAppend: string) {
        const derivedItem = findItemById(nodeId);
        if (derivedItem) {
            const paragraphs = contentToAppend.split('\n').map(p => `<p>${p || ' '}</p>`).join('');
            if (!derivedItem.content) derivedItem.content = "";
            derivedItem.content += paragraphs;
        }
    }

    /**
     * 删除与指定源ID关联的所有派生数据。
     * @param sourceId - 源的ID
     */
    function deleteDerivedDataForSource(sourceId: string) {
        plotItems.value = plotItems.value.filter(item => item.sourceId !== sourceId);
        analysisItems.value = analysisItems.value.filter(item => item.sourceId !== sourceId);
    }


    return {
        plotItems,
        analysisItems,
        fetchDerivedData,
        createDerivedItem,
        findItemById,
        updateNodeContent,
        appendNodeContent,
        deleteDerivedDataForSource,
    };
});

// =
// 文件: ..\src\novel\editor\stores\directoryStore.ts
//

// src/novel/editor/stores/directoryStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { Volume, Chapter } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { useDerivedContentStore } from './derivedContentStore';
import * as directoryService from '@/novel/editor/services/directoryService';

export const useDirectoryStore = defineStore('directory', () => {
    const directoryData = ref<Volume[]>([]);

    const fetchDirectoryData = (data: Volume[]) => {
        directoryData.value = data;
    };

    const findNodeById = (nodeId: string) => {
        return directoryService.findNodeById(directoryData.value, nodeId);
    };

    const updateChapterContent = (nodeId: string, content: string) => {
        const result = findNodeById(nodeId);
        if (result && (result.node.type === 'chapter' || result.node.type === 'volume')) {
            directoryService.updateNodeContent(result.node, content);
        }
    };

    const appendChapterContent = (nodeId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const result = findNodeById(nodeId);
        if (result && result.node.type === 'chapter') {
            directoryService.appendChapterContent(result.node, contentToAppend, isAutoApplied);
        }
    };

    const addNewVolume = () => {
        const uiStore = useUIStore();
        const editorStore = useEditorStore();
        const newVolume = directoryService.createVolume();
        directoryData.value.push(newVolume);

        editorStore.setEditingNodeId(newVolume.id);
        uiStore.ensureNodeIsExpanded(newVolume.id);
    };

    const addChapterToVolume = (volumeId: string) => {
        const volume = directoryData.value.find(v => v.id === volumeId);
        if (volume) {
            const editorStore = useEditorStore();
            const uiStore = useUIStore();
            const newChapter = directoryService.createChapter();
            volume.chapters.push(newChapter);

            uiStore.ensureNodeIsExpanded(volume.id);
            editorStore.openTab(newChapter.id);
            editorStore.setEditingNodeId(newChapter.id);
        }
    };

    const renameNode = (nodeId: string, newTitle: string) => {
        const result = findNodeById(nodeId);
        if (result?.node) {
            directoryService.renameNode(result.node, newTitle);
        }
    };

    const deleteNode = (nodeId: string) => {
        const result = findNodeById(nodeId);
        if (!result) return;

        // Coordination logic: Must happen before data is deleted
        const editorStore = useEditorStore();
        const derivedContentStore = useDerivedContentStore();

        if (result.node.type === 'chapter') {
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        } else if (result.node.type === 'volume') {
            result.node.chapters.forEach(chapter => {
                derivedContentStore.deleteDerivedDataForSource(chapter.id);
            });
            derivedContentStore.deleteDerivedDataForSource(result.node.id);
        }

        // Data manipulation logic
        const wasDeleted = directoryService.deleteNode(directoryData.value, nodeId);

        // UI update logic
        if (wasDeleted) {
            editorStore.closeTab(nodeId);
            if (editorStore.editingNodeId === nodeId) editorStore.setEditingNodeId(null);
        }
    };

    return {
        directoryData,
        fetchDirectoryData,
        findNodeById,
        updateChapterContent,
        appendChapterContent,
        addNewVolume,
        addChapterToVolume,
        renameNode,
        deleteNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\itemStore.ts
//

import { defineStore } from 'pinia';
import { useDirectoryStore } from '../directoryStore';
import { useRelatedContentStore } from '../relatedContentStore';
import { useNotesStore } from '../notesStore';
import { useDerivedContentStore } from '../derivedContentStore';
import { usePromptTemplateStore } from '../promptTemplateStore';
import { useReferenceStore } from '../referenceStore';
import type { EditorItem, SystemViewInfo, TreeNode, PlotAnalysisItem } from '@/novel/editor/types';
import { getIconByNodeType } from '@/novel/editor/utils/iconUtils';

export const SYSTEM_VIEWS: Record<string, SystemViewInfo> = {
    'system:search': { id: 'system:search', type: 'system', component: 'SearchView', title: '搜索', icon: 'fa-solid fa-magnifying-glass' },
    'system:ai_chat': { id: 'system:ai_chat', type: 'system', component: 'AIChatView', title: 'AI 聊天', icon: 'fa-solid fa-wand-magic-sparkles' },
    'system:ai_tasks': { id: 'system:ai_tasks', type: 'system', component: 'AITaskPanel', title: 'AI 任务', icon: 'fa-solid fa-list-check' },
    'system:settings_editor': { id: 'system:settings_editor', type: 'system', component: 'EditorSettings', title: '编辑器设置', icon: 'fa-solid fa-pencil' },
    'system:settings_context': { id: 'system:settings_context', type: 'system', component: 'ContextSettings', title: '上下文管理', icon: 'fa-solid fa-book-open-reader' },
    'system:settings_tasks': { id: 'system:settings_tasks', type: 'system', component: 'TaskSettings', title: '任务管理', icon: 'fa-solid fa-list-check' },
    'system:settings_ai_config': { id: 'system:settings_ai_config', type: 'system', component: 'AIConfigSettings', title: 'AI 任务配置', icon: 'fa-solid fa-microchip' },
    'system:settings_novel': { id: 'system:settings_novel', type: 'system', component: 'NovelSettings', title: '小说设置', icon: 'fa-solid fa-swatchbook' },
    'system:settings_theme': { id: 'system:settings_theme', type: 'system', component: 'ThemeSettings', title: '主题设置', icon: 'fa-solid fa-palette' },
    'system:history': { id: 'system:history', type: 'system', component: 'HistoryPanel', title: '版本历史', icon: 'fa-solid fa-code-compare' },
};

export const useItemStore = defineStore('editor-item', () => {
    const directoryStore = useDirectoryStore();
    const relatedContentStore = useRelatedContentStore();
    const notesStore = useNotesStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const referenceStore = useReferenceStore();

    function findItemById(id: string): { node: EditorItem | null; source: string | null } {
        // 1. Check for System Views
        if (id.startsWith('system:')) {
            const parts = id.split(':');
            const baseId = parts.length > 2 && (parts[1] === 'history') ? parts.slice(0, 2).join(':') : id;
            const systemView = SYSTEM_VIEWS[baseId];
            if (systemView) {
                if (parts.length > 2 && (parts[1] === 'history')) {
                    const targetId = parts[2];
                    const { node: targetNode } = findItemById(targetId);
                    return {
                        node: targetNode ? { ...systemView, id, title: `《${targetNode.title}》 ${systemView.title}` } : null,
                        source: 'system'
                    };
                }
                return { node: systemView, source: 'system' };
            }
        }

        // 2. Check for AI Derived Items
        const derivedItem = derivedContentStore.findItemById(id);
        if (derivedItem) {
            return { node: derivedItem as PlotAnalysisItem, source: 'derived' };
        }

        // 3. Check for Prompt Templates
        const promptItem = promptTemplateStore.findPromptById(id);
        if (promptItem) {
            return { node: promptItem, source: 'prompt' };
        }

        // 4. Check Directory
        let dirResult = directoryStore.findNodeById(id);
        if (dirResult?.node) return { node: dirResult.node, source: 'directory' };

        // 5. Check Related Content (Settings & Custom Items)
        const relatedResult = relatedContentStore.findNodeById(id);
        if(relatedResult?.node) return { node: relatedResult.node, source: 'related' };

        // 6. Check Notes
        const note = notesStore.findNoteById(id);
        if (note) return { node: note, source: 'notes' };

        // 7. Check Reference Books (New)
        const refResult = referenceStore.findNodeById(id);
        if (refResult?.node) return { node: refResult.node, source: 'reference' };

        return { node: null, source: null };
    }

    function updateItemContentById(id: string, content: string) {
        const { source } = findItemById(id);
        switch (source) {
            case 'directory': directoryStore.updateChapterContent(id, content); break;
            case 'related': relatedContentStore.updateNodeContent(id, content); break;
            case 'notes': notesStore.updateNoteContent(id, content); break;
            case 'derived': derivedContentStore.updateNodeContent(id, content); break;
            case 'prompt': promptTemplateStore.updatePromptContent(id, content); break;
        }
    }

    function appendContentToItem(itemId: string, content: string, auto: boolean) {
        const { source } = findItemById(itemId);
        switch (source) {
            case 'directory': directoryStore.appendChapterContent(itemId, content, auto); break;
            case 'related': relatedContentStore.appendNodeContent(itemId, content, auto); break;
            case 'notes': notesStore.appendNoteContent(itemId, content, auto); break;
            case 'derived': derivedContentStore.appendNodeContent(itemId, content, auto); break;
        }
    }

    return { findItemById, updateItemContentById, appendContentToItem, getIconByNodeType };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\metadataStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { projectLoaderService } from '@novel/editor/services/novelLoaderService.ts';
import type { NovelMetadata } from '@/novel/editor/types/project';
import { useReferenceStore } from '../referenceStore';
import { updateNovelMetadata } from '../../api/metadataApi';

export const useMetadataStore = defineStore('editor-metadata', () => {
    const novelMetadata = ref<NovelMetadata | null>(null);
    const currentNovelId = ref<string | null>(null);

    // --- Actions (Public API for components) ---

    async function fetchNovelData(novelId: string) {
        await projectLoaderService.loadProjectIntoEditor(novelId);
    }

    async function saveMetadata() {
        if (!currentNovelId.value || !novelMetadata.value) {
            console.error("保存失败：未加载小说。");
            alert('保存失败，请查看控制台获取更多信息。');
            return;
        }

        try {
            await updateNovelMetadata(currentNovelId.value, novelMetadata.value);
            alert('小说设置已保存！');
        } catch (error) {
            console.error("保存元数据失败:", error);
            alert('保存失败，请稍后重试。');
        }
    }

    // --- State Modifiers (Internal, called by services or other actions) ---

    function _setNovelMetadata(data: NovelMetadata) {
        novelMetadata.value = JSON.parse(JSON.stringify(data));
    }

    function _setCurrentNovelId(id: string) {
        currentNovelId.value = id;
    }

    function addReferenceNovel(novelIdToAdd: string) {
        if (!novelMetadata.value || novelMetadata.value.referenceNovelIds.includes(novelIdToAdd)) {
            return;
        }
        novelMetadata.value.referenceNovelIds.push(novelIdToAdd);
        const referenceStore = useReferenceStore();
        referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
    }

    function removeReferenceNovel(novelIdToRemove: string) {
        if (!novelMetadata.value) {
            return;
        }
        const index = novelMetadata.value.referenceNovelIds.indexOf(novelIdToRemove);
        if (index > -1) {
            novelMetadata.value.referenceNovelIds.splice(index, 1);
            const referenceStore = useReferenceStore();
            referenceStore.loadReferences(novelMetadata.value.referenceNovelIds);
        }
    }

    function removeTag(tagIndex: number) {
        if (novelMetadata.value) {
            novelMetadata.value.tags.splice(tagIndex, 1);
        }
    }

    function addTag() {
        if (!novelMetadata.value) return;
        const newTagText = prompt("输入新标签:");
        if (newTagText?.trim()) {
            novelMetadata.value.tags.push({ text: newTagText, class: 'bg-gray-100 text-gray-800' });
        }
    }

    return {
        // State
        novelMetadata,
        currentNovelId,
        // Actions
        fetchNovelData,
        addReferenceNovel,
        removeReferenceNovel,
        removeTag,
        addTag,
        saveMetadata,
        // Internal Setters
        _setNovelMetadata,
        _setCurrentNovelId,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\paneStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export interface EditorPane {
    id: string;
    openTabIds: string[];
    activeTabId: string | null;
}

export const usePaneStore = defineStore('editor-pane', () => {
    const panes = ref<EditorPane[]>([]);
    const activePaneId = ref<string | null>(null);

    function initializePanes() {
        if (panes.value.length > 0) return;
        const initialPaneId = `pane-${Date.now()}`;
        panes.value.push({ id: initialPaneId, openTabIds: [], activeTabId: null });
        activePaneId.value = initialPaneId;
    }

    function setActivePane(paneId: string) {
        if (panes.value.some(p => p.id === paneId)) {
            activePaneId.value = paneId;
        }
    }

    function splitPane(sourcePaneId: string): string {
        const sourcePaneIndex = panes.value.findIndex(p => p.id === sourcePaneId);
        if (sourcePaneIndex === -1) return '';

        const newPaneId = `pane-${Date.now()}`;
        const newPane: EditorPane = { id: newPaneId, openTabIds: [], activeTabId: null };
        panes.value.splice(sourcePaneIndex + 1, 0, newPane);

        return newPaneId;
    }

    function closePane(paneId: string) {
        if (panes.value.length <= 1) return;
        const paneIndex = panes.value.findIndex(p => p.id === paneId);
        if (paneIndex === -1) return;

        panes.value.splice(paneIndex, 1);
        if (activePaneId.value === paneId) {
            const newActiveIndex = Math.max(0, paneIndex - 1);
            activePaneId.value = panes.value[newActiveIndex]?.id || null;
        }
    }

    return {
        panes,
        activePaneId,
        initializePanes,
        setActivePane,
        splitPane,
        closePane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\systemViewStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useTabStore } from './tabStore';
import { useUIStore } from '../uiStore';
import { useEditorStore } from '../editorStore';

export const useSystemViewStore = defineStore('editor-system-view', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const uiStore = useUIStore();

    function toggleAIPanel(sourcePaneId: string) {
        const aiTaskPane = paneStore.panes.find(p => p.openTabIds.includes('system:ai_tasks'));
        if (aiTaskPane) {
            paneStore.closePane(aiTaskPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function ensureAIPanelIsOpen(sourcePaneId: string) {
        if (!paneStore.panes.some(p => p.openTabIds.includes('system:ai_tasks'))) {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab('system:ai_tasks', newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function toggleHistoryPanel(sourcePaneId: string) {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane?.activeTabId || sourcePane.activeTabId.startsWith('system:')) return;

        const historyTabId = `system:history:${sourcePane.activeTabId}`;
        const historyPane = paneStore.panes.find(p => p.openTabIds.includes(historyTabId));

        if (historyPane) {
            paneStore.closePane(historyPane.id);
        } else {
            const newPaneId = paneStore.splitPane(sourcePaneId);
            if(newPaneId) tabStore.openTab(historyTabId, newPaneId);
            paneStore.setActivePane(sourcePaneId);
        }
    }

    function openReaderView() {
        const editorStore = useEditorStore();
        const activeItem = editorStore.activeTab?.item;
        if (activeItem && 'content' in activeItem) {
            uiStore.showReaderMode(activeItem);
        } else {
            console.warn('Cannot open reader mode: no active document with content.');
        }
    }

    return {
        toggleAIPanel,
        ensureAIPanelIsOpen,
        toggleHistoryPanel,
        openReaderView,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editor-state\tabStore.ts
//

import { defineStore } from 'pinia';
import { usePaneStore } from './paneStore';
import { useUIStore } from '../uiStore';
import { useItemStore } from './itemStore';

export const useTabStore = defineStore('editor-tab', () => {
    const paneStore = usePaneStore();
    const uiStore = useUIStore();
    const itemStore = useItemStore();

    function openTab(itemId: string, targetPaneId?: string) {
        const paneId = targetPaneId || paneStore.activePaneId;
        if (!paneId) return;

        let pane = paneStore.panes.find(p => p.id === paneId);
        if (!pane) return;

        const { node } = itemStore.findItemById(itemId);
        if (!node || (node.type !== 'system' && !('content' in node))) {
            if (node?.type === 'volume' || node?.type === 'group') {
                uiStore.toggleNodeExpansion(itemId);
            } else if (node) {
                uiStore.toggleRelatedNodeExpansion(itemId);
            }
            return;
        }

        const existingTabPane = paneStore.panes.find(p => p.openTabIds.includes(itemId));
        if (existingTabPane) {
            existingTabPane.activeTabId = itemId;
            paneStore.setActivePane(existingTabPane.id);
            return;
        }

        if (!pane.openTabIds.includes(itemId)) {
            pane.openTabIds.push(itemId);
        }
        pane.activeTabId = itemId;
        paneStore.setActivePane(paneId);
    }

    function closeTab(itemId: string, paneId?: string) {
        const targetPaneId = paneId || paneStore.panes.find(p => p.openTabIds.includes(itemId))?.id;
        if (!targetPaneId) return;

        const pane = paneStore.panes.find(p => p.id === targetPaneId);
        if (!pane) return;

        const index = pane.openTabIds.indexOf(itemId);
        if (index === -1) return;

        pane.openTabIds.splice(index, 1);
        if (pane.activeTabId === itemId) {
            const newActiveIndex = Math.max(0, index - 1);
            pane.activeTabId = pane.openTabIds[newActiveIndex] || null;
        }

        if (pane.openTabIds.length === 0 && paneStore.panes.length > 1) {
            paneStore.closePane(pane.id);
        }
    }

    return {
        openTab,
        closeTab,
    };
});

// =
// 文件: ..\src\novel\editor\stores\editorStore.ts
//

import { defineStore } from 'pinia';
import { computed } from 'vue';
import { usePaneStore, type EditorPane } from '@novel/editor/stores/editor-state/paneStore';
import { useTabStore } from '@novel/editor/stores/editor-state/tabStore';
import { useItemStore } from '@novel/editor/stores/editor-state/itemStore';
import { useSystemViewStore } from '@novel/editor/stores/editor-state/systemViewStore';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { useUIStore } from './uiStore';
import type { TabInfo } from '@/novel/editor/types';

export { EditorPane };

export const useEditorStore = defineStore('editor-facade', () => {
    const paneStore = usePaneStore();
    const tabStore = useTabStore();
    const itemStore = useItemStore();
    const systemViewStore = useSystemViewStore();
    const metadataStore = useMetadataStore();
    const uiStore = useUIStore();

    const panes = computed(() => paneStore.panes);
    const activePaneId = computed(() => paneStore.activePaneId);
    const novelMetadata = computed(() => metadataStore.novelMetadata);
    const editingNodeId = computed(() => uiStore.editingNodeId);

    const activePane = computed(() => panes.value.find(p => p.id === activePaneId.value));
    const activeTabId = computed(() => activePane.value?.activeTabId ?? null);

    function getTabsForPane(paneId: string): TabInfo[] {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane) return [];
        return pane.openTabIds.map(id => {
            const { node } = itemStore.findItemById(id);
            return node ? {
                id,
                title: node.title,
                icon: node.icon || itemStore.getIconByNodeType(node.type),
                item: node
            } : null;
        }).filter((tab): tab is TabInfo => tab !== null);
    }

    function getActiveTabForPane(paneId: string): TabInfo | null {
        const pane = panes.value.find(p => p.id === paneId);
        if (!pane || !pane.activeTabId) return null;
        const tabs = getTabsForPane(paneId);
        return tabs.find(tab => tab.id === pane.activeTabId) ?? null;
    }

    const activeTab = computed(() => {
        if (!activePane.value || !activePane.value.activeTabId) return null;
        return getActiveTabForPane(activePane.value.id);
    });

    const splitPane = (sourcePaneId: string) => {
        const sourcePane = paneStore.panes.find(p => p.id === sourcePaneId);
        if (!sourcePane) {
            console.warn(`splitPane failed: source pane with id ${sourcePaneId} not found.`);
            return;
        }
        const newPaneId = paneStore.splitPane(sourcePaneId);
        if (sourcePane.activeTabId) {
            tabStore.openTab(sourcePane.activeTabId, newPaneId);
        }
    };

    return {
        panes,
        activePaneId,
        novelMetadata,
        editingNodeId,
        activePane,
        activeTabId,
        activeTab,
        splitPane,
        setEditingNodeId: uiStore.setEditingNodeId,
        setActivePane: paneStore.setActivePane,
        closePane: paneStore.closePane,
        openTab: tabStore.openTab,
        closeTab: tabStore.closeTab,
        findItemById: itemStore.findItemById,
        updateItemContentById: itemStore.updateItemContentById,
        appendContentToItem: itemStore.appendContentToItem,
        toggleAIPanel: systemViewStore.toggleAIPanel,
        ensureAIPanelIsOpen: systemViewStore.ensureAIPanelIsOpen,
        toggleHistoryPanel: systemViewStore.toggleHistoryPanel,
        openReaderView: systemViewStore.openReaderView,
        fetchNovelData: metadataStore.fetchNovelData,
        getTabsForPane,
        getActiveTabForPane,
    };
});

// =
// 文件: ..\src\novel\editor\stores\notesStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { NoteItem } from '@/novel/editor/types';
import { useEditorStore } from './editorStore';
import { useUIStore } from './uiStore';
import { noteService } from '@/novel/editor/services/noteService';

export const useNotesStore = defineStore('notes', () => {
    const notes = ref<NoteItem[]>([]);

    const fetchNotes = (data: NoteItem[]) => {
        notes.value = data;
    };

    const findNoteById = (noteId: string): NoteItem | undefined => {
        return notes.value.find(note => note.id === noteId);
    };

    const updateNoteContent = (noteId: string, content: string) => {
        const noteIndex = notes.value.findIndex(n => n.id === noteId);
        if (noteIndex === -1) return;

        const originalNote = notes.value[noteIndex];
        const updatedNote = noteService.updateNoteWithNewContent(originalNote, content);
        notes.value.splice(noteIndex, 1, updatedNote);
    };

    const appendNoteContent = (noteId: string, contentToAppend: string, isAutoApplied: boolean) => {
        const note = findNoteById(noteId);
        if (note) {
            note.content = noteService.appendContentToNote(note.content, contentToAppend, isAutoApplied);
        }
    };

    const renameNote = (noteId: string, newTitle: string) => {
        const uiStore = useUIStore();
        const noteIndex = notes.value.findIndex(n => n.id === noteId);

        if (noteIndex !== -1 && newTitle.trim()) {
            const originalNote = notes.value[noteIndex];
            const trimmedTitle = newTitle.trim();
            const updatedNote = noteService.renameNote(originalNote, trimmedTitle);
            notes.value.splice(noteIndex, 1, updatedNote);
        }
        uiStore.setEditingNodeId(null);
    };

    const addNote = (title: string, content: string = '') => {
        const editorStore = useEditorStore();
        const uiStore = useUIStore();

        const newNote = noteService.createNote(title, content);
        notes.value.unshift(newNote);

        editorStore.openTab(newNote.id);
        uiStore.setEditingNodeId(newNote.id);
    };

    const deleteNote = (noteId: string) => {
        const editorStore = useEditorStore();
        const index = notes.value.findIndex(n => n.id === noteId);
        if (index !== -1) {
            notes.value.splice(index, 1);
            editorStore.closeTab(noteId);
        }
    };

    return {
        notes,
        fetchNotes,
        findNoteById,
        updateNoteContent,
        appendNoteContent,
        renameNote,
        addNote,
        deleteNote
    };
});

// =
// 文件: ..\src\novel\editor\stores\novelSettingsStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { useMetadataStore } from '@novel/editor/stores/editor-state/metadataStore';
import { novelSettingsService } from '@/novel/editor/services/novelSettingsService';
import type { NovelProject } from '@/novel/editor/types/project';
import type { NovelMetadata } from '@/novel/editor/types';

export const useNovelSettingsStore = defineStore('novel-settings', () => {
    const metadataStore = useMetadataStore();

    const novelMetadata = ref<NovelMetadata | null>(null);
    const referencedNovels = ref<NovelProject[]>([]);
    const availableReferenceNovels = ref<NovelProject[]>([]);

    /**
     * Asynchronously loads and populates all data needed for the settings view.
     */
    async function loadSettingsData() {
        const meta = metadataStore.novelMetadata;
        novelMetadata.value = meta;
        if (meta) {
            referencedNovels.value = await novelSettingsService.getReferencedNovels(meta.referenceNovelIds);
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(meta);
        } else {
            referencedNovels.value = [];
            availableReferenceNovels.value = await novelSettingsService.getAvailableReferenceNovels(null);
        }
    }

    const addReferenceNovel = async (novelId: string) => {
        if (!novelId) return;
        metadataStore.addReferenceNovel(novelId);
        await loadSettingsData();
    };

    const removeReferenceNovel = async (novelId: string) => {
        metadataStore.removeReferenceNovel(novelId);
        await loadSettingsData();
    };

    const addTag = () => {
        metadataStore.addTag();
    };

    const removeTag = (index: number) => {
        metadataStore.removeTag(index);
    };

    const saveMetadata = () => {
        metadataStore.saveMetadata();
    };

    const resetMetadata = async () => {
        if (metadataStore.currentNovelId) {
            await metadataStore.fetchNovelData(metadataStore.currentNovelId);
        }
    };

    return {
        novelMetadata,
        referencedNovels,
        availableReferenceNovels,
        loadSettingsData,
        addReferenceNovel,
        removeReferenceNovel,
        addTag,
        removeTag,
        saveMetadata,
        resetMetadata,
    };
});

// =
// 文件: ..\src\novel\editor\stores\promptTemplateStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode, ItemNode, AITaskType, PromptItemNode } from '@novel/editor/types';
import { getIconByNodeType } from '@novel/editor/utils/iconUtils';
import { promptService } from '@/novel/editor/services/promptService';
import { useAIConfigStore } from './ai/aiConfigStore';

const defaultSelectedPromptIds: Record<AITaskType, string> = {
    '润色': 'prompt-polish-default',
    '续写': 'prompt-continue-default',
    '分析': 'prompt-analyze-default',
    '剧情生成': 'prompt-plot-default',
    '创作': 'prompt-create-default',
};

export const usePromptTemplateStore = defineStore('promptTemplate', () => {
    // State: Use a simple ref, not a computed property, for the main data tree.
    const promptTree = ref<TreeNode[]>([]);

    /**
     * Action to initialize the prompt tree if it's empty.
     * This should be called once when the editor loads.
     */
    function initialize() {
        if (promptTree.value.length === 0) {
            promptTree.value = promptService.buildInitialTree();
        }
    }

    const getPromptsForTask = (taskType: AITaskType): ItemNode[] => {
        const group = promptTree.value[0]?.children?.find(g => (g as any).originalData.taskType === taskType);
        return (group?.children as ItemNode[] || []);
    };

    function findPromptById(promptId: string): { prompt: PromptItemNode, group: TreeNode } | null {
        if (!promptTree.value[0]?.children) return null;
        for (const group of promptTree.value[0].children) {
            const prompt = group.children?.find(p => p.id === promptId);
            if(prompt) return { prompt: prompt as PromptItemNode, group };
        }
        return null;
    }

    function addPrompt(groupId: string, title: string, template: string): PromptItemNode | null {
        const group = promptTree.value[0]?.children?.find(g => g.id === groupId);
        if (!group || !group.children) return null;

        const taskType = group.originalData.taskType;
        const newNode: PromptItemNode = {
            id: `prompt-custom-${Date.now()}`,
            title: title,
            type: 'prompt_item',
            icon: getIconByNodeType('prompt_item'),
            content: `<pre>${template}</pre>`,
            originalData: { taskType },
        };
        group.children.push(newNode);
        return newNode;
    }

    function renamePrompt(promptId: string, newTitle: string) {
        const result = findPromptById(promptId);
        if (result && newTitle.trim()) {
            result.prompt.title = newTitle.trim();
        }
    }

    function deletePrompt(promptId: string): boolean {
        const aiConfigStore = useAIConfigStore();
        const result = findPromptById(promptId);
        if (!result) return false;

        const { prompt, group } = result;
        const taskType = prompt.originalData.taskType;

        if (group && group.children) {
            const index = group.children.findIndex(p => p.id === promptId);
            if (index > -1) {
                group.children.splice(index, 1);

                if (aiConfigStore.taskConfigs[taskType].selectedPromptId === promptId) {
                    aiConfigStore.setSelectedPromptId(taskType, defaultSelectedPromptIds[taskType]);
                }
                return true;
            }
        }
        return false;
    }

    function updatePromptContent(promptId: string, newContent: string) {
        const result = findPromptById(promptId);
        if (result) {
            result.prompt.content = newContent;
        }
    }

    return {
        promptTree,
        initialize,
        getPromptsForTask,
        findPromptById: (id: string) => findPromptById(id)?.prompt || null,
        addPrompt,
        renamePrompt,
        deletePrompt,
        updatePromptContent,
    };
});

// =
// 文件: ..\src\novel\editor\stores\referenceStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { TreeNode } from '@/novel/editor/types';
import { referenceService } from '@/novel/editor/services/referenceService';

const _findNodeRecursive = (nodes: TreeNode[], nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
    for (const node of nodes) {
        if (node.id === nodeId) {
            return { node, parent: null };
        }
        if (node.children) {
            const foundInChild = _findNodeRecursive(node.children, nodeId);
            if (foundInChild) {
                if (!foundInChild.parent) {
                    foundInChild.parent = node;
                }
                return foundInChild;
            }
        }
    }
    return null;
};

export const useReferenceStore = defineStore('reference', () => {
    const referenceData = ref<TreeNode[]>([]);

    const loadReferences = async (referenceNovelIds: string[]) => {
        referenceData.value = await referenceService.buildReferenceTree(referenceNovelIds);
    };

    const findNodeById = (nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null => {
        return _findNodeRecursive(referenceData.value, nodeId);
    };

    return {
        referenceData,
        loadReferences,
        findNodeById
    };
});

// =
// 文件: ..\src\novel\editor\stores\relatedContentStore.ts
//

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import * as nodeOperationService from '@/novel/editor/services/related/nodeOperationService';
import * as treeBuilderService from '@/novel/editor/services/related/treeBuilderService';
import { updateAllOverviewContent } from '@/novel/editor/services/related/overviewService';
import { useDirectoryStore } from '@/novel/editor/stores/directoryStore';
import { useDerivedContentStore } from '@/novel/editor/stores/derivedContentStore';
import { usePromptTemplateStore } from '@/novel/editor/stores/promptTemplateStore';
import { useEditorStore } from '@/novel/editor/stores/editorStore';
import { useUIStore } from '@/novel/editor/stores/uiStore';
import type { TreeNode, ItemNode, GroupNode } from '@/novel/editor/types';

export const useRelatedContentStore = defineStore('relatedContent', () => {
    // --- State ---
    const settingsData = ref<TreeNode[]>([]);
    const plotCustomData = ref<TreeNode[]>([]);
    const analysisCustomData = ref<TreeNode[]>([]);
    const othersCustomData = ref<TreeNode[]>([]);

    // --- Dependencies ---
    const directoryStore = useDirectoryStore();
    const derivedContentStore = useDerivedContentStore();
    const promptTemplateStore = usePromptTemplateStore();
    const editorStore = useEditorStore();
    const uiStore = useUIStore();

    // --- Computed ---
    const relatedData = computed(() => {
        // Filter out derived items whose source has been deleted
        const allValidSourceIds = new Set(directoryStore.directoryData.flatMap(v => [v.id, ...v.chapters.map(c => c.id)]));
        const validPlotItems = derivedContentStore.plotItems.filter(i => allValidSourceIds.has(i.sourceId));
        const validAnalysisItems = derivedContentStore.analysisItems.filter(i => allValidSourceIds.has(i.sourceId));

        return treeBuilderService.buildRelatedTree(
            settingsData.value,
            plotCustomData.value,
            analysisCustomData.value,
            othersCustomData.value,
            promptTemplateStore.promptTree,
            validPlotItems,
            validAnalysisItems,
            directoryStore.directoryData
        );
    });

    const allDataSources = computed(() => [
        settingsData.value,
        plotCustomData.value,
        analysisCustomData.value,
        othersCustomData.value
    ]);

    // --- Watchers ---
    watch(settingsData, (newData) => {
        updateAllOverviewContent(newData);
    }, { deep: true });

    // --- Actions ---
    function fetchRelatedData(settings: any[], plot: any[], analysis: any[], others: any[]) {
        promptTemplateStore.initialize();
        settingsData.value = settings;
        plotCustomData.value = plot;
        analysisCustomData.value = analysis;
        othersCustomData.value = others;
    }

    function findNodeById(nodeId: string): { node: TreeNode; parent: TreeNode | null; } | null {
        return nodeOperationService.findNodeById(nodeId, allDataSources.value);
    }

    function updateNodeContent(nodeId: string, content: string) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.updateNodeContent(result.node as ItemNode, content);
        }
    }

    function appendNodeContent(nodeId: string, contentToAppend: string, isAutoApplied: boolean) {
        const result = findNodeById(nodeId);
        if (result?.node && 'content' in result.node) {
            nodeOperationService.appendNodeContent(result.node as ItemNode, contentToAppend, isAutoApplied);
        }
    }

    function renameRelatedNode(nodeId: string, newTitle: string) {
        const result = findNodeById(nodeId);
        if (result?.node) {
            nodeOperationService.renameNode(result.node, newTitle);
        }
    }

    // --- Action: Add ---
    function addRelatedNode(parentId: string, type: 'group' | 'item') {
        const result = findNodeById(parentId);
        if (!result?.node || !result.node.children) return;

        const parentNode = result.node as GroupNode;
        const newNode = nodeOperationService.createRelatedNode(parentNode, type);
        parentNode.children.push(newNode);

        uiStore.ensureRelatedNodeIsExpanded(parentId);
        uiStore.setEditingNodeId(newNode.id);
        if (newNode.type.endsWith('_item')) {
            editorStore.openTab(newNode.id);
        }
    }

    function addCustomRelatedNode(target: 'plot' | 'analysis') {
        const dataRef = target === 'plot' ? plotCustomData : analysisCustomData;
        const newNode = nodeOperationService.createCustomNode(target);
        dataRef.value.unshift(newNode);

        uiStore.ensureRelatedNodeIsExpanded(target);
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    function addCustomOthersNode() {
        const newNode = nodeOperationService.createCustomNode('others');
        othersCustomData.value.unshift(newNode);
        uiStore.ensureRelatedNodeIsExpanded('others');
        editorStore.openTab(newNode.id);
        uiStore.setEditingNodeId(newNode.id);
    }

    // --- Action: Delete ---
    function deleteNode(nodeId: string): boolean {
        const wasRemoved = nodeOperationService.deleteNode(nodeId, allDataSources.value);
        if (wasRemoved) {
            editorStore.closeTab(nodeId);
        }
        return wasRemoved;
    }
    const deleteRelatedNode = deleteNode;
    const deleteCustomRelatedNode = deleteNode;
    const deleteCustomOthersNode = deleteNode;

    // --- Actions with specific naming for context menus ---
    const renameCustomRelatedNode = renameRelatedNode;
    const renameCustomOthersNode = renameRelatedNode;

    return {
        // State & Computed
        settingsData,
        plotCustomData,
        analysisCustomData,
        othersCustomData,
        relatedData,
        // Actions
        fetchRelatedData,
        findNodeById,
        updateNodeContent,
        appendNodeContent,
        addRelatedNode,
        renameRelatedNode,
        deleteRelatedNode,
        addCustomRelatedNode,
        renameCustomRelatedNode,
        deleteCustomRelatedNode,
        addCustomOthersNode,
        renameCustomOthersNode,
        deleteCustomOthersNode,
    };
});

// =
// 文件: ..\src\novel\editor\stores\searchStore.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { SearchResult } from '@/novel/editor/types';
import { searchService } from '@/novel/editor/services/searchService';

export const useSearchStore = defineStore('search', () => {
    const searchQuery = ref('');
    const lastSearchedQuery = ref('');
    const hasSearched = ref(false);
    const results = ref<SearchResult[]>([]);

    const performSearch = (query: string) => {
        hasSearched.value = true;
        lastSearchedQuery.value = query;
        results.value = searchService.search(query);
    };

    const clearSearch = () => {
        searchQuery.value = '';
        lastSearchedQuery.value = '';
        hasSearched.value = false;
        results.value = [];
    };

    return {
        searchQuery,
        lastSearchedQuery,
        hasSearched,
        results,
        performSearch,
        clearSearch
    };
});

// =
// 文件: ..\src\novel\editor\stores\uiStore.ts
//

// 文件: src/novel/editor/stores/uiStore.ts
import { defineStore } from 'pinia';
import { ref } from 'vue';
import type { EditorItem, EditorUIState } from '@/novel/editor/types';

export const useUIStore = defineStore('ui', () => {
    const editingNodeId = ref<string | null>(null);
    const uiState = ref<EditorUIState>({
        expandedNodeIds: new Set(),
        expandedRelatedNodeIds: new Set(),
        expandedReferenceNodeIds: new Set(),
        autoOpenAIPanel: true,
        activeTheme: 'default',
        concurrentTaskLimit: 3,
        taskApplicationStrategy: {
            mode: 'manual', // 'manual', 'auto', 'delayed'
            delaySeconds: 3,
        },
    });

    // Reader Mode State
    const isReaderModeVisible = ref(false);
    const readerModeItem = ref<EditorItem | null>(null);

    const setEditingNodeId = (id: string | null) => {
        editingNodeId.value = id;
    };

    const setAutoOpenAIPanel = (value: boolean) => {
        uiState.value.autoOpenAIPanel = value;
    };

    const setTheme = (theme: 'default' | 'eye-care' | 'dark') => {
        uiState.value.activeTheme = theme;
    };

    const setConcurrentTaskLimit = (limit: number) => {
        const newLimit = Math.max(1, Math.floor(limit)); // 保证至少为1
        uiState.value.concurrentTaskLimit = newLimit;
    };

    const setTaskApplicationStrategy = (strategy: EditorUIState['taskApplicationStrategy']) => {
        uiState.value.taskApplicationStrategy = strategy;
    };

    const toggleNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const ensureNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedNodeIds.has(nodeId)) {
            uiState.value.expandedNodeIds.add(nodeId);
        }
    };

    const toggleRelatedNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const ensureRelatedNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedRelatedNodeIds.has(nodeId)) {
            uiState.value.expandedRelatedNodeIds.add(nodeId);
        }
    };

    const toggleReferenceNodeExpansion = (nodeId: string) => {
        if (uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.delete(nodeId);
        } else {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const ensureReferenceNodeIsExpanded = (nodeId: string) => {
        if (!uiState.value.expandedReferenceNodeIds.has(nodeId)) {
            uiState.value.expandedReferenceNodeIds.add(nodeId);
        }
    };

    const showReaderMode = (item: EditorItem) => {
        readerModeItem.value = item;
        isReaderModeVisible.value = true;
    };

    const hideReaderMode = () => {
        isReaderModeVisible.value = false;
        readerModeItem.value = null;
    };

    return {
        editingNodeId,
        uiState,
        isReaderModeVisible,
        readerModeItem,
        setEditingNodeId,
        setAutoOpenAIPanel,
        setTheme,
        setConcurrentTaskLimit,
        setTaskApplicationStrategy,
        toggleNodeExpansion,
        ensureNodeIsExpanded,
        toggleRelatedNodeExpansion,
        ensureRelatedNodeIsExpanded,
        toggleReferenceNodeExpansion,
        ensureReferenceNodeIsExpanded,
        showReaderMode,
        hideReaderMode,
    };
});

// =
// 文件: ..\src\novel\editor\types\ai.ts
//


/**
 * AI 任务状态
 * - pending: 等待执行
 * - processing: 正在执行
 * - completed: 已完成，等待应用
 * - completed_with_conflict: 已完成，但源文档已被修改，等待用户处理
 * - applied: 已应用
 * - failed: 执行失败
 */
export type AITaskStatus = 'pending' | 'processing' | 'completed' | 'completed_with_conflict' | 'applied' | 'failed';

/**
 * AI 任务类型 (用户界面显示名称)
 */
export type AITaskType = '润色' | '续写' | '分析' | '剧情生成' | '创作';

/**
 * AI 提供商（模型）配置
 */
export interface AIProviderConfig {
    id: string;
    name: string;
    model: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

/**
 * AI 任务对象
 */
export interface AITask {
    id: string;
    title: string;
    type: AITaskType;
    sourceItemId: string;
    targetItemId: string;
    sourceItemTitle: string;
    sourceItemContent: string;
    sourceItemVersion: number; // 新增：源文档版本快照（使用Date.now()时间戳）
    status: AITaskStatus;
    generatedContent: string;
    finalPrompt?: string;
    error?: string;
    createdAt: Date;
    applyAt?: number; // 新增：用于延迟应用的时间戳
    aiConfig: AIProviderConfig;
}

/**
 * AI 任务执行前的预览数据结构
 */
export interface AITaskPreview {
    type: AITaskType;
    targetItemId: string; // 此处targetItemId即为sourceItemId
    title: string;
}

// =
// 文件: ..\src\novel\editor\types\chatTypes.ts
//

/**
 * AI模型定义
 */
export interface AIModel {
    id: string;
    name: string;
    status: 'online' | 'offline' | 'limited';
}

/**
 * 聊天消息定义
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'ai';
    content: string;
    timestamp: string;
}

/**
 * 单个聊天会话定义
 */
export interface Conversation {
    id: string;
    title: string;
    summary: string;
    createdAt: string;
    messages: ChatMessage[];
}

// =
// 文件: ..\src\novel\editor\types\index.ts
//

export * from './models';
export * from './chatTypes';
export * from './ui';
export * from './ai';

// =
// 文件: ..\src\novel\editor\types\models.ts
//

// 文件: src/novel/editor/types/models.ts

/**
 * 卷（目录的一级）
 */
export interface Volume {
    id: string;
    type: 'volume';
    title: string;
    icon?: string;
    content: string; // 卷的大纲或简介
    chapters: Chapter[];
}

/**
 * 章节（目录的二级）
 */
export interface Chapter {
    id:string;
    type: 'chapter';
    title: string;
    icon?: string;
    wordCount: number;
    content: string; // 章节正文 (HTML)
    status: 'planned' | 'editing' | 'completed' | 'archived';
}

/**
 * AI生成的派生内容（剧情/分析）的存储结构
 */
export interface PlotAnalysisItem {
    id: string; // 派生ID, e.g., 'plot_ch-1'
    type: 'plot' | 'analysis'; // 明确其类型
    icon?: string;
    sourceId: string; // 源ID, e.g., 'ch-1' or 'vol-1'
    title: string; // 派生标题, e.g., '第一章 剧情'
    content: string; // 生成的内容 (HTML)
}

/**
 * 代表一个角色
 */
export interface NovelCharacter {
    id: string;
    name: string;
    avatar: string;
    identity: string;
    gender?: string;
    age?: number;
    faction?: string;
    summary: string; // AI参考的主要描述
    notes?: string; // 作者的私人笔记
    status?: 'editing' | 'completed' | 'draft';
}


/**
 * 笔记条目
 */
export interface NoteItem {
    id: string;
    type: 'note';
    title: string;
    icon?: string;
    content: string; // 笔记内容 (HTML)
    timestamp: string; // e.g., "今天 14:32"
}

/**
 * 小说标签
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说元数据
 */
export interface NovelMetadata {
    id: string;
    title: string;
    description: string;
    cover: string;
    tags: NovelTag[];
    status: '连载中' | '已完结' | '暂停更新';
}



interface BaseNode {
    id: string;
    title: string;
    icon: string;
    children?: TreeNode[];
    isReadOnly?: boolean;
    isOverview?: boolean;
    originalData?: any;
}

export type AnyNode = Volume | Chapter | NoteItem | PlotAnalysisItem;

// --- 根节点 ---
export interface RootNode extends BaseNode {
    type: 'root';
    children: TreeNode[];
}

// --- 目录节点 ---
export interface VolumeNode extends BaseNode {
    type: 'volume';
    content: string;
    originalData: Volume;
    children: ChapterNode[];
}
export interface ChapterNode extends BaseNode {
    type: 'chapter';
    content: string;
    originalData: Chapter;
    status?: Chapter['status'];
    children?: never;
}

// --- 设定/自定义内容节点 ---
export interface GroupNode extends BaseNode {
    type: 'group';
    children: TreeNode[];
}
export interface ItemNode extends BaseNode {
    type: `${string}_item`; // e.g., character_item, plot_item, prompt_item
    content: string;
    originalData?: AnyNode;
    children?: never;
}
export interface OverviewNode extends BaseNode {
    type: `${string}_overview`; // e.g., characters_overview
    content: string;
    isOverview: true;
    isReadOnly: true;
    children?: never;
}

// --- 新增：提示词模板节点 ---
export interface PromptGroupNode extends BaseNode {
    type: 'prompt_group';
    children: PromptItemNode[];
}
export interface PromptItemNode extends BaseNode {
    type: 'prompt_item';
    content: string; // <pre>template</pre>
    children?: never;
}

// --- 新增：参考书节点 ---
export interface ReferenceBookNode extends BaseNode {
    type: 'reference_book';
    children: TreeNode[];
}
export interface ReferenceContentNode extends BaseNode {
    type: 'reference_content_item';
    children?: TreeNode[];
}
export interface ReferenceVolumeNode extends BaseNode {
    type: 'reference_volume';
    children: ReferenceChapterNode[];
}
export interface ReferenceChapterNode extends BaseNode {
    type: 'reference_chapter';
    content: string;
    children?: never;
}


export type TreeNode =
    | RootNode
    | GroupNode
    | ItemNode
    | OverviewNode
    | VolumeNode
    | ChapterNode
    | PromptGroupNode
    | PromptItemNode
    | ReferenceBookNode
    | ReferenceContentNode
    | ReferenceVolumeNode
    | ReferenceChapterNode;

// =
// 文件: ..\src\novel\editor\types\project.ts
//

import type {
    Volume,
    NoteItem,
    NovelMetadata as BaseNovelMetadata,
    TreeNode,
    ItemNode,
    PlotAnalysisItem,
} from '@/novel/editor/types';

export interface NovelMetadata extends BaseNovelMetadata {
    referenceNovelIds: string[];
}

export interface NovelProject {
    metadata: NovelMetadata;
    directoryData: Volume[];
    settingsData: TreeNode[];
    plotCustomData: ItemNode[];
    analysisCustomData: ItemNode[];
    derivedPlotData: PlotAnalysisItem[];
    derivedAnalysisData: PlotAnalysisItem[];
    othersCustomData: ItemNode[];
    noteData: NoteItem[];
}

// =
// 文件: ..\src\novel\editor\types\ui.ts
//

/**
 * 侧边活动栏（ActivityBar）的标签页ID
 */
export type ActivityBarTabId = 'directory' | 'related' | 'notes' | 'references';

/**
 * 侧边活动栏（ActivityBar）的直接动作按钮ID
 */
export type ActivityBarActionId = 'system:search' | 'system:ai_chat';

// =
// 文件: ..\src\novel\editor\utils\iconUtils.ts
//

// 文件: src/novel/editor/utils/iconUtils.ts

const ICON_MAP: Record<string, string> = {
    // 目录树 (Directory)
    'volume': 'fa-regular fa-folder-open text-gray-500',
    'chapter': 'fa-regular fa-file-lines text-gray-600',

    // 相关内容 - 设定 (Related - Settings)
    'setting': 'fa-solid fa-book-journal-whills', // 设定根节点
    'group': 'fa-regular fa-folder text-gray-500',
    'character_item': 'fa-regular fa-user',
    'location_item': 'fa-regular fa-map',
    'item_item': 'fa-solid fa-cube',
    'worldview_item': 'fa-solid fa-book-atlas',
    'characters_overview': 'fa-solid fa-users',
    'locations_overview': 'fa-solid fa-map-location-dot',
    'items_overview': 'fa-solid fa-box-archive',
    'worldview_overview': 'fa-solid fa-book-atlas',


    // 相关内容 - 剧情 (Related - Plot)
    'plot': 'fa-solid fa-feather-pointed', // 剧情根节点
    'plot_volume': 'fa-solid fa-book-bible',
    'plot_chapter': 'fa-solid fa-scroll',
    'plot_item': 'fa-solid fa-lightbulb', // 自定义剧情条目

    // 相关内容 - 分析 (Related - Analysis)
    'analysis': 'fa-solid fa-magnifying-glass-chart', // 分析根节点
    'analysis_volume': 'fa-solid fa-chart-pie',
    'analysis_chapter': 'fa-solid fa-chart-simple',
    'analysis_item': 'fa-solid fa-magnifying-glass-plus', // 自定义分析条目

    // 相关内容 - 其他 (Related - Others)
    'others': 'fa-solid fa-puzzle-piece', // 其他根节点
    'others_item': 'fa-regular fa-file-zipper', // 其他条目

    // 新增：提示词模板 (Prompt Templates)
    'prompt_root': 'fa-solid fa-flask-vial text-cyan-600',
    'prompt_group': 'fa-solid fa-layer-group text-sky-600',
    'prompt_item': 'fa-regular fa-comment-dots text-sky-500',

    // 新增：AI任务类型作为分组图标
    '润色': 'fa-solid fa-palette text-blue-500',
    '续写': 'fa-solid fa-wand-magic-sparkles text-gray-600',
    '分析': 'fa-solid fa-magnifying-glass-chart text-amber-500',
    '剧情生成': 'fa-solid fa-feather text-pink-500',
    '创作': 'fa-solid fa-pen-nib text-violet-500',


    // 笔记 (Notes)
    'note': 'fa-solid fa-note-sticky text-yellow-500',

    // 新增：参考书 (Reference Books)
    'reference_book': 'fa-solid fa-book-bookmark text-indigo-500',
    'reference_content_item': 'fa-regular fa-folder text-gray-500',
    'reference_volume': 'fa-solid fa-book-open text-purple-500',
    'reference_chapter': 'fa-regular fa-file-lines text-gray-600',

    // 通用根节点和默认
    'root': 'fa-solid fa-sitemap text-gray-500',
    'default': 'fa-solid fa-question text-gray-400'
};

/**
 * 根据节点类型获取对应的 Font Awesome 图标类名
 * @param type - 节点的类型字符串, e.g., "characters_item"
 * @returns 完整的图标类名字符串
 */
export function getIconByNodeType(type: string): string {
    // 检查是否有直接匹配
    if (ICON_MAP[type]) {
        return ICON_MAP[type];
    }

    const normalizedType = type.replace(/s_item$/, '_item'); // characters_item -> character_item

    return ICON_MAP[normalizedType] || ICON_MAP['default'];
}

// =
// 文件: ..\src\novel\importer\services\novelParser.ts
//

import type { Volume, Chapter } from '@/novel/editor/types';

/**
 * 将纯文本段落转换为带<p>标签的HTML字符串
 * @param text - 输入的文本
 * @returns HTML格式的字符串
 */
const textToHtmlParagraphs = (text: string): string => {
    return text.split('\n').map(p => p.trim()).filter(p => p).map(p => `<p>${p}</p>`).join('');
};

/**
 * 解析小说文本并根据选项进行分章和分卷
 * @param text - 要解析的小说全文
 * @param options - 解析选项
 * @returns 返回一个卷数组，可直接用于创建新的小说项目
 */
export const parseNovelText = (
    text: string,
    options: { chaptersPerVolume: number }
): Volume[] => {
    // 1. 按空行（一个或多个换行符，中间可能包含空格）分割成章节内容块
    const chapterContents = text.split(/\n\s*\n/).filter(content => content.trim() !== '');

    // 2. 将内容块转换为章节对象
    const allChapters: Chapter[] = chapterContents.map((content, index) => {
        const lines = content.trim().split('\n');
        const title = lines[0]?.trim() || `第 ${index + 1} 章`;
        const bodyText = lines.slice(1).join('\n').trim();
        const bodyHtml = textToHtmlParagraphs(bodyText);

        return {
            id: `ch-imported-${Date.now()}-${index}`,
            type: 'chapter',
            title: title,
            wordCount: content.trim().length,
            content: `<h1>${title}</h1>${bodyHtml}`,
            status: 'completed'
        };
    });

    // 3. 将章节按指定数量分组到卷中
    const volumes: Volume[] = [];
    const { chaptersPerVolume } = options;
    let volumeIndex = 1;

    for (let i = 0; i < allChapters.length; i += chaptersPerVolume) {
        const chapterChunk = allChapters.slice(i, i + chaptersPerVolume);
        const volume: Volume = {
            id: `vol-imported-${Date.now()}-${volumeIndex}`,
            type: 'volume',
            title: `第 ${volumeIndex} 卷`,
            content: `<h1>第 ${volumeIndex} 卷</h1><p>该卷由导入功能自动创建，包含 ${chapterChunk.length} 个章节。</p>`,
            chapters: chapterChunk,
        };
        volumes.push(volume);
        volumeIndex++;
    }

    // 如果没有任何内容，则创建一个默认的空卷
    if (volumes.length === 0) {
        volumes.push({
            id: `vol-imported-${Date.now()}-1`,
            type: 'volume',
            title: '第一卷',
            content: '<h1>第一卷</h1><p>未从文件中解析出任何章节。</p>',
            chapters: [],
        });
    }

    return volumes;
};

// =
// 文件: ..\src\novel\router.ts
//

import type { RouteRecordRaw } from 'vue-router'
import { dashboardRoutes } from './dashboard/router'
import { editorRoutes } from './editor/router'

export const novelRoutes: Array<RouteRecordRaw> = [
    {
        path: '/novel',
        component: () => import('@/novel/layouts/NovelDashboardLayout.vue'),
        redirect: '/novel/dashboard',
        children: [
            ...dashboardRoutes
        ]
    },
    ...editorRoutes,
]

// =
// 文件: ..\src\novel\services\novelProjectService.ts
//

import * as projectApi from '@/api/novel/projectApi';
import type { NovelProject } from '@/novel/editor/types/project';
import type { Volume } from '@/novel/editor/types';

/**
 * 根据ID从后端获取完整的小说项目数据
 * @param novelId - 小说ID
 * @returns 完整的小说项目对象或在出错时返回undefined
 */
export const getNovelProject = async (novelId: string): Promise<NovelProject | undefined> => {
    try {
        return await projectApi.getNovelProject(novelId);
    } catch (error) {
        console.error(`Failed to get novel project with ID ${novelId}:`, error);
        return undefined;
    }
};

/**
 * 获取所有小说项目
 * @returns 所有小说项目的数组或在出错时返回空数组
 */
export const getAllNovelProjects = async (): Promise<NovelProject[]> => {
    try {
        return await projectApi.fetchAllNovelProjects();
    } catch (error) {
        console.error('Failed to get all novel projects:', error);
        return [];
    }
};

/**
 * 调用后端API从解析后的数据导入一本新小说
 * @param title - 小说标题
 * @param description - 小说描述
 * @param category - 小说分类
 * @param directoryData - 卷和章节数据
 * @returns 新创建的完整小说项目
 */
export const importNovelProject = (
    title: string,
    description: string,
    category: string,
    directoryData: Volume[]
): Promise<NovelProject> => {
    return projectApi.importNovelProject({ title, description, category, directoryData });
};

// =
// 文件: ..\src\novel\types\index.ts
//

// src/novel/types/index.ts
// 定义小说模块对外共享的数据类型

/**
 * 小说标签定义
 */
export interface NovelTag {
    text: string;
    class: string;
}

/**
 * 小说状态定义
 */
export interface NovelStatus {
    text: '编辑中' | '待审核' | '已驳回' | '已发布';
    class: string;
}

/**
 * 小说分类的类型别名
 */
export type NovelCategory = '科幻' | '奇幻' | '悬疑' | '恐怖' | '都市' | '言情' | '历史';

/**
 * 小说在仪表盘列表中的数据结构。
 * 这是 NovelProject 的一个摘要视图。
 */
export interface NovelDashboardItem {
    id: string;
    title: string;
    description: string;
    cover: string;
    status: NovelStatus;
    tags: NovelTag[];
    chapters: number;
    lastUpdated: string;
    category: NovelCategory;
    deletedAt?: string;
}


/**
 * 定义“最近编辑”条目的数据结构。
 * 对应于 `RecentView.vue` 中显示的数据。
 */
export interface RecentActivityItem {
    id: string; // 活动自身的唯一ID
    novelId: string; // 关联的小说ID
    novelTitle: string; // 关联的小说标题
    novelCover: string; // 关联的小说封面

    editedItemType: 'chapter' | 'outline' | 'character'; // 被编辑的项目类型
    editedItemName: string; // 被编辑的项目名称，例如 "第四章：跃迁点" 或 "角色设定 - 艾拉"
    editedAt: string; // 编辑时间, ISO 8601 格式
    formattedTime: string; // 用于UI显示的格式化时间，如 "2小时前" 或 "下午 3:45"
}

/**
 * 定义“回收站”中条目的数据结构。
 * 对应于 `TrashView.vue` 中显示的数据。
 */
export interface DeletedItem {
    id: string; // 被删除项目的ID
    name: string; // 被删除项目的名称
    type: '小说' | '章节' | '角色'; // 被删除项目的类型
    icon: string; // 用于UI显示的图标HTML字符串
    deletedAt: string; // 删除时间, ISO 8601 格式
    retentionDays: number; // 剩余保留天数
    retentionPercent: number; // 剩余时间百分比，用于进度条显示
}

// =
// 文件: ..\src\router\index.ts
//

// 文件: ..\src\router\index.ts

import { createRouter, createWebHistory, type RouteRecordRaw } from 'vue-router'
import DefaultLayout from '@/layouts/DefaultLayout.vue'
import { protectedSettingsRoutes } from '@/settings/router' // Updated import
import { novelRoutes } from "@novel/router.ts";
import { promptRoutes } from "@/prompt/router";
import { workflowRoutes } from "@workflow/router.ts";
import { authRoutes } from "@/auth/router";
import { useAuthStore } from "@/auth/store/auth.store";
import { useAppStore } from '@/stores/app.store';

const routes: Array<RouteRecordRaw> = [
    {
        path: '/',
        redirect: '/auth/welcome',
    },
    ...authRoutes,
    {
        path: '/home',
        component: DefaultLayout,
        children: [
            {
                path: '',
                name: 'home',
                component: () => import('@/home.vue'),
                meta: { title: '工作台', requiresAuth: true },
            },
        ],
    },
    ...novelRoutes,
    ...promptRoutes,
    ...workflowRoutes,
    // Use the new protected route object here
    protectedSettingsRoutes,
    {
        path: '/vip',
        name: 'VipPlan',
        component: () => import('@/settings/views/Vip.vue'),
        meta: { requiresAuth: true },
    },
]

const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes,
    scrollBehavior(to, from, savedPosition) {
        if (savedPosition) {
            return savedPosition
        } else {
            return { top: 0 }
        }
    },
})

router.beforeEach((to, from, next) => {
    const authStore = useAuthStore();
    const appStore = useAppStore();

    // 更新页面标题
    const title = to.meta.title as string;
    appStore.setPageTitle(title);

    const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
    const isAuthRoute = to.path.startsWith('/auth');

    if (requiresAuth && !authStore.isLoggedIn) {
        // 如果路由需要认证但用户未登录，重定向到登录页
        next({ name: 'Login', query: { redirect: to.fullPath } });
    } else if (isAuthRoute && authStore.isLoggedIn) {
        // 如果用户已登录，但访问的是认证页面（登录/注册），重定向到主页
        next({ name: 'home' });
    } else {
        // 其他情况，正常放行
        next();
    }
});

export default router

// =
// 文件: ..\src\stores\app.store.ts
//

import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useAppStore = defineStore('app', () => {
    const pageTitle = ref('AI Creator Platform');

    function setPageTitle(title: string) {
        pageTitle.value = title || 'AI Creator Platform';
    }

    return { pageTitle, setPageTitle };
});

// =
// 文件: ..\src\types\apiManagement.ts
//

export interface ApiProvider {
    name: string;
    shortName: string;
    description: string;
    statusText: string;
    activeKeys: number;
    totalCalls: string;
}

export interface ApiKey {
    id: number;
    provider: string;
    providerShort: string;
    name: string;
    keyFragment: string;
    model: string;
    calls: string;
    status: '启用' | '暂停';
    created: string;
    baseUrl?: string;
    temperature: number;
    maxTokens: number;
    description: string;
}

export interface ModalProvider {
    name: string;
    shortName: string;
    description: string;
}

// =
// 文件: ..\src\types\auth.ts
//

/**
 * 用户登录凭证
 */
export interface LoginCredentials {
    email: string;
    password: string;
}

/**
 * 全局统一的用户信息结构
 */
export interface User {
    id: string;
    name: string;
    email: string;
    avatar?: string;
    plan: '免费版' | '专业版';
    phone?: string;
    region?: string;
    timezone?: string;
    bio?: string;
}

/**
 * 用户注册时所需的数据
 */
export interface RegistrationData extends LoginCredentials {
    firstName: string;
    lastName: string;
    termsAccepted: boolean;
}

// =
// 文件: ..\src\types\dataPrivacy.ts
//

export interface DataCollectionSetting {
    title: string;
    description: string;
    enabled: boolean;
}

export interface DataUsageItem {
    title: string;
    tag: string;
    includes: string;
    purpose: string;
}

export interface DataPermission {
    title: string;
    description: string;
    action: string;
}

// =
// 文件: ..\src\types\systemSettings.ts
//

export interface Theme {
    name: string;
}

export interface SettingItem {
    title: string;
    description: string;
    enabled: boolean;
}

export interface SystemSettings {
    activeTheme: string;
    zoomLevel: number;
    language: string;
    dateFormat: string;
    notificationSettings: SettingItem[];
    appSettings: SettingItem[];
}

// =
// 文件: ..\src\types\usageLogs.ts
//

export interface UsageStat {
    label: string;
    value: string;
    trend: string;
}

export interface ApiLog {
    id: number;
    timestamp: string;
    endpoint: string;
    model: string;
    tokens: string;
    status: '成功' | '失败';
    duration: string;
}

export interface ChartDataPoint {
    label: string;
    requests: number;
    tokens: number;
}

export interface FetchParams {
    period: '日' | '周' | '月';
    model: string;
    status: string;
    page: number;
    limit: number;
}

// =
// 文件: ..\src\types\user.ts
//

export interface NotificationSetting {
    id: number;
    title: string;
    description: string;
    enabled: boolean;
}

export interface SecuritySetting {
    title: string;
    status: string;
    action: string;
}

